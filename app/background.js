(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("dotenv"), require("electron-serve"), require("electron-store"), require("lodash"), require("electron-dl"), require("electron-updater"));
	else if(typeof define === 'function' && define.amd)
		define(["dotenv", "electron-serve", "electron-store", "lodash", "electron-dl", "electron-updater"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("dotenv"), require("electron-serve"), require("electron-store"), require("lodash"), require("electron-dl"), require("electron-updater")) : factory(root["dotenv"], root["electron-serve"], root["electron-store"], root["lodash"], root["electron-dl"], root["electron-updater"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(global, (__WEBPACK_EXTERNAL_MODULE_dotenv__, __WEBPACK_EXTERNAL_MODULE_electron_serve__, __WEBPACK_EXTERNAL_MODULE_electron_store__, __WEBPACK_EXTERNAL_MODULE_lodash__, __WEBPACK_EXTERNAL_MODULE_electron_dl__, __WEBPACK_EXTERNAL_MODULE_electron_updater__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/async.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/async.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callback = exports.promise = void 0;
const walker_1 = __webpack_require__(/*! ./walker */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/walker.js");
function promise(root, options) {
    return new Promise((resolve, reject) => {
        callback(root, options, (err, output) => {
            if (err)
                return reject(err);
            resolve(output);
        });
    });
}
exports.promise = promise;
function callback(root, options, callback) {
    let walker = new walker_1.Walker(root, options, callback);
    walker.start();
}
exports.callback = callback;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/counter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/counter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Counter = void 0;
class Counter {
    _files = 0;
    _directories = 0;
    set files(num) {
        this._files = num;
    }
    get files() {
        return this._files;
    }
    set directories(num) {
        this._directories = num;
    }
    get directories() {
        return this._directories;
    }
    /**
     * @deprecated use `directories` instead
     */
    /* c8 ignore next 3 */
    get dirs() {
        return this._directories;
    }
}
exports.Counter = Counter;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/get-array.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/get-array.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const getArray = (paths) => {
    return paths;
};
const getArrayGroup = () => {
    return [""].slice(0, 0);
};
function build(options) {
    return options.group ? getArrayGroup : getArray;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/group-files.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/group-files.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const groupFiles = (groups, directory, files) => {
    groups.push({ directory, files, dir: directory });
};
const empty = () => { };
function build(options) {
    return options.group ? groupFiles : empty;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/invoke-callback.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/invoke-callback.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const onlyCountsSync = (state) => {
    return state.counts;
};
const groupsSync = (state) => {
    return state.groups;
};
const defaultSync = (state) => {
    return state.paths;
};
const limitFilesSync = (state) => {
    return state.paths.slice(0, state.options.maxFiles);
};
const onlyCountsAsync = (state, error, callback) => {
    report(error, callback, state.counts, state.options.suppressErrors);
    return null;
};
const defaultAsync = (state, error, callback) => {
    report(error, callback, state.paths, state.options.suppressErrors);
    return null;
};
const limitFilesAsync = (state, error, callback) => {
    report(error, callback, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
    return null;
};
const groupsAsync = (state, error, callback) => {
    report(error, callback, state.groups, state.options.suppressErrors);
    return null;
};
function report(error, callback, output, suppressErrors) {
    if (error && !suppressErrors)
        callback(error, output);
    else
        callback(null, output);
}
function build(options, isSynchronous) {
    const { onlyCounts, group, maxFiles } = options;
    if (onlyCounts)
        return isSynchronous
            ? onlyCountsSync
            : onlyCountsAsync;
    else if (group)
        return isSynchronous
            ? groupsSync
            : groupsAsync;
    else if (maxFiles)
        return isSynchronous
            ? limitFilesSync
            : limitFilesAsync;
    else
        return isSynchronous
            ? defaultSync
            : defaultAsync;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/join-path.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/join-path.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = exports.joinDirectoryPath = exports.joinPathWithBasePath = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const utils_1 = __webpack_require__(/*! ../../utils */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/utils.js");
function joinPathWithBasePath(filename, directoryPath) {
    return directoryPath + filename;
}
exports.joinPathWithBasePath = joinPathWithBasePath;
function joinPathWithRelativePath(root, options) {
    return function (filename, directoryPath) {
        const sameRoot = directoryPath.startsWith(root);
        if (sameRoot)
            return directoryPath.replace(root, "") + filename;
        else
            return ((0, utils_1.convertSlashes)((0, path_1.relative)(root, directoryPath), options.pathSeparator) +
                options.pathSeparator +
                filename);
    };
}
function joinPath(filename) {
    return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
    return directoryPath + filename + separator;
}
exports.joinDirectoryPath = joinDirectoryPath;
function build(root, options) {
    const { relativePaths, includeBasePath } = options;
    return relativePaths && root
        ? joinPathWithRelativePath(root, options)
        : includeBasePath
            ? joinPathWithBasePath
            : joinPath;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-directory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-directory.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
function pushDirectoryWithRelativePath(root) {
    return function (directoryPath, paths) {
        paths.push(directoryPath.substring(root.length) || ".");
    };
}
function pushDirectoryFilterWithRelativePath(root) {
    return function (directoryPath, paths, filters) {
        const relativePath = directoryPath.substring(root.length) || ".";
        if (filters.every((filter) => filter(relativePath, true))) {
            paths.push(relativePath);
        }
    };
}
const pushDirectory = (directoryPath, paths) => {
    paths.push(directoryPath || ".");
};
const pushDirectoryFilter = (directoryPath, paths, filters) => {
    const path = directoryPath || ".";
    if (filters.every((filter) => filter(path, true))) {
        paths.push(path);
    }
};
const empty = () => { };
function build(root, options) {
    const { includeDirs, filters, relativePaths } = options;
    if (!includeDirs)
        return empty;
    if (relativePaths)
        return filters && filters.length
            ? pushDirectoryFilterWithRelativePath(root)
            : pushDirectoryWithRelativePath(root);
    return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-file.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-file.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const pushFileFilterAndCount = (filename, _paths, counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
        counts.files++;
};
const pushFileFilter = (filename, paths, _counts, filters) => {
    if (filters.every((filter) => filter(filename, false)))
        paths.push(filename);
};
const pushFileCount = (_filename, _paths, counts, _filters) => {
    counts.files++;
};
const pushFile = (filename, paths) => {
    paths.push(filename);
};
const empty = () => { };
function build(options) {
    const { excludeFiles, filters, onlyCounts } = options;
    if (excludeFiles)
        return empty;
    if (filters && filters.length) {
        return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
    }
    else if (onlyCounts) {
        return pushFileCount;
    }
    else {
        return pushFile;
    }
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/resolve-symlink.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/resolve-symlink.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const path_1 = __webpack_require__(/*! path */ "path");
const resolveSymlinksAsync = function (path, state, callback) {
    const { queue, options: { suppressErrors }, } = state;
    queue.enqueue();
    fs_1.default.realpath(path, (error, resolvedPath) => {
        if (error)
            return queue.dequeue(suppressErrors ? null : error, state);
        fs_1.default.stat(resolvedPath, (error, stat) => {
            if (error)
                return queue.dequeue(suppressErrors ? null : error, state);
            if (stat.isDirectory() && isRecursive(path, resolvedPath, state))
                return queue.dequeue(null, state);
            callback(stat, resolvedPath);
            queue.dequeue(null, state);
        });
    });
};
const resolveSymlinks = function (path, state, callback) {
    const { queue, options: { suppressErrors }, } = state;
    queue.enqueue();
    try {
        const resolvedPath = fs_1.default.realpathSync(path);
        const stat = fs_1.default.statSync(resolvedPath);
        if (stat.isDirectory() && isRecursive(path, resolvedPath, state))
            return;
        callback(stat, resolvedPath);
    }
    catch (e) {
        if (!suppressErrors)
            throw e;
    }
};
function build(options, isSynchronous) {
    if (!options.resolveSymlinks || options.excludeSymlinks)
        return null;
    return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
exports.build = build;
function isRecursive(path, resolved, state) {
    if (state.options.useRealPaths)
        return isRecursiveUsingRealPaths(resolved, state);
    let parent = (0, path_1.dirname)(path);
    let depth = 1;
    while (parent !== state.root && depth < 2) {
        const resolvedPath = state.symlinks.get(parent);
        const isSameRoot = !!resolvedPath &&
            (resolvedPath === resolved ||
                resolvedPath.startsWith(resolved) ||
                resolved.startsWith(resolvedPath));
        if (isSameRoot)
            depth++;
        else
            parent = (0, path_1.dirname)(parent);
    }
    state.symlinks.set(path, resolved);
    return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
    return state.visited.includes(resolved + state.options.pathSeparator);
}


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/walk-directory.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/walk-directory.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.build = void 0;
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
const readdirOpts = { withFileTypes: true };
const walkAsync = (state, crawlPath, directoryPath, currentDepth, callback) => {
    state.queue.enqueue();
    if (currentDepth < 0)
        return state.queue.dequeue(null, state);
    state.visited.push(crawlPath);
    state.counts.directories++;
    // Perf: Node >= 10 introduced withFileTypes that helps us
    // skip an extra fs.stat call.
    fs_1.default.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
        callback(entries, directoryPath, currentDepth);
        state.queue.dequeue(state.options.suppressErrors ? null : error, state);
    });
};
const walkSync = (state, crawlPath, directoryPath, currentDepth, callback) => {
    if (currentDepth < 0)
        return;
    state.visited.push(crawlPath);
    state.counts.directories++;
    let entries = [];
    try {
        entries = fs_1.default.readdirSync(crawlPath || ".", readdirOpts);
    }
    catch (e) {
        if (!state.options.suppressErrors)
            throw e;
    }
    callback(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
    return isSynchronous ? walkSync : walkAsync;
}
exports.build = build;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/queue.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/queue.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Queue = void 0;
/**
 * This is a custom stateless queue to track concurrent async fs calls.
 * It increments a counter whenever a call is queued and decrements it
 * as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
 */
class Queue {
    onQueueEmpty;
    count = 0;
    constructor(onQueueEmpty) {
        this.onQueueEmpty = onQueueEmpty;
    }
    enqueue() {
        this.count++;
        return this.count;
    }
    dequeue(error, output) {
        if (this.onQueueEmpty && (--this.count <= 0 || error)) {
            this.onQueueEmpty(error, output);
            if (error) {
                output.controller.abort();
                this.onQueueEmpty = undefined;
            }
        }
    }
}
exports.Queue = Queue;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/sync.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/sync.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sync = void 0;
const walker_1 = __webpack_require__(/*! ./walker */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/walker.js");
function sync(root, options) {
    const walker = new walker_1.Walker(root, options);
    return walker.start();
}
exports.sync = sync;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/walker.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/walker.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Walker = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/utils.js");
const joinPath = __importStar(__webpack_require__(/*! ./functions/join-path */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/join-path.js"));
const pushDirectory = __importStar(__webpack_require__(/*! ./functions/push-directory */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-directory.js"));
const pushFile = __importStar(__webpack_require__(/*! ./functions/push-file */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/push-file.js"));
const getArray = __importStar(__webpack_require__(/*! ./functions/get-array */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/get-array.js"));
const groupFiles = __importStar(__webpack_require__(/*! ./functions/group-files */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/group-files.js"));
const resolveSymlink = __importStar(__webpack_require__(/*! ./functions/resolve-symlink */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/resolve-symlink.js"));
const invokeCallback = __importStar(__webpack_require__(/*! ./functions/invoke-callback */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/invoke-callback.js"));
const walkDirectory = __importStar(__webpack_require__(/*! ./functions/walk-directory */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/functions/walk-directory.js"));
const queue_1 = __webpack_require__(/*! ./queue */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/queue.js");
const counter_1 = __webpack_require__(/*! ./counter */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/counter.js");
class Walker {
    root;
    isSynchronous;
    state;
    joinPath;
    pushDirectory;
    pushFile;
    getArray;
    groupFiles;
    resolveSymlink;
    walkDirectory;
    callbackInvoker;
    constructor(root, options, callback) {
        this.isSynchronous = !callback;
        this.callbackInvoker = invokeCallback.build(options, this.isSynchronous);
        this.root = (0, utils_1.normalizePath)(root, options);
        this.state = {
            root: (0, utils_1.isRootDirectory)(this.root) ? this.root : this.root.slice(0, -1),
            // Perf: we explicitly tell the compiler to optimize for String arrays
            paths: [""].slice(0, 0),
            groups: [],
            counts: new counter_1.Counter(),
            options,
            queue: new queue_1.Queue((error, state) => this.callbackInvoker(state, error, callback)),
            symlinks: new Map(),
            visited: [""].slice(0, 0),
            controller: new AbortController(),
        };
        /*
         * Perf: We conditionally change functions according to options. This gives a slight
         * performance boost. Since these functions are so small, they are automatically inlined
         * by the javascript engine so there's no function call overhead (in most cases).
         */
        this.joinPath = joinPath.build(this.root, options);
        this.pushDirectory = pushDirectory.build(this.root, options);
        this.pushFile = pushFile.build(options);
        this.getArray = getArray.build(options);
        this.groupFiles = groupFiles.build(options);
        this.resolveSymlink = resolveSymlink.build(options, this.isSynchronous);
        this.walkDirectory = walkDirectory.build(this.isSynchronous);
    }
    start() {
        this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
        this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
        return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
    }
    walk = (entries, directoryPath, depth) => {
        const { paths, options: { filters, resolveSymlinks, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator, }, controller, } = this.state;
        if (controller.signal.aborted ||
            (signal && signal.aborted) ||
            (maxFiles && paths.length > maxFiles))
            return;
        const files = this.getArray(this.state.paths);
        for (let i = 0; i < entries.length; ++i) {
            const entry = entries[i];
            if (entry.isFile() ||
                (entry.isSymbolicLink() && !resolveSymlinks && !excludeSymlinks)) {
                const filename = this.joinPath(entry.name, directoryPath);
                this.pushFile(filename, files, this.state.counts, filters);
            }
            else if (entry.isDirectory()) {
                let path = joinPath.joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
                if (exclude && exclude(entry.name, path))
                    continue;
                this.pushDirectory(path, paths, filters);
                this.walkDirectory(this.state, path, path, depth - 1, this.walk);
            }
            else if (this.resolveSymlink && entry.isSymbolicLink()) {
                let path = joinPath.joinPathWithBasePath(entry.name, directoryPath);
                this.resolveSymlink(path, this.state, (stat, resolvedPath) => {
                    if (stat.isDirectory()) {
                        resolvedPath = (0, utils_1.normalizePath)(resolvedPath, this.state.options);
                        if (exclude &&
                            exclude(entry.name, useRealPaths ? resolvedPath : path + pathSeparator))
                            return;
                        this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);
                    }
                    else {
                        resolvedPath = useRealPaths ? resolvedPath : path;
                        const filename = (0, path_1.basename)(resolvedPath);
                        const directoryPath = (0, utils_1.normalizePath)((0, path_1.dirname)(resolvedPath), this.state.options);
                        resolvedPath = this.joinPath(filename, directoryPath);
                        this.pushFile(resolvedPath, files, this.state.counts, filters);
                    }
                });
            }
        }
        this.groupFiles(this.state.groups, directoryPath, files);
    };
}
exports.Walker = Walker;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/api-builder.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/api-builder.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIBuilder = void 0;
const async_1 = __webpack_require__(/*! ../api/async */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/async.js");
const sync_1 = __webpack_require__(/*! ../api/sync */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/api/sync.js");
class APIBuilder {
    root;
    options;
    constructor(root, options) {
        this.root = root;
        this.options = options;
    }
    withPromise() {
        return (0, async_1.promise)(this.root, this.options);
    }
    withCallback(cb) {
        (0, async_1.callback)(this.root, this.options, cb);
    }
    sync() {
        return (0, sync_1.sync)(this.root, this.options);
    }
}
exports.APIBuilder = APIBuilder;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Builder = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
const api_builder_1 = __webpack_require__(/*! ./api-builder */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/api-builder.js");
var pm = null;
/* c8 ignore next 6 */
try {
    /*require.resolve*/(/*! picomatch */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/index.js");
    pm = __webpack_require__(/*! picomatch */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/index.js");
}
catch (_e) {
    // do nothing
}
class Builder {
    globCache = {};
    options = {
        maxDepth: Infinity,
        suppressErrors: true,
        pathSeparator: path_1.sep,
        filters: [],
    };
    globFunction;
    constructor(options) {
        this.options = { ...this.options, ...options };
        this.globFunction = this.options.globFunction;
    }
    group() {
        this.options.group = true;
        return this;
    }
    withPathSeparator(separator) {
        this.options.pathSeparator = separator;
        return this;
    }
    withBasePath() {
        this.options.includeBasePath = true;
        return this;
    }
    withRelativePaths() {
        this.options.relativePaths = true;
        return this;
    }
    withDirs() {
        this.options.includeDirs = true;
        return this;
    }
    withMaxDepth(depth) {
        this.options.maxDepth = depth;
        return this;
    }
    withMaxFiles(limit) {
        this.options.maxFiles = limit;
        return this;
    }
    withFullPaths() {
        this.options.resolvePaths = true;
        this.options.includeBasePath = true;
        return this;
    }
    withErrors() {
        this.options.suppressErrors = false;
        return this;
    }
    withSymlinks({ resolvePaths = true } = {}) {
        this.options.resolveSymlinks = true;
        this.options.useRealPaths = resolvePaths;
        return this.withFullPaths();
    }
    withAbortSignal(signal) {
        this.options.signal = signal;
        return this;
    }
    normalize() {
        this.options.normalizePath = true;
        return this;
    }
    filter(predicate) {
        this.options.filters.push(predicate);
        return this;
    }
    onlyDirs() {
        this.options.excludeFiles = true;
        this.options.includeDirs = true;
        return this;
    }
    exclude(predicate) {
        this.options.exclude = predicate;
        return this;
    }
    onlyCounts() {
        this.options.onlyCounts = true;
        return this;
    }
    crawl(root) {
        return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    withGlobFunction(fn) {
        // cast this since we don't have the new type params yet
        this.globFunction = fn;
        return this;
    }
    /**
     * @deprecated Pass options using the constructor instead:
     * ```ts
     * new fdir(options).crawl("/path/to/root");
     * ```
     * This method will be removed in v7.0
     */
    /* c8 ignore next 4 */
    crawlWithOptions(root, options) {
        this.options = { ...this.options, ...options };
        return new api_builder_1.APIBuilder(root || ".", this.options);
    }
    glob(...patterns) {
        if (this.globFunction) {
            return this.globWithOptions(patterns);
        }
        return this.globWithOptions(patterns, ...[{ dot: true }]);
    }
    globWithOptions(patterns, ...options) {
        const globFn = (this.globFunction || pm);
        /* c8 ignore next 5 */
        if (!globFn) {
            throw new Error("Please specify a glob function to use glob matching.");
        }
        var isMatch = this.globCache[patterns.join("\0")];
        if (!isMatch) {
            isMatch = globFn(patterns, ...options);
            this.globCache[patterns.join("\0")] = isMatch;
        }
        this.options.filters.push((path) => isMatch(path));
        return this;
    }
}
exports.Builder = Builder;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fdir = void 0;
const builder_1 = __webpack_require__(/*! ./builder */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/builder/index.js");
Object.defineProperty(exports, "fdir", ({ enumerable: true, get: function () { return builder_1.Builder; } }));
__exportStar(__webpack_require__(/*! ./types */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/types.js"), exports);


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/types.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/types.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizePath = exports.isRootDirectory = exports.convertSlashes = exports.cleanPath = void 0;
const path_1 = __webpack_require__(/*! path */ "path");
function cleanPath(path) {
    let normalized = (0, path_1.normalize)(path);
    // we have to remove the last path separator
    // to account for / root path
    if (normalized.length > 1 && normalized[normalized.length - 1] === path_1.sep)
        normalized = normalized.substring(0, normalized.length - 1);
    return normalized;
}
exports.cleanPath = cleanPath;
const SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path, separator) {
    return path.replace(SLASHES_REGEX, separator);
}
exports.convertSlashes = convertSlashes;
const WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path) {
    return path === "/" || WINDOWS_ROOT_DIR_REGEX.test(path);
}
exports.isRootDirectory = isRootDirectory;
function normalizePath(path, options) {
    const { resolvePaths, normalizePath, pathSeparator } = options;
    const pathNeedsCleaning = (process.platform === "win32" && path.includes("/")) ||
        path.startsWith(".");
    if (resolvePaths)
        path = (0, path_1.resolve)(path);
    if (normalizePath || pathNeedsCleaning)
        path = cleanPath(path);
    if (path === ".")
        return "";
    const needsSeperator = path[path.length - 1] !== pathSeparator;
    return convertSlashes(needsSeperator ? path + pathSeparator : path, pathSeparator);
}
exports.normalizePath = normalizePath;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const pico = __webpack_require__(/*! ./lib/picomatch */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/picomatch.js");
const utils = __webpack_require__(/*! ./lib/utils */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js");

function picomatch(glob, options, returnState = false) {
  // default to os.platform()
  if (options && (options.windows === null || options.windows === undefined)) {
    // don't mutate the original options object
    options = { ...options, windows: utils.isWindows() };
  }

  return pico(glob, options, returnState);
}

Object.assign(picomatch, pico);
module.exports = picomatch;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js ***!
  \*******************************************************************************/
/***/ ((module) => {

"use strict";


const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;
const SEP = '/';

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR,
  SEP
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
  SEP: '\\'
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    __proto__: null,
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/parse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/parse.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(/*! ./constants */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js");

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(opts.windows);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.output = (prev.output || prev.value) + tok.value;
      prev.value += tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(opts.windows);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/picomatch.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/picomatch.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const scan = __webpack_require__(/*! ./scan */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/scan.js");
const parse = __webpack_require__(/*! ./parse */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/parse.js");
const utils = __webpack_require__(/*! ./utils */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js");
const constants = __webpack_require__(/*! ./constants */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js");
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = opts.windows;
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(utils.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/scan.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/scan.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(/*! ./utils */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js");
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(/*! ./constants */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js");

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*global navigator*/


const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(/*! ./constants */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/lib/constants.js");

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.isWindows = () => {
  if (typeof navigator !== 'undefined' && navigator.platform) {
    const platform = navigator.platform.toLowerCase();
    return platform === 'win32' || platform === 'windows';
  }

  if (typeof process !== 'undefined' && process.platform) {
    return process.platform === 'win32';
  }

  return false;
};

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};

exports.basename = (path, { windows } = {}) => {
  const segs = path.split(windows ? /[\\/]/ : '/');
  const last = segs[segs.length - 1];

  if (last === '') {
    return segs[segs.length - 2];
  }

  return last;
};


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/config.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/config.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

(__webpack_require__(/*! ./main.js */ "./node_modules/@dotenvx/dotenvx/src/lib/main.js").config)()


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/buildEnvs.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/buildEnvs.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")

const conventions = __webpack_require__(/*! ./conventions */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/conventions.js")
const dotenvOptionPaths = __webpack_require__(/*! ./dotenvOptionPaths */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvOptionPaths.js")
const DeprecationNotice = __webpack_require__(/*! ./deprecationNotice */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/deprecationNotice.js")

function buildEnvs (options, DOTENV_KEY = undefined) {
  // build envs using user set option.path
  const optionPaths = dotenvOptionPaths(options) // [ '.env' ]

  let envs = []
  if (options.convention) { // handle shorthand conventions
    envs = conventions(options.convention).concat(envs)
  }

  new DeprecationNotice({ DOTENV_KEY }).dotenvKey() // DEPRECATION NOTICE

  for (const optionPath of optionPaths) {
    // if DOTENV_KEY is set then assume we are checking envVaultFile
    if (DOTENV_KEY) {
      envs.push({
        type: 'envVaultFile',
        value: path.join(path.dirname(optionPath), '.env.vault')
      })
    } else {
      envs.push({ type: 'envFile', value: optionPath })
    }
  }

  return envs
}

module.exports = buildEnvs


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/chomp.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/chomp.js ***!
  \****************************************************************/
/***/ ((module) => {

function chomp (value) {
  return value.replace(/[\r\n]+$/, '')
}

module.exports = chomp


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/colorDepth.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/colorDepth.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { WriteStream } = __webpack_require__(/*! tty */ "tty")

const getColorDepth = () => {
  try {
    return WriteStream.prototype.getColorDepth()
  } catch (error) {
    const term = process.env.TERM

    if (term && (term.includes('256color') || term.includes('xterm'))) {
      return 8 // 256 colors
    }

    return 4
  }
}

module.exports = { getColorDepth }


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/conventions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/conventions.js ***!
  \**********************************************************************/
/***/ ((module) => {

function conventions (convention) {
  const env = process.env.DOTENV_ENV || "development" || 0

  if (convention === 'nextjs') {
    const canonicalEnv = ['development', 'test', 'production'].includes(env) && env

    return [
      canonicalEnv && { type: 'envFile', value: `.env.${canonicalEnv}.local` },
      canonicalEnv !== 'test' && { type: 'envFile', value: '.env.local' },
      canonicalEnv && { type: 'envFile', value: `.env.${canonicalEnv}` },
      { type: 'envFile', value: '.env' }
    ].filter(Boolean)
  } else if (convention === 'flow') {
    return [
      { type: 'envFile', value: `.env.${env}.local` },
      { type: 'envFile', value: `.env.${env}` },
      { type: 'envFile', value: '.env.local' },
      { type: 'envFile', value: '.env' },
      { type: 'envFile', value: '.env.defaults' }
    ]
  } else {
    throw new Error(`INVALID_CONVENTION: '${convention}'. permitted conventions: ['nextjs', 'flow']`)
  }
}

module.exports = conventions


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/decrypt.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/decrypt.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const dotenv = __webpack_require__(/*! dotenv */ "dotenv")

const parseEncryptionKeyFromDotenvKey = __webpack_require__(/*! ./parseEncryptionKeyFromDotenvKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEncryptionKeyFromDotenvKey.js")

function decrypt (ciphertext, dotenvKey) {
  const key = parseEncryptionKeyFromDotenvKey(dotenvKey)

  try {
    return dotenv.decrypt(ciphertext, key)
  } catch (e) {
    if (e.code === 'DECRYPTION_FAILED') {
      const error = new Error('[DECRYPTION_FAILED] Unable to decrypt .env.vault with DOTENV_KEY.')
      error.code = 'DECRYPTION_FAILED'
      error.help = '[DECRYPTION_FAILED] Run with debug flag [dotenvx run --debug -- yourcommand] or manually run [echo $DOTENV_KEY] to compare it to the one in .env.keys.'
      error.debug = `[DECRYPTION_FAILED] DOTENV_KEY is ${dotenvKey}`
      throw error
    }

    if (e.code === 'ERR_CRYPTO_INVALID_AUTH_TAG') {
      const error = new Error('[INVALID_CIPHERTEXT] Unable to decrypt what appears to be invalid ciphertext.')
      error.code = 'INVALID_CIPHERTEXT'
      error.help = '[INVALID_CIPHERTEXT] Run with debug flag [dotenvx run --debug -- yourcommand] or manually check .env.vault.'
      error.debug = `[INVALID_CIPHERTEXT] ciphertext is '${ciphertext}'`
      throw error
    }

    throw e
  }
}

module.exports = decrypt


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/decryptKeyValue.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/decryptKeyValue.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { decrypt } = __webpack_require__(/*! eciesjs */ "./node_modules/eciesjs/dist/index.js")

const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")

const PREFIX = 'encrypted:'

function decryptKeyValue (key, value, privateKeyName, privateKey) {
  let decryptedValue
  let decryptionError

  if (!value.startsWith(PREFIX)) {
    return value
  }

  privateKey = privateKey || ''
  if (privateKey.length <= 0) {
    decryptionError = new Errors({ key, privateKeyName, privateKey }).missingPrivateKey()
  } else {
    const privateKeys = privateKey.split(',')
    for (const privKey of privateKeys) {
      const secret = Buffer.from(privKey, 'hex')
      const encoded = value.substring(PREFIX.length)
      const ciphertext = Buffer.from(encoded, 'base64')

      try {
        decryptedValue = decrypt(secret, ciphertext).toString()
        decryptionError = null // reset to null error (scenario for multiple private keys)
        break
      } catch (e) {
        if (e.message === 'Invalid private key') {
          decryptionError = new Errors({ key, privateKeyName, privateKey }).invalidPrivateKey()
        } else if (e.message === 'Unsupported state or unable to authenticate data') {
          decryptionError = new Errors({ key, privateKeyName, privateKey }).looksWrongPrivateKey()
        } else if (e.message === 'Point of length 65 was invalid. Expected 33 compressed bytes or 65 uncompressed bytes') {
          decryptionError = new Errors({ key, privateKeyName, privateKey }).malformedEncryptedData()
        } else {
          decryptionError = new Errors({ key, privateKeyName, privateKey, message: e.message }).decryptionFailed()
        }
      }
    }
  }

  if (decryptionError) {
    throw decryptionError
  }

  return decryptedValue
}

module.exports = decryptKeyValue


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/deprecationNotice.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/deprecationNotice.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { logger } = __webpack_require__(/*! ./../../shared/logger */ "./node_modules/@dotenvx/dotenvx/src/shared/logger.js")

class DeprecationNotice {
  constructor (options = {}) {
    this.DOTENV_KEY = options.DOTENV_KEY || process.env.DOTENV_KEY
  }

  dotenvKey () {
    if (this.DOTENV_KEY) {
      logger.warn('[DEPRECATION NOTICE] Setting DOTENV_KEY with .env.vault is deprecated.')
      logger.warn('[DEPRECATION NOTICE] Run [dotenvx ext vault migrate] for instructions on converting your .env.vault file to encrypted .env files (using public key encryption algorithm secp256k1)')
      logger.warn('[DEPRECATION NOTICE] Read more at [https://github.com/dotenvx/dotenvx/blob/main/CHANGELOG.md#0380]')
    }
  }
}

module.exports = DeprecationNotice


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/detectEncoding.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/detectEncoding.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(/*! fs */ "fs")

function detectEncoding (filepath) {
  const buffer = fs.readFileSync(filepath)

  // check for UTF-16LE BOM (Byte Order Mark)
  if (buffer.length >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {
    return 'utf16le'
  }

  /* c8 ignore start */
  // check for UTF-8 BOM
  if (buffer.length >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
    return 'utf8'
  }

  /* c8 ignore stop */

  return 'utf8'
}

module.exports = detectEncoding


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/determineEnvs.js":
/*!************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/determineEnvs.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const dotenvPrivateKeyNames = __webpack_require__(/*! ./dotenvPrivateKeyNames */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvPrivateKeyNames.js")
const guessPrivateKeyFilename = __webpack_require__(/*! ./guessPrivateKeyFilename */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyFilename.js")

const TYPE_ENV_FILE = 'envFile'
const TYPE_ENV_VAULT_FILE = 'envVaultFile'
const DEFAULT_ENVS = [{ type: TYPE_ENV_FILE, value: '.env' }]
const DEFAULT_ENV_VAULTS = [{ type: TYPE_ENV_VAULT_FILE, value: '.env.vault' }]

function determineEnvsFromDotenvPrivateKey (privateKeyNames) {
  const envs = []

  for (const privateKeyName of privateKeyNames) {
    const filename = guessPrivateKeyFilename(privateKeyName)
    envs.push({ type: TYPE_ENV_FILE, value: filename })
  }

  return envs
}

function determineEnvs (envs = [], processEnv, DOTENV_KEY = '') {
  const privateKeyNames = dotenvPrivateKeyNames(processEnv)
  if (!envs || envs.length <= 0) {
    // if process.env.DOTENV_PRIVATE_KEY or process.env.DOTENV_PRIVATE_KEY_${environment} is set, assume inline encryption methodology
    if (privateKeyNames.length > 0) {
      return determineEnvsFromDotenvPrivateKey(privateKeyNames)
    }

    if (DOTENV_KEY.length > 0) {
      // if DOTENV_KEY is set then default to look for .env.vault file
      return DEFAULT_ENV_VAULTS
    } else {
      return DEFAULT_ENVS // default to .env file expectation
    }
  } else {
    let fileAlreadySpecified = false // can be .env or .env.vault type

    for (const env of envs) {
      // if DOTENV_KEY set then we are checking if a .env.vault file is already specified
      if (DOTENV_KEY.length > 0 && env.type === TYPE_ENV_VAULT_FILE) {
        fileAlreadySpecified = true
      }

      // if DOTENV_KEY not set then we are checking if a .env file is already specified
      if (DOTENV_KEY.length <= 0 && env.type === TYPE_ENV_FILE) {
        fileAlreadySpecified = true
      }
    }

    // return early since envs array objects already contain 1 .env.vault or .env file
    if (fileAlreadySpecified) {
      return envs
    }

    // no .env.vault or .env file specified as a flag so we assume either .env.vault (if dotenv key is set) or a .env file
    if (DOTENV_KEY.length > 0) {
      // if DOTENV_KEY is set then default to look for .env.vault file
      return [...DEFAULT_ENV_VAULTS, ...envs]
    } else {
      // if no DOTENV_KEY then default to look for .env file
      return [...DEFAULT_ENVS, ...envs]
    }
  }
}

module.exports = determineEnvs


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvOptionPaths.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvOptionPaths.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const resolveHome = __webpack_require__(/*! ./resolveHome */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveHome.js")

function dotenvOptionPaths (options) {
  let optionPaths = []

  if (options && options.path) {
    if (!Array.isArray(options.path)) {
      optionPaths = [resolveHome(options.path)]
    } else {
      optionPaths = [] // reset default

      for (const filepath of options.path) {
        optionPaths.push(resolveHome(filepath))
      }
    }
  }

  return optionPaths
}

module.exports = dotenvOptionPaths


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js ***!
  \**********************************************************************/
/***/ ((module) => {

// historical dotenv.parse - https://github.com/motdotla/dotenv)
const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

function dotenvParse (src, skipExpandForDoubleQuotes = false, skipConvertingWindowsNewlines = false, collectAllValues = false) {
  const obj = {}

  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  if (!skipConvertingWindowsNewlines) {
    lines = lines.replace(/\r\n?/mg, '\n')
  }

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    // Remove surrounding quotes
    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (maybeQuote === '"' && !skipExpandForDoubleQuotes) {
      value = value.replace(/\\n/g, '\n') // newline
      value = value.replace(/\\r/g, '\r') // carriage return
      value = value.replace(/\\t/g, '\t') // tabs
    }

    if (collectAllValues) {
      // handle scenario where user mistakenly includes plaintext duplicate in .env:
      //
      // # .env
      // HELLO="World"
      // HELLO="enrypted:1234"
      obj[key] = obj[key] || []
      obj[key].push(value)
    } else {
      // Add to object
      obj[key] = value
    }
  }

  return obj
}

module.exports = dotenvParse


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvPrivateKeyNames.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvPrivateKeyNames.js ***!
  \********************************************************************************/
/***/ ((module) => {

const PRIVATE_KEY_NAME_SCHEMA = 'DOTENV_PRIVATE_KEY'

function dotenvPrivateKeyNames (processEnv) {
  return Object.keys(processEnv).filter(key => key.startsWith(PRIVATE_KEY_NAME_SCHEMA))
}

module.exports = dotenvPrivateKeyNames


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/encryptValue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/encryptValue.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { encrypt } = __webpack_require__(/*! eciesjs */ "./node_modules/eciesjs/dist/index.js")

const PREFIX = 'encrypted:'

function encryptValue (value, publicKey) {
  const ciphertext = encrypt(publicKey, Buffer.from(value))
  const encoded = Buffer.from(ciphertext, 'hex').toString('base64') // base64 encode ciphertext

  return `${PREFIX}${encoded}`
}

module.exports = encryptValue


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const truncate = __webpack_require__(/*! ./truncate */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/truncate.js")

class Errors {
  constructor (options = {}) {
    this.filepath = options.filepath
    this.envFilepath = options.envFilepath

    this.key = options.key
    this.privateKey = options.privateKey
    this.privateKeyName = options.privateKeyName
    this.command = options.command

    this.message = options.message
  }

  missingEnvFile () {
    const code = 'MISSING_ENV_FILE'
    const message = `[${code}] missing ${this.envFilepath} file (${this.filepath})`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/484`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  missingKey () {
    const code = 'MISSING_KEY'
    const message = `[${code}] missing ${this.key} key`

    const e = new Error(message)
    e.code = code
    return e
  }

  missingPrivateKey () {
    const code = 'MISSING_PRIVATE_KEY'
    const message = `[${code}] could not decrypt ${this.key} using private key '${this.privateKeyName}=${truncate(this.privateKey)}'`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/464`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  invalidPrivateKey () {
    const code = 'INVALID_PRIVATE_KEY'
    const message = `[${code}] could not decrypt ${this.key} using private key '${this.privateKeyName}=${truncate(this.privateKey)}'`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/465`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  looksWrongPrivateKey () {
    const code = 'WRONG_PRIVATE_KEY'
    const message = `[${code}] could not decrypt ${this.key} using private key '${this.privateKeyName}=${truncate(this.privateKey)}'`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/466`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  malformedEncryptedData () {
    const code = 'MALFORMED_ENCRYPTED_DATA'
    const message = `[${code}] could not decrypt ${this.key} because encrypted data appears malformed`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/467`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  decryptionFailed () {
    const code = 'DECRYPTION_FAILED'
    const message = this.message

    const e = new Error(message)
    e.code = code
    return e
  }

  commandSubstitutionFailed () {
    const code = 'COMMAND_SUBSTITUTION_FAILED'
    const message = `[${code}] could not eval ${this.key} containing command '${this.command}': ${this.message}`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/532`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }

  dangerousDependencyHoist () {
    const code = 'DANGEROUS_DEPENDENCY_HOIST'
    const message = `[${code}] your environment has hoisted an incompatible version of a dotenvx dependency: ${this.message}`
    const help = `[${code}] https://github.com/dotenvx/dotenvx/issues/622`

    const e = new Error(message)
    e.code = code
    e.help = help
    return e
  }
}

module.exports = Errors


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeDollarSigns.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeDollarSigns.js ***!
  \****************************************************************************/
/***/ ((module) => {

function escapeDollarSigns (str) {
  return str.replace(/\$/g, '$$$$')
}

module.exports = escapeDollarSigns


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeForRegex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeForRegex.js ***!
  \*************************************************************************/
/***/ ((module) => {

function escapeForRegex (str) {
  return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')
}

module.exports = escapeForRegex


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/evalKeyValue.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/evalKeyValue.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { execSync } = __webpack_require__(/*! child_process */ "child_process")
const chomp = __webpack_require__(/*! ./chomp */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/chomp.js")
const Errors = __webpack_require__(/*! ./errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")

function evalKeyValue (key, value, processEnv, runningParsed) {
  // Match everything between the outermost $() using a regex with non-capturing groups
  const matches = value.match(/\$\(([^)]+(?:\)[^(]*)*)\)/g) || []
  return matches.reduce((newValue, match) => {
    const command = match.slice(2, -1) // Extract command by removing $() wrapper
    let result

    try {
      result = execSync(command, { env: { ...processEnv, ...runningParsed } }).toString() // execute command (including runningParsed)
    } catch (e) {
      throw new Errors({ key, command, message: e.message.trim() }).commandSubstitutionFailed()
    }

    result = chomp(result) // chomp it
    return newValue.replace(match, result) // Replace match with result
  }, value)
}

module.exports = evalKeyValue


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findEnvFiles.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/findEnvFiles.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")

const RESERVED_ENV_FILES = ['.env.vault', '.env.project', '.env.keys', '.env.me', '.env.x', '.env.example']

function findEnvFiles (directory) {
  try {
    const files = fsx.readdirSync(directory)
    const envFiles = files.filter(file =>
      file.startsWith('.env') &&
      !file.endsWith('.previous') &&
      !RESERVED_ENV_FILES.includes(file)
    )

    return envFiles
  } catch (e) {
    if (e.code === 'ENOENT') {
      const error = new Error(`missing directory (${directory})`)
      error.code = 'MISSING_DIRECTORY'

      throw error
    } else {
      throw e
    }
  }
}

module.exports = findEnvFiles


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPrivateKey.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPrivateKey.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// helpers
const guessPrivateKeyName = __webpack_require__(/*! ./guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")
const ProKeypair = __webpack_require__(/*! ./proKeypair */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/proKeypair.js")

// services
const Keypair = __webpack_require__(/*! ./../services/keypair */ "./node_modules/@dotenvx/dotenvx/src/lib/services/keypair.js")

function findPrivateKey (envFilepath, envKeysFilepath = null) {
  // use path/to/.env.${environment} to generate privateKeyName
  const privateKeyName = guessPrivateKeyName(envFilepath)

  const proKeypairs = new ProKeypair(envFilepath).run() // TODO: implement custom envKeysFilepath
  const keypairs = new Keypair(envFilepath, envKeysFilepath).run()

  return proKeypairs[privateKeyName] || keypairs[privateKeyName]
}

module.exports = { findPrivateKey }


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPublicKey.js":
/*!************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPublicKey.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// helpers
const guessPublicKeyName = __webpack_require__(/*! ./guessPublicKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js")
const ProKeypair = __webpack_require__(/*! ./proKeypair */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/proKeypair.js")

// services
const Keypair = __webpack_require__(/*! ./../services/keypair */ "./node_modules/@dotenvx/dotenvx/src/lib/services/keypair.js")

function findPublicKey (envFilepath) {
  const publicKeyName = guessPublicKeyName(envFilepath)

  const proKeypairs = new ProKeypair(envFilepath).run()
  const keypairs = new Keypair(envFilepath).run()

  return proKeypairs[publicKeyName] || keypairs[publicKeyName]
}

module.exports = findPublicKey


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(/*! fs */ "fs")

const ENCODING = 'utf8'

function readFileX (filepath, encoding = null) {
  if (!encoding) {
    encoding = ENCODING
  }

  return fs.readFileSync(filepath, encoding) // utf8 default so it returns a string
}

function writeFileX (filepath, str) {
  return fs.writeFileSync(filepath, str, ENCODING) // utf8 always
}

const fsx = {
  chmodSync: fs.chmodSync,
  existsSync: fs.existsSync,
  readdirSync: fs.readdirSync,
  readFileSync: fs.readFileSync,
  writeFileSync: fs.writeFileSync,
  appendFileSync: fs.appendFileSync,

  // fsx special commands
  readFileX,
  writeFileX
}

module.exports = fsx


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessEnvironment.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessEnvironment.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")

function guessEnvironment (filepath) {
  const filename = path.basename(filepath)

  const parts = filename.split('.')
  const possibleEnvironmentList = [...parts.slice(2)]

  if (possibleEnvironmentList.length === 0) {
    // handle .env1 -> development1
    const environment = filename.replace('.env', 'development')

    return environment
  }

  if (possibleEnvironmentList.length === 1) {
    return possibleEnvironmentList[0]
  }

  if (
    possibleEnvironmentList.length === 2
  ) {
    return possibleEnvironmentList.join('_')
  }

  return possibleEnvironmentList.slice(0, 2).join('_')
}

module.exports = guessEnvironment


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyFilename.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyFilename.js ***!
  \**********************************************************************************/
/***/ ((module) => {

const PREFIX = 'DOTENV_PRIVATE_KEY'

function guessPrivateKeyFilename (privateKeyName) {
  // .env
  if (privateKeyName === PREFIX) {
    return '.env'
  }

  const filenameSuffix = privateKeyName.substring(`${PREFIX}_`.length).split('_').join('.').toLowerCase()
  // .env.ENVIRONMENT

  return `.env.${filenameSuffix}`
}

module.exports = guessPrivateKeyFilename


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")
const guessEnvironment = __webpack_require__(/*! ./guessEnvironment */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessEnvironment.js")

function guessPrivateKeyName (filepath) {
  const filename = path.basename(filepath).toLowerCase()

  // .env
  if (filename === '.env') {
    return 'DOTENV_PRIVATE_KEY'
  }

  // .env.ENVIRONMENT
  const environment = guessEnvironment(filename)

  return `DOTENV_PRIVATE_KEY_${environment.toUpperCase()}`
}

module.exports = guessPrivateKeyName


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")
const guessEnvironment = __webpack_require__(/*! ./guessEnvironment */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessEnvironment.js")

function guessPublicKeyName (filepath) {
  const filename = path.basename(filepath).toLowerCase()

  // .env
  if (filename === '.env') {
    return 'DOTENV_PUBLIC_KEY'
  }

  // .env.ENVIRONMENT
  const environment = guessEnvironment(filename)

  return `DOTENV_PUBLIC_KEY_${environment.toUpperCase()}`
}

module.exports = guessPublicKeyName


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/isEncrypted.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/isEncrypted.js ***!
  \**********************************************************************/
/***/ ((module) => {

const ENCRYPTION_PATTERN = /^encrypted:.+/

function isEncrypted (value) {
  return ENCRYPTION_PATTERN.test(value)
}

module.exports = isEncrypted


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/isIgnoringDotenvKeys.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/isIgnoringDotenvKeys.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const ignore = __webpack_require__(/*! ignore */ "./node_modules/ignore/index.js")

function isIgnoringDotenvKeys () {
  if (!fsx.existsSync('.gitignore')) {
    return false
  }

  const gitignore = fsx.readFileX('.gitignore')
  const ig = ignore(gitignore).add(gitignore)

  if (!ig.ignores('.env.keys')) {
    return false
  }

  return true
}

module.exports = isIgnoringDotenvKeys


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/keypair.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/keypair.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { PrivateKey } = __webpack_require__(/*! eciesjs */ "./node_modules/eciesjs/dist/index.js")

function keypair (existingPrivateKey) {
  let kp

  if (existingPrivateKey) {
    kp = new PrivateKey(Buffer.from(existingPrivateKey, 'hex'))
  } else {
    kp = new PrivateKey()
  }

  const publicKey = kp.publicKey.toHex()
  const privateKey = kp.secret.toString('hex')

  return {
    publicKey,
    privateKey
  }
}

module.exports = keypair


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/packageJson.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/packageJson.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { name, version, description } = __webpack_require__(/*! ../../../package.json */ "./node_modules/@dotenvx/dotenvx/package.json")

module.exports = { name, version, description }


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parse.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/parse.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const decryptKeyValue = __webpack_require__(/*! ./decryptKeyValue */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/decryptKeyValue.js")
const evalKeyValue = __webpack_require__(/*! ./evalKeyValue */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/evalKeyValue.js")
const resolveEscapeSequences = __webpack_require__(/*! ./resolveEscapeSequences */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveEscapeSequences.js")

class Parse {
  static LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

  constructor (src, privateKey = null, processEnv = process.env, overload = false, privateKeyName = null) {
    this.src = src
    this.privateKey = privateKey
    this.privateKeyName = privateKeyName
    this.processEnv = processEnv
    this.overload = overload

    this.parsed = {}
    this.preExisted = {}
    this.injected = {}
    this.errors = []

    // for use with progressive expansion
    this.runningParsed = {}
    // for use with stopping expansion for literals
    this.literals = {}
  }

  run () {
    const lines = this.getLines()

    let match
    while ((match = Parse.LINE.exec(lines)) !== null) {
      const key = match[1]
      const value = match[2]
      const quote = this.quote(value) // must be raw match
      this.parsed[key] = this.clean(value, quote) // file value

      if (!this.overload && this.inProcessEnv(key)) {
        this.parsed[key] = this.processEnv[key] // use process.env pre-existing value
      }

      // decrypt
      try {
        this.parsed[key] = this.decrypt(key, this.parsed[key])
      } catch (e) {
        this.errors.push(e)
      }

      // eval empty, double, or backticks
      let evaled = false
      if (quote !== "'" && (!this.inProcessEnv(key) || this.processEnv[key] === this.parsed[key])) {
        const priorEvaled = this.parsed[key]
        // eval
        try {
          this.parsed[key] = this.eval(key, priorEvaled)
        } catch (e) {
          this.errors.push(e)
        }
        if (priorEvaled !== this.parsed[key]) {
          evaled = true
        }
      }

      // expand empty, double, or backticks
      if (!evaled && quote !== "'" && (!this.processEnv[key] || this.overload)) {
        this.parsed[key] = resolveEscapeSequences(this.expand(this.parsed[key]))
      }

      if (quote === "'") {
        this.literals[key] = this.parsed[key]
      }

      // for use with progressive expansion
      this.runningParsed[key] = this.parsed[key]

      if (Object.prototype.hasOwnProperty.call(this.processEnv, key) && !this.overload) {
        this.preExisted[key] = this.processEnv[key] // track preExisted
      } else {
        this.injected[key] = this.parsed[key] // track injected
      }
    }

    return {
      parsed: this.parsed,
      processEnv: this.processEnv,
      injected: this.injected,
      preExisted: this.preExisted,
      errors: this.errors
    }
  }

  trimmer (value) {
    // Default undefined or null to empty string
    return (value || '').trim()
  }

  quote (value) {
    const v = this.trimmer(value)
    const maybeQuote = v[0]
    let q = ''
    switch (maybeQuote) {
      // single
      case "'":
        q = "'"
        break
      // double
      case '"':
        q = '"'
        break
      // backtick
      case '`':
        q = '`'
        break
      // empty
      default:
        q = ''
    }

    return q
  }

  clean (value, _quote) {
    let v = this.trimmer(value)

    // Remove surrounding quotes
    v = v.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    // Expand newlines if double quoted
    if (_quote === '"') {
      v = v.replace(/\\n/g, '\n') // newline
      v = v.replace(/\\r/g, '\r') // carriage return
      v = v.replace(/\\t/g, '\t') // tabs
    }

    return v
  }

  decrypt (key, value) {
    return decryptKeyValue(key, value, this.privateKeyName, this.privateKey)
  }

  eval (key, value) {
    return evalKeyValue(key, value, this.processEnv, this.runningParsed)
  }

  expand (value) {
    let env = { ...this.runningParsed, ...this.processEnv } // typically process.env wins
    if (this.overload) {
      env = { ...this.processEnv, ...this.runningParsed } // parsed wins
    }

    const regex = /(?<!\\)\${([^{}]+)}|(?<!\\)\$([A-Za-z_][A-Za-z0-9_]*)/g

    let result = value
    let match

    while ((match = regex.exec(result)) !== null) {
      const [template, bracedExpression, unbracedExpression] = match
      const expression = bracedExpression || unbracedExpression

      // match the operators `:+`, `+`, `:-`, and `-`
      const opRegex = /(:\+|\+|:-|-)/
      // find first match
      const opMatch = expression.match(opRegex)
      const splitter = opMatch ? opMatch[0] : null

      const r = expression.split(splitter)

      let defaultValue
      let value
      const key = r.shift()

      if ([':+', '+'].includes(splitter)) {
        defaultValue = env[key] ? r.join(splitter) : ''
        value = null
      } else {
        defaultValue = r.join(splitter)
        value = env[key]
      }

      if (value) {
        result = result.replace(template, value)
      } else {
        result = result.replace(template, defaultValue)
      }

      // if the result equaled what was in env then stop expanding - handle self-referential check as well
      if (result === env[key]) {
        break
      }

      // if the result came from what was a literal value then stop expanding
      if (this.literals[key]) {
        break
      }

      regex.lastIndex = 0 // reset regex search position to re-evaluate after each replacement
    }

    return result
  }

  inProcessEnv (key) {
    return Object.prototype.hasOwnProperty.call(this.processEnv, key)
  }

  getLines () {
    return (this.src || '').toString().replace(/\r\n?/mg, '\n') // Convert buffer to string and Convert line breaks to same format
  }
}

module.exports = Parse


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEncryptionKeyFromDotenvKey.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEncryptionKeyFromDotenvKey.js ***!
  \******************************************************************************************/
/***/ ((module) => {

function parseEncryptionKeyFromDotenvKey (dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (e) {
    throw new Error('INVALID_DOTENV_KEY: Incomplete format. It should be a dotenv uri. (dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development)')
  }

  // Get decrypt key
  const key = uri.password
  if (!key) {
    throw new Error('INVALID_DOTENV_KEY: Missing key part')
  }

  return Buffer.from(key.slice(-64), 'hex')
}

module.exports = parseEncryptionKeyFromDotenvKey


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEnvironmentFromDotenvKey.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEnvironmentFromDotenvKey.js ***!
  \****************************************************************************************/
/***/ ((module) => {

function parseEnvironmentFromDotenvKey (dotenvKey) {
  // Parse DOTENV_KEY. Format is a URI
  let uri
  try {
    uri = new URL(dotenvKey)
  } catch (e) {
    throw new Error(`INVALID_DOTENV_KEY: ${e.message}`)
  }

  // Get environment
  const environment = uri.searchParams.get('environment')
  if (!environment) {
    throw new Error('INVALID_DOTENV_KEY: Missing environment part')
  }

  return environment
}

module.exports = parseEnvironmentFromDotenvKey


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/proKeypair.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/proKeypair.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")
const childProcess = __webpack_require__(/*! child_process */ "child_process")

const guessPrivateKeyName = __webpack_require__(/*! ./guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")
const guessPublicKeyName = __webpack_require__(/*! ./guessPublicKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js")

class ProKeypair {
  constructor (envFilepath) {
    this.envFilepath = envFilepath
  }

  run () {
    let result = {}

    try {
      const fallbackBin = path.resolve(process.cwd(), 'node_modules/.bin/dotenvx-pro')
      const output = childProcess.execSync(`${fallbackBin} keypair -f ${this.envFilepath}`, { stdio: ['pipe', 'pipe', 'ignore'] }).toString().trim()
      result = JSON.parse(output)
    } catch (_e) {
      try {
        // if installed as binary cli
        const output = childProcess.execSync(`dotenvx-pro keypair -f ${this.envFilepath}`, { stdio: ['pipe', 'pipe', 'ignore'] }).toString().trim()

        result = JSON.parse(output)
      } catch (_e) {
        const privateKeyName = guessPrivateKeyName(this.envFilepath)
        const publicKeyName = guessPublicKeyName(this.envFilepath)

        // match format of dotenvx-pro
        result[privateKeyName] = null
        result[publicKeyName] = null
      }
    }

    return result
  }
}

module.exports = ProKeypair


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/quotes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/quotes.js ***!
  \*****************************************************************/
/***/ ((module) => {

const LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg

function quotes (src) {
  const obj = {}
  // Convert buffer to string
  let lines = src.toString()

  // Convert line breaks to same format
  lines = lines.replace(/\r\n?/mg, '\n')

  let match
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1]

    // Default undefined or null to empty string
    let value = (match[2] || '')

    // Remove whitespace
    value = value.trim()

    // Check if double quoted
    const maybeQuote = value[0]

    value = value.replace(/^(['"`])([\s\S]*)\1$/mg, '$2')

    if (maybeQuote === value[0]) {
      obj[key] = ''
    } else {
      obj[key] = maybeQuote
    }
  }

  return obj
}

module.exports = quotes


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/replace.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/replace.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const quotes = __webpack_require__(/*! ./quotes */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/quotes.js")
const dotenvParse = __webpack_require__(/*! ./dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")
const escapeForRegex = __webpack_require__(/*! ./escapeForRegex */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeForRegex.js")
const escapeDollarSigns = __webpack_require__(/*! ./escapeDollarSigns */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/escapeDollarSigns.js")

function replace (src, key, replaceValue) {
  let output
  let newPart = ''

  const parsed = dotenvParse(src, true, true) // skip expanding \n and skip converting \r\n
  const _quotes = quotes(src)
  if (Object.prototype.hasOwnProperty.call(parsed, key)) {
    const quote = _quotes[key]
    newPart += `${key}=${quote}${replaceValue}${quote}`

    const originalValue = parsed[key]
    const escapedOriginalValue = escapeForRegex(originalValue)

    // conditionally enforce end of line
    let enforceEndOfLine = ''
    if (escapedOriginalValue === '') {
      enforceEndOfLine = '$' // EMPTY scenario

      // if empty quote and consecutive newlines
      const newlineMatch = src.match(new RegExp(`${key}\\s*=\\s*\n\n`, 'm')) // match any consecutive newline scenario for a blank value
      if (quote === '' && newlineMatch) {
        const newlineCount = (newlineMatch[0].match(/\n/g)).length - 1
        for (let i = 0; i < newlineCount; i++) {
          newPart += '\n' // re-append the extra newline to preserve user's format choice
        }
      }
    }

    const currentPart = new RegExp(
      '^' + // start of line
      '(\\s*)?' + // spaces
      '(export\\s+)?' + // export
      key + // KEY
      '\\s*=\\s*' + // spaces (KEY = value)
      '["\'`]?' + // open quote
      escapedOriginalValue + // escaped value
      '["\'`]?' + // close quote
      enforceEndOfLine
      ,
      'gm' // (g)lobal (m)ultiline
    )

    const saferInput = escapeDollarSigns(newPart) // cleanse user inputted capture groups ($1, $2 etc)

    // $1 preserves spaces
    // $2 preserves export
    output = src.replace(currentPart, `$1$2${saferInput}`)
  } else {
    newPart += `${key}="${replaceValue}"`

    // append
    if (src.endsWith('\n')) {
      newPart = newPart + '\n'
    } else {
      newPart = '\n' + newPart
    }

    output = src + newPart
  }

  return output
}

module.exports = replace


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveEscapeSequences.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveEscapeSequences.js ***!
  \*********************************************************************************/
/***/ ((module) => {

function resolveEscapeSequences (value) {
  return value.replace(/\\\$/g, '$')
}

module.exports = resolveEscapeSequences


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveHome.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/resolveHome.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const os = __webpack_require__(/*! os */ "os")
const path = __webpack_require__(/*! path */ "path")

function resolveHome (filepath) {
  if (filepath[0] === '~') {
    return path.join(os.homedir(), filepath.slice(1))
  }

  return filepath
}

module.exports = resolveHome


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPrivateKey.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPrivateKey.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const path = __webpack_require__(/*! path */ "path")

const PUBLIC_KEY_SCHEMA = 'DOTENV_PUBLIC_KEY'
const PRIVATE_KEY_SCHEMA = 'DOTENV_PRIVATE_KEY'

const dotenvParse = __webpack_require__(/*! ./dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")
const guessPrivateKeyName = __webpack_require__(/*! ./guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")

function searchProcessEnv (privateKeyName) {
  if (process.env[privateKeyName] && process.env[privateKeyName].length > 0) {
    return process.env[privateKeyName]
  }
}

function searchKeysFile (privateKeyName, envFilepath, envKeysFilepath = null) {
  let keysFilepath = path.resolve(path.dirname(envFilepath), '.env.keys') // typical scenario
  if (envKeysFilepath) { // user specified -fk flag
    keysFilepath = path.resolve(envKeysFilepath)
  }

  if (fsx.existsSync(keysFilepath)) {
    const keysSrc = fsx.readFileX(keysFilepath)
    const keysParsed = dotenvParse(keysSrc)

    if (keysParsed[privateKeyName] && keysParsed[privateKeyName].length > 0) {
      return keysParsed[privateKeyName]
    }
  }
}

function invertForPrivateKeyName (envFilepath) {
  if (!fsx.existsSync(envFilepath)) {
    return null
  }

  const envSrc = fsx.readFileX(envFilepath)
  const envParsed = dotenvParse(envSrc)

  let publicKeyName
  for (const keyName of Object.keys(envParsed)) {
    if (keyName === PUBLIC_KEY_SCHEMA || keyName.startsWith(PUBLIC_KEY_SCHEMA)) {
      publicKeyName = keyName // find DOTENV_PUBLIC_KEY* in filename
    }
  }

  if (publicKeyName) {
    return publicKeyName.replace(PUBLIC_KEY_SCHEMA, PRIVATE_KEY_SCHEMA) // return inverted (DOTENV_PUBLIC_KEY* -> DOTENV_PRIVATE_KEY*) if found
  }

  return null
}

function smartDotenvPrivateKey (envFilepath, envKeysFilepath = null) {
  let privateKey = null
  let privateKeyName = guessPrivateKeyName(envFilepath) // DOTENV_PRIVATE_KEY_${ENVIRONMENT}

  // 1. attempt process.env first
  privateKey = searchProcessEnv(privateKeyName)
  if (privateKey) {
    return privateKey
  }

  // 2. attempt .env.keys second (path/to/.env.keys)
  privateKey = searchKeysFile(privateKeyName, envFilepath, envKeysFilepath)
  if (privateKey) {
    return privateKey
  }

  // 3. attempt inverting `DOTENV_PUBLIC_KEY*` name inside file (unlocks custom filenames not matching .env.${ENVIRONMENT} pattern)
  privateKeyName = invertForPrivateKeyName(envFilepath)
  if (privateKeyName) {
    // 3.1 attempt process.env first
    privateKey = searchProcessEnv(privateKeyName)
    if (privateKey) {
      return privateKey
    }

    // 3.2. attempt .env.keys second (path/to/.env.keys)
    privateKey = searchKeysFile(privateKeyName, envFilepath, envKeysFilepath)
    if (privateKey) {
      return privateKey
    }
  }

  return null
}

module.exports = smartDotenvPrivateKey


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPublicKey.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPublicKey.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const dotenvParse = __webpack_require__(/*! ./dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")

const guessPublicKeyName = __webpack_require__(/*! ./guessPublicKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js")

function searchProcessEnv (publicKeyName) {
  if (process.env[publicKeyName] && process.env[publicKeyName].length > 0) {
    return process.env[publicKeyName]
  }
}

function searchEnvFile (publicKeyName, envFilepath) {
  if (fsx.existsSync(envFilepath)) {
    const keysSrc = fsx.readFileX(envFilepath)
    const keysParsed = dotenvParse(keysSrc)

    if (keysParsed[publicKeyName] && keysParsed[publicKeyName].length > 0) {
      return keysParsed[publicKeyName]
    }
  }
}

function smartDotenvPublicKey (envFilepath) {
  let publicKey = null
  const publicKeyName = guessPublicKeyName(envFilepath) // DOTENV_PUBLIC_KEY_${ENVIRONMENT}

  // 1. attempt process.env first
  publicKey = searchProcessEnv(publicKeyName)
  if (publicKey) {
    return publicKey
  }

  // 2. attempt .env.keys second (path/to/.env.keys)
  publicKey = searchEnvFile(publicKeyName, envFilepath)
  if (publicKey) {
    return publicKey
  }

  return null
}

module.exports = smartDotenvPublicKey


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/truncate.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/helpers/truncate.js ***!
  \*******************************************************************/
/***/ ((module) => {

function truncate (str, showChar = 7) {
  if (str && str.length > 0) {
    const visiblePart = str.slice(0, showChar)
    return visiblePart + '…'
  } else {
    return ''
  }
}

module.exports = truncate


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/main.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/main.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// @ts-check
const path = __webpack_require__(/*! path */ "path")

// shared
const { setLogLevel, setLogName, setLogVersion, logger } = __webpack_require__(/*! ./../shared/logger */ "./node_modules/@dotenvx/dotenvx/src/shared/logger.js")
const { getColor, bold } = __webpack_require__(/*! ./../shared/colors */ "./node_modules/@dotenvx/dotenvx/src/shared/colors.js")

// services
const Ls = __webpack_require__(/*! ./services/ls */ "./node_modules/@dotenvx/dotenvx/src/lib/services/ls.js")
const Run = __webpack_require__(/*! ./services/run */ "./node_modules/@dotenvx/dotenvx/src/lib/services/run.js")
const Sets = __webpack_require__(/*! ./services/sets */ "./node_modules/@dotenvx/dotenvx/src/lib/services/sets.js")
const Get = __webpack_require__(/*! ./services/get */ "./node_modules/@dotenvx/dotenvx/src/lib/services/get.js")
const Keypair = __webpack_require__(/*! ./services/keypair */ "./node_modules/@dotenvx/dotenvx/src/lib/services/keypair.js")
const Genexample = __webpack_require__(/*! ./services/genexample */ "./node_modules/@dotenvx/dotenvx/src/lib/services/genexample.js")
const Radar = __webpack_require__(/*! ./services/radar */ "./node_modules/@dotenvx/dotenvx/src/lib/services/radar.js")

// helpers
const buildEnvs = __webpack_require__(/*! ./helpers/buildEnvs */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/buildEnvs.js")
const Parse = __webpack_require__(/*! ./helpers/parse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parse.js")
const fsx = __webpack_require__(/*! ./helpers/fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const isIgnoringDotenvKeys = __webpack_require__(/*! ./helpers/isIgnoringDotenvKeys */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/isIgnoringDotenvKeys.js")

/** @type {import('./main').config} */
const config = function (options = {}) {
  // allow user to set processEnv to write to
  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  // overload
  const overload = options.overload || options.override

  // ignore
  const ignore = options.ignore || []

  // strict
  const strict = options.strict

  // envKeysFile
  const envKeysFile = options.envKeysFile

  // DOTENV_KEY (DEPRECATED)
  let DOTENV_KEY = process.env.DOTENV_KEY
  if (options && options.DOTENV_KEY) {
    DOTENV_KEY = options.DOTENV_KEY
  }

  if (options) {
    setLogLevel(options)
    setLogName(options)
    setLogVersion(options)
  }

  try {
    const envs = buildEnvs(options, DOTENV_KEY)
    const {
      beforeEnv,
      afterEnv,
      processedEnvs,
      readableFilepaths,
      uniqueInjectedKeys
    } = new Run(envs, overload, DOTENV_KEY, processEnv, envKeysFile).run()

    try { new Radar().observe({ beforeEnv, processedEnvs, afterEnv }) } catch {}

    let lastError
    /** @type {Record<string, string>} */
    const parsedAll = {}
    for (const processedEnv of processedEnvs) {
      if (processedEnv.type === 'envVaultFile') {
        logger.verbose(`loading env from encrypted ${processedEnv.filepath} (${path.resolve(processedEnv.filepath)})`)
        logger.debug(`decrypting encrypted env from ${processedEnv.filepath} (${path.resolve(processedEnv.filepath)})`)
      }

      if (processedEnv.type === 'envFile') {
        logger.verbose(`loading env from ${processedEnv.filepath} (${path.resolve(processedEnv.filepath)})`)
      }

      for (const error of processedEnv.errors || []) {
        if (ignore.includes(error.code)) {
          logger.verbose(`ignored: ${error.message}`)
          continue // ignore error
        }

        if (strict) throw error // throw if strict and not ignored

        lastError = error // surface later in { error }

        if (error.code === 'MISSING_ENV_FILE') {
          if (!options.convention) { // do not output error for conventions (too noisy)
            logger.error(error.message)
            if (error.help) {
              logger.error(error.help)
            }
          }
        } else {
          logger.error(error.message)
          if (error.help) {
            logger.error(error.help)
          }
        }
      }

      Object.assign(parsedAll, processedEnv.injected || {})
      Object.assign(parsedAll, processedEnv.preExisted || {}) // preExisted 'wins'

      // debug parsed
      logger.debug(processedEnv.parsed)

      // verbose/debug injected key/value
      for (const [key, value] of Object.entries(processedEnv.injected || {})) {
        logger.verbose(`${key} set`)
        logger.debug(`${key} set to ${value}`)
      }

      // verbose/debug preExisted key/value
      for (const [key, value] of Object.entries(processedEnv.preExisted || {})) {
        logger.verbose(`${key} pre-exists (protip: use --overload to override)`)
        logger.debug(`${key} pre-exists as ${value} (protip: use --overload to override)`)
      }
    }

    let msg = `injecting env (${uniqueInjectedKeys.length})`
    if (readableFilepaths.length > 0) {
      msg += ` from ${readableFilepaths.join(', ')}`
    }
    logger.successv(msg)

    if (lastError) {
      return { parsed: parsedAll, error: lastError }
    } else {
      return { parsed: parsedAll }
    }
  } catch (error) {
    if (strict) throw error // throw immediately if strict

    logger.error(error.message)
    if (error.help) {
      logger.help(error.help)
    }

    return { parsed: {}, error }
  }
}

/** @type {import('./main').parse} */
const parse = function (src, options = {}) {
  // allow user to set processEnv to read from
  let processEnv = process.env
  if (options && options.processEnv != null) {
    processEnv = options.processEnv
  }

  // private decryption key
  const privateKey = options.privateKey || null

  // overload
  const overload = options.overload || options.override

  const { parsed, errors } = new Parse(src, privateKey, processEnv, overload).run()

  // display any errors
  for (const error of errors) {
    logger.error(error.message)
    if (error.help) {
      logger.error(error.help)
    }
  }

  return parsed
}

/* @type {import('./main').set} */
const set = function (key, value, options = {}) {
  // encrypt
  let encrypt = true
  if (options.plain) {
    encrypt = false
  } else if (options.encrypt === false) {
    encrypt = false
  }

  const envs = buildEnvs(options)
  const envKeysFilepath = options.envKeysFile

  const {
    processedEnvs,
    changedFilepaths,
    unchangedFilepaths
  } = new Sets(key, value, envs, encrypt, envKeysFilepath).run()

  let withEncryption = ''

  if (encrypt) {
    withEncryption = ' with encryption'
  }

  for (const processedEnv of processedEnvs) {
    logger.verbose(`setting for ${processedEnv.envFilepath}`)

    if (processedEnv.error) {
      if (processedEnv.error.code === 'MISSING_ENV_FILE') {
        logger.warn(processedEnv.error.message)
        logger.help(`? add one with [echo "HELLO=World" > ${processedEnv.envFilepath}] and re-run [dotenvx set]`)
      } else {
        logger.warn(processedEnv.error.message)
        if (processedEnv.error.help) {
          logger.help(processedEnv.error.help)
        }
      }
    } else {
      fsx.writeFileX(processedEnv.filepath, processedEnv.envSrc)

      logger.verbose(`${processedEnv.key} set${withEncryption} (${processedEnv.envFilepath})`)
      logger.debug(`${processedEnv.key} set${withEncryption} to ${processedEnv.value} (${processedEnv.envFilepath})`)
    }
  }

  if (changedFilepaths.length > 0) {
    logger.success(`✔ set ${key}${withEncryption} (${changedFilepaths.join(',')})`)
  } else if (unchangedFilepaths.length > 0) {
    logger.info(`no changes (${unchangedFilepaths})`)
  } else {
    // do nothing
  }

  for (const processedEnv of processedEnvs) {
    if (processedEnv.privateKeyAdded) {
      logger.success(`✔ key added to ${processedEnv.envKeysFilepath} (${processedEnv.privateKeyName})`)

      if (!isIgnoringDotenvKeys()) {
        logger.help('⮕  next run [dotenvx ext gitignore --pattern .env.keys] to gitignore .env.keys')
      }

      logger.help(`⮕  next run [${processedEnv.privateKeyName}='${processedEnv.privateKey}' dotenvx get ${key}] to test decryption locally`)
    }
  }

  return {
    processedEnvs,
    changedFilepaths,
    unchangedFilepaths
  }
}

/* @type {import('./main').get} */
const get = function (key, options = {}) {
  const envs = buildEnvs(options)

  // ignore
  const ignore = options.ignore || []

  const { parsed, errors } = new Get(key, envs, options.overload, process.env.DOTENV_KEY, options.all, options.envKeysFile).run()

  for (const error of errors || []) {
    if (ignore.includes(error.code)) {
      continue // ignore error
    }

    if (options.strict) throw error // throw immediately if strict

    logger.error(error.message)
    if (error.help) {
      logger.error(error.help)
    }
  }

  if (key) {
    const single = parsed[key]
    if (single === undefined) {
      return undefined
    } else {
      return single
    }
  } else {
    if (options.format === 'eval') {
      let inline = ''
      for (const [key, value] of Object.entries(parsed)) {
        inline += `${key}=${escape(value)}\n`
      }
      inline = inline.trim()

      return inline
    } else if (options.format === 'shell') {
      let inline = ''
      for (const [key, value] of Object.entries(parsed)) {
        inline += `${key}=${value} `
      }
      inline = inline.trim()

      return inline
    } else {
      return parsed
    }
  }
}

/** @type {import('./main').ls} */
const ls = function (directory, envFile, excludeEnvFile) {
  return new Ls(directory, envFile, excludeEnvFile).run()
}

/** @type {import('./main').genexample} */
const genexample = function (directory, envFile) {
  return new Genexample(directory, envFile).run()
}

/** @type {import('./main').keypair} */
const keypair = function (envFile, key, envKeysFile = null) {
  const keypairs = new Keypair(envFile, envKeysFile).run()
  if (key) {
    return keypairs[key]
  } else {
    return keypairs
  }
}

module.exports = {
  // dotenv proxies
  config,
  parse,
  // actions related
  set,
  get,
  ls,
  keypair,
  genexample,
  // expose for libs depending on @dotenvx/dotenvx - like dotenvx-radar
  setLogLevel,
  logger,
  getColor,
  bold
}


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/genexample.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/genexample.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./../helpers/fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const path = __webpack_require__(/*! path */ "path")

const Errors = __webpack_require__(/*! ../helpers/errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")
const findEnvFiles = __webpack_require__(/*! ../helpers/findEnvFiles */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findEnvFiles.js")
const replace = __webpack_require__(/*! ../helpers/replace */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/replace.js")
const dotenvParse = __webpack_require__(/*! ../helpers/dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")

class Genexample {
  constructor (directory = '.', envFile) {
    this.directory = directory
    this.envFile = envFile || findEnvFiles(directory)

    this.exampleFilename = '.env.example'
    this.exampleFilepath = path.resolve(this.directory, this.exampleFilename)
  }

  run () {
    if (this.envFile.length < 1) {
      const code = 'MISSING_ENV_FILES'
      const message = 'no .env* files found'
      const help = '? add one with [echo "HELLO=World" > .env] and then run [dotenvx genexample]'

      const error = new Error(message)
      error.code = code
      error.help = help
      throw error
    }

    const keys = new Set()
    const addedKeys = new Set()
    const envFilepaths = this._envFilepaths()
    /** @type {Record<string, string>} */
    const injected = {}
    /** @type {Record<string, string>} */
    const preExisted = {}

    let exampleSrc = `# ${this.exampleFilename} - generated with dotenvx\n`

    for (const envFilepath of envFilepaths) {
      const filepath = path.resolve(this.directory, envFilepath)
      if (!fsx.existsSync(filepath)) {
        const error = new Errors({ envFilepath, filepath }).missingEnvFile()
        error.help = `? add it with [echo "HELLO=World" > ${envFilepath}] and then run [dotenvx genexample]`
        throw error
      }

      // get the original src
      let src = fsx.readFileX(filepath)
      const parsed = dotenvParse(src)
      for (const key in parsed) {
        // used later
        keys.add(key)

        // once newSrc is built write it out
        src = replace(src, key, '') // empty value
      }

      exampleSrc += `\n${src}`
    }

    if (!fsx.existsSync(this.exampleFilepath)) {
      // it doesn't exist so just write this first generated one
      // exampleSrc - already written to from the prior loop
      for (const key of [...keys]) {
        // every key is added since it's the first time generating .env.example
        addedKeys.add(key)

        injected[key] = ''
      }
    } else {
      // it already exists (which means the user might have it modified a way in which they prefer, so replace exampleSrc with their existing .env.example)
      exampleSrc = fsx.readFileX(this.exampleFilepath)

      const parsed = dotenvParse(exampleSrc)
      for (const key of [...keys]) {
        if (key in parsed) {
          preExisted[key] = parsed[key]
        } else {
          exampleSrc += `${key}=''\n`

          addedKeys.add(key)

          injected[key] = ''
        }
      }
    }

    return {
      envExampleFile: exampleSrc,
      envFile: this.envFile,
      exampleFilepath: this.exampleFilepath,
      addedKeys: [...addedKeys],
      injected,
      preExisted
    }
  }

  _envFilepaths () {
    if (!Array.isArray(this.envFile)) {
      return [this.envFile]
    }

    return this.envFile
  }
}

module.exports = Genexample


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/get.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/get.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Run = __webpack_require__(/*! ./run */ "./node_modules/@dotenvx/dotenvx/src/lib/services/run.js")
const Errors = __webpack_require__(/*! ./../helpers/errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")

class Get {
  constructor (key, envs = [], overload = false, DOTENV_KEY = '', all = false, envKeysFilepath = null) {
    this.key = key
    this.envs = envs
    this.overload = overload
    this.DOTENV_KEY = DOTENV_KEY
    this.all = all
    this.envKeysFilepath = envKeysFilepath
  }

  run () {
    const processEnv = { ...process.env }
    const { processedEnvs } = new Run(this.envs, this.overload, this.DOTENV_KEY, processEnv, this.envKeysFilepath).run()

    const errors = []
    for (const processedEnv of processedEnvs) {
      for (const error of processedEnv.errors) {
        errors.push(error)
      }
    }

    if (this.key) {
      const parsed = {}
      const value = processEnv[this.key]
      parsed[this.key] = value

      if (value === undefined) {
        errors.push(new Errors({ key: this.key }).missingKey())
      }

      return { parsed, errors }
    } else {
      // if user wants to return ALL envs (even prior set on machine)
      if (this.all) {
        return { parsed: processEnv, errors }
      }

      // typical scenario - return only envs that were identified in the .env file
      // iterate over all processedEnvs.parsed and grab from processEnv
      /** @type {Record<string, string>} */
      const parsed = {}
      for (const processedEnv of processedEnvs) {
        // parsed means we saw the key in a file or --env flag. this effectively filters out any preset machine envs - while still respecting complex evaluating, expansion, and overload. in other words, the value might be the machine value because the key was displayed in a .env file
        if (processedEnv.parsed) {
          for (const key of Object.keys(processedEnv.parsed)) {
            parsed[key] = processEnv[key]
          }
        }
      }

      return { parsed, errors }
    }
  }
}

module.exports = Get


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/keypair.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/keypair.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const guessPublicKeyName = __webpack_require__(/*! ./../helpers/guessPublicKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js")
const smartDotenvPublicKey = __webpack_require__(/*! ./../helpers/smartDotenvPublicKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPublicKey.js")
const guessPrivateKeyName = __webpack_require__(/*! ./../helpers/guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")
const smartDotenvPrivateKey = __webpack_require__(/*! ./../helpers/smartDotenvPrivateKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/smartDotenvPrivateKey.js")

class Keypair {
  constructor (envFile = '.env', envKeysFilepath = null) {
    this.envFile = envFile
    this.envKeysFilepath = envKeysFilepath
  }

  run () {
    const out = {}

    const envFilepaths = this._envFilepaths()
    for (const envFilepath of envFilepaths) {
      // public key
      const publicKeyName = guessPublicKeyName(envFilepath)
      const publicKeyValue = smartDotenvPublicKey(envFilepath)
      out[publicKeyName] = publicKeyValue

      // private key
      const privateKeyName = guessPrivateKeyName(envFilepath)
      const privateKeyValue = smartDotenvPrivateKey(envFilepath, this.envKeysFilepath)

      out[privateKeyName] = privateKeyValue
    }

    return out
  }

  _envFilepaths () {
    if (!Array.isArray(this.envFile)) {
      return [this.envFile]
    }

    return this.envFile
  }
}

module.exports = Keypair


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/ls.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/ls.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { fdir: Fdir } = __webpack_require__(/*! fdir */ "./node_modules/@dotenvx/dotenvx/node_modules/fdir/dist/index.js")
const path = __webpack_require__(/*! path */ "path")
const picomatch = __webpack_require__(/*! picomatch */ "./node_modules/@dotenvx/dotenvx/node_modules/picomatch/index.js")

class Ls {
  constructor (directory = './', envFile = ['.env*'], excludeEnvFile = []) {
    this.ignore = ['node_modules/**', '.git/**']

    this.cwd = path.resolve(directory)
    this.envFile = envFile
    this.excludeEnvFile = excludeEnvFile
  }

  run () {
    return this._filepaths()
  }

  _filepaths () {
    const exclude = picomatch(this._exclude())
    const include = picomatch(this._patterns(), {
      ignore: this._exclude()
    })

    return new Fdir()
      .withRelativePaths()
      .exclude((dir, path) => exclude(path))
      .filter((path) => include(path))
      .crawl(this.cwd)
      .sync()
  }

  _patterns () {
    if (!Array.isArray(this.envFile)) {
      return [`**/${this.envFile}`]
    }

    return this.envFile.map(part => `**/${part}`)
  }

  _excludePatterns () {
    if (!Array.isArray(this.excludeEnvFile)) {
      return [`**/${this.excludeEnvFile}`]
    }

    return this.excludeEnvFile.map(part => `**/${part}`)
  }

  _exclude () {
    if (this._excludePatterns().length > 0) {
      return this.ignore.concat(this._excludePatterns())
    } else {
      return this.ignore
    }
  }
}

module.exports = Ls


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/radar.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/radar.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(/*! path */ "path")
const childProcess = __webpack_require__(/*! child_process */ "child_process")

const { logger } = __webpack_require__(/*! ./../../shared/logger */ "./node_modules/@dotenvx/dotenvx/src/shared/logger.js")

class Radar {
  constructor () {
    this.radarLib = null

    // check npm lib
    try {
      this.radarLib = this._radarNpm()
      logger.successv(`📡 radar: ${this.radarLib.status}`)
    } catch (e) {
      // check binary cli
      try {
        this.radarLib = this._radarCli()
        logger.successv(`📡 radar: ${this.radarLib.status}`)
      } catch (_e2) {
        // noop
      }
      // noop
    }
  }

  observe (payload) {
    if (this.radarLib && this.radarLib.status !== 'off') {
      const encoded = this.encode(payload)
      this.radarLib.observe(encoded)
    }
  }

  encode (payload) {
    return Buffer.from(JSON.stringify(payload)).toString('base64')
  }

  _radarNpm () {
    const fallbackBin = path.resolve(process.cwd(), 'node_modules/.bin/dotenvx-radar')
    const status = childProcess.execSync(`${fallbackBin} status`, { stdio: ['pipe', 'pipe', 'ignore'] })

    return {
      status: status.toString().trim(),
      observe: (encoded) => {
        try {
          const subprocess = childProcess.spawn(fallbackBin, ['observe', encoded], {
            stdio: 'ignore',
            detached: true
          })

          subprocess.unref() // let it run independently
        } catch (e) {
          // noop
        }
      }
    }
  }

  _radarCli () {
    const status = childProcess.execSync('dotenvx-radar status', { stdio: ['pipe', 'pipe', 'ignore'] })

    return {
      status: status.toString().trim(),
      observe: (encoded) => {
        try {
          const subprocess = childProcess.spawn('dotenvx-radar', ['observe', encoded], {
            stdio: 'ignore',
            detached: true
          })

          subprocess.unref() // let it run independently
        } catch (e) {
          // noop
        }
      }
    }
  }
}

module.exports = Radar


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/run.js":
/*!***************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/run.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./../helpers/fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const path = __webpack_require__(/*! path */ "path")

const TYPE_ENV = 'env'
const TYPE_ENV_FILE = 'envFile'
const TYPE_ENV_VAULT_FILE = 'envVaultFile'

const decrypt = __webpack_require__(/*! ./../helpers/decrypt */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/decrypt.js")
const Parse = __webpack_require__(/*! ./../helpers/parse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parse.js")
const Errors = __webpack_require__(/*! ./../helpers/errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")
const dotenvParse = __webpack_require__(/*! ./../helpers/dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")
const parseEnvironmentFromDotenvKey = __webpack_require__(/*! ./../helpers/parseEnvironmentFromDotenvKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/parseEnvironmentFromDotenvKey.js")
const detectEncoding = __webpack_require__(/*! ./../helpers/detectEncoding */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/detectEncoding.js")
const { findPrivateKey } = __webpack_require__(/*! ./../helpers/findPrivateKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPrivateKey.js")
const guessPrivateKeyName = __webpack_require__(/*! ./../helpers/guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")
const determineEnvs = __webpack_require__(/*! ./../helpers/determineEnvs */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/determineEnvs.js")

class Run {
  constructor (envs = [], overload = false, DOTENV_KEY = '', processEnv = process.env, envKeysFilepath = null) {
    this.envs = determineEnvs(envs, processEnv, DOTENV_KEY)
    this.overload = overload
    this.DOTENV_KEY = DOTENV_KEY
    this.processEnv = processEnv
    this.envKeysFilepath = envKeysFilepath

    this.processedEnvs = []
    this.readableFilepaths = new Set()
    this.readableStrings = new Set()
    this.uniqueInjectedKeys = new Set()
    this.beforeEnv = { ...this.processEnv }
  }

  run () {
    // example
    // envs [
    //   { type: 'envVaultFile', value: '.env.vault' },
    //   { type: 'env', value: 'HELLO=one' },
    //   { type: 'envFile', value: '.env' },
    //   { type: 'env', value: 'HELLO=three' }
    // ]

    for (const env of this.envs) {
      if (env.type === TYPE_ENV_VAULT_FILE) { // deprecate someday - for deprecated .env.vault files
        this._injectEnvVaultFile(env.value)
      } else if (env.type === TYPE_ENV_FILE) {
        this._injectEnvFile(env.value)
      } else if (env.type === TYPE_ENV) {
        this._injectEnv(env.value)
      }
    }

    return {
      processedEnvs: this.processedEnvs,
      readableStrings: [...this.readableStrings],
      readableFilepaths: [...this.readableFilepaths],
      uniqueInjectedKeys: [...this.uniqueInjectedKeys],
      beforeEnv: this.beforeEnv,
      afterEnv: { ...this.processEnv }
    }
  }

  _injectEnv (env) {
    const row = {}
    row.type = TYPE_ENV
    row.string = env

    try {
      const { parsed, errors, injected, preExisted } = new Parse(env, null, this.processEnv, this.overload).run()
      row.parsed = parsed
      row.errors = errors
      row.injected = injected
      row.preExisted = preExisted

      this.inject(row.parsed) // inject

      this.readableStrings.add(env)

      for (const key of Object.keys(injected)) {
        this.uniqueInjectedKeys.add(key) // track uniqueInjectedKeys across multiple files
      }
    } catch (e) {
      row.errors = [e]
    }

    this.processedEnvs.push(row)
  }

  _injectEnvFile (envFilepath) {
    const row = {}
    row.type = TYPE_ENV_FILE
    row.filepath = envFilepath

    const filepath = path.resolve(envFilepath)
    try {
      const encoding = detectEncoding(filepath)
      const src = fsx.readFileX(filepath, { encoding })
      this.readableFilepaths.add(envFilepath)

      const privateKey = findPrivateKey(envFilepath, this.envKeysFilepath)
      const privateKeyName = guessPrivateKeyName(envFilepath)
      const { parsed, errors, injected, preExisted } = new Parse(src, privateKey, this.processEnv, this.overload, privateKeyName).run()

      row.privateKeyName = privateKeyName
      row.privateKey = privateKey
      row.src = src
      row.parsed = parsed
      row.errors = errors
      row.injected = injected
      row.preExisted = preExisted

      this.inject(row.parsed) // inject

      for (const key of Object.keys(injected)) {
        this.uniqueInjectedKeys.add(key) // track uniqueInjectedKeys across multiple files
      }
    } catch (e) {
      if (e.code === 'ENOENT' || e.code === 'EISDIR') {
        row.errors = [new Errors({ envFilepath, filepath }).missingEnvFile()]
      } else {
        row.errors = [e]
      }
    }

    this.processedEnvs.push(row)
  }

  _injectEnvVaultFile (envVaultFilepath) {
    const row = {}
    row.type = TYPE_ENV_VAULT_FILE
    row.filepath = envVaultFilepath

    const filepath = path.resolve(envVaultFilepath)
    this.readableFilepaths.add(envVaultFilepath)

    if (!fsx.existsSync(filepath)) {
      const code = 'MISSING_ENV_VAULT_FILE'
      const message = `you set DOTENV_KEY but your .env.vault file is missing: ${filepath}`
      const error = new Error(message)
      error.code = code
      throw error
    }

    if (this.DOTENV_KEY.length < 1) {
      const code = 'MISSING_DOTENV_KEY'
      const message = `your DOTENV_KEY appears to be blank: '${this.DOTENV_KEY}'`
      const error = new Error(message)
      error.code = code
      throw error
    }

    let decrypted
    const dotenvKeys = this._dotenvKeys()
    const parsedVault = this._parsedVault(filepath)
    for (let i = 0; i < dotenvKeys.length; i++) {
      try {
        const dotenvKey = dotenvKeys[i].trim() // dotenv://key_1234@...?environment=prod

        decrypted = this._decrypted(dotenvKey, parsedVault)

        break
      } catch (error) {
        // last key
        if (i + 1 >= dotenvKeys.length) {
          throw error
        }
        // try next key
      }
    }

    try {
      // parse this. it's the equivalent of the .env file
      const { parsed, errors, injected, preExisted } = new Parse(decrypted, null, this.processEnv, this.overload).run()
      row.parsed = parsed
      row.errors = errors
      row.injected = injected
      row.preExisted = preExisted

      this.inject(row.parsed) // inject

      for (const key of Object.keys(injected)) {
        this.uniqueInjectedKeys.add(key) // track uniqueInjectedKeys across multiple files
      }
    } catch (e) {
      row.errors = [e]
    }

    this.processedEnvs.push(row)
  }

  inject (parsed) {
    for (const key of Object.keys(parsed)) {
      this.processEnv[key] = parsed[key] // inject to process.env
    }
  }

  // handle scenario for comma separated keys - for use with key rotation
  // example: DOTENV_KEY="dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod"
  _dotenvKeys () {
    return this.DOTENV_KEY.split(',')
  }

  // { "DOTENV_VAULT_DEVELOPMENT": "<ciphertext>" }
  _parsedVault (filepath) {
    const src = fsx.readFileX(filepath)
    return dotenvParse(src)
  }

  _decrypted (dotenvKey, parsedVault) {
    const environment = parseEnvironmentFromDotenvKey(dotenvKey)

    // DOTENV_KEY_PRODUCTION
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`
    const ciphertext = parsedVault[environmentKey]
    if (!ciphertext) {
      const error = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: cannot locate environment ${environmentKey} in your .env.vault file`)
      error.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'

      throw error
    }

    return decrypt(ciphertext, dotenvKey)
  }
}

module.exports = Run


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/lib/services/sets.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/lib/services/sets.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fsx = __webpack_require__(/*! ./../helpers/fsx */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/fsx.js")
const path = __webpack_require__(/*! path */ "path")

const TYPE_ENV_FILE = 'envFile'

const Errors = __webpack_require__(/*! ./../helpers/errors */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/errors.js")
const guessPrivateKeyName = __webpack_require__(/*! ./../helpers/guessPrivateKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPrivateKeyName.js")
const guessPublicKeyName = __webpack_require__(/*! ./../helpers/guessPublicKeyName */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/guessPublicKeyName.js")
const encryptValue = __webpack_require__(/*! ./../helpers/encryptValue */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/encryptValue.js")
const decryptKeyValue = __webpack_require__(/*! ./../helpers/decryptKeyValue */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/decryptKeyValue.js")
const replace = __webpack_require__(/*! ./../helpers/replace */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/replace.js")
const dotenvParse = __webpack_require__(/*! ./../helpers/dotenvParse */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/dotenvParse.js")
const detectEncoding = __webpack_require__(/*! ./../helpers/detectEncoding */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/detectEncoding.js")
const determineEnvs = __webpack_require__(/*! ./../helpers/determineEnvs */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/determineEnvs.js")
const { findPrivateKey } = __webpack_require__(/*! ./../helpers/findPrivateKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPrivateKey.js")
const findPublicKey = __webpack_require__(/*! ./../helpers/findPublicKey */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/findPublicKey.js")
const keypair = __webpack_require__(/*! ./../helpers/keypair */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/keypair.js")
const truncate = __webpack_require__(/*! ./../helpers/truncate */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/truncate.js")
const isEncrypted = __webpack_require__(/*! ./../helpers/isEncrypted */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/isEncrypted.js")

class Sets {
  constructor (key, value, envs = [], encrypt = true, envKeysFilepath = null) {
    this.envs = determineEnvs(envs, process.env)
    this.key = key
    this.value = value
    this.encrypt = encrypt
    this.envKeysFilepath = envKeysFilepath

    this.processedEnvs = []
    this.changedFilepaths = new Set()
    this.unchangedFilepaths = new Set()
    this.readableFilepaths = new Set()
  }

  run () {
    // example
    // envs [
    //   { type: 'envFile', value: '.env' }
    // ]

    for (const env of this.envs) {
      if (env.type === TYPE_ENV_FILE) {
        this._setEnvFile(env.value)
      }
    }

    return {
      processedEnvs: this.processedEnvs,
      changedFilepaths: [...this.changedFilepaths],
      unchangedFilepaths: [...this.unchangedFilepaths]
    }
  }

  _setEnvFile (envFilepath) {
    const row = {}
    row.key = this.key || null
    row.value = this.value || null
    row.type = TYPE_ENV_FILE

    const filename = path.basename(envFilepath)
    const filepath = path.resolve(envFilepath)
    row.filepath = filepath
    row.envFilepath = envFilepath
    row.changed = false

    try {
      const encoding = this._detectEncoding(filepath)
      let envSrc = fsx.readFileX(filepath, { encoding })
      const envParsed = dotenvParse(envSrc)
      row.originalValue = envParsed[row.key] || null
      const wasPlainText = !isEncrypted(row.originalValue)
      this.readableFilepaths.add(envFilepath)

      if (this.encrypt) {
        let publicKey
        let privateKey

        const publicKeyName = guessPublicKeyName(envFilepath)
        const privateKeyName = guessPrivateKeyName(envFilepath)
        const existingPrivateKey = findPrivateKey(envFilepath, this.envKeysFilepath)
        const existingPublicKey = findPublicKey(envFilepath)

        let envKeysFilepath = path.join(path.dirname(filepath), '.env.keys')
        if (this.envKeysFilepath) {
          envKeysFilepath = path.resolve(this.envKeysFilepath)
        }
        const relativeFilepath = path.relative(path.dirname(filepath), envKeysFilepath)

        if (existingPrivateKey) {
          const kp = keypair(existingPrivateKey)
          publicKey = kp.publicKey
          privateKey = kp.privateKey

          if (row.originalValue) {
            row.originalValue = decryptKeyValue(row.key, row.originalValue, privateKeyName, privateKey)
          }

          // if derivation doesn't match what's in the file (or preset in env)
          if (existingPublicKey && existingPublicKey !== publicKey) {
            const error = new Error(`derived public key (${truncate(publicKey)}) does not match the existing public key (${truncate(existingPublicKey)})`)
            error.code = 'INVALID_DOTENV_PRIVATE_KEY'
            error.help = `debug info: ${privateKeyName}=${truncate(existingPrivateKey)} (derived ${publicKeyName}=${truncate(publicKey)} vs existing ${publicKeyName}=${truncate(existingPublicKey)})`
            throw error
          }

          // typical scenario when encrypting a monorepo second .env file from a prior generated -fk .env.keys file
          if (!existingPublicKey) {
            const ps = this._preserveShebang(envSrc)
            const firstLinePreserved = ps.firstLinePreserved
            envSrc = ps.envSrc

            const prependPublicKey = this._prependPublicKey(publicKeyName, publicKey, filename, relativeFilepath)

            envSrc = `${firstLinePreserved}${prependPublicKey}\n${envSrc}`
          }
        } else if (existingPublicKey) {
          publicKey = existingPublicKey
        } else {
          // .env.keys
          let keysSrc = ''
          if (fsx.existsSync(envKeysFilepath)) {
            keysSrc = fsx.readFileX(envKeysFilepath)
          }

          const ps = this._preserveShebang(envSrc)
          const firstLinePreserved = ps.firstLinePreserved
          envSrc = ps.envSrc

          const kp = keypair() // generates a fresh keypair in memory
          publicKey = kp.publicKey
          privateKey = kp.privateKey

          const prependPublicKey = this._prependPublicKey(publicKeyName, publicKey, filename, relativeFilepath)

          // privateKey
          const firstTimeKeysSrc = [
            '#/------------------!DOTENV_PRIVATE_KEYS!-------------------/',
            '#/ private decryption keys. DO NOT commit to source control /',
            '#/     [how it works](https://dotenvx.com/encryption)       /',
            '#/----------------------------------------------------------/'
          ].join('\n')
          const appendPrivateKey = [
            `# ${filename}`,
            `${privateKeyName}=${privateKey}`,
            ''
          ].join('\n')

          envSrc = `${firstLinePreserved}${prependPublicKey}\n${envSrc}`
          keysSrc = keysSrc.length > 1 ? keysSrc : `${firstTimeKeysSrc}\n`
          keysSrc = `${keysSrc}\n${appendPrivateKey}`

          // write to .env.keys
          fsx.writeFileX(envKeysFilepath, keysSrc)

          row.privateKeyAdded = true
          row.envKeysFilepath = this.envKeysFilepath || path.join(path.dirname(envFilepath), path.basename(envKeysFilepath))
        }

        row.publicKey = publicKey
        row.privateKey = privateKey
        row.encryptedValue = encryptValue(this.value, publicKey)
        row.privateKeyName = privateKeyName
      }

      const goingFromPlainTextToEncrypted = wasPlainText && this.encrypt
      const valueChanged = this.value !== row.originalValue
      if (goingFromPlainTextToEncrypted || valueChanged) {
        row.envSrc = replace(envSrc, this.key, row.encryptedValue || this.value)
        this.changedFilepaths.add(envFilepath)
        row.changed = true
      } else {
        row.envSrc = envSrc
        this.unchangedFilepaths.add(envFilepath)
        row.changed = false
      }
    } catch (e) {
      if (e.code === 'ENOENT') {
        row.error = new Errors({ envFilepath, filepath }).missingEnvFile()
      } else {
        row.error = e
      }
    }

    this.processedEnvs.push(row)
  }

  _detectEncoding (filepath) {
    return detectEncoding(filepath)
  }

  _prependPublicKey (publicKeyName, publicKey, filename, relativeFilepath = '.env.keys') {
    const comment = relativeFilepath === '.env.keys' ? '' : ` # -fk ${relativeFilepath}`

    return [
      '#/-------------------[DOTENV_PUBLIC_KEY]--------------------/',
      '#/            public-key encryption for .env files          /',
      '#/       [how it works](https://dotenvx.com/encryption)     /',
      '#/----------------------------------------------------------/',
      `${publicKeyName}="${publicKey}"${comment}`,
      '',
      `# ${filename}`
    ].join('\n')
  }

  _preserveShebang (envSrc) {
    // preserve shebang
    const [firstLine, ...remainingLines] = envSrc.split('\n')
    let firstLinePreserved = ''

    if (firstLine.startsWith('#!')) {
      firstLinePreserved = firstLine + '\n'
      envSrc = remainingLines.join('\n')
    }

    return {
      firstLinePreserved,
      envSrc
    }
  }
}

module.exports = Sets


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/shared/colors.js":
/*!************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/shared/colors.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const depth = __webpack_require__(/*! ../lib/helpers/colorDepth */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/colorDepth.js")

const colors16 = new Map([
  ['blue', 34],
  ['gray', 37],
  ['green', 32],
  ['olive', 33],
  ['orangered', 31], // mapped to red
  ['plum', 35], // mapped to magenta
  ['red', 31],
  ['electricblue', 36],
  ['dodgerblue', 36]
])

const colors256 = new Map([
  ['blue', 21],
  ['gray', 244],
  ['green', 34],
  ['olive', 142],
  ['orangered', 202],
  ['plum', 182],
  ['red', 196],
  ['electricblue', 45],
  ['dodgerblue', 33]
])

function getColor (color) {
  const colorDepth = depth.getColorDepth()
  if (!colors256.has(color)) {
    throw new Error(`Invalid color ${color}`)
  }
  if (colorDepth >= 8) {
    const code = colors256.get(color)
    return (message) => `\x1b[38;5;${code}m${message}\x1b[39m`
  }
  if (colorDepth >= 4) {
    const code = colors16.get(color)
    return (message) => `\x1b[${code}m${message}\x1b[39m`
  }
  return (message) => message
}

function bold (message) {
  if (depth.getColorDepth() >= 4) {
    return `\x1b[1m${message}\x1b[22m`
  }

  return message
}

module.exports = {
  getColor,
  bold
}


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/src/shared/logger.js":
/*!************************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/src/shared/logger.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const packageJson = __webpack_require__(/*! ../lib/helpers/packageJson */ "./node_modules/@dotenvx/dotenvx/src/lib/helpers/packageJson.js")
const { getColor, bold } = __webpack_require__(/*! ./colors */ "./node_modules/@dotenvx/dotenvx/src/shared/colors.js")

const levels = {
  error: 0,
  warn: 1,
  success: 2,
  successv: 2,
  info: 2,
  help: 2,
  verbose: 4,
  debug: 5,
  silly: 6
}

const error = (m) => bold(getColor('red')(m))
const warn = getColor('orangered')
const success = getColor('green')
const successv = getColor('olive') // yellow-ish tint that 'looks' like dotenv
const help = getColor('dodgerblue')
const verbose = getColor('plum')
const debug = getColor('plum')

let currentLevel = levels.info // default log level
let currentName = 'dotenvx' // default logger name
let currentVersion = packageJson.version // default logger version

function stderr (level, message) {
  const formattedMessage = formatMessage(level, message)
  console.error(formattedMessage)
}

function stdout (level, message) {
  if (levels[level] === undefined) {
    throw new Error(`MISSING_LOG_LEVEL: '${level}'. implement in logger.`)
  }

  if (levels[level] <= currentLevel) {
    const formattedMessage = formatMessage(level, message)
    console.log(formattedMessage)
  }
}

function formatMessage (level, message) {
  const formattedMessage = typeof message === 'object' ? JSON.stringify(message) : message

  switch (level.toLowerCase()) {
    // errors
    case 'error':
      return error(formattedMessage)
    // warns
    case 'warn':
      return warn(formattedMessage)
    // successes
    case 'success':
      return success(formattedMessage)
    case 'successv': // success with 'version'
      return successv(`[${currentName}@${currentVersion}] ${formattedMessage}`)
    // info
    case 'info':
      return formattedMessage
    // help
    case 'help':
      return help(formattedMessage)
    // verbose
    case 'verbose':
      return verbose(formattedMessage)
    // debug
    case 'debug':
      return debug(formattedMessage)
  }
}

const logger = {
  // track level
  level: 'info',

  // errors
  error: (msg) => stderr('error', msg),
  // warns
  warn: (msg) => stdout('warn', msg),
  // success
  success: (msg) => stdout('success', msg),
  successv: (msg) => stdout('successv', msg),
  // info
  info: (msg) => stdout('info', msg),
  // help
  help: (msg) => stdout('help', msg),
  // verbose
  verbose: (msg) => stdout('verbose', msg),
  // debug
  debug: (msg) => stdout('debug', msg),
  setLevel: (level) => {
    if (levels[level] !== undefined) {
      currentLevel = levels[level]
      logger.level = level
    }
  },
  setName: (name) => {
    currentName = name
    logger.name = name
  },
  setVersion: (version) => {
    currentVersion = version
    logger.version = version
  }
}

function setLogLevel (options) {
  const logLevel = options.debug
    ? 'debug'
    : options.verbose
      ? 'verbose'
      : options.quiet
        ? 'error'
        : options.logLevel

  if (!logLevel) return
  logger.setLevel(logLevel)
  // Only log which level it's setting if it's not set to quiet mode
  if (!options.quiet || (options.quiet && logLevel !== 'error')) {
    logger.debug(`Setting log level to ${logLevel}`)
  }
}

function setLogName (options) {
  const logName = options.logName
  if (!logName) return
  logger.setName(logName)
}

function setLogVersion (options) {
  const logVersion = options.logVersion
  if (!logVersion) return
  logger.setVersion(logVersion)
}

module.exports = {
  logger,
  getColor,
  setLogLevel,
  setLogName,
  setLogVersion,
  levels
}


/***/ }),

/***/ "./node_modules/@ecies/ciphers/dist/_node/compat.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ecies/ciphers/dist/_node/compat.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._compat = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var node_crypto_1 = __webpack_require__(/*! node:crypto */ "node:crypto");
var AEAD_TAG_LENGTH = 16;
// @ts-ignore: only necessary for deno
var IS_DENO = globalThis.Deno !== undefined;
/**
 * make `node:crypto`'s ciphers compatible with `@noble/ciphers`.
 *
 * `Cipher`'s interface is the same for both `aes-256-gcm` and `chacha20-poly1305`,
 * albeit the latter is one of `CipherCCMTypes`.
 * Interestingly, whether to set `plaintextLength` or not, or which value to set, has no actual effect.
 */
var _compat = function (algorithm, key, nonce, AAD) {
    var isAEAD = algorithm === "aes-256-gcm" || algorithm === "chacha20-poly1305";
    var authTagLength = isAEAD ? AEAD_TAG_LENGTH : 0;
    // authTagLength is necessary for `chacha20-poly1305` before Node v16.17
    var options = isAEAD ? { authTagLength: authTagLength } : undefined;
    var encrypt = function (plainText) {
        var cipher = (0, node_crypto_1.createCipheriv)(algorithm, key, nonce, options);
        if (isAEAD && AAD !== undefined) {
            cipher.setAAD(AAD);
        }
        var updated = cipher.update(plainText);
        var finalized = cipher.final();
        var tag = isAEAD ? cipher.getAuthTag() : new Uint8Array(0);
        return (0, utils_1.concatBytes)(updated, finalized, tag);
    };
    var decrypt = function (cipherText) {
        var rawCipherText = cipherText.subarray(0, cipherText.length - authTagLength);
        var tag = cipherText.subarray(cipherText.length - authTagLength);
        var decipher = (0, node_crypto_1.createDecipheriv)(algorithm, key, nonce, options);
        if (isAEAD) {
            if (AAD !== undefined) {
                decipher.setAAD(AAD);
            }
            decipher.setAuthTag(tag);
        }
        /* v8 ignore next 3 */
        if (!isAEAD && IS_DENO) {
            decipher.setAutoPadding(false); // See: https://github.com/denoland/deno/issues/28381
        }
        var updated = decipher.update(rawCipherText);
        var finalized = decipher.final();
        return (0, utils_1.concatBytes)(updated, finalized);
    };
    return {
        encrypt: encrypt,
        decrypt: decrypt,
    };
};
exports._compat = _compat;


/***/ }),

/***/ "./node_modules/@ecies/ciphers/dist/_node/hchacha.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ecies/ciphers/dist/_node/hchacha.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._hchacha20 = void 0;
/**
 * Copied from `@noble/ciphers/chacha`
 */
// prettier-ignore
var _hchacha20 = function (s, k, i, o32) {
    var x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];
    for (var r = 0; r < 20; r += 2) {
        x00 = (x00 + x04) | 0;
        x12 = rotl(x12 ^ x00, 16);
        x08 = (x08 + x12) | 0;
        x04 = rotl(x04 ^ x08, 12);
        x00 = (x00 + x04) | 0;
        x12 = rotl(x12 ^ x00, 8);
        x08 = (x08 + x12) | 0;
        x04 = rotl(x04 ^ x08, 7);
        x01 = (x01 + x05) | 0;
        x13 = rotl(x13 ^ x01, 16);
        x09 = (x09 + x13) | 0;
        x05 = rotl(x05 ^ x09, 12);
        x01 = (x01 + x05) | 0;
        x13 = rotl(x13 ^ x01, 8);
        x09 = (x09 + x13) | 0;
        x05 = rotl(x05 ^ x09, 7);
        x02 = (x02 + x06) | 0;
        x14 = rotl(x14 ^ x02, 16);
        x10 = (x10 + x14) | 0;
        x06 = rotl(x06 ^ x10, 12);
        x02 = (x02 + x06) | 0;
        x14 = rotl(x14 ^ x02, 8);
        x10 = (x10 + x14) | 0;
        x06 = rotl(x06 ^ x10, 7);
        x03 = (x03 + x07) | 0;
        x15 = rotl(x15 ^ x03, 16);
        x11 = (x11 + x15) | 0;
        x07 = rotl(x07 ^ x11, 12);
        x03 = (x03 + x07) | 0;
        x15 = rotl(x15 ^ x03, 8);
        x11 = (x11 + x15) | 0;
        x07 = rotl(x07 ^ x11, 7);
        x00 = (x00 + x05) | 0;
        x15 = rotl(x15 ^ x00, 16);
        x10 = (x10 + x15) | 0;
        x05 = rotl(x05 ^ x10, 12);
        x00 = (x00 + x05) | 0;
        x15 = rotl(x15 ^ x00, 8);
        x10 = (x10 + x15) | 0;
        x05 = rotl(x05 ^ x10, 7);
        x01 = (x01 + x06) | 0;
        x12 = rotl(x12 ^ x01, 16);
        x11 = (x11 + x12) | 0;
        x06 = rotl(x06 ^ x11, 12);
        x01 = (x01 + x06) | 0;
        x12 = rotl(x12 ^ x01, 8);
        x11 = (x11 + x12) | 0;
        x06 = rotl(x06 ^ x11, 7);
        x02 = (x02 + x07) | 0;
        x13 = rotl(x13 ^ x02, 16);
        x08 = (x08 + x13) | 0;
        x07 = rotl(x07 ^ x08, 12);
        x02 = (x02 + x07) | 0;
        x13 = rotl(x13 ^ x02, 8);
        x08 = (x08 + x13) | 0;
        x07 = rotl(x07 ^ x08, 7);
        x03 = (x03 + x04) | 0;
        x14 = rotl(x14 ^ x03, 16);
        x09 = (x09 + x14) | 0;
        x04 = rotl(x04 ^ x09, 12);
        x03 = (x03 + x04) | 0;
        x14 = rotl(x14 ^ x03, 8);
        x09 = (x09 + x14) | 0;
        x04 = rotl(x04 ^ x09, 7);
    }
    var oi = 0;
    o32[oi++] = x00;
    o32[oi++] = x01;
    o32[oi++] = x02;
    o32[oi++] = x03;
    o32[oi++] = x12;
    o32[oi++] = x13;
    o32[oi++] = x14;
    o32[oi++] = x15;
};
exports._hchacha20 = _hchacha20;
var rotl = function (a, b) {
    return (a << b) | (a >>> (32 - b));
};


/***/ }),

/***/ "./node_modules/@ecies/ciphers/dist/aes/node.js":
/*!******************************************************!*\
  !*** ./node_modules/@ecies/ciphers/dist/aes/node.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aes256cbc = exports.aes256gcm = void 0;
var compat_1 = __webpack_require__(/*! ../_node/compat */ "./node_modules/@ecies/ciphers/dist/_node/compat.js");
var aes256gcm = function (key, nonce, AAD) {
    return (0, compat_1._compat)("aes-256-gcm", key, nonce, AAD);
};
exports.aes256gcm = aes256gcm;
var aes256cbc = function (key, nonce, AAD) {
    return (0, compat_1._compat)("aes-256-cbc", key, nonce);
};
exports.aes256cbc = aes256cbc;


/***/ }),

/***/ "./node_modules/@ecies/ciphers/dist/chacha/node.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ecies/ciphers/dist/chacha/node.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.chacha20 = exports.xchacha20 = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var compat_1 = __webpack_require__(/*! ../_node/compat */ "./node_modules/@ecies/ciphers/dist/_node/compat.js");
var hchacha_1 = __webpack_require__(/*! ../_node/hchacha */ "./node_modules/@ecies/ciphers/dist/_node/hchacha.js");
var xchacha20 = function (key, nonce, AAD) {
    if (nonce.length !== 24) {
        throw new Error("xchacha20's nonce must be 24 bytes");
    }
    var constants = new Uint32Array([0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]); // "expand 32-byte k"
    var subKey = new Uint32Array(8);
    (0, hchacha_1._hchacha20)(constants, (0, utils_1.u32)(key), (0, utils_1.u32)(nonce.subarray(0, 16)), subKey);
    var subNonce = new Uint8Array(12);
    subNonce.set([0, 0, 0, 0]);
    subNonce.set(nonce.subarray(16), 4);
    return (0, compat_1._compat)("chacha20-poly1305", (0, utils_1.u8)(subKey), subNonce, AAD);
};
exports.xchacha20 = xchacha20;
var chacha20 = function (key, nonce, AAD) {
    if (nonce.length !== 12) {
        throw new Error("chacha20's nonce must be 12 bytes");
    }
    return (0, compat_1._compat)("chacha20-poly1305", key, nonce, AAD);
};
exports.chacha20 = chacha20;


/***/ }),

/***/ "./node_modules/@noble/ciphers/cryptoNode.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/ciphers/cryptoNode.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */
// @ts-ignore
const nc = __webpack_require__(/*! node:crypto */ "node:crypto");
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc
    ? nc.webcrypto
    : nc && typeof nc === 'object' && 'randomBytes' in nc
        ? nc
        : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ "./node_modules/@noble/ciphers/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/ciphers/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapCipher = exports.Hash = exports.nextTick = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.abool = abool;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.numberToBytesBE = numberToBytesBE;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.overlapBytes = overlapBytes;
exports.complexOverlapBytes = complexOverlapBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.equalBytes = equalBytes;
exports.getOutput = getOutput;
exports.setBigUint64 = setBigUint64;
exports.u64Lengths = u64Lengths;
exports.isAligned32 = isAligned32;
exports.copyBytes = copyBytes;
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is boolean. */
function abool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`boolean expected, not ${b}`);
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/**
 * Asserts something is hash
 * TODO: remove
 * @deprecated
 */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
// Used in micro
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian
}
// Used in ff1
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
// Used in micro, ff1
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
// TODO: remove
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    else if (isBytes(data))
        data = copyBytes(data);
    else
        throw new Error('Uint8Array expected, got ' + typeof data);
    return data;
}
/**
 * Checks if two U8A use same underlying buffer and overlaps.
 * This is invalid and can corrupt data.
 */
function overlapBytes(a, b) {
    return (a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy
        a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end
        b.byteOffset < a.byteOffset + a.byteLength // b starts before a end
    );
}
/**
 * If input and output overlap and input starts before output, we will overwrite end of input before
 * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)
 */
function complexOverlapBytes(input, output) {
    // This is very cursed. It works somehow, but I'm completely unsure,
    // reasoning about overlapping aligned windows is very hard.
    if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)
        throw new Error('complex overlap of input and output is not supported');
}
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts == null || typeof opts !== 'object')
        throw new Error('options must be defined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** Compares 2 uint8array-s in kinda constant time. */
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
// TODO: remove
/** For runtime check if class implements interface. */
class Hash {
}
exports.Hash = Hash;
/**
 * Wraps a cipher: validates args, ensures encrypt() can only be called once.
 * @__NO_SIDE_EFFECTS__
 */
const wrapCipher = (params, constructor) => {
    function wrappedCipher(key, ...args) {
        // Validate key
        abytes(key);
        // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:
        if (!exports.isLE)
            throw new Error('Non little-endian hardware is not yet supported');
        // Validate nonce if nonceLength is present
        if (params.nonceLength !== undefined) {
            const nonce = args[0];
            if (!nonce)
                throw new Error('nonce / iv required');
            if (params.varSizeNonce)
                abytes(nonce);
            else
                abytes(nonce, params.nonceLength);
        }
        // Validate AAD if tagLength present
        const tagl = params.tagLength;
        if (tagl && args[1] !== undefined) {
            abytes(args[1]);
        }
        const cipher = constructor(key, ...args);
        const checkOutput = (fnLength, output) => {
            if (output !== undefined) {
                if (fnLength !== 2)
                    throw new Error('cipher output not supported');
                abytes(output);
            }
        };
        // Create wrapped cipher with validation and single-use encryption
        let called = false;
        const wrCipher = {
            encrypt(data, output) {
                if (called)
                    throw new Error('cannot encrypt() twice with same key + nonce');
                called = true;
                abytes(data);
                checkOutput(cipher.encrypt.length, output);
                return cipher.encrypt(data, output);
            },
            decrypt(data, output) {
                abytes(data);
                if (tagl && data.length < tagl)
                    throw new Error('invalid ciphertext length: smaller than tagLength=' + tagl);
                checkOutput(cipher.decrypt.length, output);
                return cipher.decrypt(data, output);
            },
        };
        return wrCipher;
    }
    Object.assign(wrappedCipher, params);
    return wrappedCipher;
};
exports.wrapCipher = wrapCipher;
/**
 * By default, returns u8a of length.
 * When out is available, it checks it for validity and uses it.
 */
function getOutput(expectedLength, out, onlyAligned = true) {
    if (out === undefined)
        return new Uint8Array(expectedLength);
    if (out.length !== expectedLength)
        throw new Error('invalid output length, expected ' + expectedLength + ', got: ' + out.length);
    if (onlyAligned && !isAligned32(out))
        throw new Error('invalid output, must be aligned');
    return out;
}
/** Polyfill for Safari 14. */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function u64Lengths(dataLength, aadLength, isLE) {
    abool(isLE);
    const num = new Uint8Array(16);
    const view = createView(num);
    setBigUint64(view, 0, BigInt(aadLength), isLE);
    setBigUint64(view, 8, BigInt(dataLength), isLE);
    return num;
}
// Is byte array aligned to 4 byte offset (u32)?
function isAligned32(bytes) {
    return bytes.byteOffset % 4 === 0;
}
// copy bytes to new u8a (aligned). Because Buffer.slice is broken.
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@noble/ciphers/webcrypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/ciphers/webcrypto.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gcm = exports.ctr = exports.cbc = exports.utils = void 0;
exports.randomBytes = randomBytes;
exports.getWebcryptoSubtle = getWebcryptoSubtle;
exports.managedNonce = managedNonce;
/**
 * WebCrypto-based AES gcm/ctr/cbc, `managedNonce` and `randomBytes`.
 * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
 * node.js versions earlier than v19 don't declare it in global scope.
 * For node.js, package.js on#exports field mapping rewrites import
 * from `crypto` to `cryptoNode`, which imports native module.
 * Makes the utils un-importable in browsers without a bundler.
 * Once node.js 18 is deprecated, we can just drop the import.
 * @module
 */
// Use full path so that Node.js can rewrite it to `cryptoNode.js`.
const crypto_1 = __webpack_require__(/*! @noble/ciphers/crypto */ "./node_modules/@noble/ciphers/cryptoNode.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/ciphers/utils.js");
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
function getWebcryptoSubtle() {
    if (crypto_1.crypto && typeof crypto_1.crypto.subtle === 'object' && crypto_1.crypto.subtle != null)
        return crypto_1.crypto.subtle;
    throw new Error('crypto.subtle must be defined');
}
/**
 * Uses CSPRG for nonce, nonce injected in ciphertext.
 * @example
 * const gcm = managedNonce(aes.gcm);
 * const ciphr = gcm(key).encrypt(data);
 * const plain = gcm(key).decrypt(ciph);
 */
function managedNonce(fn) {
    const { nonceLength } = fn;
    (0, utils_ts_1.anumber)(nonceLength);
    return ((key, ...args) => ({
        encrypt(plaintext, ...argsEnc) {
            const nonce = randomBytes(nonceLength);
            const ciphertext = fn(key, nonce, ...args).encrypt(plaintext, ...argsEnc);
            const out = (0, utils_ts_1.concatBytes)(nonce, ciphertext);
            ciphertext.fill(0);
            return out;
        },
        decrypt(ciphertext, ...argsDec) {
            const nonce = ciphertext.subarray(0, nonceLength);
            const data = ciphertext.subarray(nonceLength);
            return fn(key, nonce, ...args).decrypt(data, ...argsDec);
        },
    }));
}
// Overridable
// @TODO
exports.utils = {
    async encrypt(key, keyParams, cryptParams, plaintext) {
        const cr = getWebcryptoSubtle();
        const iKey = await cr.importKey('raw', key, keyParams, true, ['encrypt']);
        const ciphertext = await cr.encrypt(cryptParams, iKey, plaintext);
        return new Uint8Array(ciphertext);
    },
    async decrypt(key, keyParams, cryptParams, ciphertext) {
        const cr = getWebcryptoSubtle();
        const iKey = await cr.importKey('raw', key, keyParams, true, ['decrypt']);
        const plaintext = await cr.decrypt(cryptParams, iKey, ciphertext);
        return new Uint8Array(plaintext);
    },
};
const mode = {
    CBC: 'AES-CBC',
    CTR: 'AES-CTR',
    GCM: 'AES-GCM',
};
function getCryptParams(algo, nonce, AAD) {
    if (algo === mode.CBC)
        return { name: mode.CBC, iv: nonce };
    if (algo === mode.CTR)
        return { name: mode.CTR, counter: nonce, length: 64 };
    if (algo === mode.GCM) {
        if (AAD)
            return { name: mode.GCM, iv: nonce, additionalData: AAD };
        else
            return { name: mode.GCM, iv: nonce };
    }
    throw new Error('unknown aes block mode');
}
function generate(algo) {
    return (key, nonce, AAD) => {
        (0, utils_ts_1.abytes)(key);
        (0, utils_ts_1.abytes)(nonce);
        const keyParams = { name: algo, length: key.length * 8 };
        const cryptParams = getCryptParams(algo, nonce, AAD);
        let consumed = false;
        return {
            // keyLength,
            encrypt(plaintext) {
                (0, utils_ts_1.abytes)(plaintext);
                if (consumed)
                    throw new Error('Cannot encrypt() twice with same key / nonce');
                consumed = true;
                return exports.utils.encrypt(key, keyParams, cryptParams, plaintext);
            },
            decrypt(ciphertext) {
                (0, utils_ts_1.abytes)(ciphertext);
                return exports.utils.decrypt(key, keyParams, cryptParams, ciphertext);
            },
        };
    };
}
/** AES-CBC, native webcrypto version */
exports.cbc = (() => generate(mode.CBC))();
/** AES-CTR, native webcrypto version */
exports.ctr = (() => generate(mode.CTR))();
/** AES-GCM, native webcrypto version */
exports.gcm = 
/* @__PURE__ */ (() => generate(mode.GCM))();
// // Type tests
// import { siv, gcm, ctr, ecb, cbc } from '../aes.ts';
// import { xsalsa20poly1305 } from '../salsa.ts';
// import { chacha20poly1305, xchacha20poly1305 } from '../chacha.ts';
// const wsiv = managedNonce(siv);
// const wgcm = managedNonce(gcm);
// const wctr = managedNonce(ctr);
// const wcbc = managedNonce(cbc);
// const wsalsapoly = managedNonce(xsalsa20poly1305);
// const wchacha = managedNonce(chacha20poly1305);
// const wxchacha = managedNonce(xchacha20poly1305);
// // should fail
// const wcbc2 = managedNonce(managedNonce(cbc));
// const wctr = managedNonce(ctr);
//# sourceMappingURL=webcrypto.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/_shortw_utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/_shortw_utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/@noble/curves/abstract/weierstrass.js");
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/curve.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/curve.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wNAF = void 0;
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, points) {
    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
            if (n & _1n)
                p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n))
            throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(negateCt(isNegF, precomputes[offsetF]));
            }
            else {
                // bits are 1: add to result point
                p = p.add(negateCt(isNeg, precomputes[offset]));
            }
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            if (n === _0n)
                break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // Window bits are 0: skip processing.
                // Move to next window.
                continue;
            }
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function')
                    comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
exports.wNAF = wNAF;
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar × 256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255 × 32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order, { isLE });
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined)
        FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/edwards.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/edwards.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrimeEdwardsPoint = void 0;
exports.edwards = edwards;
exports.eddsa = eddsa;
exports.twistedEdwards = twistedEdwards;
/**
 * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².
 * For design rationale of types / exports, see weierstrass module documentation.
 * Untwisted Edwards curves exist, but they aren't used in real-world protocols.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);
function isEdValidXY(Fp, CURVE, x, y) {
    const x2 = Fp.sqr(x);
    const y2 = Fp.sqr(y);
    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);
    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));
    return Fp.eql(left, right);
}
function edwards(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('edwards', params, extraOpts, extraOpts.FpFnLE);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, { uvRatio: 'function' });
    // Important:
    // There are some places where Fp.BYTES is used instead of nByteLength.
    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.
    // TODO: test and find curves which behave otherwise.
    const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);
    const modP = (n) => Fp.create(n); // Function overrides
    // sqrt(u/v)
    const uvRatio = extraOpts.uvRatio ||
        ((u, v) => {
            try {
                return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };
            }
            catch (e) {
                return { isValid: false, value: _0n };
            }
        });
    // Validate whether the passed curve params are valid.
    // equation ax² + y² = 1 + dx²y² should work for generator point.
    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    /**
     * Asserts coordinate is valid: 0 <= n < MASK.
     * Coordinates >= Fp.ORDER are allowed for zip215.
     */
    function acoord(title, n, banZero = false) {
        const min = banZero ? _1n : _0n;
        (0, utils_ts_1.aInRange)('coordinate ' + title, n, min, MASK);
        return n;
    }
    function aextpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ExtendedPoint expected');
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        const is0 = p.is0();
        if (iz == null)
            iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily
        const x = modP(X * iz);
        const y = modP(Y * iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: _0n, y: _1n };
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return { x, y };
    });
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?
        // Equation in affine coordinates: ax² + y² = 1 + dx²y²
        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²
        const { X, Y, Z, T } = p;
        const X2 = modP(X * X); // X²
        const Y2 = modP(Y * Y); // Y²
        const Z2 = modP(Z * Z); // Z²
        const Z4 = modP(Z2 * Z2); // Z⁴
        const aX2 = modP(X2 * a); // aX²
        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²
        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²
        if (left !== right)
            throw new Error('bad point: equation left != right (1)');
        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
            throw new Error('bad point: equation left != right (2)');
        return true;
    });
    // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).
    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates
    class Point {
        constructor(X, Y, Z, T) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y);
            this.Z = acoord('z', Z, true);
            this.T = acoord('t', T);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        static fromAffine(p) {
            if (p instanceof Point)
                throw new Error('extended point not allowed');
            const { x, y } = p || {};
            acoord('x', x);
            acoord('y', y);
            return new Point(x, y, _1n, modP(x * y));
        }
        // Uses algo from RFC8032 5.1.3.
        static fromBytes(bytes, zip215 = false) {
            const len = Fp.BYTES;
            const { a, d } = CURVE;
            bytes = (0, utils_ts_1.copyBytes)((0, utils_ts_1._abytes2)(bytes, len, 'point'));
            (0, utils_ts_1._abool2)(zip215, 'zip215');
            const normed = (0, utils_ts_1.copyBytes)(bytes); // copy again, we'll manipulate it
            const lastByte = bytes[len - 1]; // select last byte
            normed[len - 1] = lastByte & ~0x80; // clear last bit
            const y = (0, utils_ts_1.bytesToNumberLE)(normed);
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // RFC8032 prohibits >= p, but ZIP215 doesn't
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            const max = zip215 ? MASK : Fp.ORDER;
            (0, utils_ts_1.aInRange)('point.y', y, _0n, max);
            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:
            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)
            const y2 = modP(y * y); // denominator is always non-0 mod p.
            const u = modP(y2 - _1n); // u = y² - 1
            const v = modP(d * y2 - a); // v = d y² + 1.
            let { isValid, value: x } = uvRatio(u, v); // √(u/v)
            if (!isValid)
                throw new Error('bad point: invalid y coordinate');
            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper
            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit
            if (!zip215 && x === _0n && isLastByteOdd)
                // if x=0 and x_0 = 1, fail
                throw new Error('bad point: x=0 and x_0=1');
            if (isLastByteOdd !== isXOdd)
                x = modP(-x); // if x_0 != x mod 2, set x = p-x
            return Point.fromAffine({ x, y });
        }
        static fromHex(bytes, zip215 = false) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('point', bytes), zip215);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_2n); // random number
            return this;
        }
        // Useful in fromAffine() - not for fromBytes(), which always created valid points.
        assertValidity() {
            assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
            aextpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const X1Z2 = modP(X1 * Z2);
            const X2Z1 = modP(X2 * Z1);
            const Y1Z2 = modP(Y1 * Z2);
            const Y2Z1 = modP(Y2 * Z1);
            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        negate() {
            // Flips point sign to a negative one (-x, y in affine coords)
            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
            const { a } = CURVE;
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const A = modP(X1 * X1); // A = X12
            const B = modP(Y1 * Y1); // B = Y12
            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12
            const D = modP(a * A); // D = a*A
            const x1y1 = X1 + Y1;
            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B
            const G = D + B; // G = D+B
            const F = G - C; // F = G-C
            const H = D - B; // H = D-B
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
            aextpoint(other);
            const { a, d } = CURVE;
            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;
            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;
            const A = modP(X1 * X2); // A = X1*X2
            const B = modP(Y1 * Y2); // B = Y1*Y2
            const C = modP(T1 * d * T2); // C = T1*d*T2
            const D = modP(Z1 * Z2); // D = Z1*Z2
            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B
            const F = D - C; // F = D-C
            const G = D + C; // G = D+C
            const H = modP(B - a * A); // H = B-a*A
            const X3 = modP(E * F); // X3 = E*F
            const Y3 = modP(G * H); // Y3 = G*H
            const T3 = modP(E * H); // T3 = E*H
            const Z3 = modP(F * G); // Z3 = F*G
            return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        // Constant-time multiplication.
        multiply(scalar) {
            // 1 <= scalar < L
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: expected 1 <= sc < curve.n');
            const { p, f } = wnaf.cached(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            return (0, curve_ts_1.normalizeZ)(Point, [p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        // Accepts optional accumulator to merge with multiply (important for sparse scalars)
        multiplyUnsafe(scalar, acc = Point.ZERO) {
            // 0 <= scalar < L
            if (!Fn.isValid(scalar))
                throw new Error('invalid scalar: expected 0 <= sc < curve.n');
            if (scalar === _0n)
                return Point.ZERO;
            if (this.is0() || scalar === _1n)
                return this;
            return wnaf.unsafe(this, scalar, (p) => (0, curve_ts_1.normalizeZ)(Point, p), acc);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
            return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
            return wnaf.unsafe(this, CURVE.n).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        clearCofactor() {
            if (cofactor === _1n)
                return this;
            return this.multiplyUnsafe(cofactor);
        }
        toBytes() {
            const { x, y } = this.toAffine();
            // Fp.toBytes() allows non-canonical encoding of y (>= p).
            const bytes = Fp.toBytes(y);
            // Each y has 2 valid points: (x, y), (x,-y).
            // When compressing, it's enough to store y and use the last byte to encode sign of x
            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;
            return bytes;
        }
        toHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes());
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get ex() {
            return this.X;
        }
        get ey() {
            return this.Y;
        }
        get ez() {
            return this.Z;
        }
        get et() {
            return this.T;
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        toRawBytes() {
            return this.toBytes();
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
    // zero / infinity / identity point
    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const wnaf = new curve_ts_1.wNAF(Point, Fn.BITS);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
/**
 * Base class for prime-order points like Ristretto255 and Decaf448.
 * These points eliminate cofactor issues by representing equivalence classes
 * of Edwards curve points.
 */
class PrimeEdwardsPoint {
    constructor(ep) {
        this.ep = ep;
    }
    // Static methods that must be implemented by subclasses
    static fromBytes(_bytes) {
        (0, utils_ts_1.notImplemented)();
    }
    static fromHex(_hex) {
        (0, utils_ts_1.notImplemented)();
    }
    get x() {
        return this.toAffine().x;
    }
    get y() {
        return this.toAffine().y;
    }
    // Common implementations
    clearCofactor() {
        // no-op for prime-order groups
        return this;
    }
    assertValidity() {
        this.ep.assertValidity();
    }
    toAffine(invertedZ) {
        return this.ep.toAffine(invertedZ);
    }
    toHex() {
        return (0, utils_ts_1.bytesToHex)(this.toBytes());
    }
    toString() {
        return this.toHex();
    }
    isTorsionFree() {
        return true;
    }
    isSmallOrder() {
        return false;
    }
    add(other) {
        this.assertSame(other);
        return this.init(this.ep.add(other.ep));
    }
    subtract(other) {
        this.assertSame(other);
        return this.init(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return this.init(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return this.init(this.ep.multiplyUnsafe(scalar));
    }
    double() {
        return this.init(this.ep.double());
    }
    negate() {
        return this.init(this.ep.negate());
    }
    precompute(windowSize, isLazy) {
        return this.init(this.ep.precompute(windowSize, isLazy));
    }
    /** @deprecated use `toBytes` */
    toRawBytes() {
        return this.toBytes();
    }
}
exports.PrimeEdwardsPoint = PrimeEdwardsPoint;
/**
 * Initializes EdDSA signatures over given Edwards curve.
 */
function eddsa(Point, cHash, eddsaOpts = {}) {
    if (typeof cHash !== 'function')
        throw new Error('"hash" function param is required');
    (0, utils_ts_1._validateObject)(eddsaOpts, {}, {
        adjustScalarBytes: 'function',
        randomBytes: 'function',
        domain: 'function',
        prehash: 'function',
        mapToCurve: 'function',
    });
    const { prehash } = eddsaOpts;
    const { BASE, Fp, Fn } = Point;
    const randomBytes = eddsaOpts.randomBytes || utils_ts_1.randomBytes;
    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);
    const domain = eddsaOpts.domain ||
        ((data, ctx, phflag) => {
            (0, utils_ts_1._abool2)(phflag, 'phflag');
            if (ctx.length || phflag)
                throw new Error('Contexts/pre-hash are not supported');
            return data;
        }); // NOOP
    // Little-endian SHA512 with modulo n
    function modN_LE(hash) {
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit
    }
    // Get the hashed private scalar per RFC8032 5.1.5
    function getPrivateScalar(key) {
        const len = lengths.secretKey;
        key = (0, utils_ts_1.ensureBytes)('private key', key, len);
        // Hash private key with curve's hash function to produce uniformingly random input
        // Check byte lengths: ensure(64, h(ensure(32, key)))
        const hashed = (0, utils_ts_1.ensureBytes)('hashed private key', cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE
        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)
        const scalar = modN_LE(head); // The actual private scalar
        return { head, prefix, scalar };
    }
    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */
    function getExtendedPublicKey(secretKey) {
        const { head, prefix, scalar } = getPrivateScalar(secretKey);
        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key
        const pointBytes = point.toBytes();
        return { head, prefix, scalar, point, pointBytes };
    }
    /** Calculates EdDSA pub key. RFC8032 5.1.5. */
    function getPublicKey(secretKey) {
        return getExtendedPublicKey(secretKey).pointBytes;
    }
    // int('LE', SHA512(dom2(F, C) || msgs)) mod N
    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {
        const msg = (0, utils_ts_1.concatBytes)(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_ts_1.ensureBytes)('context', context), !!prehash)));
    }
    /** Signs message with privateKey. RFC8032 5.1.6 */
    function sign(msg, secretKey, options = {}) {
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        if (prehash)
            msg = prehash(msg); // for ed25519ph etc.
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);
        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)
        const R = BASE.multiply(r).toBytes(); // R = rG
        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)
        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L
        if (!Fn.isValid(s))
            throw new Error('sign failed: invalid s'); // 0 <= s < L
        const rs = (0, utils_ts_1.concatBytes)(R, Fn.toBytes(s));
        return (0, utils_ts_1._abytes2)(rs, lengths.signature, 'result');
    }
    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:
    const verifyOpts = { zip215: true };
    /**
     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.
     * An extended group equation is checked.
     */
    function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = lengths.signature;
        sig = (0, utils_ts_1.ensureBytes)('signature', sig, len);
        msg = (0, utils_ts_1.ensureBytes)('message', msg);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, lengths.publicKey);
        if (zip215 !== undefined)
            (0, utils_ts_1._abool2)(zip215, 'zip215');
        if (prehash)
            msg = prehash(msg); // for ed25519ph, etc
        const mid = len / 2;
        const r = sig.subarray(0, mid);
        const s = (0, utils_ts_1.bytesToNumberLE)(sig.subarray(mid, len));
        let A, R, SB;
        try {
            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.
            // zip215=true:  0 <= y < MASK (2^256 for ed25519)
            // zip215=false: 0 <= y < P (2^255-19 for ed25519)
            A = Point.fromBytes(publicKey, zip215);
            R = Point.fromBytes(r, zip215);
            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside
        }
        catch (error) {
            return false;
        }
        if (!zip215 && A.isSmallOrder())
            return false; // zip215 allows public keys of small order
        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        // Extended group equation
        // [8][S]B = [8]R + [8][k]A'
        return RkA.subtract(SB).clearCofactor().is0();
    }
    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448
    const lengths = {
        secretKey: _size,
        publicKey: _size,
        signature: 2 * _size,
        seed: _size,
    };
    function randomSecretKey(seed = randomBytes(lengths.seed)) {
        return (0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed');
    }
    function keygen(seed) {
        const secretKey = utils.randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    function isValidSecretKey(key) {
        return (0, utils_ts_1.isBytes)(key) && key.length === Fn.BYTES;
    }
    function isValidPublicKey(key, zip215) {
        try {
            return !!Point.fromBytes(key, zip215);
        }
        catch (error) {
            return false;
        }
    }
    const utils = {
        getExtendedPublicKey,
        randomSecretKey,
        isValidSecretKey,
        isValidPublicKey,
        /**
         * Converts ed public key to x public key. Uses formula:
         * - ed25519:
         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`
         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`
         * - ed448:
         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`
         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`
         */
        toMontgomery(publicKey) {
            const { y } = Point.fromBytes(publicKey);
            const size = lengths.publicKey;
            const is25519 = size === 32;
            if (!is25519 && size !== 57)
                throw new Error('only defined for 25519 and 448');
            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);
            return Fp.toBytes(u);
        },
        toMontgomeryPriv(secretKey) {
            const size = lengths.secretKey;
            (0, utils_ts_1._abytes2)(secretKey, size);
            const hashed = cHash(secretKey.subarray(0, size));
            return adjustScalarBytes(hashed).subarray(0, size);
        },
        /** @deprecated */
        randomPrivateKey: randomSecretKey,
        /** @deprecated */
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({
        keygen,
        getPublicKey,
        sign,
        verify,
        utils,
        Point,
        lengths,
    });
}
function _eddsa_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        d: c.d,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, c.nBitLength, true);
    const curveOpts = { Fp, Fn, uvRatio: c.uvRatio };
    const eddsaOpts = {
        randomBytes: c.randomBytes,
        adjustScalarBytes: c.adjustScalarBytes,
        domain: c.domain,
        prehash: c.prehash,
        mapToCurve: c.mapToCurve,
    };
    return { CURVE, curveOpts, hash: c.hash, eddsaOpts };
}
function _eddsa_new_output_to_legacy(c, eddsa) {
    const Point = eddsa.Point;
    const legacy = Object.assign({}, eddsa, {
        ExtendedPoint: Point,
        CURVE: c,
        nBitLength: Point.Fn.BITS,
        nByteLength: Point.Fn.BYTES,
    });
    return legacy;
}
// TODO: remove. Use eddsa
function twistedEdwards(c) {
    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);
    const Point = edwards(CURVE, curveOpts);
    const EDDSA = eddsa(Point, hash, eddsaOpts);
    return _eddsa_new_output_to_legacy(c, EDDSA);
}
//# sourceMappingURL=edwards.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!**************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._DST_scalar = void 0;
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
function normDST(DST) {
    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string')
        throw new Error('DST must be Uint8Array or string');
    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST } = options;
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
            // @ts-ignore
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/modular.js":
/*!********************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/modular.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n) => {
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n)
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P ≡ 3 (mod 4)
 * 2. P ≡ 5 (mod 8)
 * 3. P ≡ 9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n)
        return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue
 * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue
 * * (a | p) ≡ 0    if a ≡ 0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?
isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean')
            modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths: allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                }
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
                scalar = mod(scalar, ORDER);
            if (!skipValidation)
                if (!f.isValid(scalar))
                    throw new Error('invalid field element: outside of range 0..ORDER');
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?
// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).
// which mean we cannot force this via opts.
// Not sure what to do with randomBytes, we can accept it inside opts if wanted.
// Probably need to export getMinHashLength somewhere?
// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {
//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;
//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?
//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;
//   return reduced;
// },
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/montgomery.js":
/*!***********************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/montgomery.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.montgomery = montgomery;
/**
 * Montgomery curve methods. It's not really whole montgomery curve,
 * just bunch of very specific methods for X25519 / X448 from
 * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
function validateOpts(curve) {
    (0, utils_ts_1._validateObject)(curve, {
        adjustScalarBytes: 'function',
        powPminus2: 'function',
    });
    return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;
    const is25519 = type === 'x25519';
    if (!is25519 && type !== 'x448')
        throw new Error('invalid type');
    const randomBytes_ = rand || utils_ts_1.randomBytes;
    const montgomeryBits = is25519 ? 255 : 448;
    const fieldLen = is25519 ? 32 : 56;
    const Gu = is25519 ? BigInt(9) : BigInt(5);
    // RFC 7748 #5:
    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and
    // (156326 - 2) / 4 = 39081 for curve448/X448
    // const a = is25519 ? 156326n : 486662n;
    const a24 = is25519 ? BigInt(121665) : BigInt(39081);
    // RFC: x25519 "the resulting integer is of the form 2^254 plus
    // eight times a value between 0 and 2^251 - 1 (inclusive)"
    // x448: "2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)"
    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);
    const maxAdded = is25519
        ? BigInt(8) * _2n ** BigInt(251) - _1n
        : BigInt(4) * _2n ** BigInt(445) - _1n;
    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)
    const modP = (n) => (0, modular_ts_1.mod)(n, P);
    const GuBytes = encodeU(Gu);
    function encodeU(u) {
        return (0, utils_ts_1.numberToBytesLE)(modP(u), fieldLen);
    }
    function decodeU(u) {
        const _u = (0, utils_ts_1.ensureBytes)('u coordinate', u, fieldLen);
        // RFC: When receiving such an array, implementations of X25519
        // (but not X448) MUST mask the most significant bit in the final byte.
        if (is25519)
            _u[31] &= 127; // 0b0111_1111
        // RFC: Implementations MUST accept non-canonical values and process them as
        // if they had been reduced modulo the field prime.  The non-canonical
        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224
        // - 1 through 2^448 - 1 for X448.
        return modP((0, utils_ts_1.bytesToNumberLE)(_u));
    }
    function decodeScalar(scalar) {
        return (0, utils_ts_1.bytesToNumberLE)(adjustScalarBytes((0, utils_ts_1.ensureBytes)('scalar', scalar, fieldLen)));
    }
    function scalarMult(scalar, u) {
        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));
        // Some public keys are useless, of low-order. Curve author doesn't think
        // it needs to be validated, but we do it nonetheless.
        // https://cr.yp.to/ecdh.html#validate
        if (pu === _0n)
            throw new Error('invalid private or public key received');
        return encodeU(pu);
    }
    // Computes public key from private. By doing scalar multiplication of base point.
    function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
    }
    // cswap from RFC7748 "example code"
    function cswap(swap, x_2, x_3) {
        // dummy = mask(swap) AND (x_2 XOR x_3)
        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2
        // and x_3, computed, e.g., as mask(swap) = 0 - swap.
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy
        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy
        return { x_2, x_3 };
    }
    /**
     * Montgomery x-only multiplication ladder.
     * @param pointU u coordinate (x) on Montgomery Curve 25519
     * @param scalar by which the point would be multiplied
     * @returns new Point on Montgomery curve
     */
    function montgomeryLadder(u, scalar) {
        (0, utils_ts_1.aInRange)('u', u, _0n, P);
        (0, utils_ts_1.aInRange)('scalar', scalar, minScalar, maxScalar);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
            const k_t = (k >> t) & _1n;
            swap ^= k_t;
            ({ x_2, x_3 } = cswap(swap, x_2, x_3));
            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
            swap = k_t;
            const A = x_2 + z_2;
            const AA = modP(A * A);
            const B = x_2 - z_2;
            const BB = modP(B * B);
            const E = AA - BB;
            const C = x_3 + z_3;
            const D = x_3 - z_3;
            const DA = modP(D * A);
            const CB = modP(C * B);
            const dacb = DA + CB;
            const da_cb = DA - CB;
            x_3 = modP(dacb * dacb);
            z_3 = modP(x_1 * modP(da_cb * da_cb));
            x_2 = modP(AA * BB);
            z_2 = modP(E * (AA + modP(a24 * E)));
        }
        ({ x_2, x_3 } = cswap(swap, x_2, x_3));
        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));
        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent
        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))
    }
    const lengths = {
        secretKey: fieldLen,
        publicKey: fieldLen,
        seed: fieldLen,
    };
    const randomSecretKey = (seed = randomBytes_(fieldLen)) => {
        (0, utils_ts_1.abytes)(seed, lengths.seed);
        return seed;
    };
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: scalarMultBase(secretKey) };
    }
    const utils = {
        randomSecretKey,
        randomPrivateKey: randomSecretKey,
    };
    return {
        keygen,
        getSharedSecret: (secretKey, publicKey) => scalarMult(secretKey, publicKey),
        getPublicKey: (secretKey) => scalarMultBase(secretKey),
        scalarMult,
        scalarMultBase,
        utils,
        GuBytes: GuBytes.slice(),
        lengths,
    };
}
//# sourceMappingURL=montgomery.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/abstract/weierstrass.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/abstract/weierstrass.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = exports.DERErr = void 0;
exports._splitEndoScalar = _splitEndoScalar;
exports._normFnElement = _normFnElement;
exports.weierstrassN = weierstrassN;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
exports.ecdh = ecdh;
exports.ecdsa = ecdsa;
exports.weierstrassPoints = weierstrassPoints;
exports._legacyHelperEquat = _legacyHelperEquat;
exports.weierstrass = weierstrass;
/**
 * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = __webpack_require__(/*! @noble/hashes/hmac.js */ "./node_modules/@noble/hashes/hmac.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/@noble/hashes/utils.js");
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
/**
 * Splits scalar for GLV endomorphism.
 */
function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg)
        k1 = -k1;
    if (k2neg)
        k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error('splitScalar (endomorphism): failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
    if (!['compact', 'recovered', 'der'].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
        // @ts-ignore
        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    }
    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');
    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');
    if (optsn.format !== undefined)
        validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else {
        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        }
        catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num))
        throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */
function weierstrassN(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y² = x³ + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y² == x³ + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y²
        const right = weierstrassEquation(x); // x³ + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y² = x³ + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
            throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x, y };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasCache(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.unsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */
function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        }
        catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp)
                return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
                return false;
            return !!Point.fromBytes(publicKey);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
            return undefined;
        const l = (0, utils_ts_1.ensureBytes)('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false)
            throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */
function ecdsa(Point, hash, ecdsaOpts = {}) {
    (0, utils_1.ahash)(hash);
    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined, //'compact' as ECDSASigFormat,
        extraEntropy: false,
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null)
                    throw new Error('recovery bit must be present');
                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() { }
        static fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // Pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, undefined, 'message');
        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */
    function prepSig(message, privateKey, opts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = k⋅G
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */
    function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            sg !== null &&
            typeof sg === 'object' &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) {
            sig = new Signature(sg.r, sg.s);
        }
        else if (isHex) {
            try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');
            }
            catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                    throw derError;
            }
            if (!sig) {
                try {
                    sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');
                }
                catch (error) {
                    return false;
                }
            }
        }
        if (!sig)
            return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1⋅G + u2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined
            ? tryParsingSig(signature)
            : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);
        if (sig === false)
            return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS())
                return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P
            if (R.is0())
                return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        }
        catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
    });
}
/** @deprecated use `weierstrass` in newer releases */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))
        : undefined;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey,
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².
     * @returns y²
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b
    }
    return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)),
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/ed25519.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/curves/ed25519.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.encodeToCurve = exports.hashToCurve = exports.RistrettoPoint = exports.edwardsToMontgomery = exports.ED25519_TORSION_SUBGROUP = exports.ristretto255_hasher = exports.ristretto255 = exports.ed25519_hasher = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = void 0;
exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
/**
 * ed25519 Twisted Edwards curve with following addons:
 * - X25519 ECDH
 * - Ristretto cofactor elimination
 * - Elligator hash-to-group / point indistinguishability
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/@noble/hashes/sha2.js");
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./abstract/curve.js */ "./node_modules/@noble/curves/abstract/curve.js");
const edwards_ts_1 = __webpack_require__(/*! ./abstract/edwards.js */ "./node_modules/@noble/curves/abstract/edwards.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
const montgomery_ts_1 = __webpack_require__(/*! ./abstract/montgomery.js */ "./node_modules/@noble/curves/abstract/montgomery.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _5n = BigInt(5), _8n = BigInt(8);
// P = 2n**255n-19n
const ed25519_CURVE_p = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed');
// N = 2n**252n + 27742317777372353535851937790883648493n
// a = Fp.create(BigInt(-1))
// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))
const ed25519_CURVE = /* @__PURE__ */ (() => ({
    p: ed25519_CURVE_p,
    n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),
    h: _8n,
    a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),
    d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),
    Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),
    Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),
}))();
function ed25519_pow_2_252_3(x) {
    // prettier-ignore
    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
    const P = ed25519_CURVE_p;
    const x2 = (x * x) % P;
    const b2 = (x2 * x) % P; // x^3, 11
    const b4 = ((0, modular_ts_1.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111
    const b5 = ((0, modular_ts_1.pow2)(b4, _1n, P) * x) % P; // x^31
    const b10 = ((0, modular_ts_1.pow2)(b5, _5n, P) * b5) % P;
    const b20 = ((0, modular_ts_1.pow2)(b10, _10n, P) * b10) % P;
    const b40 = ((0, modular_ts_1.pow2)(b20, _20n, P) * b20) % P;
    const b80 = ((0, modular_ts_1.pow2)(b40, _40n, P) * b40) % P;
    const b160 = ((0, modular_ts_1.pow2)(b80, _80n, P) * b80) % P;
    const b240 = ((0, modular_ts_1.pow2)(b160, _80n, P) * b80) % P;
    const b250 = ((0, modular_ts_1.pow2)(b240, _10n, P) * b10) % P;
    const pow_p_5_8 = ((0, modular_ts_1.pow2)(b250, _2n, P) * x) % P;
    // ^ To pow to (p+3)/8, multiply it by x.
    return { pow_p_5_8, b2 };
}
function adjustScalarBytes(bytes) {
    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,
    // set the three least significant bits of the first byte
    bytes[0] &= 248; // 0b1111_1000
    // and the most significant bit of the last to zero,
    bytes[31] &= 127; // 0b0111_1111
    // set the second most significant bit of the last byte to 1
    bytes[31] |= 64; // 0b0100_0000
    return bytes;
}
// √(-1) aka √(a) aka 2^((p-1)/4)
// Fp.sqrt(Fp.neg(1))
const ED25519_SQRT_M1 = /* @__PURE__ */ BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
// sqrt(u/v)
function uvRatio(u, v) {
    const P = ed25519_CURVE_p;
    const v3 = (0, modular_ts_1.mod)(v * v * v, P); // v³
    const v7 = (0, modular_ts_1.mod)(v3 * v3 * v, P); // v⁷
    // (p+3)/8 and (p-5)/8
    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
    let x = (0, modular_ts_1.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8
    const vx2 = (0, modular_ts_1.mod)(v * x * x, P); // vx²
    const root1 = x; // First root candidate
    const root2 = (0, modular_ts_1.mod)(x * ED25519_SQRT_M1, P); // Second root candidate
    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root
    const useRoot2 = vx2 === (0, modular_ts_1.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)
    const noRoot = vx2 === (0, modular_ts_1.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)
    if (useRoot1)
        x = root1;
    if (useRoot2 || noRoot)
        x = root2; // We return root2 anyway, for const-time
    if ((0, modular_ts_1.isNegativeLE)(x, P))
        x = (0, modular_ts_1.mod)(-x, P);
    return { isValid: useRoot1 || useRoot2, value: x };
}
const Fp = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.p, { isLE: true }))();
const Fn = /* @__PURE__ */ (() => (0, modular_ts_1.Field)(ed25519_CURVE.n, { isLE: true }))();
const ed25519Defaults = /* @__PURE__ */ (() => ({
    ...ed25519_CURVE,
    Fp,
    hash: sha2_js_1.sha512,
    adjustScalarBytes,
    // dom2
    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
    // Constant-time, u/√v
    uvRatio,
}))();
/**
 * ed25519 curve with EdDSA signatures.
 * @example
 * import { ed25519 } from '@noble/curves/ed25519';
 * const { secretKey, publicKey } = ed25519.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = ed25519.sign(msg, priv);
 * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215
 * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5
 */
exports.ed25519 = (() => (0, edwards_ts_1.twistedEdwards)(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
    if (ctx.length > 255)
        throw new Error('Context is too big');
    return (0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
/** Context of ed25519. Uses context for domain separation. */
exports.ed25519ctx = (() => (0, edwards_ts_1.twistedEdwards)({
    ...ed25519Defaults,
    domain: ed25519_domain,
}))();
/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */
exports.ed25519ph = (() => (0, edwards_ts_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
    domain: ed25519_domain,
    prehash: sha2_js_1.sha512,
})))();
/**
 * ECDH using curve25519 aka x25519.
 * @example
 * import { x25519 } from '@noble/curves/ed25519';
 * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';
 * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';
 * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases
 * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);
 * x25519.getPublicKey(x25519.utils.randomSecretKey());
 */
exports.x25519 = (() => {
    const P = Fp.ORDER;
    return (0, montgomery_ts_1.montgomery)({
        P,
        type: 'x25519',
        powPminus2: (x) => {
            // x^(p-2) aka x^(2^255-21)
            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
            return (0, modular_ts_1.mod)((0, modular_ts_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
        },
        adjustScalarBytes,
    });
})();
// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)
// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since
// SageMath returns different root first and everything falls apart
const ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic
const ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1
const ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)
// prettier-ignore
function map_to_curve_elligator2_curve25519(u) {
    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic
    const ELL2_J = BigInt(486662);
    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2
    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1
    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not
    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)
    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2
    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3
    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd
    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd
    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2
    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2
    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2
    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4
    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3
    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3
    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7
    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)
    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)
    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3
    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2
    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd
    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1
    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt
    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd
    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u
    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2
    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3
    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)
    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2
    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd
    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2
    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt
    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2
    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd
    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1
    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2
    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2
    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y
    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)
    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)
}
const ELL2_C1_EDWARDS = /* @__PURE__ */ (() => (0, modular_ts_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0
function map_to_curve_elligator2_edwards25519(u) {
    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =
    // map_to_curve_elligator2_curve25519(u)
    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd
    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1
    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM
    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd
    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)
    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd
    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0
    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)
    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)
    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)
    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)
    const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(Fp, [xd, yd], true); // batch division
    return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)
}
/** Hashing to ed25519 points / field. RFC 9380 methods. */
exports.ed25519_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.ed25519.Point, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',
    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',
    p: ed25519_CURVE_p,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha512,
}))();
// √(-1) aka √(a) aka 2^((p-1)/4)
const SQRT_M1 = ED25519_SQRT_M1;
// √(ad - 1)
const SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
// 1 / √(a-d)
const INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
// 1-d²
const ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
// (d-1)²
const D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
// Calculates 1/√(number)
const invertSqrt = (number) => uvRatio(_1n, number);
const MAX_255B = /* @__PURE__ */ BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
const bytes255ToNumberLE = (bytes) => exports.ed25519.Point.Fp.create((0, utils_ts_1.bytesToNumberLE)(bytes) & MAX_255B);
/**
 * Computes Elligator map for Ristretto255.
 * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on
 * the [website](https://ristretto.group/formulas/elligator.html).
 */
function calcElligatorRistrettoMap(r0) {
    const { d } = ed25519_CURVE;
    const P = ed25519_CURVE_p;
    const mod = (n) => Fp.create(n);
    const r = mod(SQRT_M1 * r0 * r0); // 1
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2
    let c = BigInt(-1); // 3
    const D = mod((c - d * r) * mod(r + d)); // 4
    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5
    let s_ = mod(s * r0); // 6
    if (!(0, modular_ts_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
    if (!Ns_D_is_sq)
        s = s_; // 7
    if (!Ns_D_is_sq)
        c = r; // 8
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9
    const s2 = s * s;
    const W0 = mod((s + s) * D); // 10
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11
    const W2 = mod(_1n - s2); // 12
    const W3 = mod(_1n + s2); // 13
    return new exports.ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
}
function ristretto255_map(bytes) {
    (0, utils_js_1.abytes)(bytes, 64);
    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));
    const R2 = calcElligatorRistrettoMap(r2);
    return new _RistrettoPoint(R1.add(R2));
}
/**
 * Wrapper over Edwards Point for ristretto255.
 *
 * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be
 * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.
 * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,
 * but it should work in its own namespace: do not combine those two.
 * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).
 */
class _RistrettoPoint extends edwards_ts_1.PrimeEdwardsPoint {
    constructor(ep) {
        super(ep);
    }
    static fromAffine(ap) {
        return new _RistrettoPoint(exports.ed25519.Point.fromAffine(ap));
    }
    assertSame(other) {
        if (!(other instanceof _RistrettoPoint))
            throw new Error('RistrettoPoint expected');
    }
    init(ep) {
        return new _RistrettoPoint(ep);
    }
    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
    static hashToCurve(hex) {
        return ristretto255_map((0, utils_ts_1.ensureBytes)('ristrettoHash', hex, 64));
    }
    static fromBytes(bytes) {
        (0, utils_js_1.abytes)(bytes, 32);
        const { a, d } = ed25519_CURVE;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const s = bytes255ToNumberLE(bytes);
        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.
        // 3. Check that s is non-negative, or else abort
        if (!(0, utils_ts_1.equalBytes)(Fp.toBytes(s), bytes) || (0, modular_ts_1.isNegativeLE)(s, P))
            throw new Error('invalid ristretto255 encoding 1');
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2); // 4 (a is -1)
        const u2 = mod(_1n - a * s2); // 5
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2); // 6
        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7
        const Dx = mod(I * u2); // 8
        const Dy = mod(I * Dx * v); // 9
        let x = mod((s + s) * Dx); // 10
        if ((0, modular_ts_1.isNegativeLE)(x, P))
            x = mod(-x); // 10
        const y = mod(u1 * Dy); // 11
        const t = mod(x * y); // 12
        if (!isValid || (0, modular_ts_1.isNegativeLE)(t, P) || y === _0n)
            throw new Error('invalid ristretto255 encoding 2');
        return new _RistrettoPoint(new exports.ed25519.Point(x, y, _1n, t));
    }
    /**
     * Converts ristretto-encoded string to ristretto point.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).
     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
     */
    static fromHex(hex) {
        return _RistrettoPoint.fromBytes((0, utils_ts_1.ensureBytes)('ristrettoHex', hex, 32));
    }
    static msm(points, scalars) {
        return (0, curve_ts_1.pippenger)(_RistrettoPoint, exports.ed25519.Point.Fn, points, scalars);
    }
    /**
     * Encodes ristretto point to Uint8Array.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).
     */
    toBytes() {
        let { X, Y, Z, T } = this.ep;
        const P = ed25519_CURVE_p;
        const mod = (n) => Fp.create(n);
        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1
        const u2 = mod(X * Y); // 2
        // Square root always exists
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3
        const D1 = mod(invsqrt * u1); // 4
        const D2 = mod(invsqrt * u2); // 5
        const zInv = mod(D1 * D2 * T); // 6
        let D; // 7
        if ((0, modular_ts_1.isNegativeLE)(T * zInv, P)) {
            let _x = mod(Y * SQRT_M1);
            let _y = mod(X * SQRT_M1);
            X = _x;
            Y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        }
        else {
            D = D2; // 8
        }
        if ((0, modular_ts_1.isNegativeLE)(X * zInv, P))
            Y = mod(-Y); // 9
        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))
        if ((0, modular_ts_1.isNegativeLE)(s, P))
            s = mod(-s);
        return Fp.toBytes(s); // 11
    }
    /**
     * Compares two Ristretto points.
     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).
     */
    equals(other) {
        this.assertSame(other);
        const { X: X1, Y: Y1 } = this.ep;
        const { X: X2, Y: Y2 } = other.ep;
        const mod = (n) => Fp.create(n);
        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
    }
    is0() {
        return this.equals(_RistrettoPoint.ZERO);
    }
}
// Do NOT change syntax: the following gymnastics is done,
// because typescript strips comments, which makes bundlers disable tree-shaking.
// prettier-ignore
_RistrettoPoint.BASE = 
/* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.BASE))();
// prettier-ignore
_RistrettoPoint.ZERO = 
/* @__PURE__ */ (() => new _RistrettoPoint(exports.ed25519.Point.ZERO))();
// prettier-ignore
_RistrettoPoint.Fp = 
/* @__PURE__ */ (() => Fp)();
// prettier-ignore
_RistrettoPoint.Fn = 
/* @__PURE__ */ (() => Fn)();
exports.ristretto255 = { Point: _RistrettoPoint };
/** Hashing to ristretto255 points / field. RFC 9380 methods. */
exports.ristretto255_hasher = {
    hashToCurve(msg, options) {
        const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, DST, 64, sha2_js_1.sha512);
        return ristretto255_map(xmd);
    },
    hashToScalar(msg, options = { DST: hash_to_curve_ts_1._DST_scalar }) {
        const xmd = (0, hash_to_curve_ts_1.expand_message_xmd)(msg, options.DST, 64, sha2_js_1.sha512);
        return Fn.create((0, utils_ts_1.bytesToNumberLE)(xmd));
    },
};
// export const ristretto255_oprf: OPRF = createORPF({
//   name: 'ristretto255-SHA512',
//   Point: RistrettoPoint,
//   hash: sha512,
//   hashToGroup: ristretto255_hasher.hashToCurve,
//   hashToScalar: ristretto255_hasher.hashToScalar,
// });
/**
 * Weird / bogus points, useful for debugging.
 * All 8 ed25519 points of 8-torsion subgroup can be generated from the point
 * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.
 * ⟨T⟩ = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }
 */
exports.ED25519_TORSION_SUBGROUP = [
    '0100000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
    '0000000000000000000000000000000000000000000000000000000000000080',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
    '0000000000000000000000000000000000000000000000000000000000000000',
    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',
];
/** @deprecated use `ed25519.utils.toMontgomery` */
function edwardsToMontgomeryPub(edwardsPub) {
    return exports.ed25519.utils.toMontgomery((0, utils_ts_1.ensureBytes)('pub', edwardsPub));
}
/** @deprecated use `ed25519.utils.toMontgomery` */
exports.edwardsToMontgomery = edwardsToMontgomeryPub;
/** @deprecated use `ed25519.utils.toMontgomeryPriv` */
function edwardsToMontgomeryPriv(edwardsPriv) {
    return exports.ed25519.utils.toMontgomeryPriv((0, utils_ts_1.ensureBytes)('pub', edwardsPriv));
}
/** @deprecated use `ristretto255.Point` */
exports.RistrettoPoint = _RistrettoPoint;
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */
exports.hashToCurve = (() => exports.ed25519_hasher.hashToCurve)();
/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */
exports.encodeToCurve = (() => exports.ed25519_hasher.encodeToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
exports.hashToRistretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */
exports.hash_to_ristretto255 = (() => exports.ristretto255_hasher.hashToCurve)();
//# sourceMappingURL=ed25519.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/secp256k1.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/curves/secp256k1.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/@noble/hashes/sha2.js");
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
const _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ "./node_modules/@noble/curves/_shortw_utils.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/@noble/curves/abstract/modular.js");
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/@noble/curves/abstract/weierstrass.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/curves/utils.js");
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],
        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],
    ],
};
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */
exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toBytes(true).slice(1);
const Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
const hasEven = (y) => y % _2n === _0n;
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
    const p = BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return { scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x))
        throw new Error('invalid x: Fail if x ≥ p');
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().
    // Return the unique point P such that x(P) = x and
    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    if (!hasEven(y))
        y = Fp.neg(y);
    const p = Pointk1.fromAffine({ x, y });
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const { Fn } = Pointk1;
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'⋅G
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const { Fn, BASE } = Pointk1;
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
        // int(challenge(bytes(r)||bytes(P)||m))%n
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        // R = s⋅G - e⋅P, where -eP == (n-e)P
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
        if (R.is0() || !hasEven(y) || x !== r)
            return false;
        return true;
    }
    catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = schnorr.keygen();
 * // const publicKey = schnorr.getPublicKey(secretKey);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, secretKey);
 * const isValid = schnorr.verify(sig, msg, publicKey);
 * ```
 */
exports.schnorr = (() => {
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
    };
    // TODO: remove
    exports.secp256k1.utils.randomSecretKey;
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
    }
    return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
            randomSecretKey: randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod,
        },
        lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength,
        },
    };
})();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fpk1.create(BigInt('-11')),
}))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */
exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha256,
}))();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map

/***/ }),

/***/ "./node_modules/@noble/curves/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/curves/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
var utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */
function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/cryptoNode.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/cryptoNode.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
/**
 * Internal webcrypto alias.
 * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.
 * Falls back to Node.js built-in crypto for Node.js <=v14.
 * See utils.ts for details.
 * @module
 */
// @ts-ignore
const nc = __webpack_require__(/*! node:crypto */ "node:crypto");
exports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc
    ? nc.webcrypto
    : nc && typeof nc === 'object' && 'randomBytes' in nc
        ? nc
        : undefined;
//# sourceMappingURL=cryptoNode.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/hkdf.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hkdf.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hkdf = void 0;
exports.extract = extract;
exports.expand = expand;
/**
 * HKDF (RFC 5869): extract + expand in one step.
 * See https://soatok.blog/2021/11/17/understanding-hkdf/.
 * @module
 */
const hmac_ts_1 = __webpack_require__(/*! ./hmac.js */ "./node_modules/@noble/hashes/hmac.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/**
 * HKDF-extract from spec. Less important part. `HKDF-Extract(IKM, salt) -> PRK`
 * Arguments position differs from spec (IKM is first one, since it is not optional)
 * @param hash - hash function that would be used (e.g. sha256)
 * @param ikm - input keying material, the initial key
 * @param salt - optional salt value (a non-secret random value)
 */
function extract(hash, ikm, salt) {
    (0, utils_ts_1.ahash)(hash);
    // NOTE: some libraries treat zero-length array as 'not provided';
    // we don't, since we have undefined as 'not provided'
    // https://github.com/RustCrypto/KDFs/issues/15
    if (salt === undefined)
        salt = new Uint8Array(hash.outputLen);
    return (0, hmac_ts_1.hmac)(hash, (0, utils_ts_1.toBytes)(salt), (0, utils_ts_1.toBytes)(ikm));
}
const HKDF_COUNTER = /* @__PURE__ */ Uint8Array.from([0]);
const EMPTY_BUFFER = /* @__PURE__ */ Uint8Array.of();
/**
 * HKDF-expand from the spec. The most important part. `HKDF-Expand(PRK, info, L) -> OKM`
 * @param hash - hash function that would be used (e.g. sha256)
 * @param prk - a pseudorandom key of at least HashLen octets (usually, the output from the extract step)
 * @param info - optional context and application specific information (can be a zero-length string)
 * @param length - length of output keying material in bytes
 */
function expand(hash, prk, info, length = 32) {
    (0, utils_ts_1.ahash)(hash);
    (0, utils_ts_1.anumber)(length);
    const olen = hash.outputLen;
    if (length > 255 * olen)
        throw new Error('Length should be <= 255*HashLen');
    const blocks = Math.ceil(length / olen);
    if (info === undefined)
        info = EMPTY_BUFFER;
    // first L(ength) octets of T
    const okm = new Uint8Array(blocks * olen);
    // Re-use HMAC instance between blocks
    const HMAC = hmac_ts_1.hmac.create(hash, prk);
    const HMACTmp = HMAC._cloneInto();
    const T = new Uint8Array(HMAC.outputLen);
    for (let counter = 0; counter < blocks; counter++) {
        HKDF_COUNTER[0] = counter + 1;
        // T(0) = empty string (zero length)
        // T(N) = HMAC-Hash(PRK, T(N-1) | info | N)
        HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T)
            .update(info)
            .update(HKDF_COUNTER)
            .digestInto(T);
        okm.set(T, olen * counter);
        HMAC._cloneInto(HMACTmp);
    }
    HMAC.destroy();
    HMACTmp.destroy();
    (0, utils_ts_1.clean)(T, HKDF_COUNTER);
    return okm.slice(0, length);
}
/**
 * HKDF (RFC 5869): derive keys from an initial input.
 * Combines hkdf_extract + hkdf_expand in one step
 * @param hash - hash function that would be used (e.g. sha256)
 * @param ikm - input keying material, the initial key
 * @param salt - optional salt value (a non-secret random value)
 * @param info - optional context and application specific information (can be a zero-length string)
 * @param length - length of output keying material in bytes
 * @example
 * import { hkdf } from '@noble/hashes/hkdf';
 * import { sha256 } from '@noble/hashes/sha2';
 * import { randomBytes } from '@noble/hashes/utils';
 * const inputKey = randomBytes(32);
 * const salt = randomBytes(32);
 * const info = 'application-key';
 * const hk1 = hkdf(sha256, inputKey, salt, info, 32);
 */
const hkdf = (hash, ikm, salt, info, length) => expand(hash, extract(hash, ikm, salt), info, length);
exports.hkdf = hkdf;
//# sourceMappingURL=hkdf.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hmac.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/_md.js");
const u64 = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/_u64.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/cryptoNode.js");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./main/controllers/index.js":
/*!***********************************!*\
  !*** ./main/controllers/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   launcher: () => (/* reexport safe */ _launcher__WEBPACK_IMPORTED_MODULE_0__.launcher),
/* harmony export */   store: () => (/* reexport safe */ _store__WEBPACK_IMPORTED_MODULE_1__.store),
/* harmony export */   test: () => (/* reexport safe */ _test__WEBPACK_IMPORTED_MODULE_2__.test)
/* harmony export */ });
/* harmony import */ var _launcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./launcher */ "./main/controllers/launcher.js");
/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./store */ "./main/controllers/store.js");
/* harmony import */ var _test__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./test */ "./main/controllers/test.js");





/***/ }),

/***/ "./main/controllers/launcher.js":
/*!**************************************!*\
  !*** ./main/controllers/launcher.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   launcher: () => (/* binding */ launcher)
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/filter */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-properties */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-property */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime-corejs3/helpers/defineProperty */ "./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _services_prisma__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../services/prisma */ "./main/services/prisma.js");









function ownKeys(e, r) { var t = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0___default()(e); if ((_babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_1___default())) { var o = _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_1___default()(e); r && (o = _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_2___default()(o).call(o, function (r) { return _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3___default()(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_4___default()(_context = ownKeys(Object(t), !0)).call(_context, function (r) { _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_8___default()(e, r, t[r]); }) : (_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_5___default()) ? _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_6___default()(e, _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_5___default()(t)) : _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_4___default()(_context2 = ownKeys(Object(t))).call(_context2, function (r) { _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_7___default()(e, r, _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_3___default()(t, r)); }); } return e; }


// Launcher data Controller
const launcher = {
  GET: async ({
    fn,
    args
  }) => {
    const data = await (0,_services_prisma__WEBPACK_IMPORTED_MODULE_9__.prismaService)({
      table: "launcher",
      fn: fn,
      args: _objectSpread({}, args)
    });
    if (data.status !== 200) {
      return {
        status: data.status || 500,
        data: `Method launcher.GET failed: ${data.data}`
      };
    }
    return data;
  }
};

/***/ }),

/***/ "./main/controllers/store.js":
/*!***********************************!*\
  !*** ./main/controllers/store.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   store: () => (/* binding */ store)
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash */ "lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/utils */ "./main/helpers/utils.js");




// Store data Controller
const store = {
  GET: async args => {
    const store = await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.instantiateElectronStore)();
    const data = await store.get(args);
    if (!lodash__WEBPACK_IMPORTED_MODULE_1___default().isUndefined(data)) {
      return {
        status: 200,
        data: data
      };
    } else {
      return {
        status: 500,
        data: `Method store.GET failed: ${data}`
      };
    }
  },
  POST: async args => {
    const keys = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_0___default()(args);
    if (keys.length > 1) {
      return {
        status: 414,
        data: `Method store.POST failed: Only 1 key is allowed. Found keys: ${keys.join(", ")}`
      };
    }
    const store = await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.instantiateElectronStore)();
    store.set(args);
    const hasKey = store.has(keys[0]);
    if (hasKey) {
      const data = await store.get(keys[0]);
      if (lodash__WEBPACK_IMPORTED_MODULE_1___default().isEqual(args[keys[0]], data)) {
        return {
          status: 200,
          data: data
        };
      }
    }
    return {
      status: 500,
      data: `Method store.POST failed: Cannot write Store`
    };
  },
  DELETE: async args => {
    const store = await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_2__.instantiateElectronStore)();
    store.delete(args);
    const hasKey = store.has(args);
    if (!hasKey) {
      return {
        status: 200,
        data: !hasKey
      };
    }
    return {
      status: 500,
      data: `Method store.DELETE failed`
    };
  }
};

/***/ }),

/***/ "./main/controllers/test.js":
/*!**********************************!*\
  !*** ./main/controllers/test.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   test: () => (/* binding */ test)
/* harmony export */ });
/* harmony import */ var _services_prisma__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../services/prisma */ "./main/services/prisma.js");


// Test Controller
const test = {
  GET: async ({
    user
  }) => {
    const data = await (0,_services_prisma__WEBPACK_IMPORTED_MODULE_0__.prismaService)({
      table: "user",
      fn: "findMany",
      args: {
        where: {
          name: user
        }
      }
    });
    if (data.status !== 200) {
      return {
        status: data.status || 500,
        data: `Method test.GET failed: ${data.data}`
      };
    }
    return data;
  }
};

/***/ }),

/***/ "./main/helpers/appEvents.js":
/*!***********************************!*\
  !*** ./main/helpers/appEvents.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appEvents: () => (/* binding */ appEvents)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./main/helpers/utils.js");



// All 'app.on' events
const appEvents = () => {
  const isProd = "development" === "production";

  // Close all windows
  electron__WEBPACK_IMPORTED_MODULE_0__.app.on("window-all-closed", () => {
    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.logger)(`Application Closed`);
    electron__WEBPACK_IMPORTED_MODULE_0__.app.quit();
  });

  // Keyboard commands registering
  electron__WEBPACK_IMPORTED_MODULE_0__.app.on("browser-window-focus", function () {
    if (isProd) {
      globalShortcut.register("CommandOrControl+R", () => {
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.logger)("CommandOrControl+R is pressed: Shortcut Disabled");
      });
      globalShortcut.register("F5", () => {
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.logger)("F5 is pressed: Shortcut Disabled");
      });
      globalShortcut.register("CommandOrControl+Shift+R", () => {
        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.logger)("CommandOrControl+Shift+R is pressed: Shortcut Disabled");
      });
    }
  });

  // Disabling keyboard commands on production
  electron__WEBPACK_IMPORTED_MODULE_0__.app.on("ready", () => {
    if (isProd) {
      (0,_utils__WEBPACK_IMPORTED_MODULE_1__.logger)(`Removing Keyboard Commands...`);
      globalShortcut.unregister("CommandOrControl+R");
      globalShortcut.unregister("F5");
      globalShortcut.unregister("CommandOrControl+Shift+R");
    }
  });
};

/***/ }),

/***/ "./main/helpers/createWindow.js":
/*!**************************************!*\
  !*** ./main/helpers/createWindow.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createWindow: () => (/* binding */ createWindow)
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/helpers/defineProperty */ "./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/assign */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_some__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/some */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/some.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_some__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_some__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/filter */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-properties */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/define-property */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var electron_store__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! electron-store */ "electron-store");
/* harmony import */ var electron_store__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(electron_store__WEBPACK_IMPORTED_MODULE_12__);

function ownKeys(e, r) { var t = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1___default()(e); if ((_babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_2___default())) { var o = _babel_runtime_corejs3_core_js_stable_object_get_own_property_symbols__WEBPACK_IMPORTED_MODULE_2___default()(e); r && (o = _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_3___default()(o).call(o, function (r) { return _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_4___default()(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_5___default()(_context2 = ownKeys(Object(t), !0)).call(_context2, function (r) { _babel_runtime_corejs3_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(e, r, t[r]); }) : (_babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default()) ? _babel_runtime_corejs3_core_js_stable_object_define_properties__WEBPACK_IMPORTED_MODULE_7___default()(e, _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_6___default()(t)) : _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_5___default()(_context3 = ownKeys(Object(t))).call(_context3, function (r) { _babel_runtime_corejs3_core_js_stable_object_define_property__WEBPACK_IMPORTED_MODULE_8___default()(e, r, _babel_runtime_corejs3_core_js_stable_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_4___default()(t, r)); }); } return e; }












const createWindow = (windowName, options) => {
  const key = "window-state";
  const name = `window-state-${windowName}`;
  const store = new (electron_store__WEBPACK_IMPORTED_MODULE_12___default())({
    name
  });
  const defaultSize = {
    width: options.width,
    height: options.height
  };
  let state = {};
  const restore = () => store.get(key, defaultSize);
  const getCurrentPosition = () => {
    const position = win.getPosition();
    const size = win.getSize();
    return {
      x: position[0],
      y: position[1],
      width: size[0],
      height: size[1]
    };
  };
  const windowWithinBounds = (windowState, bounds) => {
    return windowState.x >= bounds.x && windowState.y >= bounds.y && windowState.x + windowState.width <= bounds.x + bounds.width && windowState.y + windowState.height <= bounds.y + bounds.height;
  };
  const resetToDefaults = () => {
    const bounds = electron__WEBPACK_IMPORTED_MODULE_11__.screen.getPrimaryDisplay().bounds;
    return _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_9___default()({}, defaultSize, {
      x: (bounds.width - defaultSize.width) / 2,
      y: (bounds.height - defaultSize.height) / 2
    });
  };
  const ensureVisibleOnSomeDisplay = windowState => {
    var _context;
    const visible = _babel_runtime_corejs3_core_js_stable_instance_some__WEBPACK_IMPORTED_MODULE_10___default()(_context = electron__WEBPACK_IMPORTED_MODULE_11__.screen.getAllDisplays()).call(_context, display => {
      return windowWithinBounds(windowState, display.bounds);
    });
    if (!visible) {
      return resetToDefaults();
    }
    return windowState;
  };
  const saveState = () => {
    if (!win.isMinimized() && !win.isMaximized()) {
      _babel_runtime_corejs3_core_js_stable_object_assign__WEBPACK_IMPORTED_MODULE_9___default()(state, getCurrentPosition());
    }
    store.set(key, state);
  };
  state = ensureVisibleOnSomeDisplay(restore());
  const win = new electron__WEBPACK_IMPORTED_MODULE_11__.BrowserWindow(_objectSpread(_objectSpread(_objectSpread({}, state), options), {}, {
    webPreferences: _objectSpread({
      nodeIntegration: false,
      contextIsolation: true
    }, options.webPreferences)
  }));
  win.on("close", saveState);
  return win;
};

/***/ }),

/***/ "./main/helpers/electronBuilderBootstrap.js":
/*!**************************************************!*\
  !*** ./main/helpers/electronBuilderBootstrap.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   electronBuilderBootstrap: () => (/* binding */ electronBuilderBootstrap)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);



function electronBuilderBootstrap() {
  const isProd = "development" === "production";
  const config = {
    provider: "github",
    url: "https://github.com/DexDevLab/nextron-autoupdate-app",
    useMultipleRangeRequest: false,
    channel: "latest",
    updaterCacheDirName: electron__WEBPACK_IMPORTED_MODULE_0__.app.getName(),
    resourcePath: isProd ? process.resourcesPath : path__WEBPACK_IMPORTED_MODULE_2___default().join(__dirname, '../resources')
  };
  let yaml = "";
  yaml += `provider: ${config.provider}\n`;
  yaml += `url: ${config.url}\n`;
  yaml += `useMultipleRangeRequest: ${config.useMultipleRangeRequest}\n`;
  yaml += `channel: ${config.channel}\n`;
  yaml += `updaterCacheDirName: ${config.updaterCacheDirName}`;
  let update_file = [path__WEBPACK_IMPORTED_MODULE_2___default().join(config.resourcePath, "app-update.yml"), yaml];
  let dev_update_file = [path__WEBPACK_IMPORTED_MODULE_2___default().join(config.resourcePath, "dev-app-update.yml"), yaml];
  let checkFiles = [update_file, dev_update_file];
  for (let file of checkFiles) {
    if (!fs__WEBPACK_IMPORTED_MODULE_1___default().existsSync(file[0])) {
      fs__WEBPACK_IMPORTED_MODULE_1___default().writeFileSync(file[0], file[1], () => {});
    }
  }
}

/***/ }),

/***/ "./main/helpers/ipcEvents.js":
/*!***********************************!*\
  !*** ./main/helpers/ipcEvents.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ipcEvents: () => (/* binding */ ipcEvents)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron_dl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron-dl */ "electron-dl");
/* harmony import */ var electron_dl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron_dl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _services_prisma__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../services/prisma */ "./main/services/prisma.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./main/helpers/utils.js");
/* harmony import */ var _windows__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./windows */ "./main/helpers/windows.js");







// All 'ipcMain.on / ipcMain.handle' events and functions
const ipcEvents = () => {
  // Default message function
  electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("message", async (event, arg) => {
    try {
      const users = electron__WEBPACK_IMPORTED_MODULE_0__.app.getAppPath();
      event.reply("message", users);
    } catch (error) {
      (0,_utils__WEBPACK_IMPORTED_MODULE_4__.logger)(error);
      event.reply("message", error);
    }
  });

  // Mock Download function
  electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("download", async (event, arg) => {
    const window = electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.getFocusedWindow();
    console.log(41, "download args: ", arg);
    (0,electron_dl__WEBPACK_IMPORTED_MODULE_1__.download)(window, arg.url, {
      onProgress: status => {
        console.log(47, "download progress: ", status);

        //PROGRESS SENDING
        const mainWindowId = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.getAllWindows)("DexCraft Launcher").id;
        electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.fromId(mainWindowId).webContents.send("download progress", status);
        //mainWindow.webContents.send("download progress", status);
      }
    });
  });

  // Mock insert data to db function
  electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("cadastrar", async (event, {
    name,
    email,
    password
  }) => {
    try {
      const data = {
        name,
        email,
        password,
        nextSeasonTags: ""
      };

      // const createUser = await prisma.user.create({
      //   data,
      // });
      const createUser = await (0,_services_prisma__WEBPACK_IMPORTED_MODULE_3__.prismaService)({
        table: "user",
        fn: "create",
        args: data
      });
      event.reply("cadastrar", createUser);
    } catch (error) {
      event.reply("cadastrar", error);
    }
    {
      /* data: {
          name: 'CARALHO',
          email: 'meucu@teucu.com',
          password: 'Senh@123'
          nextSeasonTags: '',
          createdAt: '2025-04-10--13:47'
        }, */
    }
  });

  // Opens a window from Render
  electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("window-open", async (event, {
    windowName,
    closeParent = false
  }) => {
    if (closeParent) {
      event.sender.close();
    }
    const windowId = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.getAllWindows)({
      name: windowName
    }).id;
    if (windowId === 0) {
      _windows__WEBPACK_IMPORTED_MODULE_5__.instantiateWindow[windowName]();
    } else {
      electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.fromId(windowId).show();
    }
  });

  // Closes own window from Render. May close the entire app if needed
  electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on("window-close", async (event, exitApp = false) => {
    event.sender.close();
    if (exitApp) {
      electron__WEBPACK_IMPORTED_MODULE_0__.app.exit(0);
    }
  });
};
electron__WEBPACK_IMPORTED_MODULE_0__.ipcMain.on('update-msg', async (event, args) => {
  console.log(102, args);
  electron__WEBPACK_IMPORTED_MODULE_0__.BrowserWindow.getFocusedWindow().webContents.send('update-msg', args);
  //event.reply('update-msg', args);
});

// Gets data from Electron Store. May use specific key to get refined properties and values (recommended for performance)
// ipcMain.on("store-get", async (event, key) => {
//   const storeData = instantiateElectronStore().get(key);
//   event.reply("store-get", storeData);
// });

// Stores data to Electron Store, in Object format. Uses watchers (optional) to create identifier for a specific listener for the object was set. If the object changes, it trigggers the event using a channel made with the watcher
// ipcMain.on("store-set", async (event, { obj, watchers }) => {
//   instantiateElectronStore().set({ ...obj });
//   const storeData = instantiateElectronStore().get(Object.keys({ ...obj })[0]);
//   if (_.isArray(watchers)) {
//     watchers.forEach((id) => {
//       event.reply(`store-watch-${Object.keys({ ...obj })[0]}-${id}`, storeData);
//     });
//   } else {
//     event.reply(
//       `store-watch-${Object.keys({ ...obj })[0]}-${watchers}`,
//       storeData
//     );
//   }
// });

// Deletes a value from the Electron Store. Deletes entire store if no key is provided
// ipcMain.on("store-delete", async (event, key) => {
//   instantiateElectronStore().delete(key);
// });

// // Instantiate the Electron Store logger
// ipcMain.handle("logger-start", async (event, msg) => {
//   instantiateElectronStore(false, { name: "log" }).clear();
// });

// // Set information to the Electron Store Logger
// ipcMain.on("logger-set", async (event, msg) => {
//   instantiateElectronStore(false, { name: "log" }).set(msg);
// });

/***/ }),

/***/ "./main/helpers/ipcHandlers.js":
/*!*************************************!*\
  !*** ./main/helpers/ipcHandlers.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ipcHandlers: () => (/* binding */ ipcHandlers)
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _controllers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers */ "./main/controllers/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./main/helpers/utils.js");






// All IPC Controllers to external APIs
const ipcHandlers = () => {
  // Prisma (database) Test (Test controller) GET (Method)
  electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.handle("prisma-test-get", async (event, {
    fn,
    user
  }) => {
    const data = await _controllers__WEBPACK_IMPORTED_MODULE_3__.test.GET({
      user: user
    });
    return data;
  });
};

// Prisma (database) Launcher (Launcher controller) GET (Method)
electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.handle("prisma-launcher-get", async (event, {
  fn,
  args
}) => {
  const data = await _controllers__WEBPACK_IMPORTED_MODULE_3__.launcher.GET({
    fn: fn,
    args: args
  });
  return data;
});
electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.handle("logger", async (event, args) => {
  await (0,_utils__WEBPACK_IMPORTED_MODULE_4__.logger)(args);
});

// Store (Electron Store) GET (Method). May use specific key to get refined properties and values (recommended for performance)
electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.handle("store-get", async (event, args) => {
  const data = await _controllers__WEBPACK_IMPORTED_MODULE_3__.store.GET(args);
  return data;
});

// Store (Electron Store) POST (Method). Uses watchers (optional) to create identifier for a specific listener for the object was set. If the object changes, it trigggers the event using a channel made with the watcher
electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.on("store-post", async (event, {
  key,
  value,
  watchers
}) => {
  const data = await _controllers__WEBPACK_IMPORTED_MODULE_3__.store.POST({
    [key]: value
  });
  if (watchers) {
    if (lodash__WEBPACK_IMPORTED_MODULE_2___default().isArray(watchers)) {
      _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_0___default()(watchers).call(watchers, id => {
        event.reply(`store-watch-${key}-${id}`, data);
      });
    } else {
      event.reply(`store-watch-${key}-${watchers}`, data);
    }
  }
});

// Store (Electron Store) DELETE (Method). Deletes a value from the Electron Store. Deletes entire store if no key is provided
electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.handle("store-delete", async (event, args) => {
  const data = await _controllers__WEBPACK_IMPORTED_MODULE_3__.store.DELETE(args);
  return data;
});

/***/ }),

/***/ "./main/helpers/utils.js":
/*!*******************************!*\
  !*** ./main/helpers/utils.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateFormattedDate: () => (/* binding */ generateFormattedDate),
/* harmony export */   getAllWindows: () => (/* binding */ getAllWindows),
/* harmony export */   getBackendPath: () => (/* binding */ getBackendPath),
/* harmony export */   instantiateElectronStore: () => (/* binding */ instantiateElectronStore),
/* harmony export */   logger: () => (/* binding */ logger),
/* harmony export */   setElectronStore: () => (/* binding */ setElectronStore)
/* harmony export */ });
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/pad-start */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/pad-start.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/object/keys */ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_set_timeout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/set-timeout */ "./node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_set_timeout__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_set_timeout__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/for-each */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_reverse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/reverse */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/reverse.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_reverse__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_reverse__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime-corejs3/core-js-stable/instance/filter */ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js");
/* harmony import */ var _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var electron_store__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! electron-store */ "electron-store");
/* harmony import */ var electron_store__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(electron_store__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash */ "lodash");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _windows__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./windows */ "./main/helpers/windows.js");











// Translate page path to Window Loader depending of the application environment
function getBackendPath(pagePath) {
  const isProd = "development" === "production";
  if (isProd) {
    return `app://./${pagePath}`;
  } else {
    const port = process.argv[2];
    return `http://localhost:${port}/${pagePath}`;
  }
}

// INTERNAL FN TO FORMAT CURRENT DATE TO A SANITIZED FORMAT
function generateFormattedDate(date) {
  var _context, _context2, _context3, _context4, _context5;
  let today = null;
  if (date == null) {
    today = new Date();
  } else {
    today = new Date(date);
  }
  const YYYY = today.getFullYear();
  const MM = _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default()(_context = String(today.getMonth() + 1)).call(_context, 2, "0");
  const DD = _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default()(_context2 = String(today.getDate())).call(_context2, 2, "0");
  const hh = _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default()(_context3 = String(today.getHours())).call(_context3, 2, "0");
  const mm = _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default()(_context4 = String(today.getMinutes())).call(_context4, 2, "0");
  const ss = _babel_runtime_corejs3_core_js_stable_instance_pad_start__WEBPACK_IMPORTED_MODULE_0___default()(_context5 = String(today.getSeconds())).call(_context5, 2, "0");
  const formattedDate = `${YYYY}-${MM}-${DD}--${hh}:${mm}:${ss}`;
  return formattedDate;
}

// Create an instance of the Electron Store
const instantiateElectronStore = async (init = false, options = {}) => {
  const store = new (electron_store__WEBPACK_IMPORTED_MODULE_7___default())(options);
  if (init) {
    switch (options?.name) {
      case "log":
        store.clear();
        const timestamp = generateFormattedDate();
        store.set({
          [timestamp]: "Logger Started"
        });
        break;
      default:
        store.set({
          version: electron__WEBPACK_IMPORTED_MODULE_6__.app.getVersion()
        });
        break;
    }
  }
  return store;
};

// Stores data to Electron Store, in Object format. Uses watchers (optional) to create identifier for a specific listener for the object was set. If the object changes, it trigggers the event using a channel made with the watcher. This Function is meant to be used by the Electron backend
const setElectronStore = async (args, options = {}) => {
  try {
    const keys = _babel_runtime_corejs3_core_js_stable_object_keys__WEBPACK_IMPORTED_MODULE_1___default()(args);
    if (keys.length > 1) {
      throw new Error("Error: Only 1 key is allowed");
    }
    const store = await instantiateElectronStore(false, options);
    store.set(args);
    const hasKey = store.has(keys[0]);
    if (!hasKey) {
      throw new Error();
    } else {
      const data = await store.get(keys[0]);
      if (lodash__WEBPACK_IMPORTED_MODULE_8___default().isEqual(args[keys[0]], data)) {
        return data;
      } else {
        throw new Error();
      }
    }
  } catch (e) {
    const error = new Error(e);
    error.message = "Error: Store cannot be writable";
    const timestamp = generateFormattedDate();
    await setElectronStore({
      [timestamp]: error.message
    }, {
      name: "log"
    });
    const isProd = "development" === "production";
    if (isProd) {
      _babel_runtime_corejs3_core_js_stable_set_timeout__WEBPACK_IMPORTED_MODULE_2___default()(() => {
        electron__WEBPACK_IMPORTED_MODULE_6__.app.exit(1);
      }, 5000);
    }
  }
};

// Send message from main to logger
const logger = async message => {
  let msg = "";
  if (typeof message !== "object") {
    const timestamp = generateFormattedDate();
    msg = {
      [timestamp]: message
    };
  } else {
    msg = message;
  }
  await setElectronStore(msg, {
    name: "log"
  });
};

// Get all current Electron windows, or get by title or name
const getAllWindows = ({
  title,
  name
}) => {
  const browserWindowArr = electron__WEBPACK_IMPORTED_MODULE_6__.BrowserWindow.getAllWindows();
  let windowList = [];
  _babel_runtime_corejs3_core_js_stable_instance_for_each__WEBPACK_IMPORTED_MODULE_3___default()(browserWindowArr).call(browserWindowArr, window => {
    windowList.push({
      id: window.id,
      title: window.getTitle()
    });
  });
  windowList = _babel_runtime_corejs3_core_js_stable_instance_reverse__WEBPACK_IMPORTED_MODULE_4___default()(windowList).call(windowList);
  title = title || _windows__WEBPACK_IMPORTED_MODULE_9__.windowTitles[name] || name;
  if (title) {
    windowList = _babel_runtime_corejs3_core_js_stable_instance_filter__WEBPACK_IMPORTED_MODULE_5___default()(windowList).call(windowList, window => window.title === title);
    if (windowList.length === 0) {
      return {
        id: 0,
        title: "none"
      };
    } else {
      return windowList[windowList.length - 1];
    }
  } else {
    return windowList;
  }
};

/***/ }),

/***/ "./main/helpers/windows.js":
/*!*********************************!*\
  !*** ./main/helpers/windows.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   instantiateWindow: () => (/* binding */ instantiateWindow),
/* harmony export */   windowTitles: () => (/* binding */ windowTitles)
/* harmony export */ });
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _createWindow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createWindow */ "./main/helpers/createWindow.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./main/helpers/utils.js");




const isProd = "development" === "production";

// List all window titles for better reference
const windowTitles = {
  splash: "Splash Screen",
  login: "Entre no DexCraft Launcher",
  main: "DexCraft Launcher"
};

// Set and instantiate all application windows
const instantiateWindow = {
  splash: async () => {
    // Setting window
    const window = (0,_createWindow__WEBPACK_IMPORTED_MODULE_2__.createWindow)("splash", {
      title: windowTitles.splash,
      width: 300,
      height: 300,
      minHeight: 300,
      minWidth: 300,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, "preload.js"),
        webSecurity: false
      },
      alwaysOnTop: true,
      focusable: true,
      frame: false,
      skipTaskbar: true,
      movable: true,
      resizable: false,
      maximizable: false,
      minimizable: false
    });
    // Loading Page component
    await window.loadURL((0,_utils__WEBPACK_IMPORTED_MODULE_3__.getBackendPath)("splash"));
    window.webContents.openDevTools();
    if (!isProd) {
      // Open Dev Tools
      //window.webContents.openDevTools();
    }
    // Specific commands when closing window
    window.on("close", () => {
      electron__WEBPACK_IMPORTED_MODULE_0__.app.exit(0);
    });
    // Using 'center' before 'show' is needed to center the window properly on the screen
    window.center();
    window.show();
    return window;
  },
  login: async () => {
    const window = (0,_createWindow__WEBPACK_IMPORTED_MODULE_2__.createWindow)("login", {
      title: windowTitles.login,
      width: 1920,
      height: 1080,
      minHeight: 768,
      minWidth: 1366,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, "preload.js"),
        webSecurity: false
      }
    });
    if (!isProd) {
      window.webContents.openDevTools();
    }
    window.setBackgroundColor("#1A202C");
    await window.loadURL((0,_utils__WEBPACK_IMPORTED_MODULE_3__.getBackendPath)("login"));
    window.center();
    window.maximize();
    window.on("close", () => {
      electron__WEBPACK_IMPORTED_MODULE_0__.app.exit(0);
    });
    return window;
  },
  main: async () => {
    const window = (0,_createWindow__WEBPACK_IMPORTED_MODULE_2__.createWindow)("main", {
      title: windowTitles.main,
      width: 1920,
      height: 1080,
      minHeight: 768,
      minWidth: 1366,
      show: false,
      autoHideMenuBar: true,
      webPreferences: {
        preload: path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, "preload.js"),
        webSecurity: false
      }
    });
    if (!isProd) {
      window.webContents.openDevTools();
    }
    window.setBackgroundColor("#1A202C");
    await window.loadURL((0,_utils__WEBPACK_IMPORTED_MODULE_3__.getBackendPath)("main"));
    window.center();
    window.maximize();
    window.on("close", () => {
      electron__WEBPACK_IMPORTED_MODULE_0__.app.exit(0);
    });
    return window;
  }
};

/***/ }),

/***/ "./main/services/prisma.js":
/*!*********************************!*\
  !*** ./main/services/prisma.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   prismaService: () => (/* binding */ prismaService)
/* harmony export */ });
/* harmony import */ var _resources_generated_prisma_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../resources/generated/prisma/client */ "./resources/generated/prisma/client.ts");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/utils */ "./main/helpers/utils.js");



// Getting Database Url
const databaseUrl = process.env.DATABASE_URL;

// Call ORM client once
const prisma = new _resources_generated_prisma_client__WEBPACK_IMPORTED_MODULE_0__.PrismaClient({
  datasources: {
    db: {
      url: databaseUrl
    }
  }
});

// Prisma ORM core function. Calls database and return query.
const prismaService = async ({
  table,
  fn,
  args
}) => {
  try {
    const query = await prisma[table][fn](args);
    return {
      status: 200,
      data: query
    };
  } catch (error) {
    await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_1__.logger)(`Error: Prisma Service - ${error}`);
    await prisma.$disconnect();
    return {
      status: error.code || error.errorCode || 500,
      data: `Error: Prisma Error ${error}`
    };
  } finally {
    await prisma.$disconnect();
  }
};

/***/ }),

/***/ "./resources/generated/prisma/client.ts":
/*!**********************************************!*\
  !*** ./resources/generated/prisma/client.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $Enums: () => (/* reexport module object */ _enums_ts__WEBPACK_IMPORTED_MODULE_5__),
/* harmony export */   Prisma: () => (/* reexport module object */ _internal_prismaNamespace_ts__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   PrismaClient: () => (/* binding */ PrismaClient)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(node_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(node_path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(node_url__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _internal_class_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/class.ts */ "./resources/generated/prisma/internal/class.ts");
/* harmony import */ var _internal_prismaNamespace_ts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal/prismaNamespace.ts */ "./resources/generated/prisma/internal/prismaNamespace.ts");
/* harmony import */ var _enums_ts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./enums.ts */ "./resources/generated/prisma/enums.ts");
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * This file should be your main import to use Prisma. Through it you get access to all the models, enums, and input types.
 *
 * 🟢 You can import this file directly.
 */




const __dirname = node_path__WEBPACK_IMPORTED_MODULE_1__.dirname((0,node_url__WEBPACK_IMPORTED_MODULE_2__.fileURLToPath)("file:///D:/Git/nextron-autoupdate-app/resources/generated/prisma/client.ts"));




/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
const PrismaClient = _internal_class_ts__WEBPACK_IMPORTED_MODULE_3__.getPrismaClientClass(__dirname);


// file annotations for bundling tools to include these files
node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname, "query_engine-windows.dll.node");
node_path__WEBPACK_IMPORTED_MODULE_1__.join(node_process__WEBPACK_IMPORTED_MODULE_0__.cwd(), "generated/prisma/query_engine-windows.dll.node");

/**
 * Model User
 * 
 */

/**
 * Model Launcher
 * 
 */

/**
 * Model Motd
 * 
 */

/**
 * Model Server
 * 
 */

/**
 * Model ServerTag
 * 
 */

/**
 * Model Articles
 * 
 */

/***/ }),

/***/ "./resources/generated/prisma/enums.ts":
/*!*********************************************!*\
  !*** ./resources/generated/prisma/enums.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
* This file exports all enum related types from the schema.
*
* 🟢 You can import this file directly.
*/

// This file is empty because there are no enums in the schema.


/***/ }),

/***/ "./resources/generated/prisma/internal/class.ts":
/*!******************************************************!*\
  !*** ./resources/generated/prisma/internal/class.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getPrismaClientClass: () => (/* binding */ getPrismaClientClass)
/* harmony export */ });
/* harmony import */ var _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client/runtime/library */ "./node_modules/@prisma/client/runtime/library.mjs");
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * WARNING: This is an internal file that is subject to change!
 *
 * 🛑 Under no circumstances should you import this file directly! 🛑
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */


const config = {
  "generator": {
    "name": "client",
    "provider": {
      "fromEnvVar": null,
      "value": "prisma-client"
    },
    "output": {
      "value": "D:\\Git\\nextron-autoupdate-app\\generated\\prisma",
      "fromEnvVar": null
    },
    "config": {
      "moduleFormat": "esm",
      "engineType": "library"
    },
    "binaryTargets": [{
      "fromEnvVar": null,
      "value": "windows",
      "native": true
    }],
    "previewFeatures": [],
    "sourceFilePath": "D:\\Git\\nextron-autoupdate-app\\prisma\\schema.prisma",
    "isCustomOutput": true
  },
  "relativePath": "../../prisma",
  "clientVersion": "6.12.0",
  "engineVersion": "8047c96bbd92db98a2abc7c9323ce77c02c89dbc",
  "datasourceNames": ["db"],
  "activeProvider": "mysql",
  "postinstall": false,
  "inlineDatasources": {
    "db": {
      "url": {
        "fromEnvVar": "DATABASE_URL",
        "value": null
      }
    }
  },
  "inlineSchema": "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\n// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?\n// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init\n\ngenerator client {\n  provider      = \"prisma-client\"\n  output        = \"../generated/prisma\"\n  moduleFormat  = \"esm\"\n  // binaryTargets = [\"debian-openssl-3.0.x\", \"darwin\", \"darwin-arm64\", \"windows\", \"native\"]\n  binaryTargets = [\"native\"]\n}\n\ndatasource db {\n  provider = \"mysql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id        String   @id @unique @default(cuid())\n  email     String   @unique\n  name      String   @unique\n  password  String   @default(\"\")\n  pollTags  String\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Launcher {\n  id        String   @id @unique @default(cuid())\n  dataType  String   @unique\n  dataValue String   @db.LongText\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Motd {\n  id        String   @id @unique @default(cuid())\n  motd      String   @db.LongText\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Server {\n  id         String      @id @unique @default(cuid())\n  serverId   Int         @unique\n  name       String\n  desc       String      @default(\"\")\n  mcVersion  String      @default(\"1.7.10\")\n  difficulty Int         @default(2)\n  assets     String      @default(\"\")\n  core       String      @default(\"\")\n  modpack    String      @default(\"\")\n  available  Boolean     @default(false)\n  modded     Boolean     @default(false)\n  featured   String      @default(\"\")\n  periodic   Boolean     @default(false)\n  tags       ServerTag[]\n  createdAt  DateTime    @default(now())\n  updatedAt  DateTime    @updatedAt\n}\n\nmodel ServerTag {\n  id        String   @id @unique @default(cuid())\n  tagId     Int      @unique\n  name      String   @unique\n  desc      String\n  servers   Server[]\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n\nmodel Articles {\n  id        String   @id @unique @default(cuid())\n  articleId Int      @unique\n  serverId  Int      @default(-1)\n  tabName   String\n  pageOrder Int      @default(0)\n  title     String   @default(\"\")\n  subtitle  String   @default(\"\")\n  text      String   @db.LongText\n  available Boolean  @default(true)\n  createdAt DateTime @default(now())\n  updatedAt DateTime @updatedAt\n}\n",
  "inlineSchemaHash": "634981346a3acb3c862845162d9de50fabcfac316cb646815e40aa63ca00ae42",
  "copyEngine": true,
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  },
  "dirname": ""
};
config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"email\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"password\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"pollTags\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Launcher\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"dataType\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"dataValue\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":[\"LongText\",[]],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Motd\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"motd\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":[\"LongText\",[]],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Server\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"serverId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"desc\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"mcVersion\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"1.7.10\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"difficulty\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":2,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"assets\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"core\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"modpack\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"available\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"modded\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"featured\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"periodic\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"tags\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"ServerTag\",\"nativeType\":null,\"relationName\":\"ServerToServerTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"ServerTag\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"tagId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"name\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"desc\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"servers\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Server\",\"nativeType\":null,\"relationName\":\"ServerToServerTag\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Articles\":{\"dbName\":null,\"schema\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":{\"name\":\"cuid\",\"args\":[1]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"articleId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Int\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"serverId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":-1,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"tabName\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"pageOrder\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"nativeType\":null,\"default\":0,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"title\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"subtitle\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"String\",\"nativeType\":null,\"default\":\"\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"text\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"nativeType\":[\"LongText\",[]],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"available\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"nativeType\":null,\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"nativeType\":null,\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"nativeType\":null,\"isGenerated\":false,\"isUpdatedAt\":true}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{},\"types\":{}}");
config.engineWasm = undefined;
config.compilerWasm = undefined;

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */

function getPrismaClientClass(dirname) {
  config.dirname = dirname;
  return _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.getPrismaClient(config);
}

/***/ }),

/***/ "./resources/generated/prisma/internal/prismaNamespace.ts":
/*!****************************************************************!*\
  !*** ./resources/generated/prisma/internal/prismaNamespace.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnyNull: () => (/* binding */ AnyNull),
/* harmony export */   ArticlesOrderByRelevanceFieldEnum: () => (/* binding */ ArticlesOrderByRelevanceFieldEnum),
/* harmony export */   ArticlesScalarFieldEnum: () => (/* binding */ ArticlesScalarFieldEnum),
/* harmony export */   DbNull: () => (/* binding */ DbNull),
/* harmony export */   Decimal: () => (/* binding */ Decimal),
/* harmony export */   JsonNull: () => (/* binding */ JsonNull),
/* harmony export */   LauncherOrderByRelevanceFieldEnum: () => (/* binding */ LauncherOrderByRelevanceFieldEnum),
/* harmony export */   LauncherScalarFieldEnum: () => (/* binding */ LauncherScalarFieldEnum),
/* harmony export */   ModelName: () => (/* binding */ ModelName),
/* harmony export */   MotdOrderByRelevanceFieldEnum: () => (/* binding */ MotdOrderByRelevanceFieldEnum),
/* harmony export */   MotdScalarFieldEnum: () => (/* binding */ MotdScalarFieldEnum),
/* harmony export */   NullTypes: () => (/* binding */ NullTypes),
/* harmony export */   PrismaClientInitializationError: () => (/* binding */ PrismaClientInitializationError),
/* harmony export */   PrismaClientKnownRequestError: () => (/* binding */ PrismaClientKnownRequestError),
/* harmony export */   PrismaClientRustPanicError: () => (/* binding */ PrismaClientRustPanicError),
/* harmony export */   PrismaClientUnknownRequestError: () => (/* binding */ PrismaClientUnknownRequestError),
/* harmony export */   PrismaClientValidationError: () => (/* binding */ PrismaClientValidationError),
/* harmony export */   ServerOrderByRelevanceFieldEnum: () => (/* binding */ ServerOrderByRelevanceFieldEnum),
/* harmony export */   ServerScalarFieldEnum: () => (/* binding */ ServerScalarFieldEnum),
/* harmony export */   ServerTagOrderByRelevanceFieldEnum: () => (/* binding */ ServerTagOrderByRelevanceFieldEnum),
/* harmony export */   ServerTagScalarFieldEnum: () => (/* binding */ ServerTagScalarFieldEnum),
/* harmony export */   SortOrder: () => (/* binding */ SortOrder),
/* harmony export */   Sql: () => (/* binding */ Sql),
/* harmony export */   TransactionIsolationLevel: () => (/* binding */ TransactionIsolationLevel),
/* harmony export */   UserOrderByRelevanceFieldEnum: () => (/* binding */ UserOrderByRelevanceFieldEnum),
/* harmony export */   UserScalarFieldEnum: () => (/* binding */ UserScalarFieldEnum),
/* harmony export */   defineExtension: () => (/* binding */ defineExtension),
/* harmony export */   empty: () => (/* binding */ empty),
/* harmony export */   getExtensionContext: () => (/* binding */ getExtensionContext),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   prismaVersion: () => (/* binding */ prismaVersion),
/* harmony export */   raw: () => (/* binding */ raw),
/* harmony export */   sql: () => (/* binding */ sql),
/* harmony export */   validator: () => (/* binding */ validator)
/* harmony export */ });
/* harmony import */ var _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @prisma/client/runtime/library */ "./node_modules/@prisma/client/runtime/library.mjs");
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// @ts-nocheck 
/**
 * WARNING: This is an internal file that is subject to change!
 * 
 * 🛑 Under no circumstances should you import this file directly! 🛑
 * 
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 * 
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective 
 * model files in the `model` directory!
 */


/**
 * Validator
 */
const validator = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.Public.validator;

/**
 * Prisma Errors
 */

const PrismaClientKnownRequestError = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.PrismaClientKnownRequestError;
const PrismaClientUnknownRequestError = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.PrismaClientUnknownRequestError;
const PrismaClientRustPanicError = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.PrismaClientRustPanicError;
const PrismaClientInitializationError = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.PrismaClientInitializationError;
const PrismaClientValidationError = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.PrismaClientValidationError;
/**
 * Re-export of sql-template-tag
 */
const sql = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.sqltag;
const empty = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.empty;
const join = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.join;
const raw = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.raw;
const Sql = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.Sql;
/**
 * Decimal.js
 */
const Decimal = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.Decimal;

/**
 * Metrics
 */

/**
* Extensions
*/

const getExtensionContext = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.Extensions.getExtensionContext;
/**
 * Prisma Client JS version: 6.12.0
 * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
 */
const prismaVersion = {
  client: "6.12.0",
  engine: "8047c96bbd92db98a2abc7c9323ce77c02c89dbc"
};

/**
 * Utility Types
 */

const NullTypes = {
  DbNull: _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.classes.DbNull,
  JsonNull: _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.classes.JsonNull,
  AnyNull: _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.classes.AnyNull
};

/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
const DbNull = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.instances.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
const JsonNull = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.instances.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
const AnyNull = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.objectEnumValues.instances.AnyNull;

/**
 * From T, pick a set of properties whose keys are in the union K
 */

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */

/**
 * Is T a Record?
 */

/**
 * If it's T[], return T
 */

/**
 * From ts-toolbelt
 */

/** Helper Types for "Merge" **/

// cause typescript not to expand types and preserve names

// this type assumes the passed object is entirely optional

/** End Helper Types for "Merge" **/

/**
 * Convert tuple to union
 */

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */

/**
 * Exclude all keys with underscores
 */

const ModelName = {
  User: 'User',
  Launcher: 'Launcher',
  Motd: 'Motd',
  Server: 'Server',
  ServerTag: 'ServerTag',
  Articles: 'Articles'
};
/**
 * Enums
 */

const TransactionIsolationLevel = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
});
const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  password: 'password',
  pollTags: 'pollTags',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const LauncherScalarFieldEnum = {
  id: 'id',
  dataType: 'dataType',
  dataValue: 'dataValue',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const MotdScalarFieldEnum = {
  id: 'id',
  motd: 'motd',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const ServerScalarFieldEnum = {
  id: 'id',
  serverId: 'serverId',
  name: 'name',
  desc: 'desc',
  mcVersion: 'mcVersion',
  difficulty: 'difficulty',
  assets: 'assets',
  core: 'core',
  modpack: 'modpack',
  available: 'available',
  modded: 'modded',
  featured: 'featured',
  periodic: 'periodic',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const ServerTagScalarFieldEnum = {
  id: 'id',
  tagId: 'tagId',
  name: 'name',
  desc: 'desc',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const ArticlesScalarFieldEnum = {
  id: 'id',
  articleId: 'articleId',
  serverId: 'serverId',
  tabName: 'tabName',
  pageOrder: 'pageOrder',
  title: 'title',
  subtitle: 'subtitle',
  text: 'text',
  available: 'available',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
};
const SortOrder = {
  asc: 'asc',
  desc: 'desc'
};
const UserOrderByRelevanceFieldEnum = {
  id: 'id',
  email: 'email',
  name: 'name',
  password: 'password',
  pollTags: 'pollTags'
};
const LauncherOrderByRelevanceFieldEnum = {
  id: 'id',
  dataType: 'dataType',
  dataValue: 'dataValue'
};
const MotdOrderByRelevanceFieldEnum = {
  id: 'id',
  motd: 'motd'
};
const ServerOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  desc: 'desc',
  mcVersion: 'mcVersion',
  assets: 'assets',
  core: 'core',
  modpack: 'modpack',
  featured: 'featured'
};
const ServerTagOrderByRelevanceFieldEnum = {
  id: 'id',
  name: 'name',
  desc: 'desc'
};
const ArticlesOrderByRelevanceFieldEnum = {
  id: 'id',
  tabName: 'tabName',
  title: 'title',
  subtitle: 'subtitle',
  text: 'text'
};

/**
 * Field references 
 */

/**
 * Reference to a field of type 'String'
 */

/**
 * Reference to a field of type 'DateTime'
 */

/**
 * Reference to a field of type 'Int'
 */

/**
 * Reference to a field of type 'Boolean'
 */

/**
 * Reference to a field of type 'Float'
 */

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */

const defineExtension = _prisma_client_runtime_library__WEBPACK_IMPORTED_MODULE_0__.Extensions.defineExtension;

/* Types for Logging */

/* End Types for Logging */

/**
 * These options are being passed into the middleware as "params"
 */

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */

/**
 * `PrismaClient` proxy available in interactive transactions.
 */

/***/ }),

/***/ "./node_modules/eciesjs/dist/config.js":
/*!*********************************************!*\
  !*** ./node_modules/eciesjs/dist/config.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ephemeralKeySize = exports.symmetricNonceLength = exports.symmetricAlgorithm = exports.isHkdfKeyCompressed = exports.isEphemeralKeyCompressed = exports.ellipticCurve = exports.ECIES_CONFIG = void 0;
var consts_1 = __webpack_require__(/*! ./consts */ "./node_modules/eciesjs/dist/consts.js");
var Config = /** @class */ (function () {
    function Config() {
        this.ellipticCurve = "secp256k1";
        this.isEphemeralKeyCompressed = false; // secp256k1 only
        this.isHkdfKeyCompressed = false; // secp256k1 only
        this.symmetricAlgorithm = "aes-256-gcm";
        this.symmetricNonceLength = 16; // aes-256-gcm only
    }
    return Config;
}());
exports.ECIES_CONFIG = new Config();
var ellipticCurve = function () { return exports.ECIES_CONFIG.ellipticCurve; };
exports.ellipticCurve = ellipticCurve;
var isEphemeralKeyCompressed = function () { return exports.ECIES_CONFIG.isEphemeralKeyCompressed; };
exports.isEphemeralKeyCompressed = isEphemeralKeyCompressed;
var isHkdfKeyCompressed = function () { return exports.ECIES_CONFIG.isHkdfKeyCompressed; };
exports.isHkdfKeyCompressed = isHkdfKeyCompressed;
var symmetricAlgorithm = function () { return exports.ECIES_CONFIG.symmetricAlgorithm; };
exports.symmetricAlgorithm = symmetricAlgorithm;
var symmetricNonceLength = function () { return exports.ECIES_CONFIG.symmetricNonceLength; };
exports.symmetricNonceLength = symmetricNonceLength;
var ephemeralKeySize = function () {
    var mapping = {
        secp256k1: exports.ECIES_CONFIG.isEphemeralKeyCompressed
            ? consts_1.COMPRESSED_PUBLIC_KEY_SIZE
            : consts_1.UNCOMPRESSED_PUBLIC_KEY_SIZE,
        x25519: consts_1.CURVE25519_PUBLIC_KEY_SIZE,
        ed25519: consts_1.CURVE25519_PUBLIC_KEY_SIZE,
    };
    if (exports.ECIES_CONFIG.ellipticCurve in mapping) {
        return mapping[exports.ECIES_CONFIG.ellipticCurve];
    } /* v8 ignore next 2 */
    else {
        throw new Error("Not implemented");
    }
};
exports.ephemeralKeySize = ephemeralKeySize;


/***/ }),

/***/ "./node_modules/eciesjs/dist/consts.js":
/*!*********************************************!*\
  !*** ./node_modules/eciesjs/dist/consts.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AEAD_TAG_LENGTH = exports.XCHACHA20_NONCE_LENGTH = exports.CURVE25519_PUBLIC_KEY_SIZE = exports.ETH_PUBLIC_KEY_SIZE = exports.UNCOMPRESSED_PUBLIC_KEY_SIZE = exports.COMPRESSED_PUBLIC_KEY_SIZE = exports.SECRET_KEY_LENGTH = void 0;
// elliptic
exports.SECRET_KEY_LENGTH = 32;
exports.COMPRESSED_PUBLIC_KEY_SIZE = 33;
exports.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;
exports.ETH_PUBLIC_KEY_SIZE = 64;
exports.CURVE25519_PUBLIC_KEY_SIZE = 32;
// symmetric
exports.XCHACHA20_NONCE_LENGTH = 24;
exports.AEAD_TAG_LENGTH = 16;


/***/ }),

/***/ "./node_modules/eciesjs/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/eciesjs/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.utils = exports.PublicKey = exports.PrivateKey = exports.ECIES_CONFIG = void 0;
exports.encrypt = encrypt;
exports.decrypt = decrypt;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var config_1 = __webpack_require__(/*! ./config */ "./node_modules/eciesjs/dist/config.js");
var keys_1 = __webpack_require__(/*! ./keys */ "./node_modules/eciesjs/dist/keys/index.js");
var utils_2 = __webpack_require__(/*! ./utils */ "./node_modules/eciesjs/dist/utils/index.js");
/**
 * Encrypts data with a receiver's public key.
 * @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`.
 * To keep the same behavior, use `Buffer.from(encrypt(...))`.
 *
 * @param receiverRawPK - Raw public key of the receiver, either as a hex `string` or a `Uint8Array`.
 * @param data - Data to encrypt.
 * @returns Encrypted payload, format: `public key || encrypted`.
 */
function encrypt(receiverRawPK, data) {
    return Buffer.from(_encrypt(receiverRawPK, data));
}
function _encrypt(receiverRawPK, data) {
    var curve = (0, config_1.ellipticCurve)();
    var ephemeralSK = new keys_1.PrivateKey(undefined, curve);
    var receiverPK = receiverRawPK instanceof Uint8Array
        ? new keys_1.PublicKey(receiverRawPK, curve)
        : keys_1.PublicKey.fromHex(receiverRawPK, curve);
    var sharedKey = ephemeralSK.encapsulate(receiverPK, (0, config_1.isHkdfKeyCompressed)());
    var ephemeralPK = ephemeralSK.publicKey.toBytes((0, config_1.isEphemeralKeyCompressed)());
    var encrypted = (0, utils_2.symEncrypt)(sharedKey, data);
    return (0, utils_1.concatBytes)(ephemeralPK, encrypted);
}
/**
 * Decrypts data with a receiver's private key.
 * @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`.
 * To keep the same behavior, use `Buffer.from(decrypt(...))`.
 *
 * @param receiverRawSK - Raw private key of the receiver, either as a hex `string` or a `Uint8Array`.
 * @param data - Data to decrypt.
 * @returns Decrypted plain text.
 */
function decrypt(receiverRawSK, data) {
    return Buffer.from(_decrypt(receiverRawSK, data));
}
function _decrypt(receiverRawSK, data) {
    var curve = (0, config_1.ellipticCurve)();
    var receiverSK = receiverRawSK instanceof Uint8Array
        ? new keys_1.PrivateKey(receiverRawSK, curve)
        : keys_1.PrivateKey.fromHex(receiverRawSK, curve);
    var keySize = (0, config_1.ephemeralKeySize)();
    var ephemeralPK = new keys_1.PublicKey(data.subarray(0, keySize), curve);
    var encrypted = data.subarray(keySize);
    var sharedKey = ephemeralPK.decapsulate(receiverSK, (0, config_1.isHkdfKeyCompressed)());
    return (0, utils_2.symDecrypt)(sharedKey, encrypted);
}
var config_2 = __webpack_require__(/*! ./config */ "./node_modules/eciesjs/dist/config.js");
Object.defineProperty(exports, "ECIES_CONFIG", ({ enumerable: true, get: function () { return config_2.ECIES_CONFIG; } }));
var keys_2 = __webpack_require__(/*! ./keys */ "./node_modules/eciesjs/dist/keys/index.js");
Object.defineProperty(exports, "PrivateKey", ({ enumerable: true, get: function () { return keys_2.PrivateKey; } }));
Object.defineProperty(exports, "PublicKey", ({ enumerable: true, get: function () { return keys_2.PublicKey; } }));
/** @deprecated - use `import utils from "eciesjs/utils"` instead. */
exports.utils = {
    // TODO: remove these after 0.5.0
    aesEncrypt: utils_2.aesEncrypt,
    aesDecrypt: utils_2.aesDecrypt,
    symEncrypt: utils_2.symEncrypt,
    symDecrypt: utils_2.symDecrypt,
    decodeHex: utils_2.decodeHex,
    getValidSecret: utils_2.getValidSecret,
    remove0x: utils_2.remove0x,
};


/***/ }),

/***/ "./node_modules/eciesjs/dist/keys/PrivateKey.js":
/*!******************************************************!*\
  !*** ./node_modules/eciesjs/dist/keys/PrivateKey.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrivateKey = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var utils_2 = __webpack_require__(/*! ../utils */ "./node_modules/eciesjs/dist/utils/index.js");
var PublicKey_1 = __webpack_require__(/*! ./PublicKey */ "./node_modules/eciesjs/dist/keys/PublicKey.js");
var PrivateKey = /** @class */ (function () {
    function PrivateKey(secret, curve) {
        this.curve = curve;
        if (secret === undefined) {
            this.data = (0, utils_2.getValidSecret)(curve);
        }
        else if ((0, utils_2.isValidPrivateKey)(secret, curve)) {
            this.data = secret;
        }
        else {
            throw new Error("Invalid private key");
        }
        this.publicKey = new PublicKey_1.PublicKey((0, utils_2.getPublicKey)(this.data, curve), curve);
    }
    PrivateKey.fromHex = function (hex, curve) {
        return new PrivateKey((0, utils_2.decodeHex)(hex), curve);
    };
    Object.defineProperty(PrivateKey.prototype, "secret", {
        /** @description From version 0.5.0, `Uint8Array` will be returned instead of `Buffer`. */
        get: function () {
            // TODO: Uint8Array
            return Buffer.from(this.data);
        },
        enumerable: false,
        configurable: true
    });
    PrivateKey.prototype.toHex = function () {
        return (0, utils_1.bytesToHex)(this.data);
    };
    /**
     * Derives a shared secret from ephemeral private key (this) and receiver's public key (pk).
     * @description The shared key is 32 bytes, derived with `HKDF-SHA256(senderPoint || sharedPoint)`. See implementation for details.
     *
     * There are some variations in different ECIES implementations:
     * which key derivation function to use, compressed or uncompressed `senderPoint`/`sharedPoint`, whether to include `senderPoint`, etc.
     *
     * Because the entropy of `senderPoint`, `sharedPoint` is enough high[1], we don't need salt to derive keys.
     *
     * [1]: Two reasons: the public keys are "random" bytes (albeit secp256k1 public keys are **not uniformly** random), and ephemeral keys are generated in every encryption.
     *
     * @param pk - Receiver's public key.
     * @param compressed - (default: `false`) Whether to use compressed or uncompressed public keys in the key derivation (secp256k1 only).
     * @returns Shared secret, derived with HKDF-SHA256.
     */
    PrivateKey.prototype.encapsulate = function (pk, compressed) {
        if (compressed === void 0) { compressed = false; }
        var senderPoint = this.publicKey.toBytes(compressed);
        var sharedPoint = this.multiply(pk, compressed);
        return (0, utils_2.getSharedKey)(senderPoint, sharedPoint);
    };
    PrivateKey.prototype.multiply = function (pk, compressed) {
        if (compressed === void 0) { compressed = false; }
        return (0, utils_2.getSharedPoint)(this.data, pk.toBytes(true), compressed, this.curve);
    };
    PrivateKey.prototype.equals = function (other) {
        return (0, utils_1.equalBytes)(this.data, other.data);
    };
    return PrivateKey;
}());
exports.PrivateKey = PrivateKey;


/***/ }),

/***/ "./node_modules/eciesjs/dist/keys/PublicKey.js":
/*!*****************************************************!*\
  !*** ./node_modules/eciesjs/dist/keys/PublicKey.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublicKey = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var utils_2 = __webpack_require__(/*! ../utils */ "./node_modules/eciesjs/dist/utils/index.js");
var PublicKey = /** @class */ (function () {
    function PublicKey(data, curve) {
        // data can be either compressed or uncompressed if secp256k1
        var compressed = (0, utils_2.convertPublicKeyFormat)(data, true, curve);
        var uncompressed = (0, utils_2.convertPublicKeyFormat)(data, false, curve);
        this.data = compressed;
        this.dataUncompressed =
            compressed.length !== uncompressed.length ? uncompressed : null;
    }
    PublicKey.fromHex = function (hex, curve) {
        return new PublicKey((0, utils_2.hexToPublicKey)(hex, curve), curve);
    };
    Object.defineProperty(PublicKey.prototype, "_uncompressed", {
        get: function () {
            return this.dataUncompressed !== null ? this.dataUncompressed : this.data;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PublicKey.prototype, "uncompressed", {
        /** @deprecated - use `PublicKey.toBytes(false)` instead. You may also need `Buffer.from`. */
        get: function () {
            return Buffer.from(this._uncompressed); // TODO: delete
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PublicKey.prototype, "compressed", {
        /** @deprecated - use `PublicKey.toBytes()` instead. You may also need `Buffer.from`. */
        get: function () {
            return Buffer.from(this.data); // TODO: delete
        },
        enumerable: false,
        configurable: true
    });
    PublicKey.prototype.toBytes = function (compressed) {
        if (compressed === void 0) { compressed = true; }
        return compressed ? this.data : this._uncompressed;
    };
    PublicKey.prototype.toHex = function (compressed) {
        if (compressed === void 0) { compressed = true; }
        return (0, utils_1.bytesToHex)(this.toBytes(compressed));
    };
    /**
     * Derives a shared secret from receiver's private key (sk) and ephemeral public key (this).
     * Opposite of `encapsulate`.
     * @see PrivateKey.encapsulate
     *
     * @param sk - Receiver's private key.
     * @param compressed - (default: `false`) Whether to use compressed or uncompressed public keys in the key derivation (secp256k1 only).
     * @returns Shared secret, derived with HKDF-SHA256.
     */
    PublicKey.prototype.decapsulate = function (sk, compressed) {
        if (compressed === void 0) { compressed = false; }
        var senderPoint = this.toBytes(compressed);
        var sharedPoint = sk.multiply(this, compressed);
        return (0, utils_2.getSharedKey)(senderPoint, sharedPoint);
    };
    PublicKey.prototype.equals = function (other) {
        return (0, utils_1.equalBytes)(this.data, other.data);
    };
    return PublicKey;
}());
exports.PublicKey = PublicKey;


/***/ }),

/***/ "./node_modules/eciesjs/dist/keys/index.js":
/*!*************************************************!*\
  !*** ./node_modules/eciesjs/dist/keys/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublicKey = exports.PrivateKey = void 0;
// treat Buffer as Uint8array, i.e. no call of Buffer specific functions
// finally Uint8Array only
var PrivateKey_1 = __webpack_require__(/*! ./PrivateKey */ "./node_modules/eciesjs/dist/keys/PrivateKey.js");
Object.defineProperty(exports, "PrivateKey", ({ enumerable: true, get: function () { return PrivateKey_1.PrivateKey; } }));
var PublicKey_1 = __webpack_require__(/*! ./PublicKey */ "./node_modules/eciesjs/dist/keys/PublicKey.js");
Object.defineProperty(exports, "PublicKey", ({ enumerable: true, get: function () { return PublicKey_1.PublicKey; } }));


/***/ }),

/***/ "./node_modules/eciesjs/dist/utils/elliptic.js":
/*!*****************************************************!*\
  !*** ./node_modules/eciesjs/dist/utils/elliptic.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexToPublicKey = exports.convertPublicKeyFormat = exports.getSharedPoint = exports.getPublicKey = exports.isValidPrivateKey = exports.getValidSecret = void 0;
var webcrypto_1 = __webpack_require__(/*! @noble/ciphers/webcrypto */ "./node_modules/@noble/ciphers/webcrypto.js");
var ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ "./node_modules/@noble/curves/ed25519.js");
var secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/@noble/curves/secp256k1.js");
var config_1 = __webpack_require__(/*! ../config */ "./node_modules/eciesjs/dist/config.js");
var consts_1 = __webpack_require__(/*! ../consts */ "./node_modules/eciesjs/dist/consts.js");
var hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/eciesjs/dist/utils/hex.js");
// TODO: remove `ellipticCurve` after 0.5.0
var getValidSecret = function (curve) {
    var key;
    do {
        key = (0, webcrypto_1.randomBytes)(consts_1.SECRET_KEY_LENGTH);
    } while (!(0, exports.isValidPrivateKey)(key, curve));
    return key;
};
exports.getValidSecret = getValidSecret;
var isValidPrivateKey = function (secret, curve) {
    // on secp256k1: only key ∈ (0, group order) is valid
    // on curve25519: any 32-byte key is valid
    return _exec(curve || (0, config_1.ellipticCurve)(), function (curve) { return curve.utils.isValidPrivateKey(secret); }, function () { return true; }, function () { return true; });
};
exports.isValidPrivateKey = isValidPrivateKey;
var getPublicKey = function (secret, curve) {
    return _exec(curve || (0, config_1.ellipticCurve)(), function (curve) { return curve.getPublicKey(secret); }, function (curve) { return curve.getPublicKey(secret); }, function (curve) { return curve.getPublicKey(secret); });
};
exports.getPublicKey = getPublicKey;
var getSharedPoint = function (sk, pk, compressed, curve) {
    return _exec(curve || (0, config_1.ellipticCurve)(), function (curve) { return curve.getSharedSecret(sk, pk, compressed); }, function (curve) { return curve.getSharedSecret(sk, pk); }, function (curve) { return getSharedPointOnEd25519(curve, sk, pk); });
};
exports.getSharedPoint = getSharedPoint;
var convertPublicKeyFormat = function (pk, compressed, curve) {
    // only for secp256k1
    return _exec(curve || (0, config_1.ellipticCurve)(), function (curve) { return curve.getSharedSecret(BigInt(1), pk, compressed); }, function () { return pk; }, function () { return pk; });
};
exports.convertPublicKeyFormat = convertPublicKeyFormat;
var hexToPublicKey = function (hex, curve) {
    var decoded = (0, hex_1.decodeHex)(hex);
    return _exec(curve || (0, config_1.ellipticCurve)(), function () { return compatEthPublicKey(decoded); }, function () { return decoded; }, function () { return decoded; });
};
exports.hexToPublicKey = hexToPublicKey;
function _exec(curve, secp256k1Callback, x25519Callback, ed25519Callback) {
    if (curve === "secp256k1") {
        return secp256k1Callback(secp256k1_1.secp256k1);
    }
    else if (curve === "x25519") {
        return x25519Callback(ed25519_1.x25519);
    }
    else if (curve === "ed25519") {
        return ed25519Callback(ed25519_1.ed25519);
    } /* v8 ignore next 2 */
    else {
        throw new Error("Not implemented");
    }
}
var compatEthPublicKey = function (pk) {
    if (pk.length === consts_1.ETH_PUBLIC_KEY_SIZE) {
        var fixed = new Uint8Array(1 + pk.length);
        fixed.set([0x04]);
        fixed.set(pk, 1);
        return fixed;
    }
    return pk;
};
var getSharedPointOnEd25519 = function (curve, sk, pk) {
    // Note: scalar is hashed from sk
    var scalar = curve.utils.getExtendedPublicKey(sk).scalar;
    var point = curve.ExtendedPoint.fromHex(pk).multiply(scalar);
    return point.toRawBytes(); // `compressed` in signature has no effect
};


/***/ }),

/***/ "./node_modules/eciesjs/dist/utils/hash.js":
/*!*************************************************!*\
  !*** ./node_modules/eciesjs/dist/utils/hash.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSharedKey = exports.deriveKey = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var hkdf_1 = __webpack_require__(/*! @noble/hashes/hkdf */ "./node_modules/@noble/hashes/hkdf.js");
var sha2_1 = __webpack_require__(/*! @noble/hashes/sha2 */ "./node_modules/@noble/hashes/sha2.js");
var deriveKey = function (master, salt, info) {
    // 32 bytes shared secret for aes256 and xchacha20 derived from HKDF-SHA256
    return (0, hkdf_1.hkdf)(sha2_1.sha256, master, salt, info, 32);
};
exports.deriveKey = deriveKey;
var getSharedKey = function () {
    var parts = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        parts[_i] = arguments[_i];
    }
    return (0, exports.deriveKey)(utils_1.concatBytes.apply(void 0, parts));
};
exports.getSharedKey = getSharedKey;


/***/ }),

/***/ "./node_modules/eciesjs/dist/utils/hex.js":
/*!************************************************!*\
  !*** ./node_modules/eciesjs/dist/utils/hex.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeHex = exports.remove0x = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var remove0x = function (hex) {
    return hex.startsWith("0x") || hex.startsWith("0X") ? hex.slice(2) : hex;
};
exports.remove0x = remove0x;
var decodeHex = function (hex) { return (0, utils_1.hexToBytes)((0, exports.remove0x)(hex)); };
exports.decodeHex = decodeHex;


/***/ }),

/***/ "./node_modules/eciesjs/dist/utils/index.js":
/*!**************************************************!*\
  !*** ./node_modules/eciesjs/dist/utils/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./elliptic */ "./node_modules/eciesjs/dist/utils/elliptic.js"), exports);
__exportStar(__webpack_require__(/*! ./hash */ "./node_modules/eciesjs/dist/utils/hash.js"), exports);
__exportStar(__webpack_require__(/*! ./hex */ "./node_modules/eciesjs/dist/utils/hex.js"), exports);
__exportStar(__webpack_require__(/*! ./symmetric */ "./node_modules/eciesjs/dist/utils/symmetric.js"), exports);


/***/ }),

/***/ "./node_modules/eciesjs/dist/utils/symmetric.js":
/*!******************************************************!*\
  !*** ./node_modules/eciesjs/dist/utils/symmetric.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aesDecrypt = exports.aesEncrypt = exports.symDecrypt = exports.symEncrypt = void 0;
var utils_1 = __webpack_require__(/*! @noble/ciphers/utils */ "./node_modules/@noble/ciphers/utils.js");
var webcrypto_1 = __webpack_require__(/*! @noble/ciphers/webcrypto */ "./node_modules/@noble/ciphers/webcrypto.js");
var aes_1 = __webpack_require__(/*! @ecies/ciphers/aes */ "./node_modules/@ecies/ciphers/dist/aes/node.js");
var chacha_1 = __webpack_require__(/*! @ecies/ciphers/chacha */ "./node_modules/@ecies/ciphers/dist/chacha/node.js");
var config_1 = __webpack_require__(/*! ../config */ "./node_modules/eciesjs/dist/config.js");
var consts_1 = __webpack_require__(/*! ../consts */ "./node_modules/eciesjs/dist/consts.js");
var symEncrypt = function (key, plainText, AAD) { return _exec(_encrypt, key, plainText, AAD); };
exports.symEncrypt = symEncrypt;
var symDecrypt = function (key, cipherText, AAD) { return _exec(_decrypt, key, cipherText, AAD); };
exports.symDecrypt = symDecrypt;
/** @deprecated - use `symEncrypt` instead. */
exports.aesEncrypt = exports.symEncrypt; // TODO: delete
/** @deprecated - use `symDecrypt` instead. */
exports.aesDecrypt = exports.symDecrypt; // TODO: delete
function _exec(callback, key, data, AAD) {
    var algorithm = (0, config_1.symmetricAlgorithm)();
    if (algorithm === "aes-256-gcm") {
        return callback(aes_1.aes256gcm, key, data, (0, config_1.symmetricNonceLength)(), consts_1.AEAD_TAG_LENGTH, AAD);
    }
    else if (algorithm === "xchacha20") {
        return callback(chacha_1.xchacha20, key, data, consts_1.XCHACHA20_NONCE_LENGTH, consts_1.AEAD_TAG_LENGTH, AAD);
    }
    else if (algorithm === "aes-256-cbc") {
        // NOT RECOMMENDED. There is neither AAD nor AEAD tag in cbc mode
        // aes-256-cbc always uses 16 bytes iv
        return callback(aes_1.aes256cbc, key, data, 16, 0);
    }
    else {
        throw new Error("Not implemented");
    }
}
function _encrypt(func, key, data, nonceLength, tagLength, AAD) {
    var nonce = (0, webcrypto_1.randomBytes)(nonceLength);
    var cipher = func(key, nonce, AAD);
    // @noble/ciphers format: cipherText || tag
    var encrypted = cipher.encrypt(data);
    if (tagLength === 0) {
        return (0, utils_1.concatBytes)(nonce, encrypted);
    }
    var cipherTextLength = encrypted.length - tagLength;
    var cipherText = encrypted.subarray(0, cipherTextLength);
    var tag = encrypted.subarray(cipherTextLength);
    // ecies payload format: pk || nonce || tag || cipherText
    return (0, utils_1.concatBytes)(nonce, tag, cipherText);
}
function _decrypt(func, key, data, nonceLength, tagLength, AAD) {
    var nonce = data.subarray(0, nonceLength);
    var cipher = func(key, Uint8Array.from(nonce), AAD); // to reset byteOffset
    var encrypted = data.subarray(nonceLength);
    if (tagLength === 0) {
        return cipher.decrypt(encrypted);
    }
    var tag = encrypted.subarray(0, tagLength);
    var cipherText = encrypted.subarray(tagLength);
    return cipher.decrypt((0, utils_1.concatBytes)(cipherText, tag));
}


/***/ }),

/***/ "./node_modules/ignore/index.js":
/*!**************************************!*\
  !*** ./node_modules/ignore/index.js ***!
  \**************************************/
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = ''
const SPACE = ' '
const ESCAPE = '\\'
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'

// Do not use ternary expression here, since "istanbul ignore next" is buggy
let TMP_KEY_IGNORE = 'node-ignore'
/* istanbul ignore else */
if (typeof Symbol !== 'undefined') {
  TMP_KEY_IGNORE = Symbol.for('node-ignore')
}
const KEY_IGNORE = TMP_KEY_IGNORE

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const RETURN_FALSE = () => false

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  [
    // remove BOM
    // TODO:
    // Other similar zero-width characters?
    /^\uFEFF/,
    () => EMPTY
  ],

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a ) -> (a)
    // (a \ ) -> (a  )
    /((?:\\\\)*?)(\\?\s+)$/,
    (_, m1, m2) => m1 + (
      m2.indexOf('\\') === 0
        ? SPACE
        : EMPTY
    )
  ],

  // replace (\ ) with ' '
  // (\ ) -> ' '
  // (\\ ) -> '\\ '
  // (\\\ ) -> '\\ '
  [
    /(\\+?)\s/g,
    (_, m1) => {
      const {length} = m1
      return m1.slice(0, length - length % 2) + SPACE
    }
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // normal intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule,
    //    coz trailing single wildcard will be handed by [trailing wildcard]
    /(^|[^\\]+)(\\\*)+(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1, p2) => {
      // 1.
      // > An asterisk "*" matches anything except a slash.
      // 2.
      // > Other consecutive asterisks are considered regular asterisks
      // > and will match according to the previous rules.
      const unescaped = p2.replace(/\\\*/g, '[^\\/]*')
      return p1 + unescaped
    }
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignoreCase) => {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, [matcher, replacer]) =>
        prev.replace(matcher, replacer.bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignoreCase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)
  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignoreCase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, ignoreCase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignoreCase = ignoreCase
    this._allowRelativePaths = allowRelativePaths
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    )

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "node:async_hooks":
/*!***********************************!*\
  !*** external "node:async_hooks" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:async_hooks");

/***/ }),

/***/ "node:child_process":
/*!*************************************!*\
  !*** external "node:child_process" ***!
  \*************************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:child_process");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:events");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:fs/promises":
/*!***********************************!*\
  !*** external "node:fs/promises" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ "node:module":
/*!******************************!*\
  !*** external "node:module" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:module");

/***/ }),

/***/ "node:os":
/*!**************************!*\
  !*** external "node:os" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:util");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "dotenv":
/*!*************************!*\
  !*** external "dotenv" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_dotenv__;

/***/ }),

/***/ "electron-dl":
/*!******************************!*\
  !*** external "electron-dl" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_electron_dl__;

/***/ }),

/***/ "electron-serve":
/*!*********************************!*\
  !*** external "electron-serve" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_electron_serve__;

/***/ }),

/***/ "electron-store":
/*!*********************************!*\
  !*** external "electron-store" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_electron_store__;

/***/ }),

/***/ "electron-updater":
/*!***********************************!*\
  !*** external "electron-updater" ***!
  \***********************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_electron_updater__;

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/filter.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/filter */ "./node_modules/core-js-pure/stable/instance/filter.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/for-each.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/for-each */ "./node_modules/core-js-pure/stable/instance/for-each.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/pad-start.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/pad-start.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/pad-start */ "./node_modules/core-js-pure/stable/instance/pad-start.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/reverse.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/reverse.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/reverse */ "./node_modules/core-js-pure/stable/instance/reverse.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/instance/some.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/some.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/instance/some */ "./node_modules/core-js-pure/stable/instance/some.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/assign.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/assign */ "./node_modules/core-js-pure/stable/object/assign.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-properties.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/define-properties */ "./node_modules/core-js-pure/stable/object/define-properties.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/define-property.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/define-property */ "./node_modules/core-js-pure/stable/object/define-property.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor.js ***!
  \**************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/get-own-property-descriptor */ "./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptors.js ***!
  \***************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/get-own-property-descriptors */ "./node_modules/core-js-pure/stable/object/get-own-property-descriptors.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/get-own-property-symbols.js ***!
  \***********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/get-own-property-symbols */ "./node_modules/core-js-pure/stable/object/get-own-property-symbols.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/object/keys.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/object/keys */ "./node_modules/core-js-pure/stable/object/keys.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/core-js-stable/set-timeout.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! core-js-pure/stable/set-timeout */ "./node_modules/core-js-pure/stable/set-timeout.js");

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Object$defineProperty = __webpack_require__(/*! core-js-pure/features/object/define-property.js */ "./node_modules/core-js-pure/features/object/define-property.js");
var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ "./node_modules/@babel/runtime-corejs3/helpers/toPropertyKey.js");
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? _Object$defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/helpers/toPrimitive.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/helpers/toPrimitive.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol$toPrimitive = __webpack_require__(/*! core-js-pure/features/symbol/to-primitive.js */ "./node_modules/core-js-pure/features/symbol/to-primitive.js");
var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime-corejs3/helpers/typeof.js")["default"]);
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[_Symbol$toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/helpers/toPropertyKey.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/helpers/toPropertyKey.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(/*! ./typeof.js */ "./node_modules/@babel/runtime-corejs3/helpers/typeof.js")["default"]);
var toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ "./node_modules/@babel/runtime-corejs3/helpers/toPrimitive.js");
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/@babel/runtime-corejs3/helpers/typeof.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime-corejs3/helpers/typeof.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(/*! core-js-pure/features/symbol/index.js */ "./node_modules/core-js-pure/features/symbol/index.js");
var _Symbol$iterator = __webpack_require__(/*! core-js-pure/features/symbol/iterator.js */ "./node_modules/core-js-pure/features/symbol/iterator.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof _Symbol && o.constructor === _Symbol && o !== _Symbol.prototype ? "symbol" : typeof o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ "./node_modules/core-js-pure/actual/object/define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/actual/object/define-property.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../stable/object/define-property */ "./node_modules/core-js-pure/stable/object/define-property.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/actual/symbol/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/actual/symbol/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../stable/symbol */ "./node_modules/core-js-pure/stable/symbol/index.js");

__webpack_require__(/*! ../../modules/esnext.function.metadata */ "./node_modules/core-js-pure/modules/esnext.function.metadata.js");
__webpack_require__(/*! ../../modules/esnext.symbol.async-dispose */ "./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js");
__webpack_require__(/*! ../../modules/esnext.symbol.dispose */ "./node_modules/core-js-pure/modules/esnext.symbol.dispose.js");
__webpack_require__(/*! ../../modules/esnext.symbol.metadata */ "./node_modules/core-js-pure/modules/esnext.symbol.metadata.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/actual/symbol/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/actual/symbol/iterator.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../stable/symbol/iterator */ "./node_modules/core-js-pure/stable/symbol/iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/actual/symbol/to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/actual/symbol/to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../stable/symbol/to-primitive */ "./node_modules/core-js-pure/stable/symbol/to-primitive.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/filter.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/filter.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../../modules/es.array.filter */ "./node_modules/core-js-pure/modules/es.array.filter.js");
var getBuiltInPrototypeMethod = __webpack_require__(/*! ../../../internals/get-built-in-prototype-method */ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js");

module.exports = getBuiltInPrototypeMethod('Array', 'filter');


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/for-each.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/for-each.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../../modules/es.array.for-each */ "./node_modules/core-js-pure/modules/es.array.for-each.js");
var getBuiltInPrototypeMethod = __webpack_require__(/*! ../../../internals/get-built-in-prototype-method */ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js");

module.exports = getBuiltInPrototypeMethod('Array', 'forEach');


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/reverse.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/reverse.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../../modules/es.array.reverse */ "./node_modules/core-js-pure/modules/es.array.reverse.js");
var getBuiltInPrototypeMethod = __webpack_require__(/*! ../../../internals/get-built-in-prototype-method */ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js");

module.exports = getBuiltInPrototypeMethod('Array', 'reverse');


/***/ }),

/***/ "./node_modules/core-js-pure/es/array/virtual/some.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/es/array/virtual/some.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../../modules/es.array.some */ "./node_modules/core-js-pure/modules/es.array.some.js");
var getBuiltInPrototypeMethod = __webpack_require__(/*! ../../../internals/get-built-in-prototype-method */ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js");

module.exports = getBuiltInPrototypeMethod('Array', 'some');


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/filter.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/filter */ "./node_modules/core-js-pure/es/array/virtual/filter.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.filter;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.filter) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/pad-start.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/pad-start.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../string/virtual/pad-start */ "./node_modules/core-js-pure/es/string/virtual/pad-start.js");

var StringPrototype = String.prototype;

module.exports = function (it) {
  var own = it.padStart;
  return typeof it == 'string' || it === StringPrototype
    || (isPrototypeOf(StringPrototype, it) && own === StringPrototype.padStart) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/reverse.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/reverse.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/reverse */ "./node_modules/core-js-pure/es/array/virtual/reverse.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.reverse;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.reverse) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/instance/some.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/es/instance/some.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/some */ "./node_modules/core-js-pure/es/array/virtual/some.js");

var ArrayPrototype = Array.prototype;

module.exports = function (it) {
  var own = it.some;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.some) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/assign.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/assign.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.assign */ "./node_modules/core-js-pure/modules/es.object.assign.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.assign;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/define-properties.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/define-properties.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.define-properties */ "./node_modules/core-js-pure/modules/es.object.define-properties.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

var Object = path.Object;

var defineProperties = module.exports = function defineProperties(T, D) {
  return Object.defineProperties(T, D);
};

if (Object.defineProperties.sham) defineProperties.sham = true;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/define-property.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/define-property.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.define-property */ "./node_modules/core-js-pure/modules/es.object.define-property.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/get-own-property-descriptor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/get-own-property-descriptor.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.get-own-property-descriptor */ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

var Object = path.Object;

var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {
  return Object.getOwnPropertyDescriptor(it, key);
};

if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/get-own-property-descriptors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/get-own-property-descriptors.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.get-own-property-descriptors */ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.getOwnPropertyDescriptors;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/get-own-property-symbols.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/get-own-property-symbols.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.symbol */ "./node_modules/core-js-pure/modules/es.symbol.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js-pure/es/object/keys.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/es/object/keys.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.object.keys */ "./node_modules/core-js-pure/modules/es.object.keys.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Object.keys;


/***/ }),

/***/ "./node_modules/core-js-pure/es/string/virtual/pad-start.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/es/string/virtual/pad-start.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../../modules/es.string.pad-start */ "./node_modules/core-js-pure/modules/es.string.pad-start.js");
var getBuiltInPrototypeMethod = __webpack_require__(/*! ../../../internals/get-built-in-prototype-method */ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js");

module.exports = getBuiltInPrototypeMethod('String', 'padStart');


/***/ }),

/***/ "./node_modules/core-js-pure/es/symbol/index.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/es/symbol/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.array.concat */ "./node_modules/core-js-pure/modules/es.array.concat.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.symbol */ "./node_modules/core-js-pure/modules/es.symbol.js");
__webpack_require__(/*! ../../modules/es.symbol.async-dispose */ "./node_modules/core-js-pure/modules/es.symbol.async-dispose.js");
__webpack_require__(/*! ../../modules/es.symbol.async-iterator */ "./node_modules/core-js-pure/modules/es.symbol.async-iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.description */ "./node_modules/core-js-pure/modules/es.symbol.description.js");
__webpack_require__(/*! ../../modules/es.symbol.dispose */ "./node_modules/core-js-pure/modules/es.symbol.dispose.js");
__webpack_require__(/*! ../../modules/es.symbol.has-instance */ "./node_modules/core-js-pure/modules/es.symbol.has-instance.js");
__webpack_require__(/*! ../../modules/es.symbol.is-concat-spreadable */ "./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js");
__webpack_require__(/*! ../../modules/es.symbol.iterator */ "./node_modules/core-js-pure/modules/es.symbol.iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.match */ "./node_modules/core-js-pure/modules/es.symbol.match.js");
__webpack_require__(/*! ../../modules/es.symbol.match-all */ "./node_modules/core-js-pure/modules/es.symbol.match-all.js");
__webpack_require__(/*! ../../modules/es.symbol.replace */ "./node_modules/core-js-pure/modules/es.symbol.replace.js");
__webpack_require__(/*! ../../modules/es.symbol.search */ "./node_modules/core-js-pure/modules/es.symbol.search.js");
__webpack_require__(/*! ../../modules/es.symbol.species */ "./node_modules/core-js-pure/modules/es.symbol.species.js");
__webpack_require__(/*! ../../modules/es.symbol.split */ "./node_modules/core-js-pure/modules/es.symbol.split.js");
__webpack_require__(/*! ../../modules/es.symbol.to-primitive */ "./node_modules/core-js-pure/modules/es.symbol.to-primitive.js");
__webpack_require__(/*! ../../modules/es.symbol.to-string-tag */ "./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.symbol.unscopables */ "./node_modules/core-js-pure/modules/es.symbol.unscopables.js");
__webpack_require__(/*! ../../modules/es.json.to-string-tag */ "./node_modules/core-js-pure/modules/es.json.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.math.to-string-tag */ "./node_modules/core-js-pure/modules/es.math.to-string-tag.js");
__webpack_require__(/*! ../../modules/es.reflect.to-string-tag */ "./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js");
var path = __webpack_require__(/*! ../../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.Symbol;


/***/ }),

/***/ "./node_modules/core-js-pure/es/symbol/iterator.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/es/symbol/iterator.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
__webpack_require__(/*! ../../modules/es.object.to-string */ "./node_modules/core-js-pure/modules/es.object.to-string.js");
__webpack_require__(/*! ../../modules/es.string.iterator */ "./node_modules/core-js-pure/modules/es.string.iterator.js");
__webpack_require__(/*! ../../modules/es.symbol.iterator */ "./node_modules/core-js-pure/modules/es.symbol.iterator.js");
var WrappedWellKnownSymbolModule = __webpack_require__(/*! ../../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");

module.exports = WrappedWellKnownSymbolModule.f('iterator');


/***/ }),

/***/ "./node_modules/core-js-pure/es/symbol/to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/es/symbol/to-primitive.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../../modules/es.date.to-primitive */ "./node_modules/core-js-pure/modules/es.date.to-primitive.js");
__webpack_require__(/*! ../../modules/es.symbol.to-primitive */ "./node_modules/core-js-pure/modules/es.symbol.to-primitive.js");
var WrappedWellKnownSymbolModule = __webpack_require__(/*! ../../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");

module.exports = WrappedWellKnownSymbolModule.f('toPrimitive');


/***/ }),

/***/ "./node_modules/core-js-pure/features/object/define-property.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/features/object/define-property.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ../../full/object/define-property */ "./node_modules/core-js-pure/full/object/define-property.js");


/***/ }),

/***/ "./node_modules/core-js-pure/features/symbol/index.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/features/symbol/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ../../full/symbol */ "./node_modules/core-js-pure/full/symbol/index.js");


/***/ }),

/***/ "./node_modules/core-js-pure/features/symbol/iterator.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/features/symbol/iterator.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ../../full/symbol/iterator */ "./node_modules/core-js-pure/full/symbol/iterator.js");


/***/ }),

/***/ "./node_modules/core-js-pure/features/symbol/to-primitive.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js-pure/features/symbol/to-primitive.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ../../full/symbol/to-primitive */ "./node_modules/core-js-pure/full/symbol/to-primitive.js");


/***/ }),

/***/ "./node_modules/core-js-pure/full/object/define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/full/object/define-property.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../actual/object/define-property */ "./node_modules/core-js-pure/actual/object/define-property.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/full/symbol/index.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/full/symbol/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../actual/symbol */ "./node_modules/core-js-pure/actual/symbol/index.js");
__webpack_require__(/*! ../../modules/esnext.symbol.is-registered-symbol */ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered-symbol.js");
__webpack_require__(/*! ../../modules/esnext.symbol.is-well-known-symbol */ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known-symbol.js");
__webpack_require__(/*! ../../modules/esnext.symbol.custom-matcher */ "./node_modules/core-js-pure/modules/esnext.symbol.custom-matcher.js");
__webpack_require__(/*! ../../modules/esnext.symbol.observable */ "./node_modules/core-js-pure/modules/esnext.symbol.observable.js");
// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../../modules/esnext.symbol.is-registered */ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js");
__webpack_require__(/*! ../../modules/esnext.symbol.is-well-known */ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js");
__webpack_require__(/*! ../../modules/esnext.symbol.matcher */ "./node_modules/core-js-pure/modules/esnext.symbol.matcher.js");
__webpack_require__(/*! ../../modules/esnext.symbol.metadata-key */ "./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js");
__webpack_require__(/*! ../../modules/esnext.symbol.pattern-match */ "./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js");
__webpack_require__(/*! ../../modules/esnext.symbol.replace-all */ "./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/full/symbol/iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/full/symbol/iterator.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../actual/symbol/iterator */ "./node_modules/core-js-pure/actual/symbol/iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/full/symbol/to-primitive.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/full/symbol/to-primitive.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../actual/symbol/to-primitive */ "./node_modules/core-js-pure/actual/symbol/to-primitive.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/a-callable.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/a-callable.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/a-possible-prototype.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/a-possible-prototype.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPossiblePrototype = __webpack_require__(/*! ../internals/is-possible-prototype */ "./node_modules/core-js-pure/internals/is-possible-prototype.js");

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (isPossiblePrototype(argument)) return argument;
  throw new $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/add-to-unscopables.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/add-to-unscopables.js ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js-pure/internals/an-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/an-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-for-each.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-for-each.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").forEach);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js-pure/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-includes.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-includes.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js-pure/internals/to-absolute-index.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    if (length === 0) return !IS_INCLUDES && -1;
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el !== el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value !== value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-iteration.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-iteration.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js-pure/internals/array-species-create.js");

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE === 1;
  var IS_FILTER = TYPE === 2;
  var IS_SOME = TYPE === 3;
  var IS_EVERY = TYPE === 4;
  var IS_FIND_INDEX = TYPE === 6;
  var IS_FILTER_REJECT = TYPE === 7;
  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var length = lengthOfArrayLike(self);
    var boundFunction = bind(callbackfn, that);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-method-has-species-support.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-method-has-species-support.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js-pure/internals/environment-v8-version.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-method-is-strict.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-method-is-strict.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call -- required for testing
    method.call(null, argument || function () { return 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-slice.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-slice.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = uncurryThis([].slice);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-species-constructor.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-species-constructor.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isConstructor = __webpack_require__(/*! ../internals/is-constructor */ "./node_modules/core-js-pure/internals/is-constructor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/array-species-create.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/array-species-create.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(/*! ../internals/array-species-constructor */ "./node_modules/core-js-pure/internals/array-species-constructor.js");

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/classof-raw.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/classof-raw.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/classof.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/classof.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/correct-prototype-getter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/correct-prototype-getter.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-iter-result-object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-iter-result-object.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-non-enumerable-property.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-property-descriptor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-property-descriptor.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-property.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-property.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  if (DESCRIPTORS) definePropertyModule.f(object, key, createPropertyDescriptor(0, value));
  else object[key] = value;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-built-in-accessor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-built-in-accessor.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");

module.exports = function (target, name, descriptor) {
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-built-in.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-built-in.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-global-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-global-property.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    globalThis[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/descriptors.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/descriptors.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/document-create-element.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/document-create-element.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js ***!
  \*****************************************************************************/
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/dom-iterables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/dom-iterables.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/enum-bug-keys.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/enum-bug-keys.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js-pure/internals/environment-user-agent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/environment-user-agent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;

module.exports = userAgent ? String(userAgent) : '';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/environment-v8-version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/environment-v8-version.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js-pure/internals/environment-user-agent.js");

var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/environment.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/environment.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global Bun, Deno -- detection */
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js-pure/internals/environment-user-agent.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");

var userAgentStartsWith = function (string) {
  return userAgent.slice(0, string.length) === string;
};

module.exports = (function () {
  if (userAgentStartsWith('Bun/')) return 'BUN';
  if (userAgentStartsWith('Cloudflare-Workers')) return 'CLOUDFLARE';
  if (userAgentStartsWith('Deno/')) return 'DENO';
  if (userAgentStartsWith('Node.js/')) return 'NODE';
  if (globalThis.Bun && typeof Bun.version == 'string') return 'BUN';
  if (globalThis.Deno && typeof Deno.version == 'object') return 'DENO';
  if (classof(globalThis.process) === 'process') return 'NODE';
  if (globalThis.window && globalThis.document) return 'BROWSER';
  return 'REST';
})();


/***/ }),

/***/ "./node_modules/core-js-pure/internals/export.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/export.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js").f);
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js-pure/internals/is-forced.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
// add debugging info
__webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/fails.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/fails.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-apply.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-apply.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-context.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-context.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-native.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-native.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-call.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-call.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-name.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-name.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this-clause.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-built-in-prototype-method.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-built-in-prototype-method.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = function (CONSTRUCTOR, METHOD) {
  var Namespace = path[CONSTRUCTOR + 'Prototype'];
  var pureMethod = Namespace && Namespace[METHOD];
  if (pureMethod) return pureMethod;
  var NativeConstructor = globalThis[CONSTRUCTOR];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  return NativePrototype && NativePrototype[METHOD];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-built-in.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-built-in.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(globalThis[namespace])
    : path[namespace] && path[namespace][method] || globalThis[namespace] && globalThis[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-json-replacer-function.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-json-replacer-function.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) === 'Number' || classof(element) === 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-method.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-method.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/global-this.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/global-this.js ***!
  \************************************************************/
/***/ (function(module) {

"use strict";

var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  check(typeof this == 'object' && this) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ "./node_modules/core-js-pure/internals/has-own-property.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/has-own-property.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/hidden-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/hidden-keys.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/html.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/html.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js-pure/internals/ie8-dom-define.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ie8-dom-define.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js-pure/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a !== 7;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/indexed-object.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/indexed-object.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/inspect-source.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/inspect-source.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/internal-state.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/internal-state.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/weak-map-basic-detection */ "./node_modules/core-js-pure/internals/weak-map-basic-detection.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var shared = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = globalThis.TypeError;
var WeakMap = globalThis.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-array.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-array.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) === 'Array';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-callable.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-callable.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-constructor.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var inspectSource = __webpack_require__(/*! ../internals/inspect-source */ "./node_modules/core-js-pure/internals/inspect-source.js");

var noop = function () { /* empty */ };
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.test(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, [], argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-forced.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-forced.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true
    : value === NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-null-or-undefined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-null-or-undefined.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-possible-prototype.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-possible-prototype.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

module.exports = function (argument) {
  return isObject(argument) || argument === null;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-pure.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-pure.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";

module.exports = true;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-symbol.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-symbol.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterator-create-constructor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterator-create-constructor.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js-pure/internals/iterators-core.js").IteratorPrototype);
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterator-define.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterator-define.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var FunctionName = __webpack_require__(/*! ../internals/function-name */ "./node_modules/core-js-pure/internals/function-name.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/iterator-create-constructor */ "./node_modules/core-js-pure/internals/iterator-create-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js-pure/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js-pure/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js-pure/internals/iterators-core.js");

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    }

    return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterators-core.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterators-core.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js-pure/internals/object-get-prototype-of.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/iterators.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/iterators.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/length-of-array-like.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/length-of-array-like.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js-pure/internals/to-length.js");

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/math-trunc.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/math-trunc.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-assign.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-assign.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");

// eslint-disable-next-line es/no-object-assign -- safe
var $assign = Object.assign;
// eslint-disable-next-line es/no-object-defineproperty -- required for testing
var defineProperty = Object.defineProperty;
var concat = uncurryThis([].concat);

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !$assign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line es/no-symbol -- safe
  var symbol = Symbol('assign detection');
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  // eslint-disable-next-line es/no-array-prototype-foreach -- safe
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return $assign({}, A)[symbol] !== 7 || objectKeys($assign({}, B)).join('') !== alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || call(propertyIsEnumerable, S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-create.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-create.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js-pure/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js-pure/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js-pure/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  // eslint-disable-next-line no-useless-assignment -- avoid memory leak
  activeXDocument = null;
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-define-properties.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-define-properties.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-define-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-define-property.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-names-external.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-names-external.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var $getOwnPropertyNames = (__webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js").f);
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js-pure/internals/array-slice.js");

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) === 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-names.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-names.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js-pure/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-symbols.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-prototype-of.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-prototype-of.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js-pure/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-is-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-is-prototype-of.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-keys-internal.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-keys-internal.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var indexOf = (__webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js-pure/internals/array-includes.js").indexOf);
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-keys.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-keys.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js-pure/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js-pure/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-property-is-enumerable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-set-prototype-of.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-set-prototype-of.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(/*! ../internals/function-uncurry-this-accessor */ "./node_modules/core-js-pure/internals/function-uncurry-this-accessor.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js-pure/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    requireObjectCoercible(O);
    aPossiblePrototype(proto);
    if (!isObject(O)) return O;
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-to-string.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-to-string.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ordinary-to-primitive.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/own-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/own-keys.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");

var concat = uncurryThis([].concat);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/path.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/path.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/require-object-coercible.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/require-object-coercible.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/schedulers-fix.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/schedulers-fix.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var ENVIRONMENT = __webpack_require__(/*! ../internals/environment */ "./node_modules/core-js-pure/internals/environment.js");
var USER_AGENT = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js-pure/internals/environment-user-agent.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js-pure/internals/array-slice.js");
var validateArgumentsLength = __webpack_require__(/*! ../internals/validate-arguments-length */ "./node_modules/core-js-pure/internals/validate-arguments-length.js");

var Function = globalThis.Function;
// dirty IE9- and Bun 0.3.0- checks
var WRAP = /MSIE .\./.test(USER_AGENT) || ENVIRONMENT === 'BUN' && (function () {
  var version = globalThis.Bun.version.split('.');
  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');
})();

// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
// https://github.com/oven-sh/bun/issues/1633
module.exports = function (scheduler, hasTimeArg) {
  var firstParamIndex = hasTimeArg ? 2 : 1;
  return WRAP ? function (handler, timeout /* , ...arguments */) {
    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;
    var fn = isCallable(handler) ? handler : Function(handler);
    var params = boundArgs ? arraySlice(arguments, firstParamIndex) : [];
    var callback = boundArgs ? function () {
      apply(fn, this, params);
    } : fn;
    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);
  } : scheduler;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/set-to-string-tag.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/set-to-string-tag.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(/*! ../internals/to-string-tag-support */ "./node_modules/core-js-pure/internals/to-string-tag-support.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js-pure/internals/object-to-string.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  var target = STATIC ? it : it && it.prototype;
  if (target) {
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared-key.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared-key.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js-pure/internals/define-global-property.js");

var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});

(store.versions || (store.versions = [])).push({
  version: '3.44.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.44.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");

module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-multibyte.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-multibyte.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-pad-webkit-bug.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-pad-webkit-bug.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// https://github.com/zloirock/core-js/issues/280
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js-pure/internals/environment-user-agent.js");

module.exports = /Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(userAgent);


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-pad.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-pad.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js-pure/internals/to-length.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var $repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js-pure/internals/string-repeat.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var repeat = uncurryThis($repeat);
var stringSlice = uncurryThis(''.slice);
var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = toString(requireObjectCoercible($this));
    var intMaxLength = toLength(maxLength);
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : toString(fillString);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr === '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringSlice(stringFiller, 0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/string-repeat.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/string-repeat.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var $RangeError = RangeError;

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = toString(requireObjectCoercible(this));
  var result = '';
  var n = toIntegerOrInfinity(count);
  if (n < 0 || n === Infinity) throw new $RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-constructor-detection.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js-pure/internals/environment-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-define-to-primitive.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-is-registered.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-is-registered.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var Symbol = getBuiltIn('Symbol');
var keyFor = Symbol.keyFor;
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
module.exports = Symbol.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor(thisSymbolValue(value)) !== undefined;
  } catch (error) {
    return false;
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-is-well-known.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-is-well-known.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var Symbol = getBuiltIn('Symbol');
var $isWellKnownSymbol = Symbol.isWellKnownSymbol;
var getOwnPropertyNames = getBuiltIn('Object', 'getOwnPropertyNames');
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);
var WellKnownSymbolsStore = shared('wks');

for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  // some old engines throws on access to some keys like `arguments` or `caller`
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol[symbolKey])) wellKnownSymbol(symbolKey);
  } catch (error) { /* empty */ }
}

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
module.exports = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
  try {
    var symbol = thisSymbolValue(value);
    for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
      // eslint-disable-next-line eqeqeq -- polyfilled symbols case
      if (WellKnownSymbolsStore[keys[j]] == symbol) return true;
    }
  } catch (error) { /* empty */ }
  return false;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-registry-detection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-registry-detection.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-absolute-index.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-absolute-index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-indexed-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-indexed-object.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-integer-or-infinity.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(/*! ../internals/math-trunc */ "./node_modules/core-js-pure/internals/math-trunc.js");

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-length.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-length.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(/*! ../internals/to-integer-or-infinity */ "./node_modules/core-js-pure/internals/to-integer-or-infinity.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  var len = toIntegerOrInfinity(argument);
  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-primitive.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js-pure/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-property-key.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-property-key.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js-pure/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-string-tag-support.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-string-tag-support.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-string.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-string.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/try-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/try-to-string.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/uid.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/uid.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.1.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/use-symbol-as-uid.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

module.exports = NATIVE_SYMBOL &&
  !Symbol.sham &&
  typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/v8-prototype-define-bug.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});


/***/ }),

/***/ "./node_modules/core-js-pure/internals/validate-arguments-length.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/validate-arguments-length.js ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;

module.exports = function (passed, required) {
  if (passed < required) throw new $TypeError('Not enough arguments');
  return passed;
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/weak-map-basic-detection.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/weak-map-basic-detection.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");

var WeakMap = globalThis.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol-define.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol-define.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");

var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.concat.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.concat.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var lengthOfArrayLike = __webpack_require__(/*! ../internals/length-of-array-like */ "./node_modules/core-js-pure/internals/length-of-array-like.js");
var doesNotExceedSafeInteger = __webpack_require__(/*! ../internals/does-not-exceed-safe-integer */ "./node_modules/core-js-pure/internals/does-not-exceed-safe-integer.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js-pure/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js-pure/internals/environment-v8-version.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.filter.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.filter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $filter = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").filter);
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js-pure/internals/array-method-has-species-support.js");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.for-each.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.for-each.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js-pure/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
$({ target: 'Array', proto: true, forced: [].forEach !== forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.iterator.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.iterator.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js-pure/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js-pure/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js-pure/internals/create-iter-result-object.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = null;
    return createIterResultObject(undefined, true);
  }
  switch (state.kind) {
    case 'keys': return createIterResultObject(index, false);
    case 'values': return createIterResultObject(target[index], false);
  } return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.reverse.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.reverse.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js-pure/internals/is-array.js");

var nativeReverse = uncurryThis([].reverse);
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray(this)) this.length = this.length;
    return nativeReverse(this);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.array.some.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.array.some.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $some = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").some);
var arrayMethodIsStrict = __webpack_require__(/*! ../internals/array-method-is-strict */ "./node_modules/core-js-pure/internals/array-method-is-strict.js");

var STRICT_METHOD = arrayMethodIsStrict('some');

// `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.date.to-primitive.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.date.to-primitive.js ***!
  \*******************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.json.stringify.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.json.stringify.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var arraySlice = __webpack_require__(/*! ../internals/array-slice */ "./node_modules/core-js-pure/internals/array-slice.js");
var getReplacerFunction = __webpack_require__(/*! ../internals/get-json-replacer-function */ "./node_modules/core-js-pure/internals/get-json-replacer-function.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.1.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')('stringify detection');
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) !== '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) !== '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) !== '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.json.to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.json.to-string-tag.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(globalThis.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.math.to-string-tag.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.math.to-string-tag.js ***!
  \********************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.assign.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.assign.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js-pure/internals/object-assign.js");

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
// eslint-disable-next-line es/no-object-assign -- required for testing
$({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.define-properties.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.define-properties.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var defineProperties = (__webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js-pure/internals/object-define-properties.js").f);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperties !== defineProperties, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.define-property.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.define-property.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js":
/*!************************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-own-property-descriptor.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js").f);
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");

var FORCED = !DESCRIPTORS || fails(function () { nativeGetOwnPropertyDescriptor(1); });

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-own-property-descriptors.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js-pure/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js-pure/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.keys.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.keys.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.object.to-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.object.to-string.js ***!
  \******************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.reflect.to-string-tag.js ***!
  \***********************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.string.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.string.iterator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js-pure/internals/string-multibyte.js").charAt);
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/iterator-define */ "./node_modules/core-js-pure/internals/iterator-define.js");
var createIterResultObject = __webpack_require__(/*! ../internals/create-iter-result-object */ "./node_modules/core-js-pure/internals/create-iter-result-object.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.string.pad-start.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.string.pad-start.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var $padStart = (__webpack_require__(/*! ../internals/string-pad */ "./node_modules/core-js-pure/internals/string-pad.js").start);
var WEBKIT_BUG = __webpack_require__(/*! ../internals/string-pad-webkit-bug */ "./node_modules/core-js-pure/internals/string-pad-webkit-bug.js");

// `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.async-dispose.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.async-dispose.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-async-explicit-resource-management
defineWellKnownSymbol('asyncDispose');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.async-iterator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.async-iterator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.constructor.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.constructor.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var $toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js-pure/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js-pure/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js-pure/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js-pure/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js-pure/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var definePropertiesModule = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js-pure/internals/object-define-properties.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var defineBuiltIn = __webpack_require__(/*! ../internals/define-built-in */ "./node_modules/core-js-pure/internals/define-built-in.js");
var defineBuiltInAccessor = __webpack_require__(/*! ../internals/define-built-in-accessor */ "./node_modules/core-js-pure/internals/define-built-in-accessor.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js-pure/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js-pure/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js-pure/internals/well-known-symbol-wrapped.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js-pure/internals/internal-state.js");
var $forEach = (__webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js-pure/internals/array-iteration.js").forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = globalThis.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var RangeError = globalThis.RangeError;
var TypeError = globalThis.TypeError;
var QObject = globalThis.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var fallbackDefineProperty = function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
};

var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a !== 7;
}) ? fallbackDefineProperty : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, nativeObjectCreate(null)));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw new TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      var $this = this === undefined ? globalThis : this;
      if ($this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn($this, HIDDEN) && hasOwn($this[HIDDEN], tag)) $this[HIDDEN][tag] = false;
      var descriptor = createPropertyDescriptor(1, value);
      try {
        setSymbolDescriptor($this, tag, descriptor);
      } catch (error) {
        if (!(error instanceof RangeError)) throw error;
        fallbackDefineProperty($this, tag, descriptor);
      }
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://tc39.es/ecma262/#sec-symbol.prototype.description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.description.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.description.js ***!
  \********************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.dispose.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.dispose.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.for.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.for.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var toString = __webpack_require__(/*! ../internals/to-string */ "./node_modules/core-js-pure/internals/to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js-pure/internals/symbol-registry-detection.js");

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.has-instance.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.has-instance.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.is-concat-spreadable.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.iterator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/es.symbol.constructor */ "./node_modules/core-js-pure/modules/es.symbol.constructor.js");
__webpack_require__(/*! ../modules/es.symbol.for */ "./node_modules/core-js-pure/modules/es.symbol.for.js");
__webpack_require__(/*! ../modules/es.symbol.key-for */ "./node_modules/core-js-pure/modules/es.symbol.key-for.js");
__webpack_require__(/*! ../modules/es.json.stringify */ "./node_modules/core-js-pure/modules/es.json.stringify.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js-pure/modules/es.object.get-own-property-symbols.js");


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.key-for.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.key-for.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(/*! ../internals/symbol-registry-detection */ "./node_modules/core-js-pure/internals/symbol-registry-detection.js");

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw new TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.match-all.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.match-all.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.match.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.match.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.replace.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.replace.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.search.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.search.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.species.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.species.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.split.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.split.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.to-primitive.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.to-primitive.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var defineSymbolToPrimitive = __webpack_require__(/*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js-pure/internals/symbol-define-to-primitive.js");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.to-string-tag.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.symbol.unscopables.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.symbol.unscopables.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.function.metadata.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.function.metadata.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var defineProperty = (__webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js").f);

var METADATA = wellKnownSymbol('metadata');
var FunctionPrototype = Function.prototype;

// Function.prototype[@@metadata]
// https://github.com/tc39/proposal-decorator-metadata
if (FunctionPrototype[METADATA] === undefined) {
  defineProperty(FunctionPrototype, METADATA, {
    value: null
  });
}


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.async-dispose.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.symbol.async-dispose */ "./node_modules/core-js-pure/modules/es.symbol.async-dispose.js");


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.custom-matcher.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.custom-matcher.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.customMatcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('customMatcher');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.dispose.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.dispose.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.symbol.dispose */ "./node_modules/core-js-pure/modules/es.symbol.dispose.js");


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered-symbol.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-registered-symbol.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var isRegisteredSymbol = __webpack_require__(/*! ../internals/symbol-is-registered */ "./node_modules/core-js-pure/internals/symbol-is-registered.js");

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true }, {
  isRegisteredSymbol: isRegisteredSymbol
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-registered.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var isRegisteredSymbol = __webpack_require__(/*! ../internals/symbol-is-registered */ "./node_modules/core-js-pure/internals/symbol-is-registered.js");

// `Symbol.isRegistered` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true, name: 'isRegisteredSymbol' }, {
  isRegistered: isRegisteredSymbol
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known-symbol.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-well-known-symbol.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var isWellKnownSymbol = __webpack_require__(/*! ../internals/symbol-is-well-known */ "./node_modules/core-js-pure/internals/symbol-is-well-known.js");

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, forced: true }, {
  isWellKnownSymbol: isWellKnownSymbol
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.is-well-known.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var isWellKnownSymbol = __webpack_require__(/*! ../internals/symbol-is-well-known */ "./node_modules/core-js-pure/internals/symbol-is-well-known.js");

// `Symbol.isWellKnown` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, name: 'isWellKnownSymbol', forced: true }, {
  isWellKnown: isWellKnownSymbol
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.matcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.matcher.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.metadata-key.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.metadataKey` well-known symbol
// https://github.com/tc39/proposal-decorator-metadata
defineWellKnownSymbol('metadataKey');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.metadata.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.metadata.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.observable.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.observable.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.pattern-match.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.symbol.replace-all.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol-define */ "./node_modules/core-js-pure/internals/well-known-symbol-define.js");

defineWellKnownSymbol('replaceAll');


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.dom-collections.for-each.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.dom-collections.for-each.js ***!
  \***************************************************************************/
/***/ (() => {

// empty


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.dom-collections.iterator.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js-pure/modules/es.array.iterator.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js-pure/internals/dom-iterables.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js-pure/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js-pure/internals/iterators.js");

for (var COLLECTION_NAME in DOMIterables) {
  setToStringTag(globalThis[COLLECTION_NAME], COLLECTION_NAME);
  Iterators[COLLECTION_NAME] = Iterators.Array;
}


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.set-interval.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.set-interval.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var schedulersFix = __webpack_require__(/*! ../internals/schedulers-fix */ "./node_modules/core-js-pure/internals/schedulers-fix.js");

var setInterval = schedulersFix(globalThis.setInterval, true);

// Bun / IE9- setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
$({ global: true, bind: true, forced: globalThis.setInterval !== setInterval }, {
  setInterval: setInterval
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.set-timeout.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.set-timeout.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var schedulersFix = __webpack_require__(/*! ../internals/schedulers-fix */ "./node_modules/core-js-pure/internals/schedulers-fix.js");

var setTimeout = schedulersFix(globalThis.setTimeout, true);

// Bun / IE9- setTimeout additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
$({ global: true, bind: true, forced: globalThis.setTimeout !== setTimeout }, {
  setTimeout: setTimeout
});


/***/ }),

/***/ "./node_modules/core-js-pure/modules/web.timers.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/modules/web.timers.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(/*! ../modules/web.set-interval */ "./node_modules/core-js-pure/modules/web.set-interval.js");
__webpack_require__(/*! ../modules/web.set-timeout */ "./node_modules/core-js-pure/modules/web.set-timeout.js");


/***/ }),

/***/ "./node_modules/core-js-pure/stable/array/virtual/for-each.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/array/virtual/for-each.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../../es/array/virtual/for-each */ "./node_modules/core-js-pure/es/array/virtual/for-each.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/filter.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/filter.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/instance/filter */ "./node_modules/core-js-pure/es/instance/filter.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/for-each.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/for-each.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(/*! ../../internals/classof */ "./node_modules/core-js-pure/internals/classof.js");
var hasOwn = __webpack_require__(/*! ../../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var isPrototypeOf = __webpack_require__(/*! ../../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var method = __webpack_require__(/*! ../array/virtual/for-each */ "./node_modules/core-js-pure/stable/array/virtual/for-each.js");
__webpack_require__(/*! ../../modules/web.dom-collections.for-each */ "./node_modules/core-js-pure/modules/web.dom-collections.for-each.js");

var ArrayPrototype = Array.prototype;

var DOMIterables = {
  DOMTokenList: true,
  NodeList: true
};

module.exports = function (it) {
  var own = it.forEach;
  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.forEach)
    || hasOwn(DOMIterables, classof(it)) ? method : own;
};


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/pad-start.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/pad-start.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/instance/pad-start */ "./node_modules/core-js-pure/es/instance/pad-start.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/reverse.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/reverse.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/instance/reverse */ "./node_modules/core-js-pure/es/instance/reverse.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/instance/some.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/instance/some.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/instance/some */ "./node_modules/core-js-pure/es/instance/some.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/assign.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/assign.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/assign */ "./node_modules/core-js-pure/es/object/assign.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/define-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/define-properties.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/define-properties */ "./node_modules/core-js-pure/es/object/define-properties.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/define-property.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/define-property */ "./node_modules/core-js-pure/es/object/define-property.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/get-own-property-descriptor.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/get-own-property-descriptor */ "./node_modules/core-js-pure/es/object/get-own-property-descriptor.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/get-own-property-descriptors.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/get-own-property-descriptors.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/get-own-property-descriptors */ "./node_modules/core-js-pure/es/object/get-own-property-descriptors.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/get-own-property-symbols.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/get-own-property-symbols.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/get-own-property-symbols */ "./node_modules/core-js-pure/es/object/get-own-property-symbols.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/object/keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/object/keys.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/object/keys */ "./node_modules/core-js-pure/es/object/keys.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/set-timeout.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/set-timeout.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(/*! ../modules/web.timers */ "./node_modules/core-js-pure/modules/web.timers.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");

module.exports = path.setTimeout;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/symbol/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/symbol/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/symbol */ "./node_modules/core-js-pure/es/symbol/index.js");
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/symbol/iterator.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/symbol/iterator.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/symbol/iterator */ "./node_modules/core-js-pure/es/symbol/iterator.js");
__webpack_require__(/*! ../../modules/web.dom-collections.iterator */ "./node_modules/core-js-pure/modules/web.dom-collections.iterator.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/core-js-pure/stable/symbol/to-primitive.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/stable/symbol/to-primitive.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(/*! ../../es/symbol/to-primitive */ "./node_modules/core-js-pure/es/symbol/to-primitive.js");

module.exports = parent;


/***/ }),

/***/ "./node_modules/@prisma/client/runtime/library.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/@prisma/client/runtime/library.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
var node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DMMF: () => (/* binding */ hn),
/* harmony export */   Debug: () => (/* binding */ L),
/* harmony export */   Decimal: () => (/* binding */ Fe),
/* harmony export */   Extensions: () => (/* binding */ Io),
/* harmony export */   MetricsClient: () => (/* binding */ yt),
/* harmony export */   PrismaClientInitializationError: () => (/* binding */ T),
/* harmony export */   PrismaClientKnownRequestError: () => (/* binding */ Z),
/* harmony export */   PrismaClientRustPanicError: () => (/* binding */ de),
/* harmony export */   PrismaClientUnknownRequestError: () => (/* binding */ q),
/* harmony export */   PrismaClientValidationError: () => (/* binding */ X),
/* harmony export */   Public: () => (/* binding */ Do),
/* harmony export */   Sql: () => (/* binding */ le),
/* harmony export */   createParam: () => (/* binding */ Gd),
/* harmony export */   defineDmmfProperty: () => (/* binding */ em),
/* harmony export */   deserializeJsonResponse: () => (/* binding */ st),
/* harmony export */   deserializeRawResult: () => (/* binding */ To),
/* harmony export */   dmmfToRuntimeDataModel: () => (/* binding */ td),
/* harmony export */   empty: () => (/* binding */ im),
/* harmony export */   getPrismaClient: () => (/* binding */ qf),
/* harmony export */   getRuntime: () => (/* binding */ io),
/* harmony export */   join: () => (/* binding */ nm),
/* harmony export */   makeStrictEnum: () => (/* binding */ Bf),
/* harmony export */   makeTypedQueryFactory: () => (/* binding */ tm),
/* harmony export */   objectEnumValues: () => (/* binding */ Ui),
/* harmony export */   raw: () => (/* binding */ Ta),
/* harmony export */   serializeJsonQuery: () => (/* binding */ Hi),
/* harmony export */   skip: () => (/* binding */ Wi),
/* harmony export */   sqltag: () => (/* binding */ Sa),
/* harmony export */   warnEnvConflicts: () => (/* binding */ Uf),
/* harmony export */   warnOnce: () => (/* binding */ on)
/* harmony export */ });
/* harmony import */ var node_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:module */ "node:module");
/* harmony import */ var node_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:path */ "node:path");
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! node:url */ "node:url");
/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node:fs */ "node:fs");
/* harmony import */ var node_child_process__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! node:child_process */ "node:child_process");
/* harmony import */ var node_fs_promises__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! node:fs/promises */ "node:fs/promises");
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! node:os */ "node:os");
/* harmony import */ var node_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! node:util */ "node:util");
/* harmony import */ var node_async_hooks__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! node:async_hooks */ "node:async_hooks");
/* harmony import */ var node_events__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! node:events */ "node:events");




const __filename = node_url__WEBPACK_IMPORTED_MODULE_3__.fileURLToPath("file:///D:/Git/nextron-autoupdate-app/node_modules/@prisma/client/runtime/library.mjs");
const __dirname = node_path__WEBPACK_IMPORTED_MODULE_1__.dirname(__filename);
const require = node_module__WEBPACK_IMPORTED_MODULE_0__.createRequire("file:///D:/Git/nextron-autoupdate-app/node_modules/@prisma/client/runtime/library.mjs");
var nu=Object.create;var Kn=Object.defineProperty;var iu=Object.getOwnPropertyDescriptor;var ou=Object.getOwnPropertyNames;var su=Object.getPrototypeOf,au=Object.prototype.hasOwnProperty;var fr=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(r,t)=>(typeof require<"u"?require:r)[t]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var Ro=(e,r)=>()=>(e&&(r=e(e=0)),r);var te=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),gr=(e,r)=>{for(var t in r)Kn(e,t,{get:r[t],enumerable:!0})},lu=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of ou(r))!au.call(e,i)&&i!==t&&Kn(e,i,{get:()=>r[i],enumerable:!(n=iu(r,i))||n.enumerable});return e};var ne=(e,r,t)=>(t=e!=null?nu(su(e)):{},lu(r||!e||!e.__esModule?Kn(t,"default",{value:e,enumerable:!0}):t,e));var li=te((Vg,Xo)=>{"use strict";Xo.exports=(e,r=node_process__WEBPACK_IMPORTED_MODULE_2__.argv)=>{let t=e.startsWith("-")?"":e.length===1?"-":"--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1&&(i===-1||n<i)}});var ts=te((Bg,rs)=>{"use strict";var Sc=fr("node:os"),es=fr("node:tty"),pe=li(),{env:U}=/*#__PURE__*/ (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(node_process__WEBPACK_IMPORTED_MODULE_2__, 2))),Qe;pe("no-color")||pe("no-colors")||pe("color=false")||pe("color=never")?Qe=0:(pe("color")||pe("colors")||pe("color=true")||pe("color=always"))&&(Qe=1);"FORCE_COLOR"in U&&(U.FORCE_COLOR==="true"?Qe=1:U.FORCE_COLOR==="false"?Qe=0:Qe=U.FORCE_COLOR.length===0?1:Math.min(parseInt(U.FORCE_COLOR,10),3));function ui(e){return e===0?!1:{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function ci(e,r){if(Qe===0)return 0;if(pe("color=16m")||pe("color=full")||pe("color=truecolor"))return 3;if(pe("color=256"))return 2;if(e&&!r&&Qe===void 0)return 0;let t=Qe||0;if(U.TERM==="dumb")return t;if(node_process__WEBPACK_IMPORTED_MODULE_2__.platform==="win32"){let n=Sc.release().split(".");return Number(n[0])>=10&&Number(n[2])>=10586?Number(n[2])>=14931?3:2:1}if("CI"in U)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE"].some(n=>n in U)||U.CI_NAME==="codeship"?1:t;if("TEAMCITY_VERSION"in U)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(U.TEAMCITY_VERSION)?1:0;if(U.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in U){let n=parseInt((U.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(U.TERM_PROGRAM){case"iTerm.app":return n>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(U.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(U.TERM)||"COLORTERM"in U?1:t}function Rc(e){let r=ci(e,e&&e.isTTY);return ui(r)}rs.exports={supportsColor:Rc,stdout:ui(ci(!0,es.isatty(1))),stderr:ui(ci(!0,es.isatty(2)))}});var os=te((Ug,is)=>{"use strict";var Ac=ts(),Er=li();function ns(e){if(/^\d{3,4}$/.test(e)){let t=/(\d{1,2})(\d{2})/.exec(e)||[];return{major:0,minor:parseInt(t[1],10),patch:parseInt(t[2],10)}}let r=(e||"").split(".").map(t=>parseInt(t,10));return{major:r[0],minor:r[1],patch:r[2]}}function pi(e){let{CI:r,FORCE_HYPERLINK:t,NETLIFY:n,TEAMCITY_VERSION:i,TERM_PROGRAM:o,TERM_PROGRAM_VERSION:s,VTE_VERSION:a,TERM:l}=node_process__WEBPACK_IMPORTED_MODULE_2__.env;if(t)return!(t.length>0&&parseInt(t,10)===0);if(Er("no-hyperlink")||Er("no-hyperlinks")||Er("hyperlink=false")||Er("hyperlink=never"))return!1;if(Er("hyperlink=true")||Er("hyperlink=always")||n)return!0;if(!Ac.supportsColor(e)||e&&!e.isTTY)return!1;if("WT_SESSION" in node_process__WEBPACK_IMPORTED_MODULE_2__.env)return!0;if(node_process__WEBPACK_IMPORTED_MODULE_2__.platform==="win32"||r||i)return!1;if(o){let u=ns(s||"");switch(o){case"iTerm.app":return u.major===3?u.minor>=1:u.major>3;case"WezTerm":return u.major>=20200620;case"vscode":return u.major>1||u.major===1&&u.minor>=72;case"ghostty":return!0}}if(a){if(a==="0.50.0")return!1;let u=ns(a);return u.major>0||u.minor>=50}switch(l){case"alacritty":return!0}return!1}is.exports={supportsHyperlink:pi,stdout:pi(node_process__WEBPACK_IMPORTED_MODULE_2__.stdout),stderr:pi(node_process__WEBPACK_IMPORTED_MODULE_2__.stderr)}});var ss=te((th,Cc)=>{Cc.exports={name:"@prisma/internals",version:"6.13.0",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek <suchanek@prisma.io>",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",esbuild:"0.25.5","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/schema-engine-wasm":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:">=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}});var hi=te((Ph,Nc)=>{Nc.exports={name:"@prisma/engines-version",version:"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek <suchanek@prisma.io>",prisma:{enginesVersion:"361e86d0ea4987e9f53a565309b3eed797a6bcbd"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}});var Zt=te(zt=>{"use strict";Object.defineProperty(zt,"__esModule",{value:!0});zt.enginesVersion=void 0;zt.enginesVersion=hi().prisma.enginesVersion});var ds=te((qh,ps)=>{"use strict";ps.exports=e=>{let r=e.match(/^[ \t]*(?=\S)/gm);return r?r.reduce((t,n)=>Math.min(t,n.length),1/0):0}});var xi=te((Bh,gs)=>{"use strict";gs.exports=(e,r=1,t)=>{if(t={indent:" ",includeEmptyLines:!1,...t},typeof e!="string")throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);if(typeof r!="number")throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof r}\``);if(typeof t.indent!="string")throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof t.indent}\``);if(r===0)return e;let n=t.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return e.replace(n,t.indent.repeat(r))}});var Es=te((Qh,bs)=>{"use strict";bs.exports=({onlyFirst:e=!1}={})=>{let r=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(r,e?void 0:"g")}});var Si=te((Wh,ws)=>{"use strict";var Gc=Es();ws.exports=e=>typeof e=="string"?e.replace(Gc(),""):e});var xs=te((zh,Qc)=>{Qc.exports={name:"dotenv",version:"16.5.0",description:"Loads environment variables from .env file",main:"lib/main.js",types:"lib/main.d.ts",exports:{".":{types:"./lib/main.d.ts",require:"./lib/main.js",default:"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},scripts:{"dts-check":"tsc --project tests/types/tsconfig.json",lint:"standard",pretest:"npm run lint && npm run dts-check",test:"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test:coverage":"tap run --show-full-coverage --timeout=60000 --coverage-report=lcov",prerelease:"npm test",release:"standard-version"},repository:{type:"git",url:"git://github.com/motdotla/dotenv.git"},homepage:"https://github.com/motdotla/dotenv#readme",funding:"https://dotenvx.com",keywords:["dotenv","env",".env","environment","variables","config","settings"],readmeFilename:"README.md",license:"BSD-2-Clause",devDependencies:{"@types/node":"^18.11.3",decache:"^4.6.2",sinon:"^14.0.1",standard:"^17.0.0","standard-version":"^9.5.0",tap:"^19.2.0",typescript:"^4.8.4"},engines:{node:">=12"},browser:{fs:!1}}});var Rs=te((Zh,Ne)=>{"use strict";var Ai=fr("node:fs"),Ci=fr("node:path"),Wc=fr("node:os"),Jc=fr("node:crypto"),Hc=xs(),Ps=Hc.version,Kc=/(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;function Yc(e){let r={},t=e.toString();t=t.replace(/\r\n?/mg,`
`);let n;for(;(n=Kc.exec(t))!=null;){let i=n[1],o=n[2]||"";o=o.trim();let s=o[0];o=o.replace(/^(['"`])([\s\S]*)\1$/mg,"$2"),s==='"'&&(o=o.replace(/\\n/g,`
`),o=o.replace(/\\r/g,"\r")),r[i]=o}return r}function zc(e){let r=Ss(e),t=V.configDotenv({path:r});if(!t.parsed){let s=new Error(`MISSING_DATA: Cannot parse ${r} for an unknown reason`);throw s.code="MISSING_DATA",s}let n=Ts(e).split(","),i=n.length,o;for(let s=0;s<i;s++)try{let a=n[s].trim(),l=Xc(t,a);o=V.decrypt(l.ciphertext,l.key);break}catch(a){if(s+1>=i)throw a}return V.parse(o)}function Zc(e){console.log(`[dotenv@${Ps}][WARN] ${e}`)}function tt(e){console.log(`[dotenv@${Ps}][DEBUG] ${e}`)}function Ts(e){return e&&e.DOTENV_KEY&&e.DOTENV_KEY.length>0?e.DOTENV_KEY:node_process__WEBPACK_IMPORTED_MODULE_2__.env.DOTENV_KEY&&node_process__WEBPACK_IMPORTED_MODULE_2__.env.DOTENV_KEY.length>0?node_process__WEBPACK_IMPORTED_MODULE_2__.env.DOTENV_KEY:""}function Xc(e,r){let t;try{t=new URL(r)}catch(a){if(a.code==="ERR_INVALID_URL"){let l=new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");throw l.code="INVALID_DOTENV_KEY",l}throw a}let n=t.password;if(!n){let a=new Error("INVALID_DOTENV_KEY: Missing key part");throw a.code="INVALID_DOTENV_KEY",a}let i=t.searchParams.get("environment");if(!i){let a=new Error("INVALID_DOTENV_KEY: Missing environment part");throw a.code="INVALID_DOTENV_KEY",a}let o=`DOTENV_VAULT_${i.toUpperCase()}`,s=e.parsed[o];if(!s){let a=new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${o} in your .env.vault file.`);throw a.code="NOT_FOUND_DOTENV_ENVIRONMENT",a}return{ciphertext:s,key:n}}function Ss(e){let r=null;if(e&&e.path&&e.path.length>0)if(Array.isArray(e.path))for(let t of e.path)Ai.existsSync(t)&&(r=t.endsWith(".vault")?t:`${t}.vault`);else r=e.path.endsWith(".vault")?e.path:`${e.path}.vault`;else r=Ci.resolve(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),".env.vault");return Ai.existsSync(r)?r:null}function vs(e){return e[0]==="~"?Ci.join(Wc.homedir(),e.slice(1)):e}function ep(e){!!(e&&e.debug)&&tt("Loading env from encrypted .env.vault");let t=V._parseVault(e),n=node_process__WEBPACK_IMPORTED_MODULE_2__.env;return e&&e.processEnv!=null&&(n=e.processEnv),V.populate(n,t,e),{parsed:t}}function rp(e){let r=Ci.resolve(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),".env"),t="utf8",n=!!(e&&e.debug);e&&e.encoding?t=e.encoding:n&&tt("No encoding is specified. UTF-8 is used by default");let i=[r];if(e&&e.path)if(!Array.isArray(e.path))i=[vs(e.path)];else{i=[];for(let l of e.path)i.push(vs(l))}let o,s={};for(let l of i)try{let u=V.parse(Ai.readFileSync(l,{encoding:t}));V.populate(s,u,e)}catch(u){n&&tt(`Failed to load ${l} ${u.message}`),o=u}let a=node_process__WEBPACK_IMPORTED_MODULE_2__.env;return e&&e.processEnv!=null&&(a=e.processEnv),V.populate(a,s,e),o?{parsed:s,error:o}:{parsed:s}}function tp(e){if(Ts(e).length===0)return V.configDotenv(e);let r=Ss(e);return r?V._configVault(e):(Zc(`You set DOTENV_KEY but you are missing a .env.vault file at ${r}. Did you forget to build it?`),V.configDotenv(e))}function np(e,r){let t=Buffer.from(r.slice(-64),"hex"),n=Buffer.from(e,"base64"),i=n.subarray(0,12),o=n.subarray(-16);n=n.subarray(12,-16);try{let s=Jc.createDecipheriv("aes-256-gcm",t,i);return s.setAuthTag(o),`${s.update(n)}${s.final()}`}catch(s){let a=s instanceof RangeError,l=s.message==="Invalid key length",u=s.message==="Unsupported state or unable to authenticate data";if(a||l){let c=new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");throw c.code="INVALID_DOTENV_KEY",c}else if(u){let c=new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");throw c.code="DECRYPTION_FAILED",c}else throw s}}function ip(e,r,t={}){let n=!!(t&&t.debug),i=!!(t&&t.override);if(typeof r!="object"){let o=new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");throw o.code="OBJECT_REQUIRED",o}for(let o of Object.keys(r))Object.prototype.hasOwnProperty.call(e,o)?(i===!0&&(e[o]=r[o]),n&&tt(i===!0?`"${o}" is already defined and WAS overwritten`:`"${o}" is already defined and was NOT overwritten`)):e[o]=r[o]}var V={configDotenv:rp,_configVault:ep,_parseVault:zc,config:tp,decrypt:np,parse:Yc,populate:ip};Ne.exports.configDotenv=V.configDotenv;Ne.exports._configVault=V._configVault;Ne.exports._parseVault=V._parseVault;Ne.exports.config=V.config;Ne.exports.decrypt=V.decrypt;Ne.exports.parse=V.parse;Ne.exports.populate=V.populate;Ne.exports=V});var ks=te((sy,nn)=>{"use strict";nn.exports=(e={})=>{let r;if(e.repoUrl)r=e.repoUrl;else if(e.user&&e.repo)r=`https://github.com/${e.user}/${e.repo}`;else throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");let t=new URL(`${r}/issues/new`),n=["body","title","labels","template","milestone","assignee","projects"];for(let i of n){let o=e[i];if(o!==void 0){if(i==="labels"||i==="projects"){if(!Array.isArray(o))throw new TypeError(`The \`${i}\` option should be an array`);o=o.join(",")}t.searchParams.set(i,o)}}return t.toString()};nn.exports.default=nn.exports});var ji=te(($b,zs)=>{"use strict";zs.exports=function(){function e(r,t,n,i,o){return r<t||n<t?r>n?n+1:r+1:i===o?t:t+1}return function(r,t){if(r===t)return 0;if(r.length>t.length){var n=r;r=t,t=n}for(var i=r.length,o=t.length;i>0&&r.charCodeAt(i-1)===t.charCodeAt(o-1);)i--,o--;for(var s=0;s<i&&r.charCodeAt(s)===t.charCodeAt(s);)s++;if(i-=s,o-=s,i===0||o<3)return o;var a=0,l,u,c,p,d,f,h,g,S,P,R,b,k=[];for(l=0;l<i;l++)k.push(l+1),k.push(r.charCodeAt(s+l));for(var me=k.length-1;a<o-3;)for(S=t.charCodeAt(s+(u=a)),P=t.charCodeAt(s+(c=a+1)),R=t.charCodeAt(s+(p=a+2)),b=t.charCodeAt(s+(d=a+3)),f=a+=4,l=0;l<me;l+=2)h=k[l],g=k[l+1],u=e(h,u,c,S,g),c=e(u,c,p,P,g),p=e(c,p,d,R,g),f=e(p,d,f,b,g),k[l]=f,d=p,p=c,c=u,u=h;for(;a<o;)for(S=t.charCodeAt(s+(u=a)),f=++a,l=0;l<me;l+=2)h=k[l],k[l]=f=e(h,u,f,S,k[l+1]),u=h;return f}}()});var ta=Ro(()=>{"use strict"});var na=Ro(()=>{"use strict"});var Io={};gr(Io,{defineExtension:()=>Ao,getExtensionContext:()=>Co});function Ao(e){return typeof e=="function"?e:r=>r.$extends(e)}function Co(e){return e}var Do={};gr(Do,{validator:()=>ko});function ko(...e){return r=>r}var $t={};gr($t,{$:()=>Fo,bgBlack:()=>bu,bgBlue:()=>vu,bgCyan:()=>Tu,bgGreen:()=>wu,bgMagenta:()=>Pu,bgRed:()=>Eu,bgWhite:()=>Su,bgYellow:()=>xu,black:()=>fu,blue:()=>tr,bold:()=>Q,cyan:()=>ke,dim:()=>Ce,gray:()=>Jr,green:()=>qe,grey:()=>yu,hidden:()=>du,inverse:()=>pu,italic:()=>cu,magenta:()=>gu,red:()=>ue,reset:()=>uu,strikethrough:()=>mu,underline:()=>K,white:()=>hu,yellow:()=>Ie});var Yn,Oo,_o,No,Lo=!0;typeof /*#__PURE__*/ (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(node_process__WEBPACK_IMPORTED_MODULE_2__, 2)))<"u"&&({FORCE_COLOR:Yn,NODE_DISABLE_COLORS:Oo,NO_COLOR:_o,TERM:No}=node_process__WEBPACK_IMPORTED_MODULE_2__.env||{},Lo=node_process__WEBPACK_IMPORTED_MODULE_2__.stdout&&node_process__WEBPACK_IMPORTED_MODULE_2__.stdout.isTTY);var Fo={enabled:!Oo&&_o==null&&No!=="dumb"&&(Yn!=null&&Yn!=="0"||Lo)};function N(e,r){let t=new RegExp(`\\x1b\\[${r}m`,"g"),n=`\x1B[${e}m`,i=`\x1B[${r}m`;return function(o){return!Fo.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(t,i+n):o)+i}}var uu=N(0,0),Q=N(1,22),Ce=N(2,22),cu=N(3,23),K=N(4,24),pu=N(7,27),du=N(8,28),mu=N(9,29),fu=N(30,39),ue=N(31,39),qe=N(32,39),Ie=N(33,39),tr=N(34,39),gu=N(35,39),ke=N(36,39),hu=N(37,39),Jr=N(90,39),yu=N(90,39),bu=N(40,49),Eu=N(41,49),wu=N(42,49),xu=N(43,49),vu=N(44,49),Pu=N(45,49),Tu=N(46,49),Su=N(47,49);var Ru=100,Mo=["green","yellow","blue","magenta","cyan","red"],Hr=[],$o=Date.now(),Au=0,zn=typeof /*#__PURE__*/ (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(node_process__WEBPACK_IMPORTED_MODULE_2__, 2)))<"u"?node_process__WEBPACK_IMPORTED_MODULE_2__.env:{};globalThis.DEBUG??=zn.DEBUG??"";globalThis.DEBUG_COLORS??=zn.DEBUG_COLORS?zn.DEBUG_COLORS==="true":!0;var Kr={enable(e){typeof e=="string"&&(globalThis.DEBUG=e)},disable(){let e=globalThis.DEBUG;return globalThis.DEBUG="",e},enabled(e){let r=globalThis.DEBUG.split(",").map(i=>i.replace(/[.+?^${}()|[\]\\]/g,"\\$&")),t=r.some(i=>i===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n=r.some(i=>i===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));return t&&!n},log:(...e)=>{let[r,t,...n]=e;(console.warn??console.log)(`${r} ${t}`,...n)},formatters:{}};function Cu(e){let r={color:Mo[Au++%Mo.length],enabled:Kr.enabled(e),namespace:e,log:Kr.log,extend:()=>{}},t=(...n)=>{let{enabled:i,namespace:o,color:s,log:a}=r;if(n.length!==0&&Hr.push([o,...n]),Hr.length>Ru&&Hr.shift(),Kr.enabled(o)||i){let l=n.map(c=>typeof c=="string"?c:Iu(c)),u=`+${Date.now()-$o}ms`;$o=Date.now(),globalThis.DEBUG_COLORS?a($t[s](Q(o)),...l,$t[s](u)):a(o,...l,u)}};return new Proxy(t,{get:(n,i)=>r[i],set:(n,i,o)=>r[i]=o})}var L=new Proxy(Cu,{get:(e,r)=>Kr[r],set:(e,r,t)=>Kr[r]=t});function Iu(e,r=2){let t=new Set;return JSON.stringify(e,(n,i)=>{if(typeof i=="object"&&i!==null){if(t.has(i))return"[Circular *]";t.add(i)}else if(typeof i=="bigint")return i.toString();return i},r)}function qo(e=7500){let r=Hr.map(([t,...n])=>`${t} ${n.map(i=>typeof i=="string"?i:JSON.stringify(i)).join(" ")}`).join(`
`);return r.length<e?r:r.slice(-e)}function jo(){Hr.length=0}var hr=L;function Zn(){let e=node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_QUERY_ENGINE_LIBRARY;if(!(e&&node_fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(e))&&node_process__WEBPACK_IMPORTED_MODULE_2__.arch==="ia32")throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)')}var Xn=["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];var qt="libquery_engine";function jt(e,r){let t=r==="url";return e.includes("windows")?t?"query_engine.dll.node":`query_engine-${e}.dll.node`:e.includes("darwin")?t?`${qt}.dylib.node`:`${qt}-${e}.dylib.node`:t?`${qt}.so.node`:`${qt}-${e}.so.node`}var De=Symbol.for("@ts-pattern/matcher"),Du=Symbol.for("@ts-pattern/isVariadic"),Bt="@ts-pattern/anonymous-select-key",ei=e=>!!(e&&typeof e=="object"),Vt=e=>e&&!!e[De],Ee=(e,r,t)=>{if(Vt(e)){let n=e[De](),{matched:i,selections:o}=n.match(r);return i&&o&&Object.keys(o).forEach(s=>t(s,o[s])),i}if(ei(e)){if(!ei(r))return!1;if(Array.isArray(e)){if(!Array.isArray(r))return!1;let n=[],i=[],o=[];for(let s of e.keys()){let a=e[s];Vt(a)&&a[Du]?o.push(a):o.length?i.push(a):n.push(a)}if(o.length){if(o.length>1)throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(r.length<n.length+i.length)return!1;let s=r.slice(0,n.length),a=i.length===0?[]:r.slice(-i.length),l=r.slice(n.length,i.length===0?1/0:-i.length);return n.every((u,c)=>Ee(u,s[c],t))&&i.every((u,c)=>Ee(u,a[c],t))&&(o.length===0||Ee(o[0],l,t))}return e.length===r.length&&e.every((s,a)=>Ee(s,r[a],t))}return Reflect.ownKeys(e).every(n=>{let i=e[n];return(n in r||Vt(o=i)&&o[De]().matcherType==="optional")&&Ee(i,r[n],t);var o})}return Object.is(r,e)},Ge=e=>{var r,t,n;return ei(e)?Vt(e)?(r=(t=(n=e[De]()).getSelectionKeys)==null?void 0:t.call(n))!=null?r:[]:Array.isArray(e)?Yr(e,Ge):Yr(Object.values(e),Ge):[]},Yr=(e,r)=>e.reduce((t,n)=>t.concat(r(n)),[]);function ce(e){return Object.assign(e,{optional:()=>Ou(e),and:r=>$(e,r),or:r=>_u(e,r),select:r=>r===void 0?Vo(e):Vo(r,e)})}function Ou(e){return ce({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return r===void 0?(Ge(e).forEach(i=>n(i,void 0)),{matched:!0,selections:t}):{matched:Ee(e,r,n),selections:t}},getSelectionKeys:()=>Ge(e),matcherType:"optional"})})}function $(...e){return ce({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return{matched:e.every(i=>Ee(i,r,n)),selections:t}},getSelectionKeys:()=>Yr(e,Ge),matcherType:"and"})})}function _u(...e){return ce({[De]:()=>({match:r=>{let t={},n=(i,o)=>{t[i]=o};return Yr(e,Ge).forEach(i=>n(i,void 0)),{matched:e.some(i=>Ee(i,r,n)),selections:t}},getSelectionKeys:()=>Yr(e,Ge),matcherType:"or"})})}function C(e){return{[De]:()=>({match:r=>({matched:!!e(r)})})}}function Vo(...e){let r=typeof e[0]=="string"?e[0]:void 0,t=e.length===2?e[1]:typeof e[0]=="string"?void 0:e[0];return ce({[De]:()=>({match:n=>{let i={[r??Bt]:n};return{matched:t===void 0||Ee(t,n,(o,s)=>{i[o]=s}),selections:i}},getSelectionKeys:()=>[r??Bt].concat(t===void 0?[]:Ge(t))})})}function ye(e){return typeof e=="number"}function je(e){return typeof e=="string"}function Ve(e){return typeof e=="bigint"}var ng=ce(C(function(e){return!0}));var Be=e=>Object.assign(ce(e),{startsWith:r=>{return Be($(e,(t=r,C(n=>je(n)&&n.startsWith(t)))));var t},endsWith:r=>{return Be($(e,(t=r,C(n=>je(n)&&n.endsWith(t)))));var t},minLength:r=>Be($(e,(t=>C(n=>je(n)&&n.length>=t))(r))),length:r=>Be($(e,(t=>C(n=>je(n)&&n.length===t))(r))),maxLength:r=>Be($(e,(t=>C(n=>je(n)&&n.length<=t))(r))),includes:r=>{return Be($(e,(t=r,C(n=>je(n)&&n.includes(t)))));var t},regex:r=>{return Be($(e,(t=r,C(n=>je(n)&&!!n.match(t)))));var t}}),ig=Be(C(je)),be=e=>Object.assign(ce(e),{between:(r,t)=>be($(e,((n,i)=>C(o=>ye(o)&&n<=o&&i>=o))(r,t))),lt:r=>be($(e,(t=>C(n=>ye(n)&&n<t))(r))),gt:r=>be($(e,(t=>C(n=>ye(n)&&n>t))(r))),lte:r=>be($(e,(t=>C(n=>ye(n)&&n<=t))(r))),gte:r=>be($(e,(t=>C(n=>ye(n)&&n>=t))(r))),int:()=>be($(e,C(r=>ye(r)&&Number.isInteger(r)))),finite:()=>be($(e,C(r=>ye(r)&&Number.isFinite(r)))),positive:()=>be($(e,C(r=>ye(r)&&r>0))),negative:()=>be($(e,C(r=>ye(r)&&r<0)))}),og=be(C(ye)),Ue=e=>Object.assign(ce(e),{between:(r,t)=>Ue($(e,((n,i)=>C(o=>Ve(o)&&n<=o&&i>=o))(r,t))),lt:r=>Ue($(e,(t=>C(n=>Ve(n)&&n<t))(r))),gt:r=>Ue($(e,(t=>C(n=>Ve(n)&&n>t))(r))),lte:r=>Ue($(e,(t=>C(n=>Ve(n)&&n<=t))(r))),gte:r=>Ue($(e,(t=>C(n=>Ve(n)&&n>=t))(r))),positive:()=>Ue($(e,C(r=>Ve(r)&&r>0))),negative:()=>Ue($(e,C(r=>Ve(r)&&r<0)))}),sg=Ue(C(Ve)),ag=ce(C(function(e){return typeof e=="boolean"})),lg=ce(C(function(e){return typeof e=="symbol"})),ug=ce(C(function(e){return e==null})),cg=ce(C(function(e){return e!=null}));var ri=class extends Error{constructor(r){let t;try{t=JSON.stringify(r)}catch{t=r}super(`Pattern matching error: no pattern matches value ${t}`),this.input=void 0,this.input=r}},ti={matched:!1,value:void 0};function yr(e){return new ni(e,ti)}var ni=class e{constructor(r,t){this.input=void 0,this.state=void 0,this.input=r,this.state=t}with(...r){if(this.state.matched)return this;let t=r[r.length-1],n=[r[0]],i;r.length===3&&typeof r[1]=="function"?i=r[1]:r.length>2&&n.push(...r.slice(1,r.length-1));let o=!1,s={},a=(u,c)=>{o=!0,s[u]=c},l=!n.some(u=>Ee(u,this.input,a))||i&&!i(this.input)?ti:{matched:!0,value:t(o?Bt in s?s[Bt]:s:this.input,this.input)};return new e(this.input,l)}when(r,t){if(this.state.matched)return this;let n=!!r(this.input);return new e(this.input,n?{matched:!0,value:t(this.input,this.input)}:ti)}otherwise(r){return this.state.matched?this.state.value:r(this.input)}exhaustive(){if(this.state.matched)return this.state.value;throw new ri(this.input)}run(){return this.exhaustive()}returnType(){return this}};var Nu={warn:Ie("prisma:warn")},Lu={warn:()=>!node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_DISABLE_WARNINGS};function Ut(e,...r){Lu.warn()&&console.warn(`${Nu.warn} ${e}`,...r)}var $u=(0,node_util__WEBPACK_IMPORTED_MODULE_8__.promisify)(node_child_process__WEBPACK_IMPORTED_MODULE_5__.exec),z=hr("prisma:get-platform"),qu=["1.0.x","1.1.x","3.0.x"];async function Qo(){let e=node_os__WEBPACK_IMPORTED_MODULE_7__.platform(),r=node_process__WEBPACK_IMPORTED_MODULE_2__.arch;if(e==="freebsd"){let s=await Qt("freebsd-version");if(s&&s.trim().length>0){let l=/^(\d+)\.?/.exec(s);if(l)return{platform:"freebsd",targetDistro:`freebsd${l[1]}`,arch:r}}}if(e!=="linux")return{platform:e,arch:r};let t=await Vu(),n=await Ku(),i=Uu({arch:r,archFromUname:n,familyDistro:t.familyDistro}),{libssl:o}=await Gu(i);return{platform:"linux",libssl:o,arch:r,archFromUname:n,...t}}function ju(e){let r=/^ID="?([^"\n]*)"?$/im,t=/^ID_LIKE="?([^"\n]*)"?$/im,n=r.exec(e),i=n&&n[1]&&n[1].toLowerCase()||"",o=t.exec(e),s=o&&o[1]&&o[1].toLowerCase()||"",a=yr({id:i,idLike:s}).with({id:"alpine"},({id:l})=>({targetDistro:"musl",familyDistro:l,originalDistro:l})).with({id:"raspbian"},({id:l})=>({targetDistro:"arm",familyDistro:"debian",originalDistro:l})).with({id:"nixos"},({id:l})=>({targetDistro:"nixos",originalDistro:l,familyDistro:"nixos"})).with({id:"debian"},{id:"ubuntu"},({id:l})=>({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).with({id:"rhel"},{id:"centos"},{id:"fedora"},({id:l})=>({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).when(({idLike:l})=>l.includes("debian")||l.includes("ubuntu"),({id:l})=>({targetDistro:"debian",familyDistro:"debian",originalDistro:l})).when(({idLike:l})=>i==="arch"||l.includes("arch"),({id:l})=>({targetDistro:"debian",familyDistro:"arch",originalDistro:l})).when(({idLike:l})=>l.includes("centos")||l.includes("fedora")||l.includes("rhel")||l.includes("suse"),({id:l})=>({targetDistro:"rhel",familyDistro:"rhel",originalDistro:l})).otherwise(({id:l})=>({targetDistro:void 0,familyDistro:void 0,originalDistro:l}));return z(`Found distro info:
${JSON.stringify(a,null,2)}`),a}async function Vu(){let e="/etc/os-release";try{let r=await node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.readFile(e,{encoding:"utf-8"});return ju(r)}catch{return{targetDistro:void 0,familyDistro:void 0,originalDistro:void 0}}}function Bu(e){let r=/^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);if(r){let t=`${r[1]}.x`;return Wo(t)}}function Bo(e){let r=/libssl\.so\.(\d)(\.\d)?/.exec(e);if(r){let t=`${r[1]}${r[2]??".0"}.x`;return Wo(t)}}function Wo(e){let r=(()=>{if(Ho(e))return e;let t=e.split(".");return t[1]="0",t.join(".")})();if(qu.includes(r))return r}function Uu(e){return yr(e).with({familyDistro:"musl"},()=>(z('Trying platform-specific paths for "alpine"'),["/lib","/usr/lib"])).with({familyDistro:"debian"},({archFromUname:r})=>(z('Trying platform-specific paths for "debian" (and "ubuntu")'),[`/usr/lib/${r}-linux-gnu`,`/lib/${r}-linux-gnu`])).with({familyDistro:"rhel"},()=>(z('Trying platform-specific paths for "rhel"'),["/lib64","/usr/lib64"])).otherwise(({familyDistro:r,arch:t,archFromUname:n})=>(z(`Don't know any platform-specific paths for "${r}" on ${t} (${n})`),[]))}async function Gu(e){let r='grep -v "libssl.so.0"',t=await Uo(e);if(t){z(`Found libssl.so file using platform-specific paths: ${t}`);let o=Bo(t);if(z(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"libssl-specific-path"}}z('Falling back to "ldconfig" and other generic paths');let n=await Qt(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${r}`);if(n||(n=await Uo(["/lib64","/usr/lib64","/lib","/usr/lib"])),n){z(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);let o=Bo(n);if(z(`The parsed libssl version is: ${o}`),o)return{libssl:o,strategy:"ldconfig"}}let i=await Qt("openssl version -v");if(i){z(`Found openssl binary with version: ${i}`);let o=Bu(i);if(z(`The parsed openssl version is: ${o}`),o)return{libssl:o,strategy:"openssl-binary"}}return z("Couldn't find any version of libssl or OpenSSL in the system"),{}}async function Uo(e){for(let r of e){let t=await Qu(r);if(t)return t}}async function Qu(e){try{return(await node_fs_promises__WEBPACK_IMPORTED_MODULE_6__.readdir(e)).find(t=>t.startsWith("libssl.so.")&&!t.startsWith("libssl.so.0"))}catch(r){if(r.code==="ENOENT")return;throw r}}async function nr(){let{binaryTarget:e}=await Jo();return e}function Wu(e){return e.binaryTarget!==void 0}async function oi(){let{memoized:e,...r}=await Jo();return r}var Gt={};async function Jo(){if(Wu(Gt))return Promise.resolve({...Gt,memoized:!0});let e=await Qo(),r=Ju(e);return Gt={...e,binaryTarget:r},{...Gt,memoized:!1}}function Ju(e){let{platform:r,arch:t,archFromUname:n,libssl:i,targetDistro:o,familyDistro:s,originalDistro:a}=e;r==="linux"&&!["x64","arm64"].includes(t)&&Ut(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures (detected "${t}" instead). If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);let l="1.1.x";if(r==="linux"&&i===void 0){let c=yr({familyDistro:s}).with({familyDistro:"debian"},()=>"Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(()=>"Please manually install OpenSSL and try installing Prisma again.");Ut(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`)}let u="debian";if(r==="linux"&&o===void 0&&z(`Distro is "${a}". Falling back to Prisma engines built for "${u}".`),r==="darwin"&&t==="arm64")return"darwin-arm64";if(r==="darwin")return"darwin";if(r==="win32")return"windows";if(r==="freebsd")return o;if(r==="openbsd")return"openbsd";if(r==="netbsd")return"netbsd";if(r==="linux"&&o==="nixos")return"linux-nixos";if(r==="linux"&&t==="arm64")return`${o==="musl"?"linux-musl-arm64":"linux-arm64"}-openssl-${i||l}`;if(r==="linux"&&t==="arm")return`linux-arm-openssl-${i||l}`;if(r==="linux"&&o==="musl"){let c="linux-musl";return!i||Ho(i)?c:`${c}-openssl-${i}`}return r==="linux"&&o&&i?`${o}-openssl-${i}`:(r!=="linux"&&Ut(`Prisma detected unknown OS "${r}" and may not work as expected. Defaulting to "linux".`),i?`${u}-openssl-${i}`:o?`${o}-openssl-${l}`:`${u}-openssl-${l}`)}async function Hu(e){try{return await e()}catch{return}}function Qt(e){return Hu(async()=>{let r=await $u(e);return z(`Command "${e}" successfully returned "${r.stdout}"`),r.stdout})}async function Ku(){return typeof node_os__WEBPACK_IMPORTED_MODULE_7__.machine=="function"?node_os__WEBPACK_IMPORTED_MODULE_7__.machine():(await Qt("uname -m"))?.trim()}function Ho(e){return e.startsWith("1.")}var Jt={};gr(Jt,{beep:()=>xc,clearScreen:()=>yc,clearTerminal:()=>bc,cursorBackward:()=>tc,cursorDown:()=>ec,cursorForward:()=>rc,cursorGetPosition:()=>oc,cursorHide:()=>lc,cursorLeft:()=>zo,cursorMove:()=>Xu,cursorNextLine:()=>sc,cursorPrevLine:()=>ac,cursorRestorePosition:()=>ic,cursorSavePosition:()=>nc,cursorShow:()=>uc,cursorTo:()=>Zu,cursorUp:()=>Yo,enterAlternativeScreen:()=>Ec,eraseDown:()=>mc,eraseEndLine:()=>pc,eraseLine:()=>Zo,eraseLines:()=>cc,eraseScreen:()=>si,eraseStartLine:()=>dc,eraseUp:()=>fc,exitAlternativeScreen:()=>wc,iTerm:()=>Tc,image:()=>Pc,link:()=>vc,scrollDown:()=>hc,scrollUp:()=>gc});var Wt=globalThis.window?.document!==void 0,vg=globalThis.process?.versions?.node!==void 0,Pg=globalThis.process?.versions?.bun!==void 0,Tg=globalThis.Deno?.version?.deno!==void 0,Sg=globalThis.process?.versions?.electron!==void 0,Rg=globalThis.navigator?.userAgent?.includes("jsdom")===!0,Ag=typeof WorkerGlobalScope<"u"&&globalThis instanceof WorkerGlobalScope,Cg=typeof DedicatedWorkerGlobalScope<"u"&&globalThis instanceof DedicatedWorkerGlobalScope,Ig=typeof SharedWorkerGlobalScope<"u"&&globalThis instanceof SharedWorkerGlobalScope,kg=typeof ServiceWorkerGlobalScope<"u"&&globalThis instanceof ServiceWorkerGlobalScope,zr=globalThis.navigator?.userAgentData?.platform,Dg=zr==="macOS"||globalThis.navigator?.platform==="MacIntel"||globalThis.navigator?.userAgent?.includes(" Mac ")===!0||globalThis.process?.platform==="darwin",Og=zr==="Windows"||globalThis.navigator?.platform==="Win32"||globalThis.process?.platform==="win32",_g=zr==="Linux"||globalThis.navigator?.platform?.startsWith("Linux")===!0||globalThis.navigator?.userAgent?.includes(" Linux ")===!0||globalThis.process?.platform==="linux",Ng=zr==="iOS"||globalThis.navigator?.platform==="MacIntel"&&globalThis.navigator?.maxTouchPoints>1||/iPad|iPhone|iPod/.test(globalThis.navigator?.platform),Lg=zr==="Android"||globalThis.navigator?.platform==="Android"||globalThis.navigator?.userAgent?.includes(" Android ")===!0||globalThis.process?.platform==="android";var I="\x1B[",Xr="\x1B]",br="\x07",Zr=";",Ko=!Wt&&node_process__WEBPACK_IMPORTED_MODULE_2__.env.TERM_PROGRAM==="Apple_Terminal",Yu=!Wt&&node_process__WEBPACK_IMPORTED_MODULE_2__.platform==="win32",zu=Wt?()=>{throw new Error("`process.cwd()` only works in Node.js, not the browser.")}:node_process__WEBPACK_IMPORTED_MODULE_2__.cwd,Zu=(e,r)=>{if(typeof e!="number")throw new TypeError("The `x` argument is required");return typeof r!="number"?I+(e+1)+"G":I+(r+1)+Zr+(e+1)+"H"},Xu=(e,r)=>{if(typeof e!="number")throw new TypeError("The `x` argument is required");let t="";return e<0?t+=I+-e+"D":e>0&&(t+=I+e+"C"),r<0?t+=I+-r+"A":r>0&&(t+=I+r+"B"),t},Yo=(e=1)=>I+e+"A",ec=(e=1)=>I+e+"B",rc=(e=1)=>I+e+"C",tc=(e=1)=>I+e+"D",zo=I+"G",nc=Ko?"\x1B7":I+"s",ic=Ko?"\x1B8":I+"u",oc=I+"6n",sc=I+"E",ac=I+"F",lc=I+"?25l",uc=I+"?25h",cc=e=>{let r="";for(let t=0;t<e;t++)r+=Zo+(t<e-1?Yo():"");return e&&(r+=zo),r},pc=I+"K",dc=I+"1K",Zo=I+"2K",mc=I+"J",fc=I+"1J",si=I+"2J",gc=I+"S",hc=I+"T",yc="\x1Bc",bc=Yu?`${si}${I}0f`:`${si}${I}3J${I}H`,Ec=I+"?1049h",wc=I+"?1049l",xc=br,vc=(e,r)=>[Xr,"8",Zr,Zr,r,br,e,Xr,"8",Zr,Zr,br].join(""),Pc=(e,r={})=>{let t=`${Xr}1337;File=inline=1`;return r.width&&(t+=`;width=${r.width}`),r.height&&(t+=`;height=${r.height}`),r.preserveAspectRatio===!1&&(t+=";preserveAspectRatio=0"),t+":"+Buffer.from(e).toString("base64")+br},Tc={setCwd:(e=zu())=>`${Xr}50;CurrentDir=${e}${br}`,annotation(e,r={}){let t=`${Xr}1337;`,n=r.x!==void 0,i=r.y!==void 0;if((n||i)&&!(n&&i&&r.length!==void 0))throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");return e=e.replaceAll("|",""),t+=r.isHidden?"AddHiddenAnnotation=":"AddAnnotation=",r.length>0?t+=(n?[e,r.length,r.x,r.y]:[r.length,e]).join("|"):t+=e,t+br}};var Ht=ne(os(),1);function ir(e,r,{target:t="stdout",...n}={}){return Ht.default[t]?Jt.link(e,r):n.fallback===!1?e:typeof n.fallback=="function"?n.fallback(e,r):`${e} (\u200B${r}\u200B)`}ir.isSupported=Ht.default.stdout;ir.stderr=(e,r,t={})=>ir(e,r,{target:"stderr",...t});ir.stderr.isSupported=Ht.default.stderr;function di(e){return ir(e,e,{fallback:K})}var Ic=ss(),mi=Ic.version;function wr(e){let r=kc();return r||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":Dc(e))}function kc(){let e=node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_CLIENT_ENGINE_TYPE;return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}function Dc(e){return e?.previewFeatures.includes("queryCompiler")?"client":"library"}function fi(e){return e.name==="DriverAdapterError"&&typeof e.cause=="object"}function Kt(e){return{ok:!0,value:e,map(r){return Kt(r(e))},flatMap(r){return r(e)}}}function or(e){return{ok:!1,error:e,map(){return or(e)},flatMap(){return or(e)}}}var as=L("driver-adapter-utils"),gi=class{registeredErrors=[];consumeError(r){return this.registeredErrors[r]}registerNewError(r){let t=0;for(;this.registeredErrors[t]!==void 0;)t++;return this.registeredErrors[t]={error:r},t}};var Yt=(e,r=new gi)=>{let t={adapterName:e.adapterName,errorRegistry:r,queryRaw:Oe(r,e.queryRaw.bind(e)),executeRaw:Oe(r,e.executeRaw.bind(e)),executeScript:Oe(r,e.executeScript.bind(e)),dispose:Oe(r,e.dispose.bind(e)),provider:e.provider,startTransaction:async(...n)=>(await Oe(r,e.startTransaction.bind(e))(...n)).map(o=>Oc(r,o))};return e.getConnectionInfo&&(t.getConnectionInfo=_c(r,e.getConnectionInfo.bind(e))),t},Oc=(e,r)=>({adapterName:r.adapterName,provider:r.provider,options:r.options,queryRaw:Oe(e,r.queryRaw.bind(r)),executeRaw:Oe(e,r.executeRaw.bind(r)),commit:Oe(e,r.commit.bind(r)),rollback:Oe(e,r.rollback.bind(r))});function Oe(e,r){return async(...t)=>{try{return Kt(await r(...t))}catch(n){if(as("[error@wrapAsync]",n),fi(n))return or(n.cause);let i=e.registerNewError(n);return or({kind:"GenericJs",id:i})}}}function _c(e,r){return(...t)=>{try{return Kt(r(...t))}catch(n){if(as("[error@wrapSync]",n),fi(n))return or(n.cause);let i=e.registerNewError(n);return or({kind:"GenericJs",id:i})}}}var Lc=ne(Zt());var Fc=ne(Zt());var Ih=L("prisma:engines");function ls(){return node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../")}var kh="libquery-engine";node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-darwin");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-darwin-arm64");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-debian-openssl-1.0.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-debian-openssl-1.1.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-debian-openssl-3.0.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-linux-static-x64");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-linux-static-arm64");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-rhel-openssl-1.0.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-rhel-openssl-1.1.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query-engine-rhel-openssl-3.0.x");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-darwin.dylib.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-darwin-arm64.dylib.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-debian-openssl-1.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-debian-openssl-1.1.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-debian-openssl-3.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-linux-arm64-openssl-1.1.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-linux-arm64-openssl-3.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-linux-musl.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-linux-musl-openssl-3.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-rhel-openssl-1.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-rhel-openssl-1.1.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../libquery_engine-rhel-openssl-3.0.x.so.node");node_path__WEBPACK_IMPORTED_MODULE_1__.join(__dirname,"../query_engine-windows.dll.node");var cs=hr("chmodPlusX");function yi(e){if(node_process__WEBPACK_IMPORTED_MODULE_2__.platform==="win32")return;let r=node_fs__WEBPACK_IMPORTED_MODULE_4__.statSync(e),t=r.mode|64|8|1;if(r.mode===t){cs(`Execution permissions of ${e} are fine`);return}let n=t.toString(8).slice(-3);cs(`Have to call chmodPlusX on ${e}`),node_fs__WEBPACK_IMPORTED_MODULE_4__.chmodSync(e,n)}function bi(e){let r=e.e,t=a=>`Prisma cannot find the required \`${a}\` system library in your system`,n=r.message.includes("cannot open shared object file"),i=`Please refer to the documentation about Prisma's system requirements: ${di("https://pris.ly/d/system-requirements")}`,o=`Unable to require(\`${Ce(e.id)}\`).`,s=yr({message:r.message,code:r.code}).with({code:"ENOENT"},()=>"File does not exist.").when(({message:a})=>n&&a.includes("libz"),()=>`${t("libz")}. Please install it and try again.`).when(({message:a})=>n&&a.includes("libgcc_s"),()=>`${t("libgcc_s")}. Please install it and try again.`).when(({message:a})=>n&&a.includes("libssl"),()=>{let a=e.platformInfo.libssl?`openssl-${e.platformInfo.libssl}`:"openssl";return`${t("libssl")}. Please install ${a} and try again.`}).when(({message:a})=>a.includes("GLIBC"),()=>`Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({message:a})=>e.platformInfo.platform==="linux"&&a.includes("symbol not found"),()=>`The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(()=>`The Prisma engines do not seem to be compatible with your system. ${i}`);return`${o}
${s}

Details: ${r.message}`}var ms=ne(ds(),1);function Ei(e){let r=(0,ms.default)(e);if(r===0)return e;let t=new RegExp(`^[ \\t]{${r}}`,"gm");return e.replace(t,"")}var fs="prisma+postgres",Xt=`${fs}:`;function en(e){return e?.toString().startsWith(`${Xt}//`)??!1}function wi(e){if(!en(e))return!1;let{host:r}=new URL(e);return r.includes("localhost")||r.includes("127.0.0.1")||r.includes("[::1]")}var hs=ne(xi());function Pi(e){return String(new vi(e))}var vi=class{constructor(r){this.config=r}toString(){let{config:r}=this,t=r.provider.fromEnvVar?`env("${r.provider.fromEnvVar}")`:r.provider.value,n=JSON.parse(JSON.stringify({provider:t,binaryTargets:Mc(r.binaryTargets)}));return`generator ${r.name} {
${(0,hs.default)($c(n),2)}
}`}};function Mc(e){let r;if(e.length>0){let t=e.find(n=>n.fromEnvVar!==null);t?r=`env("${t.fromEnvVar}")`:r=e.map(n=>n.native?"native":n.value)}else r=void 0;return r}function $c(e){let r=Object.keys(e).reduce((t,n)=>Math.max(t,n.length),0);return Object.entries(e).map(([t,n])=>`${t.padEnd(r)} = ${qc(n)}`).join(`
`)}function qc(e){return JSON.parse(JSON.stringify(e,(r,t)=>Array.isArray(t)?`[${t.map(n=>JSON.stringify(n)).join(", ")}]`:JSON.stringify(t)))}var rt={};gr(rt,{error:()=>Bc,info:()=>Vc,log:()=>jc,query:()=>Uc,should:()=>ys,tags:()=>et,warn:()=>Ti});var et={error:ue("prisma:error"),warn:Ie("prisma:warn"),info:ke("prisma:info"),query:tr("prisma:query")},ys={warn:()=>!node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_DISABLE_WARNINGS};function jc(...e){console.log(...e)}function Ti(e,...r){ys.warn()&&console.warn(`${et.warn} ${e}`,...r)}function Vc(e,...r){console.info(`${et.info} ${e}`,...r)}function Bc(e,...r){console.error(`${et.error} ${e}`,...r)}function Uc(e,...r){console.log(`${et.query} ${e}`,...r)}function rn(e,r){if(!e)throw new Error(`${r}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}function _e(e,r){throw new Error(r)}function Ri(e){return node_path__WEBPACK_IMPORTED_MODULE_1__.sep===node_path__WEBPACK_IMPORTED_MODULE_1__.posix.sep?e:e.split(node_path__WEBPACK_IMPORTED_MODULE_1__.sep).join(node_path__WEBPACK_IMPORTED_MODULE_1__.posix.sep)}var Di=ne(Rs());function As(e){let r=e.ignoreProcessEnv?{}:node_process__WEBPACK_IMPORTED_MODULE_2__.env,t=n=>n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o,s){let a=/(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);if(!a)return o;let l=a[1],u,c;if(l==="\\")c=a[0],u=c.replace("\\$","$");else{let p=a[2];c=a[0].substring(l.length),u=Object.hasOwnProperty.call(r,p)?r[p]:e.parsed[p]||"",u=t(u)}return o.replace(c,u)},n)??n;for(let n in e.parsed){let i=Object.hasOwnProperty.call(r,n)?r[n]:e.parsed[n];e.parsed[n]=t(i)}for(let n in e.parsed)r[n]=e.parsed[n];return e}var ki=hr("prisma:tryLoadEnv");function it({rootEnvPath:e,schemaEnvPath:r},t={conflictCheck:"none"}){let n=Cs(e);t.conflictCheck!=="none"&&op(n,r,t.conflictCheck);let i=null;return Is(n?.path,r)||(i=Cs(r)),!n&&!i&&ki("No Environment variables loaded"),i?.dotenvResult.error?console.error(ue(Q("Schema Env Error: "))+i.dotenvResult.error):{message:[n?.message,i?.message].filter(Boolean).join(`
`),parsed:{...n?.dotenvResult?.parsed,...i?.dotenvResult?.parsed}}}function op(e,r,t){let n=e?.dotenvResult.parsed,i=!Is(e?.path,r);if(n&&r&&i&&node_fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(r)){let o=Di.default.parse(node_fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync(r)),s=[];for(let a in o)n[a]===o[a]&&s.push(a);if(s.length>0){let a=node_path__WEBPACK_IMPORTED_MODULE_1__.relative(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),e.path),l=node_path__WEBPACK_IMPORTED_MODULE_1__.relative(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),r);if(t==="error"){let u=`There is a conflict between env var${s.length>1?"s":""} in ${K(a)} and ${K(l)}
Conflicting env vars:
${s.map(c=>`  ${Q(c)}`).join(`
`)}

We suggest to move the contents of ${K(l)} to ${K(a)} to consolidate your env vars.
`;throw new Error(u)}else if(t==="warn"){let u=`Conflict for env var${s.length>1?"s":""} ${s.map(c=>Q(c)).join(", ")} in ${K(a)} and ${K(l)}
Env vars from ${K(l)} overwrite the ones from ${K(a)}
      `;console.warn(`${Ie("warn(prisma)")} ${u}`)}}}}function Cs(e){if(sp(e)){ki(`Environment variables loaded from ${e}`);let r=Di.default.config({path:e,debug:node_process__WEBPACK_IMPORTED_MODULE_2__.env.DOTENV_CONFIG_DEBUG?!0:void 0});return{dotenvResult:As(r),message:Ce(`Environment variables loaded from ${node_path__WEBPACK_IMPORTED_MODULE_1__.relative(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),e)}`),path:e}}else ki(`Environment variables not found at ${e}`);return null}function Is(e,r){return e&&r&&node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(e)===node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(r)}function sp(e){return!!(e&&node_fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(e))}function Oi(e,r){return Object.prototype.hasOwnProperty.call(e,r)}function xr(e,r){let t={};for(let n of Object.keys(e))t[n]=r(e[n],n);return t}function _i(e,r){if(e.length===0)return;let t=e[0];for(let n=1;n<e.length;n++)r(t,e[n])<0&&(t=e[n]);return t}function x(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var Ds=new Set,on=(e,r,...t)=>{Ds.has(e)||(Ds.add(e),Ti(r,...t))};var T=class e extends Error{clientVersion;errorCode;retryable;constructor(r,t,n){super(r),this.name="PrismaClientInitializationError",this.clientVersion=t,this.errorCode=n,Error.captureStackTrace(e)}get[Symbol.toStringTag](){return"PrismaClientInitializationError"}};x(T,"PrismaClientInitializationError");var Z=class extends Error{code;meta;clientVersion;batchRequestIdx;constructor(r,{code:t,clientVersion:n,meta:i,batchRequestIdx:o}){super(r),this.name="PrismaClientKnownRequestError",this.code=t,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PrismaClientKnownRequestError"}};x(Z,"PrismaClientKnownRequestError");var de=class extends Error{clientVersion;constructor(r,t){super(r),this.name="PrismaClientRustPanicError",this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientRustPanicError"}};x(de,"PrismaClientRustPanicError");var q=class extends Error{clientVersion;batchRequestIdx;constructor(r,{clientVersion:t,batchRequestIdx:n}){super(r),this.name="PrismaClientUnknownRequestError",this.clientVersion=t,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}get[Symbol.toStringTag](){return"PrismaClientUnknownRequestError"}};x(q,"PrismaClientUnknownRequestError");var X=class extends Error{name="PrismaClientValidationError";clientVersion;constructor(r,{clientVersion:t}){super(r),this.clientVersion=t}get[Symbol.toStringTag](){return"PrismaClientValidationError"}};x(X,"PrismaClientValidationError");var vr=9e15,Ke=1e9,Ni="0123456789abcdef",un="2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",cn="3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",Li={precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-vr,maxE:vr,crypto:!1},Ls,Le,w=!0,dn="[DecimalError] ",He=dn+"Invalid argument: ",Fs=dn+"Precision limit exceeded",Ms=dn+"crypto unavailable",$s="[object Decimal]",Y=Math.floor,B=Math.pow,ap=/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,lp=/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,up=/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,qs=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,fe=1e7,E=7,cp=9007199254740991,pp=un.length-1,Fi=cn.length-1,m={toStringTag:$s};m.absoluteValue=m.abs=function(){var e=new this.constructor(this);return e.s<0&&(e.s=1),y(e)};m.ceil=function(){return y(new this.constructor(this),this.e+1,2)};m.clampedTo=m.clamp=function(e,r){var t,n=this,i=n.constructor;if(e=new i(e),r=new i(r),!e.s||!r.s)return new i(NaN);if(e.gt(r))throw Error(He+r);return t=n.cmp(e),t<0?e:n.cmp(r)>0?r:new i(n)};m.comparedTo=m.cmp=function(e){var r,t,n,i,o=this,s=o.d,a=(e=new o.constructor(e)).d,l=o.s,u=e.s;if(!s||!a)return!l||!u?NaN:l!==u?l:s===a?0:!s^l<0?1:-1;if(!s[0]||!a[0])return s[0]?l:a[0]?-u:0;if(l!==u)return l;if(o.e!==e.e)return o.e>e.e^l<0?1:-1;for(n=s.length,i=a.length,r=0,t=n<i?n:i;r<t;++r)if(s[r]!==a[r])return s[r]>a[r]^l<0?1:-1;return n===i?0:n>i^l<0?1:-1};m.cosine=m.cos=function(){var e,r,t=this,n=t.constructor;return t.d?t.d[0]?(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=dp(n,Gs(n,t)),n.precision=e,n.rounding=r,y(Le==2||Le==3?t.neg():t,e,r,!0)):new n(1):new n(NaN)};m.cubeRoot=m.cbrt=function(){var e,r,t,n,i,o,s,a,l,u,c=this,p=c.constructor;if(!c.isFinite()||c.isZero())return new p(c);for(w=!1,o=c.s*B(c.s*c,1/3),!o||Math.abs(o)==1/0?(t=W(c.d),e=c.e,(o=(e-t.length+1)%3)&&(t+=o==1||o==-2?"0":"00"),o=B(t,1/3),e=Y((e+1)/3)-(e%3==(e<0?-1:2)),o==1/0?t="5e"+e:(t=o.toExponential(),t=t.slice(0,t.indexOf("e")+1)+e),n=new p(t),n.s=c.s):n=new p(o.toString()),s=(e=p.precision)+3;;)if(a=n,l=a.times(a).times(a),u=l.plus(c),n=_(u.plus(c).times(a),u.plus(l),s+2,1),W(a.d).slice(0,s)===(t=W(n.d)).slice(0,s))if(t=t.slice(s-3,s+1),t=="9999"||!i&&t=="4999"){if(!i&&(y(a,e+1,0),a.times(a).times(a).eq(c))){n=a;break}s+=4,i=1}else{(!+t||!+t.slice(1)&&t.charAt(0)=="5")&&(y(n,e+1,1),r=!n.times(n).times(n).eq(c));break}return w=!0,y(n,e,p.rounding,r)};m.decimalPlaces=m.dp=function(){var e,r=this.d,t=NaN;if(r){if(e=r.length-1,t=(e-Y(this.e/E))*E,e=r[e],e)for(;e%10==0;e/=10)t--;t<0&&(t=0)}return t};m.dividedBy=m.div=function(e){return _(this,new this.constructor(e))};m.dividedToIntegerBy=m.divToInt=function(e){var r=this,t=r.constructor;return y(_(r,new t(e),0,1,1),t.precision,t.rounding)};m.equals=m.eq=function(e){return this.cmp(e)===0};m.floor=function(){return y(new this.constructor(this),this.e+1,3)};m.greaterThan=m.gt=function(e){return this.cmp(e)>0};m.greaterThanOrEqualTo=m.gte=function(e){var r=this.cmp(e);return r==1||r===0};m.hyperbolicCosine=m.cosh=function(){var e,r,t,n,i,o=this,s=o.constructor,a=new s(1);if(!o.isFinite())return new s(o.s?1/0:NaN);if(o.isZero())return a;t=s.precision,n=s.rounding,s.precision=t+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i<32?(e=Math.ceil(i/3),r=(1/fn(4,e)).toString()):(e=16,r="2.3283064365386962890625e-10"),o=Pr(s,1,o.times(r),new s(1),!0);for(var l,u=e,c=new s(8);u--;)l=o.times(o),o=a.minus(l.times(c.minus(l.times(c))));return y(o,s.precision=t,s.rounding=n,!0)};m.hyperbolicSine=m.sinh=function(){var e,r,t,n,i=this,o=i.constructor;if(!i.isFinite()||i.isZero())return new o(i);if(r=o.precision,t=o.rounding,o.precision=r+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n<3)i=Pr(o,2,i,i,!0);else{e=1.4*Math.sqrt(n),e=e>16?16:e|0,i=i.times(1/fn(5,e)),i=Pr(o,2,i,i,!0);for(var s,a=new o(5),l=new o(16),u=new o(20);e--;)s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(u))))}return o.precision=r,o.rounding=t,y(i,r,t,!0)};m.hyperbolicTangent=m.tanh=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+7,n.rounding=1,_(t.sinh(),t.cosh(),n.precision=e,n.rounding=r)):new n(t.s)};m.inverseCosine=m.acos=function(){var e=this,r=e.constructor,t=e.abs().cmp(1),n=r.precision,i=r.rounding;return t!==-1?t===0?e.isNeg()?we(r,n,i):new r(0):new r(NaN):e.isZero()?we(r,n+4,i).times(.5):(r.precision=n+6,r.rounding=1,e=new r(1).minus(e).div(e.plus(1)).sqrt().atan(),r.precision=n,r.rounding=i,e.times(2))};m.inverseHyperbolicCosine=m.acosh=function(){var e,r,t=this,n=t.constructor;return t.lte(1)?new n(t.eq(1)?0:NaN):t.isFinite()?(e=n.precision,r=n.rounding,n.precision=e+Math.max(Math.abs(t.e),t.sd())+4,n.rounding=1,w=!1,t=t.times(t).minus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln()):new n(t)};m.inverseHyperbolicSine=m.asinh=function(){var e,r,t=this,n=t.constructor;return!t.isFinite()||t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+2*Math.max(Math.abs(t.e),t.sd())+6,n.rounding=1,w=!1,t=t.times(t).plus(1).sqrt().plus(t),w=!0,n.precision=e,n.rounding=r,t.ln())};m.inverseHyperbolicTangent=m.atanh=function(){var e,r,t,n,i=this,o=i.constructor;return i.isFinite()?i.e>=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,r=o.rounding,n=i.sd(),Math.max(n,e)<2*-i.e-1?y(new o(i),e,r,!0):(o.precision=t=n-i.e,i=_(i.plus(1),new o(1).minus(i),t+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=r,i.times(.5))):new o(NaN)};m.inverseSine=m.asin=function(){var e,r,t,n,i=this,o=i.constructor;return i.isZero()?new o(i):(r=i.abs().cmp(1),t=o.precision,n=o.rounding,r!==-1?r===0?(e=we(o,t+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=t+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=t,o.rounding=n,i.times(2)))};m.inverseTangent=m.atan=function(){var e,r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding;if(u.isFinite()){if(u.isZero())return new c(u);if(u.abs().eq(1)&&p+4<=Fi)return s=we(c,p+4,d).times(.25),s.s=u.s,s}else{if(!u.s)return new c(NaN);if(p+4<=Fi)return s=we(c,p+4,d).times(.5),s.s=u.s,s}for(c.precision=a=p+10,c.rounding=1,t=Math.min(28,a/E+2|0),e=t;e;--e)u=u.div(u.times(u).plus(1).sqrt().plus(1));for(w=!1,r=Math.ceil(a/E),n=1,l=u.times(u),s=new c(u),i=u;e!==-1;)if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[r]!==void 0)for(e=r;s.d[e]===o.d[e]&&e--;);return t&&(s=s.times(2<<t-1)),w=!0,y(s,c.precision=p,c.rounding=d,!0)};m.isFinite=function(){return!!this.d};m.isInteger=m.isInt=function(){return!!this.d&&Y(this.e/E)>this.d.length-2};m.isNaN=function(){return!this.s};m.isNegative=m.isNeg=function(){return this.s<0};m.isPositive=m.isPos=function(){return this.s>0};m.isZero=function(){return!!this.d&&this.d[0]===0};m.lessThan=m.lt=function(e){return this.cmp(e)<0};m.lessThanOrEqualTo=m.lte=function(e){return this.cmp(e)<1};m.logarithm=m.log=function(e){var r,t,n,i,o,s,a,l,u=this,c=u.constructor,p=c.precision,d=c.rounding,f=5;if(e==null)e=new c(10),r=!0;else{if(e=new c(e),t=e.d,e.s<0||!t||!t[0]||e.eq(1))return new c(NaN);r=e.eq(10)}if(t=u.d,u.s<0||!t||!t[0]||u.eq(1))return new c(t&&!t[0]?-1/0:u.s!=1?NaN:t?0:1/0);if(r)if(t.length>1)o=!0;else{for(i=t[0];i%10===0;)i/=10;o=i!==1}if(w=!1,a=p+f,s=Je(u,a),n=r?pn(c,a+10):Je(e,a),l=_(s,n,a,1),ot(l.d,i=p,d))do if(a+=10,s=Je(u,a),n=r?pn(c,a+10):Je(e,a),l=_(s,n,a,1),!o){+W(l.d).slice(i+1,i+15)+1==1e14&&(l=y(l,p+1,0));break}while(ot(l.d,i+=10,d));return w=!0,y(l,p,d)};m.minus=m.sub=function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,h=f.constructor;if(e=new h(e),!f.d||!e.d)return!f.s||!e.s?e=new h(NaN):f.d?e.s=-e.s:e=new h(e.d||f.s!==e.s?f:NaN),e;if(f.s!=e.s)return e.s=-e.s,f.plus(e);if(u=f.d,d=e.d,a=h.precision,l=h.rounding,!u[0]||!d[0]){if(d[0])e.s=-e.s;else if(u[0])e=new h(f);else return new h(l===3?-0:0);return w?y(e,a,l):e}if(t=Y(e.e/E),c=Y(f.e/E),u=u.slice(),o=c-t,o){for(p=o<0,p?(r=u,o=-o,s=d.length):(r=d,t=c,s=u.length),n=Math.max(Math.ceil(a/E),s)+2,o>n&&(o=n,r.length=1),r.reverse(),n=o;n--;)r.push(0);r.reverse()}else{for(n=u.length,s=d.length,p=n<s,p&&(s=n),n=0;n<s;n++)if(u[n]!=d[n]){p=u[n]<d[n];break}o=0}for(p&&(r=u,u=d,d=r,e.s=-e.s),s=u.length,n=d.length-s;n>0;--n)u[s++]=0;for(n=d.length;n>o;){if(u[--n]<d[n]){for(i=n;i&&u[--i]===0;)u[i]=fe-1;--u[i],u[n]+=fe}u[n]-=d[n]}for(;u[--s]===0;)u.pop();for(;u[0]===0;u.shift())--t;return u[0]?(e.d=u,e.e=mn(u,t),w?y(e,a,l):e):new h(l===3?-0:0)};m.modulo=m.mod=function(e){var r,t=this,n=t.constructor;return e=new n(e),!t.d||!e.s||e.d&&!e.d[0]?new n(NaN):!e.d||t.d&&!t.d[0]?y(new n(t),n.precision,n.rounding):(w=!1,n.modulo==9?(r=_(t,e.abs(),0,3,1),r.s*=e.s):r=_(t,e,0,n.modulo,1),r=r.times(e),w=!0,t.minus(r))};m.naturalExponential=m.exp=function(){return Mi(this)};m.naturalLogarithm=m.ln=function(){return Je(this)};m.negated=m.neg=function(){var e=new this.constructor(this);return e.s=-e.s,y(e)};m.plus=m.add=function(e){var r,t,n,i,o,s,a,l,u,c,p=this,d=p.constructor;if(e=new d(e),!p.d||!e.d)return!p.s||!e.s?e=new d(NaN):p.d||(e=new d(e.d||p.s===e.s?p:NaN)),e;if(p.s!=e.s)return e.s=-e.s,p.minus(e);if(u=p.d,c=e.d,a=d.precision,l=d.rounding,!u[0]||!c[0])return c[0]||(e=new d(p)),w?y(e,a,l):e;if(o=Y(p.e/E),n=Y(e.e/E),u=u.slice(),i=o-n,i){for(i<0?(t=u,i=-i,s=c.length):(t=c,n=o,s=u.length),o=Math.ceil(a/E),s=o>s?o+1:s+1,i>s&&(i=s,t.length=1),t.reverse();i--;)t.push(0);t.reverse()}for(s=u.length,i=c.length,s-i<0&&(i=s,t=c,c=u,u=t),r=0;i;)r=(u[--i]=u[i]+c[i]+r)/fe|0,u[i]%=fe;for(r&&(u.unshift(r),++n),s=u.length;u[--s]==0;)u.pop();return e.d=u,e.e=mn(u,n),w?y(e,a,l):e};m.precision=m.sd=function(e){var r,t=this;if(e!==void 0&&e!==!!e&&e!==1&&e!==0)throw Error(He+e);return t.d?(r=js(t.d),e&&t.e+1>r&&(r=t.e+1)):r=NaN,r};m.round=function(){var e=this,r=e.constructor;return y(new r(e),e.e+1,r.rounding)};m.sine=m.sin=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+Math.max(t.e,t.sd())+E,n.rounding=1,t=fp(n,Gs(n,t)),n.precision=e,n.rounding=r,y(Le>2?t.neg():t,e,r,!0)):new n(NaN)};m.squareRoot=m.sqrt=function(){var e,r,t,n,i,o,s=this,a=s.d,l=s.e,u=s.s,c=s.constructor;if(u!==1||!a||!a[0])return new c(!u||u<0&&(!a||a[0])?NaN:a?s:1/0);for(w=!1,u=Math.sqrt(+s),u==0||u==1/0?(r=W(a),(r.length+l)%2==0&&(r+="0"),u=Math.sqrt(r),l=Y((l+1)/2)-(l<0||l%2),u==1/0?r="5e"+l:(r=u.toExponential(),r=r.slice(0,r.indexOf("e")+1)+l),n=new c(r)):n=new c(u.toString()),t=(l=c.precision)+3;;)if(o=n,n=o.plus(_(s,o,t+2,1)).times(.5),W(o.d).slice(0,t)===(r=W(n.d)).slice(0,t))if(r=r.slice(t-3,t+1),r=="9999"||!i&&r=="4999"){if(!i&&(y(o,l+1,0),o.times(o).eq(s))){n=o;break}t+=4,i=1}else{(!+r||!+r.slice(1)&&r.charAt(0)=="5")&&(y(n,l+1,1),e=!n.times(n).eq(s));break}return w=!0,y(n,l,c.rounding,e)};m.tangent=m.tan=function(){var e,r,t=this,n=t.constructor;return t.isFinite()?t.isZero()?new n(t):(e=n.precision,r=n.rounding,n.precision=e+10,n.rounding=1,t=t.sin(),t.s=1,t=_(t,new n(1).minus(t.times(t)).sqrt(),e+10,0),n.precision=e,n.rounding=r,y(Le==2||Le==4?t.neg():t,e,r,!0)):new n(NaN)};m.times=m.mul=function(e){var r,t,n,i,o,s,a,l,u,c=this,p=c.constructor,d=c.d,f=(e=new p(e)).d;if(e.s*=c.s,!d||!d[0]||!f||!f[0])return new p(!e.s||d&&!d[0]&&!f||f&&!f[0]&&!d?NaN:!d||!f?e.s/0:e.s*0);for(t=Y(c.e/E)+Y(e.e/E),l=d.length,u=f.length,l<u&&(o=d,d=f,f=o,s=l,l=u,u=s),o=[],s=l+u,n=s;n--;)o.push(0);for(n=u;--n>=0;){for(r=0,i=l+n;i>n;)a=o[i]+f[n]*d[i-n-1]+r,o[i--]=a%fe|0,r=a/fe|0;o[i]=(o[i]+r)%fe|0}for(;!o[--s];)o.pop();return r?++t:o.shift(),e.d=o,e.e=mn(o,t),w?y(e,p.precision,p.rounding):e};m.toBinary=function(e,r){return $i(this,2,e,r)};m.toDecimalPlaces=m.toDP=function(e,r){var t=this,n=t.constructor;return t=new n(t),e===void 0?t:(ie(e,0,Ke),r===void 0?r=n.rounding:ie(r,0,8),y(t,e+t.e+1,r))};m.toExponential=function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=xe(n,!0):(ie(e,0,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e+1,r),t=xe(n,!0,e+1)),n.isNeg()&&!n.isZero()?"-"+t:t};m.toFixed=function(e,r){var t,n,i=this,o=i.constructor;return e===void 0?t=xe(i):(ie(e,0,Ke),r===void 0?r=o.rounding:ie(r,0,8),n=y(new o(i),e+i.e+1,r),t=xe(n,!1,e+n.e+1)),i.isNeg()&&!i.isZero()?"-"+t:t};m.toFraction=function(e){var r,t,n,i,o,s,a,l,u,c,p,d,f=this,h=f.d,g=f.constructor;if(!h)return new g(f);if(u=t=new g(1),n=l=new g(0),r=new g(n),o=r.e=js(h)-f.e-1,s=o%E,r.d[0]=B(10,s<0?E+s:s),e==null)e=o>0?r:u;else{if(a=new g(e),!a.isInt()||a.lt(u))throw Error(He+a);e=a.gt(r)?o>0?r:u:a}for(w=!1,a=new g(W(h)),c=g.precision,g.precision=o=h.length*E*2;p=_(a,r,0,1,1),i=t.plus(p.times(n)),i.cmp(e)!=1;)t=n,n=i,i=u,u=l.plus(p.times(i)),l=i,i=r,r=a.minus(p.times(i)),a=i;return i=_(e.minus(t),n,0,1,1),l=l.plus(i.times(u)),t=t.plus(i.times(n)),l.s=u.s=f.s,d=_(u,n,o,1).minus(f).abs().cmp(_(l,t,o,1).minus(f).abs())<1?[u,n]:[l,t],g.precision=c,w=!0,d};m.toHexadecimal=m.toHex=function(e,r){return $i(this,16,e,r)};m.toNearest=function(e,r){var t=this,n=t.constructor;if(t=new n(t),e==null){if(!t.d)return t;e=new n(1),r=n.rounding}else{if(e=new n(e),r===void 0?r=n.rounding:ie(r,0,8),!t.d)return e.s?t:e;if(!e.d)return e.s&&(e.s=t.s),e}return e.d[0]?(w=!1,t=_(t,e,0,r,1).times(e),w=!0,y(t)):(e.s=t.s,t=e),t};m.toNumber=function(){return+this};m.toOctal=function(e,r){return $i(this,8,e,r)};m.toPower=m.pow=function(e){var r,t,n,i,o,s,a=this,l=a.constructor,u=+(e=new l(e));if(!a.d||!e.d||!a.d[0]||!e.d[0])return new l(B(+a,u));if(a=new l(a),a.eq(1))return a;if(n=l.precision,o=l.rounding,e.eq(1))return y(a,n,o);if(r=Y(e.e/E),r>=e.d.length-1&&(t=u<0?-u:u)<=cp)return i=Vs(l,a,t,n),e.s<0?new l(1).div(i):y(i,n,o);if(s=a.s,s<0){if(r<e.d.length-1)return new l(NaN);if((e.d[r]&1)==0&&(s=1),a.e==0&&a.d[0]==1&&a.d.length==1)return a.s=s,a}return t=B(+a,u),r=t==0||!isFinite(t)?Y(u*(Math.log("0."+W(a.d))/Math.LN10+a.e+1)):new l(t+"").e,r>l.maxE+1||r<l.minE-1?new l(r>0?s/0:0):(w=!1,l.rounding=a.s=1,t=Math.min(12,(r+"").length),i=Mi(e.times(Je(a,n+t)),n),i.d&&(i=y(i,n+5,1),ot(i.d,n,o)&&(r=n+10,i=y(Mi(e.times(Je(a,r+t)),r),r+5,1),+W(i.d).slice(n+1,n+15)+1==1e14&&(i=y(i,n+1,0)))),i.s=s,w=!0,l.rounding=o,y(i,n,o))};m.toPrecision=function(e,r){var t,n=this,i=n.constructor;return e===void 0?t=xe(n,n.e<=i.toExpNeg||n.e>=i.toExpPos):(ie(e,1,Ke),r===void 0?r=i.rounding:ie(r,0,8),n=y(new i(n),e,r),t=xe(n,e<=n.e||n.e<=i.toExpNeg,e)),n.isNeg()&&!n.isZero()?"-"+t:t};m.toSignificantDigits=m.toSD=function(e,r){var t=this,n=t.constructor;return e===void 0?(e=n.precision,r=n.rounding):(ie(e,1,Ke),r===void 0?r=n.rounding:ie(r,0,8)),y(new n(t),e,r)};m.toString=function(){var e=this,r=e.constructor,t=xe(e,e.e<=r.toExpNeg||e.e>=r.toExpPos);return e.isNeg()&&!e.isZero()?"-"+t:t};m.truncated=m.trunc=function(){return y(new this.constructor(this),this.e+1,1)};m.valueOf=m.toJSON=function(){var e=this,r=e.constructor,t=xe(e,e.e<=r.toExpNeg||e.e>=r.toExpPos);return e.isNeg()?"-"+t:t};function W(e){var r,t,n,i=e.length-1,o="",s=e[0];if(i>0){for(o+=s,r=1;r<i;r++)n=e[r]+"",t=E-n.length,t&&(o+=We(t)),o+=n;s=e[r],n=s+"",t=E-n.length,t&&(o+=We(t))}else if(s===0)return"0";for(;s%10===0;)s/=10;return o+s}function ie(e,r,t){if(e!==~~e||e<r||e>t)throw Error(He+e)}function ot(e,r,t,n){var i,o,s,a;for(o=e[0];o>=10;o/=10)--r;return--r<0?(r+=E,i=0):(i=Math.ceil((r+1)/E),r%=E),o=B(10,E-r),a=e[i]%o|0,n==null?r<3?(r==0?a=a/100|0:r==1&&(a=a/10|0),s=t<4&&a==99999||t>3&&a==49999||a==5e4||a==0):s=(t<4&&a+1==o||t>3&&a+1==o/2)&&(e[i+1]/o/100|0)==B(10,r-2)-1||(a==o/2||a==0)&&(e[i+1]/o/100|0)==0:r<4?(r==0?a=a/1e3|0:r==1?a=a/100|0:r==2&&(a=a/10|0),s=(n||t<4)&&a==9999||!n&&t>3&&a==4999):s=((n||t<4)&&a+1==o||!n&&t>3&&a+1==o/2)&&(e[i+1]/o/1e3|0)==B(10,r-3)-1,s}function an(e,r,t){for(var n,i=[0],o,s=0,a=e.length;s<a;){for(o=i.length;o--;)i[o]*=r;for(i[0]+=Ni.indexOf(e.charAt(s++)),n=0;n<i.length;n++)i[n]>t-1&&(i[n+1]===void 0&&(i[n+1]=0),i[n+1]+=i[n]/t|0,i[n]%=t)}return i.reverse()}function dp(e,r){var t,n,i;if(r.isZero())return r;n=r.d.length,n<32?(t=Math.ceil(n/3),i=(1/fn(4,t)).toString()):(t=16,i="2.3283064365386962890625e-10"),e.precision+=t,r=Pr(e,1,r.times(i),new e(1));for(var o=t;o--;){var s=r.times(r);r=s.times(s).minus(s).times(8).plus(1)}return e.precision-=t,r}var _=function(){function e(n,i,o){var s,a=0,l=n.length;for(n=n.slice();l--;)s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;return a&&n.unshift(a),n}function r(n,i,o,s){var a,l;if(o!=s)l=o>s?1:-1;else for(a=l=0;a<o;a++)if(n[a]!=i[a]){l=n[a]>i[a]?1:-1;break}return l}function t(n,i,o,s){for(var a=0;o--;)n[o]-=a,a=n[o]<i[o]?1:0,n[o]=a*s+n[o]-i[o];for(;!n[0]&&n.length>1;)n.shift()}return function(n,i,o,s,a,l){var u,c,p,d,f,h,g,S,P,R,b,k,me,se,Wr,j,re,Ae,J,mr,Mt=n.constructor,Hn=n.s==i.s?1:-1,H=n.d,O=i.d;if(!H||!H[0]||!O||!O[0])return new Mt(!n.s||!i.s||(H?O&&H[0]==O[0]:!O)?NaN:H&&H[0]==0||!O?Hn*0:Hn/0);for(l?(f=1,c=n.e-i.e):(l=fe,f=E,c=Y(n.e/f)-Y(i.e/f)),J=O.length,re=H.length,P=new Mt(Hn),R=P.d=[],p=0;O[p]==(H[p]||0);p++);if(O[p]>(H[p]||0)&&c--,o==null?(se=o=Mt.precision,s=Mt.rounding):a?se=o+(n.e-i.e)+1:se=o,se<0)R.push(1),h=!0;else{if(se=se/f+2|0,p=0,J==1){for(d=0,O=O[0],se++;(p<re||d)&&se--;p++)Wr=d*l+(H[p]||0),R[p]=Wr/O|0,d=Wr%O|0;h=d||p<re}else{for(d=l/(O[0]+1)|0,d>1&&(O=e(O,d,l),H=e(H,d,l),J=O.length,re=H.length),j=J,b=H.slice(0,J),k=b.length;k<J;)b[k++]=0;mr=O.slice(),mr.unshift(0),Ae=O[0],O[1]>=l/2&&++Ae;do d=0,u=r(O,b,J,k),u<0?(me=b[0],J!=k&&(me=me*l+(b[1]||0)),d=me/Ae|0,d>1?(d>=l&&(d=l-1),g=e(O,d,l),S=g.length,k=b.length,u=r(g,b,S,k),u==1&&(d--,t(g,J<S?mr:O,S,l))):(d==0&&(u=d=1),g=O.slice()),S=g.length,S<k&&g.unshift(0),t(b,g,k,l),u==-1&&(k=b.length,u=r(O,b,J,k),u<1&&(d++,t(b,J<k?mr:O,k,l))),k=b.length):u===0&&(d++,b=[0]),R[p++]=d,u&&b[0]?b[k++]=H[j]||0:(b=[H[j]],k=1);while((j++<re||b[0]!==void 0)&&se--);h=b[0]!==void 0}R[0]||R.shift()}if(f==1)P.e=c,Ls=h;else{for(p=1,d=R[0];d>=10;d/=10)p++;P.e=p+c*f-1,y(P,a?o+P.e+1:o,s,h)}return P}}();function y(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor;e:if(r!=null){if(p=e.d,!p)return e;for(i=1,a=p[0];a>=10;a/=10)i++;if(o=r-i,o<0)o+=E,s=r,c=p[d=0],l=c/B(10,i-s-1)%10|0;else if(d=Math.ceil((o+1)/E),a=p.length,d>=a)if(n){for(;a++<=d;)p.push(0);c=l=0,i=1,o%=E,s=o-E+1}else break e;else{for(c=a=p[d],i=1;a>=10;a/=10)i++;o%=E,s=o-E+i,l=s<0?0:c/B(10,i-s-1)%10|0}if(n=n||r<0||p[d+1]!==void 0||(s<0?c:c%B(10,i-s-1)),u=t<4?(l||n)&&(t==0||t==(e.s<0?3:2)):l>5||l==5&&(t==4||n||t==6&&(o>0?s>0?c/B(10,i-s):0:p[d-1])%10&1||t==(e.s<0?8:7)),r<1||!p[0])return p.length=0,u?(r-=e.e+1,p[0]=B(10,(E-r%E)%E),e.e=-r||0):p[0]=e.e=0,e;if(o==0?(p.length=d,a=1,d--):(p.length=d+1,a=B(10,E-o),p[d]=s>0?(c/B(10,i-s)%B(10,s)|0)*a:0),u)for(;;)if(d==0){for(o=1,s=p[0];s>=10;s/=10)o++;for(s=p[0]+=a,a=1;s>=10;s/=10)a++;o!=a&&(e.e++,p[0]==fe&&(p[0]=1));break}else{if(p[d]+=a,p[d]!=fe)break;p[d--]=0,a=1}for(o=p.length;p[--o]===0;)p.pop()}return w&&(e.e>f.maxE?(e.d=null,e.e=NaN):e.e<f.minE&&(e.e=0,e.d=[0])),e}function xe(e,r,t){if(!e.isFinite())return Us(e);var n,i=e.e,o=W(e.d),s=o.length;return r?(t&&(n=t-s)>0?o=o.charAt(0)+"."+o.slice(1)+We(n):s>1&&(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e<0?"e":"e+")+e.e):i<0?(o="0."+We(-i-1)+o,t&&(n=t-s)>0&&(o+=We(n))):i>=s?(o+=We(i+1-s),t&&(n=t-i-1)>0&&(o=o+"."+We(n))):((n=i+1)<s&&(o=o.slice(0,n)+"."+o.slice(n)),t&&(n=t-s)>0&&(i+1===s&&(o+="."),o+=We(n))),o}function mn(e,r){var t=e[0];for(r*=E;t>=10;t/=10)r++;return r}function pn(e,r,t){if(r>pp)throw w=!0,t&&(e.precision=t),Error(Fs);return y(new e(un),r,1,!0)}function we(e,r,t){if(r>Fi)throw Error(Fs);return y(new e(cn),r,t,!0)}function js(e){var r=e.length-1,t=r*E+1;if(r=e[r],r){for(;r%10==0;r/=10)t--;for(r=e[0];r>=10;r/=10)t++}return t}function We(e){for(var r="";e--;)r+="0";return r}function Vs(e,r,t,n){var i,o=new e(1),s=Math.ceil(n/E+4);for(w=!1;;){if(t%2&&(o=o.times(r),_s(o.d,s)&&(i=!0)),t=Y(t/2),t===0){t=o.d.length-1,i&&o.d[t]===0&&++o.d[t];break}r=r.times(r),_s(r.d,s)}return w=!0,o}function Os(e){return e.d[e.d.length-1]&1}function Bs(e,r,t){for(var n,i,o=new e(r[0]),s=0;++s<r.length;){if(i=new e(r[s]),!i.s){o=i;break}n=o.cmp(i),(n===t||n===0&&o.s===t)&&(o=i)}return o}function Mi(e,r){var t,n,i,o,s,a,l,u=0,c=0,p=0,d=e.constructor,f=d.rounding,h=d.precision;if(!e.d||!e.d[0]||e.e>17)return new d(e.d?e.d[0]?e.s<0?0:1/0:1:e.s?e.s<0?0:e:NaN);for(r==null?(w=!1,l=h):l=r,a=new d(.03125);e.e>-2;)e=e.times(a),p+=5;for(n=Math.log(B(2,p))/Math.LN10*2+5|0,l+=n,t=o=s=new d(1),d.precision=l;;){if(o=y(o.times(e),l,1),t=t.times(++c),a=s.plus(_(o,t,l,1)),W(a.d).slice(0,l)===W(s.d).slice(0,l)){for(i=p;i--;)s=y(s.times(s),l,1);if(r==null)if(u<3&&ot(s.d,l-n,f,u))d.precision=l+=10,t=o=a=new d(1),c=0,u++;else return y(s,d.precision=h,f,w=!0);else return d.precision=h,s}s=a}}function Je(e,r){var t,n,i,o,s,a,l,u,c,p,d,f=1,h=10,g=e,S=g.d,P=g.constructor,R=P.rounding,b=P.precision;if(g.s<0||!S||!S[0]||!g.e&&S[0]==1&&S.length==1)return new P(S&&!S[0]?-1/0:g.s!=1?NaN:S?0:g);if(r==null?(w=!1,c=b):c=r,P.precision=c+=h,t=W(S),n=t.charAt(0),Math.abs(o=g.e)<15e14){for(;n<7&&n!=1||n==1&&t.charAt(1)>3;)g=g.times(e),t=W(g.d),n=t.charAt(0),f++;o=g.e,n>1?(g=new P("0."+t),o++):g=new P(n+"."+t.slice(1))}else return u=pn(P,c+2,b).times(o+""),g=Je(new P(n+"."+t.slice(1)),c-h).plus(u),P.precision=b,r==null?y(g,b,R,w=!0):g;for(p=g,l=s=g=_(g.minus(1),g.plus(1),c,1),d=y(g.times(g),c,1),i=3;;){if(s=y(s.times(d),c,1),u=l.plus(_(s,new P(i),c,1)),W(u.d).slice(0,c)===W(l.d).slice(0,c))if(l=l.times(2),o!==0&&(l=l.plus(pn(P,c+2,b).times(o+""))),l=_(l,new P(f),c,1),r==null)if(ot(l.d,c-h,R,a))P.precision=c+=h,u=s=g=_(p.minus(1),p.plus(1),c,1),d=y(g.times(g),c,1),i=a=1;else return y(l,P.precision=b,R,w=!0);else return P.precision=b,l;l=u,i+=2}}function Us(e){return String(e.s*e.s/0)}function ln(e,r){var t,n,i;for((t=r.indexOf("."))>-1&&(r=r.replace(".","")),(n=r.search(/e/i))>0?(t<0&&(t=n),t+=+r.slice(n+1),r=r.substring(0,n)):t<0&&(t=r.length),n=0;r.charCodeAt(n)===48;n++);for(i=r.length;r.charCodeAt(i-1)===48;--i);if(r=r.slice(n,i),r){if(i-=n,e.e=t=t-n-1,e.d=[],n=(t+1)%E,t<0&&(n+=E),n<i){for(n&&e.d.push(+r.slice(0,n)),i-=E;n<i;)e.d.push(+r.slice(n,n+=E));r=r.slice(n),n=E-r.length}else n-=i;for(;n--;)r+="0";e.d.push(+r),w&&(e.e>e.constructor.maxE?(e.d=null,e.e=NaN):e.e<e.constructor.minE&&(e.e=0,e.d=[0]))}else e.e=0,e.d=[0];return e}function mp(e,r){var t,n,i,o,s,a,l,u,c;if(r.indexOf("_")>-1){if(r=r.replace(/(\d)_(?=\d)/g,"$1"),qs.test(r))return ln(e,r)}else if(r==="Infinity"||r==="NaN")return+r||(e.s=NaN),e.e=NaN,e.d=null,e;if(lp.test(r))t=16,r=r.toLowerCase();else if(ap.test(r))t=2;else if(up.test(r))t=8;else throw Error(He+r);for(o=r.search(/p/i),o>0?(l=+r.slice(o+1),r=r.substring(2,o)):r=r.slice(2),o=r.indexOf("."),s=o>=0,n=e.constructor,s&&(r=r.replace(".",""),a=r.length,o=a-o,i=Vs(n,new n(t),o,o*2)),u=an(r,t,fe),c=u.length-1,o=c;u[o]===0;--o)u.pop();return o<0?new n(e.s*0):(e.e=mn(u,c),e.d=u,w=!1,s&&(e=_(e,i,a*4)),l&&(e=e.times(Math.abs(l)<54?B(2,l):sr.pow(2,l))),w=!0,e)}function fp(e,r){var t,n=r.d.length;if(n<3)return r.isZero()?r:Pr(e,2,r,r);t=1.4*Math.sqrt(n),t=t>16?16:t|0,r=r.times(1/fn(5,t)),r=Pr(e,2,r,r);for(var i,o=new e(5),s=new e(16),a=new e(20);t--;)i=r.times(r),r=r.times(o.plus(i.times(s.times(i).minus(a))));return r}function Pr(e,r,t,n,i){var o,s,a,l,u=1,c=e.precision,p=Math.ceil(c/E);for(w=!1,l=t.times(t),a=new e(n);;){if(s=_(a.times(l),new e(r++*r++),c,1),a=i?n.plus(s):n.minus(s),n=_(s.times(l),new e(r++*r++),c,1),s=a.plus(n),s.d[p]!==void 0){for(o=p;s.d[o]===a.d[o]&&o--;);if(o==-1)break}o=a,a=n,n=s,s=o,u++}return w=!0,s.d.length=p+1,s}function fn(e,r){for(var t=e;--r;)t*=e;return t}function Gs(e,r){var t,n=r.s<0,i=we(e,e.precision,1),o=i.times(.5);if(r=r.abs(),r.lte(o))return Le=n?4:1,r;if(t=r.divToInt(i),t.isZero())Le=n?3:2;else{if(r=r.minus(t.times(i)),r.lte(o))return Le=Os(t)?n?2:3:n?4:1,r;Le=Os(t)?n?1:4:n?3:2}return r.minus(i).abs()}function $i(e,r,t,n){var i,o,s,a,l,u,c,p,d,f=e.constructor,h=t!==void 0;if(h?(ie(t,1,Ke),n===void 0?n=f.rounding:ie(n,0,8)):(t=f.precision,n=f.rounding),!e.isFinite())c=Us(e);else{for(c=xe(e),s=c.indexOf("."),h?(i=2,r==16?t=t*4-3:r==8&&(t=t*3-2)):i=r,s>=0&&(c=c.replace(".",""),d=new f(1),d.e=c.length-s,d.d=an(xe(d),10,i),d.e=d.d.length),p=an(c,10,i),o=l=p.length;p[--l]==0;)p.pop();if(!p[0])c=h?"0p+0":"0";else{if(s<0?o--:(e=new f(e),e.d=p,e.e=o,e=_(e,d,t,n,0,i),p=e.d,o=e.e,u=Ls),s=p[t],a=i/2,u=u||p[t+1]!==void 0,u=n<4?(s!==void 0||u)&&(n===0||n===(e.s<0?3:2)):s>a||s===a&&(n===4||u||n===6&&p[t-1]&1||n===(e.s<0?8:7)),p.length=t,u)for(;++p[--t]>i-1;)p[t]=0,t||(++o,p.unshift(1));for(l=p.length;!p[l-1];--l);for(s=0,c="";s<l;s++)c+=Ni.charAt(p[s]);if(h){if(l>1)if(r==16||r==8){for(s=r==16?4:3,--l;l%s;l++)c+="0";for(p=an(c,i,r),l=p.length;!p[l-1];--l);for(s=1,c="1.";s<l;s++)c+=Ni.charAt(p[s])}else c=c.charAt(0)+"."+c.slice(1);c=c+(o<0?"p":"p+")+o}else if(o<0){for(;++o;)c="0"+c;c="0."+c}else if(++o>l)for(o-=l;o--;)c+="0";else o<l&&(c=c.slice(0,o)+"."+c.slice(o))}c=(r==16?"0x":r==2?"0b":r==8?"0o":"")+c}return e.s<0?"-"+c:c}function _s(e,r){if(e.length>r)return e.length=r,!0}function gp(e){return new this(e).abs()}function hp(e){return new this(e).acos()}function yp(e){return new this(e).acosh()}function bp(e,r){return new this(e).plus(r)}function Ep(e){return new this(e).asin()}function wp(e){return new this(e).asinh()}function xp(e){return new this(e).atan()}function vp(e){return new this(e).atanh()}function Pp(e,r){e=new this(e),r=new this(r);var t,n=this.precision,i=this.rounding,o=n+4;return!e.s||!r.s?t=new this(NaN):!e.d&&!r.d?(t=we(this,o,1).times(r.s>0?.25:.75),t.s=e.s):!r.d||e.isZero()?(t=r.s<0?we(this,n,i):new this(0),t.s=e.s):!e.d||r.isZero()?(t=we(this,o,1).times(.5),t.s=e.s):r.s<0?(this.precision=o,this.rounding=1,t=this.atan(_(e,r,o,1)),r=we(this,o,1),this.precision=n,this.rounding=i,t=e.s<0?t.minus(r):t.plus(r)):t=this.atan(_(e,r,o,1)),t}function Tp(e){return new this(e).cbrt()}function Sp(e){return y(e=new this(e),e.e+1,2)}function Rp(e,r,t){return new this(e).clamp(r,t)}function Ap(e){if(!e||typeof e!="object")throw Error(dn+"Object expected");var r,t,n,i=e.defaults===!0,o=["precision",1,Ke,"rounding",0,8,"toExpNeg",-vr,0,"toExpPos",0,vr,"maxE",0,vr,"minE",-vr,0,"modulo",0,9];for(r=0;r<o.length;r+=3)if(t=o[r],i&&(this[t]=Li[t]),(n=e[t])!==void 0)if(Y(n)===n&&n>=o[r+1]&&n<=o[r+2])this[t]=n;else throw Error(He+t+": "+n);if(t="crypto",i&&(this[t]=Li[t]),(n=e[t])!==void 0)if(n===!0||n===!1||n===0||n===1)if(n)if(typeof crypto<"u"&&crypto&&(crypto.getRandomValues||crypto.randomBytes))this[t]=!0;else throw Error(Ms);else this[t]=!1;else throw Error(He+t+": "+n);return this}function Cp(e){return new this(e).cos()}function Ip(e){return new this(e).cosh()}function Qs(e){var r,t,n;function i(o){var s,a,l,u=this;if(!(u instanceof i))return new i(o);if(u.constructor=i,Ns(o)){u.s=o.s,w?!o.d||o.e>i.maxE?(u.e=NaN,u.d=null):o.e<i.minE?(u.e=0,u.d=[0]):(u.e=o.e,u.d=o.d.slice()):(u.e=o.e,u.d=o.d?o.d.slice():o.d);return}if(l=typeof o,l==="number"){if(o===0){u.s=1/o<0?-1:1,u.e=0,u.d=[0];return}if(o<0?(o=-o,u.s=-1):u.s=1,o===~~o&&o<1e7){for(s=0,a=o;a>=10;a/=10)s++;w?s>i.maxE?(u.e=NaN,u.d=null):s<i.minE?(u.e=0,u.d=[0]):(u.e=s,u.d=[o]):(u.e=s,u.d=[o]);return}if(o*0!==0){o||(u.s=NaN),u.e=NaN,u.d=null;return}return ln(u,o.toString())}if(l==="string")return(a=o.charCodeAt(0))===45?(o=o.slice(1),u.s=-1):(a===43&&(o=o.slice(1)),u.s=1),qs.test(o)?ln(u,o):mp(u,o);if(l==="bigint")return o<0?(o=-o,u.s=-1):u.s=1,ln(u,o.toString());throw Error(He+o)}if(i.prototype=m,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Ap,i.clone=Qs,i.isDecimal=Ns,i.abs=gp,i.acos=hp,i.acosh=yp,i.add=bp,i.asin=Ep,i.asinh=wp,i.atan=xp,i.atanh=vp,i.atan2=Pp,i.cbrt=Tp,i.ceil=Sp,i.clamp=Rp,i.cos=Cp,i.cosh=Ip,i.div=kp,i.exp=Dp,i.floor=Op,i.hypot=_p,i.ln=Np,i.log=Lp,i.log10=Mp,i.log2=Fp,i.max=$p,i.min=qp,i.mod=jp,i.mul=Vp,i.pow=Bp,i.random=Up,i.round=Gp,i.sign=Qp,i.sin=Wp,i.sinh=Jp,i.sqrt=Hp,i.sub=Kp,i.sum=Yp,i.tan=zp,i.tanh=Zp,i.trunc=Xp,e===void 0&&(e={}),e&&e.defaults!==!0)for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],r=0;r<n.length;)e.hasOwnProperty(t=n[r++])||(e[t]=this[t]);return i.config(e),i}function kp(e,r){return new this(e).div(r)}function Dp(e){return new this(e).exp()}function Op(e){return y(e=new this(e),e.e+1,3)}function _p(){var e,r,t=new this(0);for(w=!1,e=0;e<arguments.length;)if(r=new this(arguments[e++]),r.d)t.d&&(t=t.plus(r.times(r)));else{if(r.s)return w=!0,new this(1/0);t=r}return w=!0,t.sqrt()}function Ns(e){return e instanceof sr||e&&e.toStringTag===$s||!1}function Np(e){return new this(e).ln()}function Lp(e,r){return new this(e).log(r)}function Fp(e){return new this(e).log(2)}function Mp(e){return new this(e).log(10)}function $p(){return Bs(this,arguments,-1)}function qp(){return Bs(this,arguments,1)}function jp(e,r){return new this(e).mod(r)}function Vp(e,r){return new this(e).mul(r)}function Bp(e,r){return new this(e).pow(r)}function Up(e){var r,t,n,i,o=0,s=new this(1),a=[];if(e===void 0?e=this.precision:ie(e,1,Ke),n=Math.ceil(e/E),this.crypto)if(crypto.getRandomValues)for(r=crypto.getRandomValues(new Uint32Array(n));o<n;)i=r[o],i>=429e7?r[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else if(crypto.randomBytes){for(r=crypto.randomBytes(n*=4);o<n;)i=r[o]+(r[o+1]<<8)+(r[o+2]<<16)+((r[o+3]&127)<<24),i>=214e7?crypto.randomBytes(4).copy(r,o):(a.push(i%1e7),o+=4);o=n/4}else throw Error(Ms);else for(;o<n;)a[o++]=Math.random()*1e7|0;for(n=a[--o],e%=E,n&&e&&(i=B(10,E-e),a[o]=(n/i|0)*i);a[o]===0;o--)a.pop();if(o<0)t=0,a=[0];else{for(t=-1;a[0]===0;t-=E)a.shift();for(n=1,i=a[0];i>=10;i/=10)n++;n<E&&(t-=E-n)}return s.e=t,s.d=a,s}function Gp(e){return y(e=new this(e),e.e+1,this.rounding)}function Qp(e){return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}function Wp(e){return new this(e).sin()}function Jp(e){return new this(e).sinh()}function Hp(e){return new this(e).sqrt()}function Kp(e,r){return new this(e).sub(r)}function Yp(){var e=0,r=arguments,t=new this(r[e]);for(w=!1;t.s&&++e<r.length;)t=t.plus(r[e]);return w=!0,y(t,this.precision,this.rounding)}function zp(e){return new this(e).tan()}function Zp(e){return new this(e).tanh()}function Xp(e){return y(e=new this(e),e.e+1,1)}m[Symbol.for("nodejs.util.inspect.custom")]=m.toString;m[Symbol.toStringTag]="Decimal";var sr=m.constructor=Qs(Li);un=new sr(un);cn=new sr(cn);var Fe=sr;function st(e){return e===null?e:Array.isArray(e)?e.map(st):typeof e=="object"?ed(e)?rd(e):e.constructor!==null&&e.constructor.name!=="Object"?e:xr(e,st):e}function ed(e){return e!==null&&typeof e=="object"&&typeof e.$type=="string"}function rd({$type:e,value:r}){switch(e){case"BigInt":return BigInt(r);case"Bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"DateTime":return new Date(r);case"Decimal":return new Fe(r);case"Json":return JSON.parse(r);default:_e(r,"Unknown tagged value")}}var ve=class{_map=new Map;get(r){return this._map.get(r)?.value}set(r,t){this._map.set(r,{value:t})}getOrCreate(r,t){let n=this._map.get(r);if(n)return n.value;let i=t();return this.set(r,i),i}};function Ye(e){return e.substring(0,1).toLowerCase()+e.substring(1)}function Ws(e,r){let t={};for(let n of e){let i=n[r];t[i]=n}return t}function at(e){let r;return{get(){return r||(r={value:e()}),r.value}}}function td(e){return{models:qi(e.models),enums:qi(e.enums),types:qi(e.types)}}function qi(e){let r={};for(let{name:t,...n}of e)r[t]=n;return r}function Tr(e){return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}function gn(e){return e.toString()!=="Invalid Date"}function Sr(e){return sr.isDecimal(e)?!0:e!==null&&typeof e=="object"&&typeof e.s=="number"&&typeof e.e=="number"&&typeof e.toFixed=="function"&&Array.isArray(e.d)}var hn={};gr(hn,{ModelAction:()=>Rr,datamodelEnumToSchemaEnum:()=>nd});function nd(e){return{name:e.name,values:e.values.map(r=>r.name)}}var Rr=(b=>(b.findUnique="findUnique",b.findUniqueOrThrow="findUniqueOrThrow",b.findFirst="findFirst",b.findFirstOrThrow="findFirstOrThrow",b.findMany="findMany",b.create="create",b.createMany="createMany",b.createManyAndReturn="createManyAndReturn",b.update="update",b.updateMany="updateMany",b.updateManyAndReturn="updateManyAndReturn",b.upsert="upsert",b.delete="delete",b.deleteMany="deleteMany",b.groupBy="groupBy",b.count="count",b.aggregate="aggregate",b.findRaw="findRaw",b.aggregateRaw="aggregateRaw",b))(Rr||{});var Ys=ne(xi());var Js={keyword:ke,entity:ke,value:e=>Q(tr(e)),punctuation:tr,directive:ke,function:ke,variable:e=>Q(tr(e)),string:e=>Q(qe(e)),boolean:Ie,number:ke,comment:Jr};var id=e=>e,yn={},od=0,v={manual:yn.Prism&&yn.Prism.manual,disableWorkerMessageHandler:yn.Prism&&yn.Prism.disableWorkerMessageHandler,util:{encode:function(e){if(e instanceof ge){let r=e;return new ge(r.type,v.util.encode(r.content),r.alias)}else return Array.isArray(e)?e.map(v.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++od}),e.__id},clone:function e(r,t){let n,i,o=v.util.type(r);switch(t=t||{},o){case"Object":if(i=v.util.objId(r),t[i])return t[i];n={},t[i]=n;for(let s in r)r.hasOwnProperty(s)&&(n[s]=e(r[s],t));return n;case"Array":return i=v.util.objId(r),t[i]?t[i]:(n=[],t[i]=n,r.forEach(function(s,a){n[a]=e(s,t)}),n);default:return r}}},languages:{extend:function(e,r){let t=v.util.clone(v.languages[e]);for(let n in r)t[n]=r[n];return t},insertBefore:function(e,r,t,n){n=n||v.languages;let i=n[e],o={};for(let a in i)if(i.hasOwnProperty(a)){if(a==r)for(let l in t)t.hasOwnProperty(l)&&(o[l]=t[l]);t.hasOwnProperty(a)||(o[a]=i[a])}let s=n[e];return n[e]=o,v.languages.DFS(v.languages,function(a,l){l===s&&a!=e&&(this[a]=o)}),o},DFS:function e(r,t,n,i){i=i||{};let o=v.util.objId;for(let s in r)if(r.hasOwnProperty(s)){t.call(r,s,r[s],n||s);let a=r[s],l=v.util.type(a);l==="Object"&&!i[o(a)]?(i[o(a)]=!0,e(a,t,null,i)):l==="Array"&&!i[o(a)]&&(i[o(a)]=!0,e(a,t,s,i))}}},plugins:{},highlight:function(e,r,t){let n={code:e,grammar:r,language:t};return v.hooks.run("before-tokenize",n),n.tokens=v.tokenize(n.code,n.grammar),v.hooks.run("after-tokenize",n),ge.stringify(v.util.encode(n.tokens),n.language)},matchGrammar:function(e,r,t,n,i,o,s){for(let g in t){if(!t.hasOwnProperty(g)||!t[g])continue;if(g==s)return;let S=t[g];S=v.util.type(S)==="Array"?S:[S];for(let P=0;P<S.length;++P){let R=S[P],b=R.inside,k=!!R.lookbehind,me=!!R.greedy,se=0,Wr=R.alias;if(me&&!R.pattern.global){let j=R.pattern.toString().match(/[imuy]*$/)[0];R.pattern=RegExp(R.pattern.source,j+"g")}R=R.pattern||R;for(let j=n,re=i;j<r.length;re+=r[j].length,++j){let Ae=r[j];if(r.length>e.length)return;if(Ae instanceof ge)continue;if(me&&j!=r.length-1){R.lastIndex=re;var p=R.exec(e);if(!p)break;var c=p.index+(k?p[1].length:0),d=p.index+p[0].length,a=j,l=re;for(let O=r.length;a<O&&(l<d||!r[a].type&&!r[a-1].greedy);++a)l+=r[a].length,c>=l&&(++j,re=l);if(r[j]instanceof ge)continue;u=a-j,Ae=e.slice(re,l),p.index-=re}else{R.lastIndex=0;var p=R.exec(Ae),u=1}if(!p){if(o)break;continue}k&&(se=p[1]?p[1].length:0);var c=p.index+se,p=p[0].slice(se),d=c+p.length,f=Ae.slice(0,c),h=Ae.slice(d);let J=[j,u];f&&(++j,re+=f.length,J.push(f));let mr=new ge(g,b?v.tokenize(p,b):p,Wr,p,me);if(J.push(mr),h&&J.push(h),Array.prototype.splice.apply(r,J),u!=1&&v.matchGrammar(e,r,t,j,re,!0,g),o)break}}}},tokenize:function(e,r){let t=[e],n=r.rest;if(n){for(let i in n)r[i]=n[i];delete r.rest}return v.matchGrammar(e,t,r,0,0,!1),t},hooks:{all:{},add:function(e,r){let t=v.hooks.all;t[e]=t[e]||[],t[e].push(r)},run:function(e,r){let t=v.hooks.all[e];if(!(!t||!t.length))for(var n=0,i;i=t[n++];)i(r)}},Token:ge};v.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,boolean:/\b(?:true|false)\b/,function:/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};v.languages.javascript=v.languages.extend("clike",{"class-name":[v.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},{pattern:/(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],number:/\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/,function:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/});v.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;v.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/,lookbehind:!0,inside:v.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i,inside:v.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/,lookbehind:!0,inside:v.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/,lookbehind:!0,inside:v.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/});v.languages.markup&&v.languages.markup.tag.addInlined("script","javascript");v.languages.js=v.languages.javascript;v.languages.typescript=v.languages.extend("javascript",{keyword:/\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/,builtin:/\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/});v.languages.ts=v.languages.typescript;function ge(e,r,t,n,i){this.type=e,this.content=r,this.alias=t,this.length=(n||"").length|0,this.greedy=!!i}ge.stringify=function(e,r){return typeof e=="string"?e:Array.isArray(e)?e.map(function(t){return ge.stringify(t,r)}).join(""):sd(e.type)(e.content)};function sd(e){return Js[e]||id}function Hs(e){return ad(e,v.languages.javascript)}function ad(e,r){return v.tokenize(e,r).map(n=>ge.stringify(n)).join("")}function Ks(e){return Ei(e)}var bn=class e{firstLineNumber;lines;static read(r){let t;try{t=node_fs__WEBPACK_IMPORTED_MODULE_4__.readFileSync(r,"utf-8")}catch{return null}return e.fromContent(t)}static fromContent(r){let t=r.split(/\r?\n/);return new e(1,t)}constructor(r,t){this.firstLineNumber=r,this.lines=t}get lastLineNumber(){return this.firstLineNumber+this.lines.length-1}mapLineAt(r,t){if(r<this.firstLineNumber||r>this.lines.length+this.firstLineNumber)return this;let n=r-this.firstLineNumber,i=[...this.lines];return i[n]=t(i[n]),new e(this.firstLineNumber,i)}mapLines(r){return new e(this.firstLineNumber,this.lines.map((t,n)=>r(t,this.firstLineNumber+n)))}lineAt(r){return this.lines[r-this.firstLineNumber]}prependSymbolAt(r,t){return this.mapLines((n,i)=>i===r?`${t} ${n}`:`  ${n}`)}slice(r,t){let n=this.lines.slice(r-1,t).join(`
`);return new e(r,Ks(n).split(`
`))}highlight(){let r=Hs(this.toString());return new e(this.firstLineNumber,r.split(`
`))}toString(){return this.lines.join(`
`)}};var ud={red:ue,gray:Jr,dim:Ce,bold:Q,underline:K,highlightSource:e=>e.highlight()},cd={red:e=>e,gray:e=>e,dim:e=>e,bold:e=>e,underline:e=>e,highlightSource:e=>e};function pd({message:e,originalMethod:r,isPanic:t,callArguments:n}){return{functionName:`prisma.${r}()`,message:e,isPanic:t??!1,callArguments:n}}function dd({callsite:e,message:r,originalMethod:t,isPanic:n,callArguments:i},o){let s=pd({message:r,originalMethod:t,isPanic:n,callArguments:i});if(!e||typeof window<"u"||"development"==="production")return s;let a=e.getLocation();if(!a||!a.lineNumber||!a.columnNumber)return s;let l=Math.max(1,a.lineNumber-3),u=bn.read(a.fileName)?.slice(l,a.lineNumber),c=u?.lineAt(a.lineNumber);if(u&&c){let p=fd(c),d=md(c);if(!d)return s;s.functionName=`${d.code})`,s.location=a,n||(u=u.mapLineAt(a.lineNumber,h=>h.slice(0,d.openingBraceIndex))),u=o.highlightSource(u);let f=String(u.lastLineNumber).length;if(s.contextLines=u.mapLines((h,g)=>o.gray(String(g).padStart(f))+" "+h).mapLines(h=>o.dim(h)).prependSymbolAt(a.lineNumber,o.bold(o.red("\u2192"))),i){let h=p+f+1;h+=2,s.callArguments=(0,Ys.default)(i,h).slice(h)}}return s}function md(e){let r=Object.keys(Rr).join("|"),n=new RegExp(String.raw`\.(${r})\(`).exec(e);if(n){let i=n.index+n[0].length,o=e.lastIndexOf(" ",n.index)+1;return{code:e.slice(o,i),openingBraceIndex:i}}return null}function fd(e){let r=0;for(let t=0;t<e.length;t++){if(e.charAt(t)!==" ")return r;r++}return r}function gd({functionName:e,location:r,message:t,isPanic:n,contextLines:i,callArguments:o},s){let a=[""],l=r?" in":":";if(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),r&&a.push(s.underline(hd(r))),i){a.push("");let u=[i.toString()];o&&(u.push(o),u.push(s.dim(")"))),a.push(u.join("")),o&&a.push("")}else a.push(""),o&&a.push(o),a.push("");return a.push(t),a.join(`
`)}function hd(e){let r=[e.fileName];return e.lineNumber&&r.push(String(e.lineNumber)),e.columnNumber&&r.push(String(e.columnNumber)),r.join(":")}function En(e){let r=e.showColors?ud:cd,t;return t=dd(e,r),gd(t,r)}var oa=ne(ji());function ea(e,r,t){let n=ra(e),i=yd(n),o=Ed(i);o?wn(o,r,t):r.addErrorMessage(()=>"Unknown error")}function ra(e){return e.errors.flatMap(r=>r.kind==="Union"?ra(r):[r])}function yd(e){let r=new Map,t=[];for(let n of e){if(n.kind!=="InvalidArgumentType"){t.push(n);continue}let i=`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,o=r.get(i);o?r.set(i,{...n,argument:{...n.argument,typeNames:bd(o.argument.typeNames,n.argument.typeNames)}}):r.set(i,n)}return t.push(...r.values()),t}function bd(e,r){return[...new Set(e.concat(r))]}function Ed(e){return _i(e,(r,t)=>{let n=Zs(r),i=Zs(t);return n!==i?n-i:Xs(r)-Xs(t)})}function Zs(e){let r=0;return Array.isArray(e.selectionPath)&&(r+=e.selectionPath.length),Array.isArray(e.argumentPath)&&(r+=e.argumentPath.length),r}function Xs(e){switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":return 20;case"InvalidArgumentType":return 10;case"RequiredArgumentMissing":return-10;default:return 0}}var ae=class{constructor(r,t){this.name=r;this.value=t}isRequired=!1;makeRequired(){return this.isRequired=!0,this}write(r){let{colors:{green:t}}=r.context;r.addMarginSymbol(t(this.isRequired?"+":"?")),r.write(t(this.name)),this.isRequired||r.write(t("?")),r.write(t(": ")),typeof this.value=="string"?r.write(t(this.value)):r.write(this.value)}};na();var Ar=class{constructor(r=0,t){this.context=t;this.currentIndent=r}lines=[];currentLine="";currentIndent=0;marginSymbol;afterNextNewLineCallback;write(r){return typeof r=="string"?this.currentLine+=r:r.write(this),this}writeJoined(r,t,n=(i,o)=>o.write(i)){let i=t.length-1;for(let o=0;o<t.length;o++)n(t[o],this),o!==i&&this.write(r);return this}writeLine(r){return this.write(r).newLine()}newLine(){this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;let r=this.afterNextNewLineCallback;return this.afterNextNewLineCallback=void 0,r?.(),this}withIndent(r){return this.indent(),r(this),this.unindent(),this}afterNextNewline(r){return this.afterNextNewLineCallback=r,this}indent(){return this.currentIndent++,this}unindent(){return this.currentIndent>0&&this.currentIndent--,this}addMarginSymbol(r){return this.marginSymbol=r,this}toString(){return this.lines.concat(this.indentedCurrentLine()).join(`
`)}getCurrentLineLength(){return this.currentLine.length}indentedCurrentLine(){let r=this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);return this.marginSymbol?this.marginSymbol+r.slice(1):r}};ta();var xn=class{constructor(r){this.value=r}write(r){r.write(this.value)}markAsError(){this.value.markAsError()}};var vn=e=>e,Pn={bold:vn,red:vn,green:vn,dim:vn,enabled:!1},ia={bold:Q,red:ue,green:qe,dim:Ce,enabled:!0},Cr={write(e){e.writeLine(",")}};var Pe=class{constructor(r){this.contents=r}isUnderlined=!1;color=r=>r;underline(){return this.isUnderlined=!0,this}setColor(r){return this.color=r,this}write(r){let t=r.getCurrentLineLength();r.write(this.color(this.contents)),this.isUnderlined&&r.afterNextNewline(()=>{r.write(" ".repeat(t)).writeLine(this.color("~".repeat(this.contents.length)))})}};var ze=class{hasError=!1;markAsError(){return this.hasError=!0,this}};var Ir=class extends ze{items=[];addItem(r){return this.items.push(new xn(r)),this}getField(r){return this.items[r]}getPrintWidth(){return this.items.length===0?2:Math.max(...this.items.map(t=>t.value.getPrintWidth()))+2}write(r){if(this.items.length===0){this.writeEmpty(r);return}this.writeWithItems(r)}writeEmpty(r){let t=new Pe("[]");this.hasError&&t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithItems(r){let{colors:t}=r.context;r.writeLine("[").withIndent(()=>r.writeJoined(Cr,this.items).newLine()).write("]"),this.hasError&&r.afterNextNewline(()=>{r.writeLine(t.red("~".repeat(this.getPrintWidth())))})}asObject(){}};var kr=class e extends ze{fields={};suggestions=[];addField(r){this.fields[r.name]=r}addSuggestion(r){this.suggestions.push(r)}getField(r){return this.fields[r]}getDeepField(r){let[t,...n]=r,i=this.getField(t);if(!i)return;let o=i;for(let s of n){let a;if(o.value instanceof e?a=o.value.getField(s):o.value instanceof Ir&&(a=o.value.getField(Number(s))),!a)return;o=a}return o}getDeepFieldValue(r){return r.length===0?this:this.getDeepField(r)?.value}hasField(r){return!!this.getField(r)}removeAllFields(){this.fields={}}removeField(r){delete this.fields[r]}getFields(){return this.fields}isEmpty(){return Object.keys(this.fields).length===0}getFieldValue(r){return this.getField(r)?.value}getDeepSubSelectionValue(r){let t=this;for(let n of r){if(!(t instanceof e))return;let i=t.getSubSelectionValue(n);if(!i)return;t=i}return t}getDeepSelectionParent(r){let t=this.getSelectionParent();if(!t)return;let n=t;for(let i of r){let o=n.value.getFieldValue(i);if(!o||!(o instanceof e))return;let s=o.getSelectionParent();if(!s)return;n=s}return n}getSelectionParent(){let r=this.getField("select")?.value.asObject();if(r)return{kind:"select",value:r};let t=this.getField("include")?.value.asObject();if(t)return{kind:"include",value:t}}getSubSelectionValue(r){return this.getSelectionParent()?.value.fields[r].value}getPrintWidth(){let r=Object.values(this.fields);return r.length==0?2:Math.max(...r.map(n=>n.getPrintWidth()))+2}write(r){let t=Object.values(this.fields);if(t.length===0&&this.suggestions.length===0){this.writeEmpty(r);return}this.writeWithContents(r,t)}asObject(){return this}writeEmpty(r){let t=new Pe("{}");this.hasError&&t.setColor(r.context.colors.red).underline(),r.write(t)}writeWithContents(r,t){r.writeLine("{").withIndent(()=>{r.writeJoined(Cr,[...t,...this.suggestions]).newLine()}),r.write("}"),this.hasError&&r.afterNextNewline(()=>{r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())))})}};var G=class extends ze{constructor(t){super();this.text=t}getPrintWidth(){return this.text.length}write(t){let n=new Pe(this.text);this.hasError&&n.underline().setColor(t.context.colors.red),t.write(n)}asObject(){}};var lt=class{fields=[];addField(r,t){return this.fields.push({write(n){let{green:i,dim:o}=n.context.colors;n.write(i(o(`${r}: ${t}`))).addMarginSymbol(i(o("+")))}}),this}write(r){let{colors:{green:t}}=r.context;r.writeLine(t("{")).withIndent(()=>{r.writeJoined(Cr,this.fields).newLine()}).write(t("}")).addMarginSymbol(t("+"))}};function wn(e,r,t){switch(e.kind){case"MutuallyExclusiveFields":wd(e,r);break;case"IncludeOnScalar":xd(e,r);break;case"EmptySelection":vd(e,r,t);break;case"UnknownSelectionField":Rd(e,r);break;case"InvalidSelectionValue":Ad(e,r);break;case"UnknownArgument":Cd(e,r);break;case"UnknownInputField":Id(e,r);break;case"RequiredArgumentMissing":kd(e,r);break;case"InvalidArgumentType":Dd(e,r);break;case"InvalidArgumentValue":Od(e,r);break;case"ValueTooLarge":_d(e,r);break;case"SomeFieldsMissing":Nd(e,r);break;case"TooManyFieldsGiven":Ld(e,r);break;case"Union":ea(e,r,t);break;default:throw new Error("not implemented: "+e.kind)}}function wd(e,r){let t=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();t&&(t.getField(e.firstField)?.markAsError(),t.getField(e.secondField)?.markAsError()),r.addErrorMessage(n=>`Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)}function xd(e,r){let[t,n]=Dr(e.selectionPath),i=e.outputType,o=r.arguments.getDeepSelectionParent(t)?.value;if(o&&(o.getField(n)?.markAsError(),i))for(let s of i.fields)s.isRelation&&o.addSuggestion(new ae(s.name,"true"));r.addErrorMessage(s=>{let a=`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;return i?a+=` on model ${s.bold(i.name)}. ${ut(s)}`:a+=".",a+=`
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function vd(e,r,t){let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getField("omit")?.value.asObject();if(i){Pd(e,r,i);return}if(n.hasField("select")){Td(e,r);return}}if(t?.[Ye(e.outputType.name)]){Sd(e,r);return}r.addErrorMessage(()=>`Unknown field at "${e.selectionPath.join(".")} selection"`)}function Pd(e,r,t){t.removeAllFields();for(let n of e.outputType.fields)t.addSuggestion(new ae(n.name,"false"));r.addErrorMessage(n=>`The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)}function Td(e,r){let t=e.outputType,n=r.arguments.getDeepSelectionParent(e.selectionPath)?.value,i=n?.isEmpty()??!1;n&&(n.removeAllFields(),la(n,t)),r.addErrorMessage(o=>i?`The ${o.red("`select`")} statement for type ${o.bold(t.name)} must not be empty. ${ut(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(t.name)} needs ${o.bold("at least one truthy value")}.`)}function Sd(e,r){let t=new lt;for(let i of e.outputType.fields)i.isRelation||t.addField(i.name,"false");let n=new ae("omit",t).makeRequired();if(e.selectionPath.length===0)r.arguments.addSuggestion(n);else{let[i,o]=Dr(e.selectionPath),a=r.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);if(a){let l=a?.value.asObject()??new kr;l.addSuggestion(n),a.value=l}}r.addErrorMessage(i=>`The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)}function Rd(e,r){let t=ua(e.selectionPath,r);if(t.parentKind!=="unknown"){t.field.markAsError();let n=t.parent;switch(t.parentKind){case"select":la(n,e.outputType);break;case"include":Fd(n,e.outputType);break;case"omit":Md(n,e.outputType);break}}r.addErrorMessage(n=>{let i=[`Unknown field ${n.red(`\`${t.fieldName}\``)}`];return t.parentKind!=="unknown"&&i.push(`for ${n.bold(t.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(ut(n)),i.join(" ")})}function Ad(e,r){let t=ua(e.selectionPath,r);t.parentKind!=="unknown"&&t.field.value.markAsError(),r.addErrorMessage(n=>`Invalid value for selection field \`${n.red(t.fieldName)}\`: ${e.underlyingError}`)}function Cd(e,r){let t=e.argumentPath[0],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&(n.getField(t)?.markAsError(),$d(n,e.arguments)),r.addErrorMessage(i=>sa(i,t,e.arguments.map(o=>o.name)))}function Id(e,r){let[t,n]=Dr(e.argumentPath),i=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(i){i.getDeepField(e.argumentPath)?.markAsError();let o=i.getDeepFieldValue(t)?.asObject();o&&ca(o,e.inputType)}r.addErrorMessage(o=>sa(o,n,e.inputType.fields.map(s=>s.name)))}function sa(e,r,t){let n=[`Unknown argument \`${e.red(r)}\`.`],i=jd(r,t);return i&&n.push(`Did you mean \`${e.green(i)}\`?`),t.length>0&&n.push(ut(e)),n.join(" ")}function kd(e,r){let t;r.addErrorMessage(l=>t?.value instanceof G&&t.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`);let n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(!n)return;let[i,o]=Dr(e.argumentPath),s=new lt,a=n.getDeepFieldValue(i)?.asObject();if(a){if(t=a.getField(o),t&&a.removeField(o),e.inputTypes.length===1&&e.inputTypes[0].kind==="object"){for(let l of e.inputTypes[0].fields)s.addField(l.name,l.typeNames.join(" | "));a.addSuggestion(new ae(o,s).makeRequired())}else{let l=e.inputTypes.map(aa).join(" | ");a.addSuggestion(new ae(o,l).makeRequired())}if(e.dependentArgumentPath){n.getDeepField(e.dependentArgumentPath)?.markAsError();let[,l]=Dr(e.dependentArgumentPath);r.addErrorMessage(u=>`Argument \`${u.green(o)}\` is required because argument \`${u.green(l)}\` was provided.`)}}}function aa(e){return e.kind==="list"?`${aa(e.elementType)}[]`:e.name}function Dd(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=>{let o=Tn("or",e.argument.typeNames.map(s=>i.green(s)));return`Argument \`${i.bold(t)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}function Od(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();n&&n.getDeepFieldValue(e.argumentPath)?.markAsError(),r.addErrorMessage(i=>{let o=[`Invalid value for argument \`${i.bold(t)}\``];if(e.underlyingError&&o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length>0){let s=Tn("or",e.argument.typeNames.map(a=>i.green(a)));o.push(` Expected ${s}.`)}return o.join("")})}function _d(e,r){let t=e.argument.name,n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i;if(n){let s=n.getDeepField(e.argumentPath)?.value;s?.markAsError(),s instanceof G&&(i=s.text)}r.addErrorMessage(o=>{let s=["Unable to fit value"];return i&&s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(t)}\``),s.join(" ")})}function Nd(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();if(n){let i=n.getDeepFieldValue(e.argumentPath)?.asObject();i&&ca(i,e.inputType)}r.addErrorMessage(i=>{let o=[`Argument \`${i.bold(t)}\` of type ${i.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Tn("or",e.constraints.requiredFields.map(s=>`\`${i.bold(s)}\``))} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(ut(i)),o.join(" ")})}function Ld(e,r){let t=e.argumentPath[e.argumentPath.length-1],n=r.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i=[];if(n){let o=n.getDeepFieldValue(e.argumentPath)?.asObject();o&&(o.markAsError(),i=Object.keys(o.getFields()))}r.addErrorMessage(o=>{let s=[`Argument \`${o.bold(t)}\` of type ${o.bold(e.inputType.name)} needs`];return e.constraints.minFieldCount===1&&e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Tn("and",i.map(a=>o.red(a)))}. Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")})}function la(e,r){for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ae(t.name,"true"))}function Fd(e,r){for(let t of r.fields)t.isRelation&&!e.hasField(t.name)&&e.addSuggestion(new ae(t.name,"true"))}function Md(e,r){for(let t of r.fields)!e.hasField(t.name)&&!t.isRelation&&e.addSuggestion(new ae(t.name,"true"))}function $d(e,r){for(let t of r)e.hasField(t.name)||e.addSuggestion(new ae(t.name,t.typeNames.join(" | ")))}function ua(e,r){let[t,n]=Dr(e),i=r.arguments.getDeepSubSelectionValue(t)?.asObject();if(!i)return{parentKind:"unknown",fieldName:n};let o=i.getFieldValue("select")?.asObject(),s=i.getFieldValue("include")?.asObject(),a=i.getFieldValue("omit")?.asObject(),l=o?.getField(n);return o&&l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&&l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&&l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}function ca(e,r){if(r.kind==="object")for(let t of r.fields)e.hasField(t.name)||e.addSuggestion(new ae(t.name,t.typeNames.join(" | ")))}function Dr(e){let r=[...e],t=r.pop();if(!t)throw new Error("unexpected empty path");return[r,t]}function ut({green:e,enabled:r}){return"Available options are "+(r?`listed in ${e("green")}`:"marked with ?")+"."}function Tn(e,r){if(r.length===1)return r[0];let t=[...r],n=t.pop();return`${t.join(", ")} ${e} ${n}`}var qd=3;function jd(e,r){let t=1/0,n;for(let i of r){let o=(0,oa.default)(e,i);o>qd||o<t&&(t=o,n=i)}return n}var ct=class{modelName;name;typeName;isList;isEnum;constructor(r,t,n,i,o){this.modelName=r,this.name=t,this.typeName=n,this.isList=i,this.isEnum=o}_toGraphQLInputType(){let r=this.isList?"List":"",t=this.isEnum?"Enum":"";return`${r}${t}${this.typeName}FieldRefInput<${this.modelName}>`}};function Or(e){return e instanceof ct}var Sn=Symbol(),Bi=new WeakMap,Me=class{constructor(r){r===Sn?Bi.set(this,`Prisma.${this._getName()}`):Bi.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}_getName(){return this.constructor.name}toString(){return Bi.get(this)}},pt=class extends Me{_getNamespace(){return"NullTypes"}},dt=class extends pt{#e};Gi(dt,"DbNull");var mt=class extends pt{#e};Gi(mt,"JsonNull");var ft=class extends pt{#e};Gi(ft,"AnyNull");var Ui={classes:{DbNull:dt,JsonNull:mt,AnyNull:ft},instances:{DbNull:new dt(Sn),JsonNull:new mt(Sn),AnyNull:new ft(Sn)}};function Gi(e,r){Object.defineProperty(e,"name",{value:r,configurable:!0})}var pa=": ",Rn=class{constructor(r,t){this.name=r;this.value=t}hasError=!1;markAsError(){this.hasError=!0}getPrintWidth(){return this.name.length+this.value.getPrintWidth()+pa.length}write(r){let t=new Pe(this.name);this.hasError&&t.underline().setColor(r.context.colors.red),r.write(t).write(pa).write(this.value)}};var Qi=class{arguments;errorMessages=[];constructor(r){this.arguments=r}write(r){r.write(this.arguments)}addErrorMessage(r){this.errorMessages.push(r)}renderAllMessages(r){return this.errorMessages.map(t=>t(r)).join(`
`)}};function _r(e){return new Qi(da(e))}function da(e){let r=new kr;for(let[t,n]of Object.entries(e)){let i=new Rn(t,ma(n));r.addField(i)}return r}function ma(e){if(typeof e=="string")return new G(JSON.stringify(e));if(typeof e=="number"||typeof e=="boolean")return new G(String(e));if(typeof e=="bigint")return new G(`${e}n`);if(e===null)return new G("null");if(e===void 0)return new G("undefined");if(Sr(e))return new G(`new Prisma.Decimal("${e.toFixed()}")`);if(e instanceof Uint8Array)return Buffer.isBuffer(e)?new G(`Buffer.alloc(${e.byteLength})`):new G(`new Uint8Array(${e.byteLength})`);if(e instanceof Date){let r=gn(e)?e.toISOString():"Invalid Date";return new G(`new Date("${r}")`)}return e instanceof Me?new G(`Prisma.${e._getName()}`):Or(e)?new G(`prisma.${Ye(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Vd(e):typeof e=="object"?da(e):new G(Object.prototype.toString.call(e))}function Vd(e){let r=new Ir;for(let t of e)r.addItem(ma(t));return r}function An(e,r){let t=r==="pretty"?ia:Pn,n=e.renderAllMessages(t),i=new Ar(0,{colors:t}).write(e).toString();return{message:n,args:i}}function Cn({args:e,errors:r,errorFormat:t,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=_r(e);for(let p of r)wn(p,a,s);let{message:l,args:u}=An(a,t),c=En({message:l,callsite:n,originalMethod:i,showColors:t==="pretty",callArguments:u});throw new X(c,{clientVersion:o})}function Te(e){return e.replace(/^./,r=>r.toLowerCase())}function ga(e,r,t){let n=Te(t);return!r.result||!(r.result.$allModels||r.result[n])?e:Bd({...e,...fa(r.name,e,r.result.$allModels),...fa(r.name,e,r.result[n])})}function Bd(e){let r=new ve,t=(n,i)=>r.getOrCreate(n,()=>i.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(o=>t(o,i)):[n]));return xr(e,n=>({...n,needs:t(n.name,new Set)}))}function fa(e,r,t){return t?xr(t,({needs:n,compute:i},o)=>({name:o,needs:n?Object.keys(n).filter(s=>n[s]):[],compute:Ud(r,o,i)})):{}}function Ud(e,r,t){let n=e?.[r]?.compute;return n?i=>t({...i,[r]:n(i)}):t}function ha(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(e[n.name])for(let i of n.needs)t[i]=!0;return t}function ya(e,r){if(!r)return e;let t={...e};for(let n of Object.values(r))if(!e[n.name])for(let i of n.needs)delete t[i];return t}var In=class{constructor(r,t){this.extension=r;this.previous=t}computedFieldsCache=new ve;modelExtensionsCache=new ve;queryCallbacksCache=new ve;clientExtensions=at(()=>this.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());batchCallbacks=at(()=>{let r=this.previous?.getAllBatchQueryCallbacks()??[],t=this.extension.query?.$__internalBatch;return t?r.concat(t):r});getAllComputedFields(r){return this.computedFieldsCache.getOrCreate(r,()=>ga(this.previous?.getAllComputedFields(r),this.extension,r))}getAllClientExtensions(){return this.clientExtensions.get()}getAllModelExtensions(r){return this.modelExtensionsCache.getOrCreate(r,()=>{let t=Te(r);return!this.extension.model||!(this.extension.model[t]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(r):{...this.previous?.getAllModelExtensions(r),...this.extension.model.$allModels,...this.extension.model[t]}})}getAllQueryCallbacks(r,t){return this.queryCallbacksCache.getOrCreate(`${r}:${t}`,()=>{let n=this.previous?.getAllQueryCallbacks(r,t)??[],i=[],o=this.extension.query;return!o||!(o[r]||o.$allModels||o[t]||o.$allOperations)?n:(o[r]!==void 0&&(o[r][t]!==void 0&&i.push(o[r][t]),o[r].$allOperations!==void 0&&i.push(o[r].$allOperations)),r!=="$none"&&o.$allModels!==void 0&&(o.$allModels[t]!==void 0&&i.push(o.$allModels[t]),o.$allModels.$allOperations!==void 0&&i.push(o.$allModels.$allOperations)),o[t]!==void 0&&i.push(o[t]),o.$allOperations!==void 0&&i.push(o.$allOperations),n.concat(i))})}getAllBatchQueryCallbacks(){return this.batchCallbacks.get()}},Nr=class e{constructor(r){this.head=r}static empty(){return new e}static single(r){return new e(new In(r))}isEmpty(){return this.head===void 0}append(r){return new e(new In(r,this.head))}getAllComputedFields(r){return this.head?.getAllComputedFields(r)}getAllClientExtensions(){return this.head?.getAllClientExtensions()}getAllModelExtensions(r){return this.head?.getAllModelExtensions(r)}getAllQueryCallbacks(r,t){return this.head?.getAllQueryCallbacks(r,t)??[]}getAllBatchQueryCallbacks(){return this.head?.getAllBatchQueryCallbacks()??[]}};var kn=class{constructor(r){this.name=r}};function ba(e){return e instanceof kn}function Gd(e){return new kn(e)}var Ea=Symbol(),gt=class{constructor(r){if(r!==Ea)throw new Error("Skip instance can not be constructed directly")}ifUndefined(r){return r===void 0?Wi:r}},Wi=new gt(Ea);function Se(e){return e instanceof gt}var Qd={findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},wa="explicitly `undefined` values are not allowed";function Hi({modelName:e,action:r,args:t,runtimeDataModel:n,extensions:i=Nr.empty(),callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c}){let p=new Ji({runtimeDataModel:n,modelName:e,action:r,rootArgs:t,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:u,globalOmit:c});return{modelName:e,action:Qd[r],query:ht(t,p)}}function ht({select:e,include:r,...t}={},n){let i=t.omit;return delete t.omit,{arguments:va(t,n),selection:Wd(e,r,i,n)}}function Wd(e,r,t,n){return e?(r?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):t&&n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),Yd(e,n)):Jd(n,r,t)}function Jd(e,r,t){let n={};return e.modelOrType&&!e.isRawAction()&&(n.$composites=!0,n.$scalars=!0),r&&Hd(n,r,e),Kd(n,t,e),n}function Hd(e,r,t){for(let[n,i]of Object.entries(r)){if(Se(i))continue;let o=t.nestSelection(n);if(Ki(i,o),i===!1||i===void 0){e[n]=!1;continue}let s=t.findField(n);if(s&&s.kind!=="object"&&t.throwValidationError({kind:"IncludeOnScalar",selectionPath:t.getSelectionPath().concat(n),outputType:t.getOutputTypeDescription()}),s){e[n]=ht(i===!0?{}:i,o);continue}if(i===!0){e[n]=!0;continue}e[n]=ht(i,o)}}function Kd(e,r,t){let n=t.getComputedFields(),i={...t.getGlobalOmit(),...r},o=ya(i,n);for(let[s,a]of Object.entries(o)){if(Se(a))continue;Ki(a,t.nestSelection(s));let l=t.findField(s);n?.[s]&&!l||(e[s]=!a)}}function Yd(e,r){let t={},n=r.getComputedFields(),i=ha(e,n);for(let[o,s]of Object.entries(i)){if(Se(s))continue;let a=r.nestSelection(o);Ki(s,a);let l=r.findField(o);if(!(n?.[o]&&!l)){if(s===!1||s===void 0||Se(s)){t[o]=!1;continue}if(s===!0){l?.kind==="object"?t[o]=ht({},a):t[o]=!0;continue}t[o]=ht(s,a)}}return t}function xa(e,r){if(e===null)return null;if(typeof e=="string"||typeof e=="number"||typeof e=="boolean")return e;if(typeof e=="bigint")return{$type:"BigInt",value:String(e)};if(Tr(e)){if(gn(e))return{$type:"DateTime",value:e.toISOString()};r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}if(ba(e))return{$type:"Param",value:e.name};if(Or(e))return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};if(Array.isArray(e))return zd(e,r);if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{$type:"Bytes",value:Buffer.from(t,n,i).toString("base64")}}if(Zd(e))return e.values;if(Sr(e))return{$type:"Decimal",value:e.toFixed()};if(e instanceof Me){if(e!==Ui.instances[e._getName()])throw new Error("Invalid ObjectEnumValue");return{$type:"Enum",value:e._getName()}}if(Xd(e))return e.toJSON();if(typeof e=="object")return va(e,r);r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:r.getSelectionPath(),argumentPath:r.getArgumentPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}function va(e,r){if(e.$type)return{$type:"Raw",value:e};let t={};for(let n in e){let i=e[n],o=r.nestArgument(n);Se(i)||(i!==void 0?t[n]=xa(i,o):r.isPreviewFeatureOn("strictUndefinedChecks")&&r.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:r.getSelectionPath(),argument:{name:r.getArgumentName(),typeNames:[]},underlyingError:wa}))}return t}function zd(e,r){let t=[];for(let n=0;n<e.length;n++){let i=r.nestArgument(String(n)),o=e[n];if(o===void 0||Se(o)){let s=o===void 0?"undefined":"Prisma.skip";r.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${r.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}t.push(xa(o,i))}return t}function Zd(e){return typeof e=="object"&&e!==null&&e.__prismaRawParameters__===!0}function Xd(e){return typeof e=="object"&&e!==null&&typeof e.toJSON=="function"}function Ki(e,r){e===void 0&&r.isPreviewFeatureOn("strictUndefinedChecks")&&r.throwValidationError({kind:"InvalidSelectionValue",selectionPath:r.getSelectionPath(),underlyingError:wa})}var Ji=class e{constructor(r){this.params=r;this.params.modelName&&(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName])}modelOrType;throwValidationError(r){Cn({errors:[r],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}getSelectionPath(){return this.params.selectionPath}getArgumentPath(){return this.params.argumentPath}getArgumentName(){return this.params.argumentPath[this.params.argumentPath.length-1]}getOutputTypeDescription(){if(!(!this.params.modelName||!this.modelOrType))return{name:this.params.modelName,fields:this.modelOrType.fields.map(r=>({name:r.name,typeName:"boolean",isRelation:r.kind==="object"}))}}isRawAction(){return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}isPreviewFeatureOn(r){return this.params.previewFeatures.includes(r)}getComputedFields(){if(this.params.modelName)return this.params.extensions.getAllComputedFields(this.params.modelName)}findField(r){return this.modelOrType?.fields.find(t=>t.name===r)}nestSelection(r){let t=this.findField(r),n=t?.kind==="object"?t.type:void 0;return new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(r)})}getGlobalOmit(){return this.params.modelName&&this.shouldApplyGlobalOmit()?this.params.globalOmit?.[Ye(this.params.modelName)]??{}:{}}shouldApplyGlobalOmit(){switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":return!0;case"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":return!1;default:_e(this.params.action,"Unknown action")}}nestArgument(r){return new e({...this.params,argumentPath:this.params.argumentPath.concat(r)})}};function Pa(e){if(!e._hasPreviewFlag("metrics"))throw new X("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}var yt=class{_client;constructor(r){this._client=r}prometheus(r){return Pa(this._client),this._client._engine.metrics({format:"prometheus",...r})}json(r){return Pa(this._client),this._client._engine.metrics({format:"json",...r})}};function em(e,r){let t=at(()=>rm(r));Object.defineProperty(e,"dmmf",{get:()=>t.get()})}function rm(e){return{datamodel:{models:Yi(e.models),enums:Yi(e.enums),types:Yi(e.types)}}}function Yi(e){return Object.entries(e).map(([r,t])=>({name:r,...t}))}var zi=new WeakMap,Dn="$$PrismaTypedSql",bt=class{constructor(r,t){zi.set(this,{sql:r,values:t}),Object.defineProperty(this,Dn,{value:Dn})}get sql(){return zi.get(this).sql}get values(){return zi.get(this).values}};function tm(e){return(...r)=>new bt(e,r)}function On(e){return e!=null&&e[Dn]===Dn}var tu=ne(hi());var le=class e{constructor(r,t){if(r.length-1!==t.length)throw r.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${r.length} strings to have ${r.length-1} values`);let n=t.reduce((s,a)=>s+(a instanceof e?a.values.length:1),0);this.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=r[0];let i=0,o=0;for(;i<t.length;){let s=t[i++],a=r[i];if(s instanceof e){this.strings[o]+=s.strings[0];let l=0;for(;l<s.values.length;)this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];this.strings[o]+=a}else this.values[o++]=s,this.strings[o]=a}}get sql(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`?${this.strings[t++]}`;return n}get statement(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`:${t}${this.strings[t++]}`;return n}get text(){let r=this.strings.length,t=1,n=this.strings[0];for(;t<r;)n+=`$${t}${this.strings[t++]}`;return n}inspect(){return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}};function nm(e,r=",",t="",n=""){if(e.length===0)throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");return new le([t,...Array(e.length-1).fill(r),n],e)}function Ta(e){return new le([e],[])}var im=Ta("");function Sa(e,...r){return new le(e,r)}function Et(e){return{getKeys(){return Object.keys(e)},getPropertyValue(r){return e[r]}}}function ee(e,r){return{getKeys(){return[e]},getPropertyValue(){return r()}}}function ar(e){let r=new ve;return{getKeys(){return e.getKeys()},getPropertyValue(t){return r.getOrCreate(t,()=>e.getPropertyValue(t))},getPropertyDescriptor(t){return e.getPropertyDescriptor?.(t)}}}var _n={enumerable:!0,configurable:!0,writable:!0};function Nn(e){let r=new Set(e);return{getPrototypeOf:()=>Object.prototype,getOwnPropertyDescriptor:()=>_n,has:(t,n)=>r.has(n),set:(t,n,i)=>r.add(n)&&Reflect.set(t,n,i),ownKeys:()=>[...r]}}var Ra=Symbol.for("nodejs.util.inspect.custom");function he(e,r){let t=om(r),n=new Set,i=new Proxy(e,{get(o,s){if(n.has(s))return o[s];let a=t.get(s);return a?a.getPropertyValue(s):o[s]},has(o,s){if(n.has(s))return!0;let a=t.get(s);return a?a.has?.(s)??!0:Reflect.has(o,s)},ownKeys(o){let s=Aa(Reflect.ownKeys(o),t),a=Aa(Array.from(t.keys()),t);return[...new Set([...s,...a,...n])]},set(o,s,a){return t.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))},getOwnPropertyDescriptor(o,s){let a=Reflect.getOwnPropertyDescriptor(o,s);if(a&&!a.configurable)return a;let l=t.get(s);return l?l.getPropertyDescriptor?{..._n,...l?.getPropertyDescriptor(s)}:_n:a},defineProperty(o,s,a){return n.add(s),Reflect.defineProperty(o,s,a)},getPrototypeOf:()=>Object.prototype});return i[Ra]=function(){let o={...this};return delete o[Ra],o},i}function om(e){let r=new Map;for(let t of e){let n=t.getKeys();for(let i of n)r.set(i,t)}return r}function Aa(e,r){return e.filter(t=>r.get(t)?.has?.(t)??!0)}function Lr(e){return{getKeys(){return e},has(){return!1},getPropertyValue(){}}}function Fr(e,r){return{batch:e,transaction:r?.kind==="batch"?{isolationLevel:r.options.isolationLevel}:void 0}}function Ca(e){if(e===void 0)return"";let r=_r(e);return new Ar(0,{colors:Pn}).write(r).toString()}var sm="P2037";function Mr({error:e,user_facing_error:r},t,n){return r.error_code?new Z(am(r,n),{code:r.error_code,clientVersion:t,meta:r.meta,batchRequestIdx:r.batch_request_idx}):new q(e,{clientVersion:t,batchRequestIdx:r.batch_request_idx})}function am(e,r){let t=e.message;return(r==="postgresql"||r==="postgres"||r==="mysql")&&e.error_code===sm&&(t+=`
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),t}var wt="<unknown>";function Ia(e){var r=e.split(`
`);return r.reduce(function(t,n){var i=cm(n)||dm(n)||gm(n)||Em(n)||ym(n);return i&&t.push(i),t},[])}var lm=/^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,um=/\((\S*)(?::(\d+))(?::(\d+))\)/;function cm(e){var r=lm.exec(e);if(!r)return null;var t=r[2]&&r[2].indexOf("native")===0,n=r[2]&&r[2].indexOf("eval")===0,i=um.exec(r[2]);return n&&i!=null&&(r[2]=i[1],r[3]=i[2],r[4]=i[3]),{file:t?null:r[2],methodName:r[1]||wt,arguments:t?[r[2]]:[],lineNumber:r[3]?+r[3]:null,column:r[4]?+r[4]:null}}var pm=/^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;function dm(e){var r=pm.exec(e);return r?{file:r[2],methodName:r[1]||wt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}var mm=/^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i,fm=/(\S+) line (\d+)(?: > eval line \d+)* > eval/i;function gm(e){var r=mm.exec(e);if(!r)return null;var t=r[3]&&r[3].indexOf(" > eval")>-1,n=fm.exec(r[3]);return t&&n!=null&&(r[3]=n[1],r[4]=n[2],r[5]=null),{file:r[3],methodName:r[1]||wt,arguments:r[2]?r[2].split(","):[],lineNumber:r[4]?+r[4]:null,column:r[5]?+r[5]:null}}var hm=/^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;function ym(e){var r=hm.exec(e);return r?{file:r[3],methodName:r[1]||wt,arguments:[],lineNumber:+r[4],column:r[5]?+r[5]:null}:null}var bm=/^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;function Em(e){var r=bm.exec(e);return r?{file:r[2],methodName:r[1]||wt,arguments:[],lineNumber:+r[3],column:r[4]?+r[4]:null}:null}var Zi=class{getLocation(){return null}},Xi=class{_error;constructor(){this._error=new Error}getLocation(){let r=this._error.stack;if(!r)return null;let n=Ia(r).find(i=>{if(!i.file)return!1;let o=Ri(i.file);return o!=="<anonymous>"&&!o.includes("@prisma")&&!o.includes("/packages/client/src/runtime/")&&!o.endsWith("/runtime/binary.js")&&!o.endsWith("/runtime/library.js")&&!o.endsWith("/runtime/edge.js")&&!o.endsWith("/runtime/edge-esm.js")&&!o.startsWith("internal/")&&!i.methodName.includes("new ")&&!i.methodName.includes("getCallSite")&&!i.methodName.includes("Proxy.")&&i.methodName.split(".").length<4});return!n||!n.file?null:{fileName:n.file,lineNumber:n.lineNumber,columnNumber:n.column}}};function Ze(e){return e==="minimal"?typeof $EnabledCallSite=="function"&&e!=="minimal"?new $EnabledCallSite:new Zi:new Xi}var ka={_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};function $r(e={}){let r=xm(e);return Object.entries(r).reduce((n,[i,o])=>(ka[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{select:{}})}function xm(e={}){return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}function Ln(e={}){return r=>(typeof e._count=="boolean"&&(r._count=r._count._all),r)}function Da(e,r){let t=Ln(e);return r({action:"aggregate",unpacker:t,argsMapper:$r})(e)}function vm(e={}){let{select:r,...t}=e;return typeof r=="object"?$r({...t,_count:r}):$r({...t,_count:{_all:!0}})}function Pm(e={}){return typeof e.select=="object"?r=>Ln(e)(r)._count:r=>Ln(e)(r)._count._all}function Oa(e,r){return r({action:"count",unpacker:Pm(e),argsMapper:vm})(e)}function Tm(e={}){let r=$r(e);if(Array.isArray(r.by))for(let t of r.by)typeof t=="string"&&(r.select[t]=!0);else typeof r.by=="string"&&(r.select[r.by]=!0);return r}function Sm(e={}){return r=>(typeof e?._count=="boolean"&&r.forEach(t=>{t._count=t._count._all}),r)}function _a(e,r){return r({action:"groupBy",unpacker:Sm(e),argsMapper:Tm})(e)}function Na(e,r,t){if(r==="aggregate")return n=>Da(n,t);if(r==="count")return n=>Oa(n,t);if(r==="groupBy")return n=>_a(n,t)}function La(e,r){let t=r.fields.filter(i=>!i.relationName),n=Ws(t,"name");return new Proxy({},{get(i,o){if(o in i||typeof o=="symbol")return i[o];let s=n[o];if(s)return new ct(e,o,s.type,s.isList,s.kind==="enum")},...Nn(Object.keys(n))})}var Fa=e=>Array.isArray(e)?e:e.split("."),eo=(e,r)=>Fa(r).reduce((t,n)=>t&&t[n],e),Ma=(e,r,t)=>Fa(r).reduceRight((n,i,o,s)=>Object.assign({},eo(e,s.slice(0,o)),{[i]:n}),t);function Rm(e,r){return e===void 0||r===void 0?[]:[...r,"select",e]}function Am(e,r,t){return r===void 0?e??{}:Ma(r,t,e||!0)}function ro(e,r,t,n,i,o){let a=e._runtimeDataModel.models[r].fields.reduce((l,u)=>({...l,[u.name]:u}),{});return l=>{let u=Ze(e._errorFormat),c=Rm(n,i),p=Am(l,o,c),d=t({dataPath:c,callsite:u})(p),f=Cm(e,r);return new Proxy(d,{get(h,g){if(!f.includes(g))return h[g];let P=[a[g].type,t,g],R=[c,p];return ro(e,...P,...R)},...Nn([...f,...Object.getOwnPropertyNames(d)])})}}function Cm(e,r){return e._runtimeDataModel.models[r].fields.filter(t=>t.kind==="object").map(t=>t.name)}var Im=["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],km=["aggregate","count","groupBy"];function to(e,r){let t=e._extensions.getAllModelExtensions(r)??{},n=[Dm(e,r),_m(e,r),Et(t),ee("name",()=>r),ee("$name",()=>r),ee("$parent",()=>e._appliedParent)];return he({},n)}function Dm(e,r){let t=Te(r),n=Object.keys(Rr).concat("count");return{getKeys(){return n},getPropertyValue(i){let o=i,s=a=>l=>{let u=Ze(e._errorFormat);return e._createPrismaPromise(c=>{let p={args:l,dataPath:[],action:o,model:r,clientMethod:`${t}.${i}`,jsModelName:t,transaction:c,callsite:u};return e._request({...p,...a})},{action:o,args:l,model:r})};return Im.includes(o)?ro(e,r,s):Om(i)?Na(e,i,s):s({})}}}function Om(e){return km.includes(e)}function _m(e,r){return ar(ee("fields",()=>{let t=e._runtimeDataModel.models[r];return La(r,t)}))}function $a(e){return e.replace(/^./,r=>r.toUpperCase())}var no=Symbol();function xt(e){let r=[Nm(e),Lm(e),ee(no,()=>e),ee("$parent",()=>e._appliedParent)],t=e._extensions.getAllClientExtensions();return t&&r.push(Et(t)),he(e,r)}function Nm(e){let r=Object.getPrototypeOf(e._originalClient),t=[...new Set(Object.getOwnPropertyNames(r))];return{getKeys(){return t},getPropertyValue(n){return e[n]}}}function Lm(e){let r=Object.keys(e._runtimeDataModel.models),t=r.map(Te),n=[...new Set(r.concat(t))];return ar({getKeys(){return n},getPropertyValue(i){let o=$a(i);if(e._runtimeDataModel.models[o]!==void 0)return to(e,o);if(e._runtimeDataModel.models[i]!==void 0)return to(e,i)},getPropertyDescriptor(i){if(!t.includes(i))return{enumerable:!1}}})}function qa(e){return e[no]?e[no]:e}function ja(e){if(typeof e=="function")return e(this);if(e.client?.__AccelerateEngine){let t=e.client.__AccelerateEngine;this._originalClient._engine=new t(this._originalClient._accelerateEngineConfig)}let r=Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});return xt(r)}function Va({result:e,modelName:r,select:t,omit:n,extensions:i}){let o=i.getAllComputedFields(r);if(!o)return e;let s=[],a=[];for(let l of Object.values(o)){if(n){if(n[l.name])continue;let u=l.needs.filter(c=>n[c]);u.length>0&&a.push(Lr(u))}else if(t){if(!t[l.name])continue;let u=l.needs.filter(c=>!t[c]);u.length>0&&a.push(Lr(u))}Fm(e,l.needs)&&s.push(Mm(l,he(e,s)))}return s.length>0||a.length>0?he(e,[...s,...a]):e}function Fm(e,r){return r.every(t=>Oi(e,t))}function Mm(e,r){return ar(ee(e.name,()=>e.compute(r)))}function Fn({visitor:e,result:r,args:t,runtimeDataModel:n,modelName:i}){if(Array.isArray(r)){for(let s=0;s<r.length;s++)r[s]=Fn({result:r[s],args:t,modelName:i,runtimeDataModel:n,visitor:e});return r}let o=e(r,i,t)??r;return t.include&&Ba({includeOrSelect:t.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),t.select&&Ba({includeOrSelect:t.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}function Ba({includeOrSelect:e,result:r,parentModelName:t,runtimeDataModel:n,visitor:i}){for(let[o,s]of Object.entries(e)){if(!s||r[o]==null||Se(s))continue;let l=n.models[t].fields.find(c=>c.name===o);if(!l||l.kind!=="object"||!l.relationName)continue;let u=typeof s=="object"?s:{};r[o]=Fn({visitor:i,result:r[o],args:u,modelName:l.type,runtimeDataModel:n})}}function Ua({result:e,modelName:r,args:t,extensions:n,runtimeDataModel:i,globalOmit:o}){return n.isEmpty()||e==null||typeof e!="object"||!i.models[r]?e:Fn({result:e,args:t??{},modelName:r,runtimeDataModel:i,visitor:(a,l,u)=>{let c=Te(l);return Va({result:a,modelName:c,select:u.select,omit:u.select?void 0:{...o?.[c],...u.omit},extensions:n})}})}var $m=["$connect","$disconnect","$on","$transaction","$use","$extends"],Ga=$m;function Qa(e){if(e instanceof le)return qm(e);if(On(e))return jm(e);if(Array.isArray(e)){let t=[e[0]];for(let n=1;n<e.length;n++)t[n]=vt(e[n]);return t}let r={};for(let t in e)r[t]=vt(e[t]);return r}function qm(e){return new le(e.strings,e.values)}function jm(e){return new bt(e.sql,e.values)}function vt(e){if(typeof e!="object"||e==null||e instanceof Me||Or(e))return e;if(Sr(e))return new Fe(e.toFixed());if(Tr(e))return new Date(+e);if(ArrayBuffer.isView(e))return e.slice(0);if(Array.isArray(e)){let r=e.length,t;for(t=Array(r);r--;)t[r]=vt(e[r]);return t}if(typeof e=="object"){let r={};for(let t in e)t==="__proto__"?Object.defineProperty(r,t,{value:vt(e[t]),configurable:!0,enumerable:!0,writable:!0}):r[t]=vt(e[t]);return r}_e(e,"Unknown value")}function Ja(e,r,t,n=0){return e._createPrismaPromise(i=>{let o=r.customDataProxyFetch;return"transaction"in r&&i!==void 0&&(r.transaction?.kind==="batch"&&r.transaction.lock.then(),r.transaction=i),n===t.length?e._executeRequest(r):t[n]({model:r.model,operation:r.model?r.action:r.clientMethod,args:Qa(r.args??{}),__internalParams:r,query:(s,a=r)=>{let l=a.customDataProxyFetch;return a.customDataProxyFetch=za(o,l),a.args=s,Ja(e,a,t,n+1)}})})}function Ha(e,r){let{jsModelName:t,action:n,clientMethod:i}=r,o=t?n:i;if(e._extensions.isEmpty())return e._executeRequest(r);let s=e._extensions.getAllQueryCallbacks(t??"$none",o);return Ja(e,r,s)}function Ka(e){return r=>{let t={requests:r},n=r[0].extensions.getAllBatchQueryCallbacks();return n.length?Ya(t,n,0,e):e(t)}}function Ya(e,r,t,n){if(t===r.length)return n(e);let i=e.customDataProxyFetch,o=e.requests[0].transaction;return r[t]({args:{queries:e.requests.map(s=>({model:s.modelName,operation:s.action,args:s.args})),transaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,query(s,a=e){let l=a.customDataProxyFetch;return a.customDataProxyFetch=za(i,l),Ya(a,r,t+1,n)}})}var Wa=e=>e;function za(e=Wa,r=Wa){return t=>e(r(t))}var Za=L("prisma:client"),Xa={Vercel:"vercel","Netlify CI":"netlify"};function el({postinstall:e,ciName:r,clientVersion:t}){if(Za("checkPlatformCaching:postinstall",e),Za("checkPlatformCaching:ciName",r),e===!0&&r&&r in Xa){let n=`Prisma has detected that this project was built on ${r}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${Xa[r]}-build`;throw console.error(n),new T(n,t)}}function rl(e,r){return e?e.datasources?e.datasources:e.datasourceUrl?{[r[0]]:{url:e.datasourceUrl}}:{}:{}}var Vm=()=>globalThis.process?.release?.name==="node",Bm=()=>!!globalThis.Bun||!!globalThis.process?.versions?.bun,Um=()=>!!globalThis.Deno,Gm=()=>typeof globalThis.Netlify=="object",Qm=()=>typeof globalThis.EdgeRuntime=="object",Wm=()=>globalThis.navigator?.userAgent==="Cloudflare-Workers";function Jm(){return[[Gm,"netlify"],[Qm,"edge-light"],[Wm,"workerd"],[Um,"deno"],[Bm,"bun"],[Vm,"node"]].flatMap(t=>t[0]()?[t[1]]:[]).at(0)??""}var Hm={node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};function io(){let e=Jm();return{id:e,prettyName:Hm[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}function Mn(e){let{runtimeBinaryTarget:r}=e;return`Add "${r}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Km(e)}`}function Km(e){let{generator:r,generatorBinaryTargets:t,runtimeBinaryTarget:n}=e,i={fromEnvVar:null,value:n},o=[...t,i];return Pi({...r,binaryTargets:o})}function Xe(e){let{runtimeBinaryTarget:r}=e;return`Prisma Client could not locate the Query Engine for runtime "${r}".`}function er(e){let{searchedLocations:r}=e;return`The following locations have been searched:
${[...new Set(r)].map(i=>`  ${i}`).join(`
`)}`}function tl(e){let{runtimeBinaryTarget:r}=e;return`${Xe(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${r}".
${Mn(e)}

${er(e)}`}function $n(e){return`We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`}function qn(e){let{errorStack:r}=e;return r?.match(/\/\.next|\/next@|\/next\//)?`

We detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.`:""}function nl(e){let{queryEngineName:r}=e;return`${Xe(e)}${qn(e)}

This is likely caused by a bundler that has not copied "${r}" next to the resulting bundle.
Ensure that "${r}" has been copied next to the bundle or in "${e.expectedLocation}".

${$n("engine-not-found-bundler-investigation")}

${er(e)}`}function il(e){let{runtimeBinaryTarget:r,generatorBinaryTargets:t}=e,n=t.find(i=>i.native);return`${Xe(e)}

This happened because Prisma Client was generated for "${n?.value??"unknown"}", but the actual deployment required "${r}".
${Mn(e)}

${er(e)}`}function ol(e){let{queryEngineName:r}=e;return`${Xe(e)}${qn(e)}

This is likely caused by tooling that has not copied "${r}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${r}" has been copied to "${e.expectedLocation}".

${$n("engine-not-found-tooling-investigation")}

${er(e)}`}var zm=L("prisma:client:engines:resolveEnginePath"),Zm=()=>new RegExp("runtime[\\\\/]library\\.m?js$");async function sl(e,r){let t={binary:node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_QUERY_ENGINE_BINARY,library:node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_QUERY_ENGINE_LIBRARY}[e]??r.prismaPath;if(t!==void 0)return t;let{enginePath:n,searchedLocations:i}=await Xm(e,r);if(zm("enginePath",n),n!==void 0&&e==="binary"&&yi(n),n!==void 0)return r.prismaPath=n;let o=await nr(),s=r.generator?.binaryTargets??[],a=s.some(d=>d.native),l=!s.some(d=>d.value===o),u=__filename.match(Zm())===null,c={searchedLocations:i,generatorBinaryTargets:s,generator:r.generator,runtimeBinaryTarget:o,queryEngineName:al(e,o),expectedLocation:node_path__WEBPACK_IMPORTED_MODULE_1__.relative(node_process__WEBPACK_IMPORTED_MODULE_2__.cwd(),r.dirname),errorStack:new Error().stack},p;throw a&&l?p=il(c):l?p=tl(c):u?p=nl(c):p=ol(c),new T(p,r.clientVersion)}async function Xm(e,r){let t=await nr(),n=[],i=[r.dirname,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(__dirname,".."),r.generator?.output?.value??__dirname,node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(__dirname,"../../../.prisma/client"),"/tmp/prisma-engines",r.cwd];__filename.includes("resolveEnginePath")&&i.push(ls());for(let o of i){let s=al(e,t),a=node_path__WEBPACK_IMPORTED_MODULE_1__.join(o,s);if(n.push(o),node_fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(a))return{enginePath:a,searchedLocations:n}}return{enginePath:void 0,searchedLocations:n}}function al(e,r){return e==="library"?jt(r,"fs"):`query-engine-${r}${r==="windows"?".exe":""}`}var oo=ne(Si());function ll(e){return e?e.replace(/".*"/g,'"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g,r=>`${r[0]}5`):""}function ul(e){return e.split(`
`).map(r=>r.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/,"").replace(/\+\d+\s*ms$/,"")).join(`
`)}var cl=ne(ks());function pl({title:e,user:r="prisma",repo:t="prisma",template:n="bug_report.yml",body:i}){return(0,cl.default)({user:r,repo:t,template:n,title:e,body:i})}function dl({version:e,binaryTarget:r,title:t,description:n,engineVersion:i,database:o,query:s}){let a=qo(6e3-(s?.length??0)),l=ul((0,oo.default)(a)),u=n?`# Description
\`\`\`
${n}
\`\`\``:"",c=(0,oo.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${node_process__WEBPACK_IMPORTED_MODULE_2__.version?.padEnd(19)}| 
| OS              | ${r?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s?ll(s):""}
\`\`\`
`),p=pl({title:t,body:c});return`${t}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${K(p)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`}var ml="6.13.0";function qr({inlineDatasources:e,overrideDatasources:r,env:t,clientVersion:n}){let i,o=Object.keys(e)[0],s=e[o]?.url,a=r[o]?.url;if(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&&(i=t[s.fromEnvVar]),s?.fromEnvVar!==void 0&&i===void 0)throw new T(`error: Environment variable not found: ${s.fromEnvVar}.`,n);if(i===void 0)throw new T("error: Missing URL environment variable, value, or override.",n);return i}var Vn=class extends Error{clientVersion;cause;constructor(r,t){super(r),this.clientVersion=t.clientVersion,this.cause=t.cause}get[Symbol.toStringTag](){return this.name}};var oe=class extends Vn{isRetryable;constructor(r,t){super(r,t),this.isRetryable=t.isRetryable??!0}};function A(e,r){return{...e,isRetryable:r}}var lr=class extends oe{name="InvalidDatasourceError";code="P6001";constructor(r,t){super(r,A(t,!1))}};x(lr,"InvalidDatasourceError");function fl(e){let r={clientVersion:e.clientVersion},t=Object.keys(e.inlineDatasources)[0],n=qr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,clientVersion:e.clientVersion,env:{...e.env,...typeof /*#__PURE__*/ (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache || (node_process__WEBPACK_IMPORTED_MODULE_2___namespace_cache = __webpack_require__.t(node_process__WEBPACK_IMPORTED_MODULE_2__, 2)))<"u"?node_process__WEBPACK_IMPORTED_MODULE_2__.env:{}}}),i;try{i=new URL(n)}catch{throw new lr(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\``,r)}let{protocol:o,searchParams:s}=i;if(o!=="prisma:"&&o!==Xt)throw new lr(`Error validating datasource \`${t}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,r);let a=s.get("api_key");if(a===null||a.length<1)throw new lr(`Error validating datasource \`${t}\`: the URL must contain a valid API key`,r);let l=wi(i)?"http:":"https:",u=new URL(i.href.replace(o,l));return{apiKey:a,url:u}}var gl=ne(Zt()),Bn=class{apiKey;tracingHelper;logLevel;logQueries;engineHash;constructor({apiKey:r,tracingHelper:t,logLevel:n,logQueries:i,engineHash:o}){this.apiKey=r,this.tracingHelper=t,this.logLevel=n,this.logQueries=i,this.engineHash=o}build({traceparent:r,transactionId:t}={}){let n={Accept:"application/json",Authorization:`Bearer ${this.apiKey}`,"Content-Type":"application/json","Prisma-Engine-Hash":this.engineHash,"Prisma-Engine-Version":gl.enginesVersion};this.tracingHelper.isEnabled()&&(n.traceparent=r??this.tracingHelper.getTraceParent()),t&&(n["X-Transaction-Id"]=t);let i=this.#e();return i.length>0&&(n["X-Capture-Telemetry"]=i.join(", ")),n}#e(){let r=[];return this.tracingHelper.isEnabled()&&r.push("tracing"),this.logLevel&&r.push(this.logLevel),this.logQueries&&r.push("query"),r}};function rf(e){return e[0]*1e3+e[1]/1e6}function so(e){return new Date(rf(e))}var jr=class extends oe{name="ForcedRetryError";code="P5001";constructor(r){super("This request must be retried",A(r,!0))}};x(jr,"ForcedRetryError");var ur=class extends oe{name="NotImplementedYetError";code="P5004";constructor(r,t){super(r,A(t,!1))}};x(ur,"NotImplementedYetError");var F=class extends oe{response;constructor(r,t){super(r,t),this.response=t.response;let n=this.response.headers.get("prisma-request-id");if(n){let i=`(The request id was: ${n})`;this.message=this.message+" "+i}}};var cr=class extends F{name="SchemaMissingError";code="P5005";constructor(r){super("Schema needs to be uploaded",A(r,!0))}};x(cr,"SchemaMissingError");var ao="This request could not be understood by the server",Pt=class extends F{name="BadRequestError";code="P5000";constructor(r,t,n){super(t||ao,A(r,!1)),n&&(this.code=n)}};x(Pt,"BadRequestError");var Tt=class extends F{name="HealthcheckTimeoutError";code="P5013";logs;constructor(r,t){super("Engine not started: healthcheck timeout",A(r,!0)),this.logs=t}};x(Tt,"HealthcheckTimeoutError");var St=class extends F{name="EngineStartupError";code="P5014";logs;constructor(r,t,n){super(t,A(r,!0)),this.logs=n}};x(St,"EngineStartupError");var Rt=class extends F{name="EngineVersionNotSupportedError";code="P5012";constructor(r){super("Engine version is not supported",A(r,!1))}};x(Rt,"EngineVersionNotSupportedError");var lo="Request timed out",At=class extends F{name="GatewayTimeoutError";code="P5009";constructor(r,t=lo){super(t,A(r,!1))}};x(At,"GatewayTimeoutError");var tf="Interactive transaction error",Ct=class extends F{name="InteractiveTransactionError";code="P5015";constructor(r,t=tf){super(t,A(r,!1))}};x(Ct,"InteractiveTransactionError");var nf="Request parameters are invalid",It=class extends F{name="InvalidRequestError";code="P5011";constructor(r,t=nf){super(t,A(r,!1))}};x(It,"InvalidRequestError");var uo="Requested resource does not exist",kt=class extends F{name="NotFoundError";code="P5003";constructor(r,t=uo){super(t,A(r,!1))}};x(kt,"NotFoundError");var co="Unknown server error",Vr=class extends F{name="ServerError";code="P5006";logs;constructor(r,t,n){super(t||co,A(r,!0)),this.logs=n}};x(Vr,"ServerError");var po="Unauthorized, check your connection string",Dt=class extends F{name="UnauthorizedError";code="P5007";constructor(r,t=po){super(t,A(r,!1))}};x(Dt,"UnauthorizedError");var mo="Usage exceeded, retry again later",Ot=class extends F{name="UsageExceededError";code="P5008";constructor(r,t=mo){super(t,A(r,!0))}};x(Ot,"UsageExceededError");async function of(e){let r;try{r=await e.text()}catch{return{type:"EmptyError"}}try{let t=JSON.parse(r);if(typeof t=="string")switch(t){case"InternalDataProxyError":return{type:"DataProxyError",body:t};default:return{type:"UnknownTextError",body:t}}if(typeof t=="object"&&t!==null){if("is_panic"in t&&"message"in t&&"error_code"in t)return{type:"QueryEngineError",body:t};if("EngineNotStarted"in t||"InteractiveTransactionMisrouted"in t||"InvalidRequestError"in t){let n=Object.values(t)[0].reason;return typeof n=="string"&&!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:t}:{type:"DataProxyError",body:t}}}return{type:"UnknownJsonError",body:t}}catch{return r===""?{type:"EmptyError"}:{type:"UnknownTextError",body:r}}}async function _t(e,r){if(e.ok)return;let t={clientVersion:r,response:e},n=await of(e);if(n.type==="QueryEngineError")throw new Z(n.body.message,{code:n.body.error_code,clientVersion:r});if(n.type==="DataProxyError"){if(n.body==="InternalDataProxyError")throw new Vr(t,"Internal Data Proxy error");if("EngineNotStarted"in n.body){if(n.body.EngineNotStarted.reason==="SchemaMissing")return new cr(t);if(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")throw new Rt(t);if("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=n.body.EngineNotStarted.reason.EngineStartupError;throw new St(t,i,o)}if("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=n.body.EngineNotStarted.reason.KnownEngineStartupError;throw new T(i,r,o)}if("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=n.body.EngineNotStarted.reason.HealthcheckTimeout;throw new Tt(t,i)}}if("InteractiveTransactionMisrouted"in n.body){let i={IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};throw new Ct(t,i[n.body.InteractiveTransactionMisrouted.reason])}if("InvalidRequestError"in n.body)throw new It(t,n.body.InvalidRequestError.reason)}if(e.status===401||e.status===403)throw new Dt(t,Br(po,n));if(e.status===404)return new kt(t,Br(uo,n));if(e.status===429)throw new Ot(t,Br(mo,n));if(e.status===504)throw new At(t,Br(lo,n));if(e.status>=500)throw new Vr(t,Br(co,n));if(e.status>=400)throw new Pt(t,Br(ao,n))}function Br(e,r){return r.type==="EmptyError"?e:`${e}: ${JSON.stringify(r)}`}function hl(e){let r=Math.pow(2,e)*50,t=Math.ceil(Math.random()*r)-Math.ceil(r/2),n=r+t;return new Promise(i=>setTimeout(()=>i(n),n))}var $e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";function yl(e){let r=new TextEncoder().encode(e),t="",n=r.byteLength,i=n%3,o=n-i,s,a,l,u,c;for(let p=0;p<o;p=p+3)c=r[p]<<16|r[p+1]<<8|r[p+2],s=(c&16515072)>>18,a=(c&258048)>>12,l=(c&4032)>>6,u=c&63,t+=$e[s]+$e[a]+$e[l]+$e[u];return i==1?(c=r[o],s=(c&252)>>2,a=(c&3)<<4,t+=$e[s]+$e[a]+"=="):i==2&&(c=r[o]<<8|r[o+1],s=(c&64512)>>10,a=(c&1008)>>4,l=(c&15)<<2,t+=$e[s]+$e[a]+$e[l]+"="),t}function bl(e){if(!!e.generator?.previewFeatures.some(t=>t.toLowerCase().includes("metrics")))throw new T("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}var El={"@prisma/debug":"workspace:*","@prisma/engines-version":"6.13.0-35.361e86d0ea4987e9f53a565309b3eed797a6bcbd","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};var Nt=class extends oe{name="RequestError";code="P5010";constructor(r,t){super(`Cannot fetch data from service:
${r}`,A(t,!0))}};x(Nt,"RequestError");async function pr(e,r,t=n=>n){let{clientVersion:n,...i}=r,o=t(fetch);try{return await o(e,i)}catch(s){let a=s.message??"Unknown error";throw new Nt(a,{clientVersion:n,cause:s})}}var af=/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,wl=L("prisma:client:dataproxyEngine");async function lf(e,r){let t=El["@prisma/engines-version"],n=r.clientVersion??"unknown";if(node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)return node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;if(e.includes("accelerate")&&n!=="0.0.0"&&n!=="in-memory")return n;let[i,o]=n?.split("-")??[];if(o===void 0&&af.test(i))return i;if(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=t.split("-")??[],[a,l,u]=s.split("."),c=uf(`<=${a}.${l}.${u}`),p=await pr(c,{clientVersion:n});if(!p.ok)throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text()||"<empty body>"}`);let d=await p.text();wl("length of body fetched from unpkg.com",d.length);let f;try{f=JSON.parse(d)}catch(h){throw console.error("JSON.parse error: body fetched from unpkg.com: ",d),h}return f.version}throw new ur("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}async function xl(e,r){let t=await lf(e,r);return wl("version",t),t}function uf(e){return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}var vl=3,Lt=L("prisma:client:dataproxyEngine"),Ft=class{name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;constructor(r){bl(r),this.config=r,this.env=r.env,this.inlineSchema=yl(r.inlineSchema),this.inlineDatasources=r.inlineDatasources,this.inlineSchemaHash=r.inlineSchemaHash,this.clientVersion=r.clientVersion,this.engineHash=r.engineVersion,this.logEmitter=r.logEmitter,this.tracingHelper=r.tracingHelper}apiKey(){return this.headerBuilder.apiKey}version(){return this.engineHash}async start(){this.startPromise!==void 0&&await this.startPromise,this.startPromise=(async()=>{let{apiKey:r,url:t}=this.getURLAndAPIKey();this.host=t.host,this.protocol=t.protocol,this.headerBuilder=new Bn({apiKey:r,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel??"error",logQueries:this.config.logQueries,engineHash:this.engineHash}),this.remoteClientVersion=await xl(this.host,this.config),Lt("host",this.host),Lt("protocol",this.protocol)})(),await this.startPromise}async stop(){}propagateResponseExtensions(r){r?.logs?.length&&r.logs.forEach(t=>{switch(t.level){case"debug":case"trace":Lt(t);break;case"error":case"warn":case"info":{this.logEmitter.emit(t.level,{timestamp:so(t.timestamp),message:t.attributes.message??"",target:t.target});break}case"query":{this.logEmitter.emit("query",{query:t.attributes.query??"",timestamp:so(t.timestamp),duration:t.attributes.duration_ms??0,params:t.attributes.params??"",target:t.target});break}default:t.level}}),r?.traces?.length&&this.tracingHelper.dispatchEngineSpans(r.traces)}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the remote query engine')}async url(r){return await this.start(),`${this.protocol}//${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`}async uploadSchema(){let r={name:"schemaUpload",internal:!0};return this.tracingHelper.runInChildSpan(r,async()=>{let t=await pr(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});t.ok||Lt("schema response status",t.status);let n=await _t(t,this.clientVersion);if(n)throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;this.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})})}request(r,{traceparent:t,interactiveTransaction:n,customDataProxyFetch:i}){return this.requestInternal({body:r,traceparent:t,interactiveTransaction:n,customDataProxyFetch:i})}async requestBatch(r,{traceparent:t,transaction:n,customDataProxyFetch:i}){let o=n?.kind==="itx"?n.options:void 0,s=Fr(r,n);return(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:t})).map(l=>(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}requestInternal({body:r,traceparent:t,customDataProxyFetch:n,interactiveTransaction:i}){return this.withRetry({actionGerund:"querying",callback:async({logHttpCall:o})=>{let s=i?`${i.payload.endpoint}/graphql`:await this.url("graphql");o(s);let a=await pr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t,transactionId:i?.id}),body:JSON.stringify(r),clientVersion:this.clientVersion},n);a.ok||Lt("graphql response status",a.status),await this.handleError(await _t(a,this.clientVersion));let l=await a.json();if(l.extensions&&this.propagateResponseExtensions(l.extensions),"errors"in l)throw this.convertProtocolErrorsToClientError(l.errors);return"batchResult"in l?l.batchResult:l}})}async transaction(r,t,n){let i={start:"starting",commit:"committing",rollback:"rolling back"};return this.withRetry({actionGerund:`${i[r]} transaction`,callback:async({logHttpCall:o})=>{if(r==="start"){let s=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a=await this.url("transaction/start");o(a);let l=await pr(a,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),body:s,clientVersion:this.clientVersion});await this.handleError(await _t(l,this.clientVersion));let u=await l.json(),{extensions:c}=u;c&&this.propagateResponseExtensions(c);let p=u.id,d=u["data-proxy"].endpoint;return{id:p,payload:{endpoint:d}}}else{let s=`${n.payload.endpoint}/${r}`;o(s);let a=await pr(s,{method:"POST",headers:this.headerBuilder.build({traceparent:t.traceparent}),clientVersion:this.clientVersion});await this.handleError(await _t(a,this.clientVersion));let l=await a.json(),{extensions:u}=l;u&&this.propagateResponseExtensions(u);return}}})}getURLAndAPIKey(){return fl({clientVersion:this.clientVersion,env:this.env,inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources})}metrics(){throw new ur("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}async withRetry(r){for(let t=0;;t++){let n=i=>{this.logEmitter.emit("info",{message:`Calling ${i} (n=${t})`,timestamp:new Date,target:""})};try{return await r.callback({logHttpCall:n})}catch(i){if(!(i instanceof oe)||!i.isRetryable)throw i;if(t>=vl)throw i instanceof jr?i.cause:i;this.logEmitter.emit("warn",{message:`Attempt ${t+1}/${vl} failed for ${r.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});let o=await hl(t);this.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}}}async handleError(r){if(r instanceof cr)throw await this.uploadSchema(),new jr({clientVersion:this.clientVersion,cause:r});if(r)throw r}convertProtocolErrorsToClientError(r){return r.length===1?Mr(r[0],this.config.clientVersion,this.config.activeProvider):new q(JSON.stringify(r),{clientVersion:this.config.clientVersion})}applyPendingMigrations(){throw new Error("Method not implemented.")}};function Pl(e){if(e?.kind==="itx")return e.options.id}var fo=Symbol("PrismaLibraryEngineCache");function pf(){let e=globalThis;return e[fo]===void 0&&(e[fo]={}),e[fo]}function df(e){let r=pf();if(r[e]!==void 0)return r[e];let t=node_path__WEBPACK_IMPORTED_MODULE_1__.toNamespacedPath(e),n={exports:{}},i=0;return node_process__WEBPACK_IMPORTED_MODULE_2__.platform!=="win32"&&(i=node_os__WEBPACK_IMPORTED_MODULE_7__.constants.dlopen.RTLD_LAZY|node_os__WEBPACK_IMPORTED_MODULE_7__.constants.dlopen.RTLD_DEEPBIND),node_process__WEBPACK_IMPORTED_MODULE_2__.dlopen(n,t,i),r[e]=n.exports,n.exports}var Sl={async loadLibrary(e){let r=await oi(),t=await sl("library",e);try{return e.tracingHelper.runInChildSpan({name:"loadLibrary",internal:!0},()=>df(t))}catch(n){let i=bi({e:n,platformInfo:r,id:t});throw new T(i,e.clientVersion)}}};var go,Rl={async loadLibrary(e){let{clientVersion:r,adapter:t,engineWasm:n}=e;if(t===void 0)throw new T(`The \`adapter\` option for \`PrismaClient\` is required in this context (${io().prettyName})`,r);if(n===void 0)throw new T("WASM engine was unexpectedly `undefined`",r);go===void 0&&(go=(async()=>{let o=await n.getRuntime(),s=await n.getQueryEngineWasmModule();if(s==null)throw new T("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",r);let a={"./query_engine_bg.js":o},l=new WebAssembly.Instance(s,a),u=l.exports.__wbindgen_start;return o.__wbg_set_wasm(l.exports),u(),o.QueryEngine})());let i=await go;return{debugPanic(){return Promise.reject("{}")},dmmf(){return Promise.resolve("{}")},version(){return{commit:"unknown",version:"unknown"}},QueryEngine:i}}};var mf="P2036",Re=L("prisma:client:libraryEngine");function ff(e){return e.item_type==="query"&&"query"in e}function gf(e){return"level"in e?e.level==="error"&&e.message==="PANIC":!1}var Al=[...Xn,"native"],hf=0xffffffffffffffffn,ho=1n;function yf(){let e=ho++;return ho>hf&&(ho=1n),e}var Ur=class{name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;constructor(r,t){this.libraryLoader=t??Sl,r.engineWasm!==void 0&&(this.libraryLoader=t??Rl),this.config=r,this.libraryStarted=!1,this.logQueries=r.logQueries??!1,this.logLevel=r.logLevel??"error",this.logEmitter=r.logEmitter,this.datamodel=r.inlineSchema,this.tracingHelper=r.tracingHelper,r.enableDebugLogs&&(this.logLevel="debug");let n=Object.keys(r.overrideDatasources)[0],i=r.overrideDatasources[n]?.url;n!==void 0&&i!==void 0&&(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}wrapEngine(r){return{applyPendingMigrations:r.applyPendingMigrations?.bind(r),commitTransaction:this.withRequestId(r.commitTransaction.bind(r)),connect:this.withRequestId(r.connect.bind(r)),disconnect:this.withRequestId(r.disconnect.bind(r)),metrics:r.metrics?.bind(r),query:this.withRequestId(r.query.bind(r)),rollbackTransaction:this.withRequestId(r.rollbackTransaction.bind(r)),sdlSchema:r.sdlSchema?.bind(r),startTransaction:this.withRequestId(r.startTransaction.bind(r)),trace:r.trace.bind(r),free:r.free?.bind(r)}}withRequestId(r){return async(...t)=>{let n=yf().toString();try{return await r(...t,n)}finally{if(this.tracingHelper.isEnabled()){let i=await this.engine?.trace(n);if(i){let o=JSON.parse(i);this.tracingHelper.dispatchEngineSpans(o.spans)}}}}}async applyPendingMigrations(){throw new Error("Cannot call this method from this type of engine instance")}async transaction(r,t,n){await this.start();let i=await this.adapterPromise,o=JSON.stringify(t),s;if(r==="start"){let l=JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});s=await this.engine?.startTransaction(l,o)}else r==="commit"?s=await this.engine?.commitTransaction(n.id,o):r==="rollback"&&(s=await this.engine?.rollbackTransaction(n.id,o));let a=this.parseEngineResponse(s);if(bf(a)){let l=this.getExternalAdapterError(a,i?.errorRegistry);throw l?l.error:new Z(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}else if(typeof a.message=="string")throw new q(a.message,{clientVersion:this.config.clientVersion});return a}async instantiateLibrary(){if(Re("internalSetup"),this.libraryInstantiationPromise)return this.libraryInstantiationPromise;Zn(),this.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",()=>this.loadEngine()),this.version()}async getCurrentBinaryTarget(){{if(this.binaryTarget)return this.binaryTarget;let r=await this.tracingHelper.runInChildSpan("detect_platform",()=>nr());if(!Al.includes(r))throw new T(`Unknown ${ue("PRISMA_QUERY_ENGINE_LIBRARY")} ${ue(Q(r))}. Possible binaryTargets: ${qe(Al.join(", "))} or a path to the query engine library.
You may have to run ${qe("prisma generate")} for your changes to take effect.`,this.config.clientVersion);return r}}parseEngineResponse(r){if(!r)throw new q("Response from the Engine was empty",{clientVersion:this.config.clientVersion});try{return JSON.parse(r)}catch{throw new q("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}}async loadEngine(){if(!this.engine){this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine);try{let r=new WeakRef(this);this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(Yt));let t=await this.adapterPromise;t&&Re("Using driver adapter: %O",t),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:node_process__WEBPACK_IMPORTED_MODULE_2__.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},n=>{r.deref()?.logger(n)},t))}catch(r){let t=r,n=this.parseInitError(t.message);throw typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}}}logger(r){let t=this.parseEngineResponse(r);t&&(t.level=t?.level.toLowerCase()??"unknown",ff(t)?this.logEmitter.emit("query",{timestamp:new Date,query:t.query,params:t.params,duration:Number(t.duration_ms),target:t.module_path}):gf(t)?this.loggerRustPanic=new de(yo(this,`${t.message}: ${t.reason} in ${t.file}:${t.line}:${t.column}`),this.config.clientVersion):this.logEmitter.emit(t.level,{timestamp:new Date,message:t.message,target:t.module_path}))}parseInitError(r){try{return JSON.parse(r)}catch{}return r}parseRequestError(r){try{return JSON.parse(r)}catch{}return r}onBeforeExit(){throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}async start(){if(this.libraryInstantiationPromise||(this.libraryInstantiationPromise=this.instantiateLibrary()),await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)return Re(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;if(this.libraryStarted)return;let r=async()=>{Re("library starting");try{let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.connect(JSON.stringify(t)),this.libraryStarted=!0,this.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(Yt)),await this.adapterPromise,Re("library started")}catch(t){let n=this.parseInitError(t.message);throw typeof n=="string"?t:new T(n.message,this.config.clientVersion,n.error_code)}finally{this.libraryStartingPromise=void 0}};return this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",r),this.libraryStartingPromise}async stop(){if(await this.libraryInstantiationPromise,await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)return Re("library is already stopping"),this.libraryStoppingPromise;if(!this.libraryStarted){await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0;return}let r=async()=>{await new Promise(n=>setImmediate(n)),Re("library stopping");let t={traceparent:this.tracingHelper.getTraceParent()};await this.engine?.disconnect(JSON.stringify(t)),this.engine?.free&&this.engine.free(),this.engine=void 0,this.libraryStarted=!1,this.libraryStoppingPromise=void 0,this.libraryInstantiationPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,Re("library stopped")};return this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",r),this.libraryStoppingPromise}version(){return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}debugPanic(r){return this.library?.debugPanic(r)}async request(r,{traceparent:t,interactiveTransaction:n}){Re(`sending request, this.libraryStarted: ${this.libraryStarted}`);let i=JSON.stringify({traceparent:t}),o=JSON.stringify(r);try{await this.start();let s=await this.adapterPromise;this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;let a=this.parseEngineResponse(await this.executingQueryPromise);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new q(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});if(this.loggerRustPanic)throw this.loggerRustPanic;return{data:a}}catch(s){if(s instanceof T)throw s;if(s.code==="GenericFailure"&&s.message?.startsWith("PANIC:"))throw new de(yo(this,s.message),this.config.clientVersion);let a=this.parseRequestError(s.message);throw typeof a=="string"?s:new q(`${a.message}
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}async requestBatch(r,{transaction:t,traceparent:n}){Re("requestBatch");let i=Fr(r,t);await this.start();let o=await this.adapterPromise;this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine?.query(this.lastQuery,JSON.stringify({traceparent:n}),Pl(t));let s=await this.executingQueryPromise,a=this.parseEngineResponse(s);if(a.errors)throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new q(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});let{batchResult:l,errors:u}=a;if(Array.isArray(l))return l.map(c=>c.errors&&c.errors.length>0?this.loggerRustPanic??this.buildQueryError(c.errors[0],o?.errorRegistry):{data:c});throw u&&u.length===1?new Error(u[0].error):new Error(JSON.stringify(a))}buildQueryError(r,t){if(r.user_facing_error.is_panic)return new de(yo(this,r.user_facing_error.message),this.config.clientVersion);let n=this.getExternalAdapterError(r.user_facing_error,t);return n?n.error:Mr(r,this.config.clientVersion,this.config.activeProvider)}getExternalAdapterError(r,t){if(r.error_code===mf&&t){let n=r.meta?.id;rn(typeof n=="number","Malformed external JS error received from the engine");let i=t.consumeError(n);return rn(i,"External error with reported id was not registered"),i}}async metrics(r){await this.start();let t=await this.engine.metrics(JSON.stringify(r));return r.format==="prometheus"?t:this.parseEngineResponse(t)}};function bf(e){return typeof e=="object"&&e!==null&&e.error_code!==void 0}function yo(e,r){return dl({binaryTarget:e.binaryTarget,title:r,version:e.config.clientVersion,engineVersion:e.versionInfo?.commit,database:e.config.activeProvider,query:e.lastQuery})}function Cl({url:e,adapter:r,copyEngine:t,targetBuildType:n}){let i=[],o=[],s=g=>{i.push({_tag:"warning",value:g})},a=g=>{let S=g.join(`
`);o.push({_tag:"error",value:S})},l=!!e?.startsWith("prisma://"),u=en(e),c=!!r,p=l||u;!c&&t&&p&&s(["recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)"]);let d=p||!t;c&&(d||n==="edge")&&(n==="edge"?a(["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."]):t?l&&a(["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]):a(["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."]));let f={accelerate:d,ppg:u,driverAdapters:c};function h(g){return g.length>0}return h(o)?{ok:!1,diagnostics:{warnings:i,errors:o},isUsing:f}:{ok:!0,diagnostics:{warnings:i},isUsing:f}}function Il({copyEngine:e=!0},r){let t;try{t=qr({inlineDatasources:r.inlineDatasources,overrideDatasources:r.overrideDatasources,env:{...r.env,...node_process__WEBPACK_IMPORTED_MODULE_2__.env},clientVersion:r.clientVersion})}catch{}let{ok:n,isUsing:i,diagnostics:o}=Cl({url:t,adapter:r.adapter,copyEngine:e,targetBuildType:"library"});for(let p of o.warnings)on(...p.value);if(!n){let p=o.errors[0];throw new X(p.value,{clientVersion:r.clientVersion})}let s=wr(r.generator),a=s==="library",l=s==="binary",u=s==="client",c=(i.accelerate||i.ppg)&&!i.driverAdapters;return i.accelerate?new Ft(r):(i.driverAdapters,a?new Ur(r):(i.accelerate,new Ur(r)))}function Un({generator:e}){return e?.previewFeatures??[]}var kl=e=>({command:e});var Dl=e=>e.strings.reduce((r,t,n)=>`${r}@P${n}${t}`);function Gr(e){try{return Ol(e,"fast")}catch{return Ol(e,"slow")}}function Ol(e,r){return JSON.stringify(e.map(t=>Nl(t,r)))}function Nl(e,r){if(Array.isArray(e))return e.map(t=>Nl(t,r));if(typeof e=="bigint")return{prisma__type:"bigint",prisma__value:e.toString()};if(Tr(e))return{prisma__type:"date",prisma__value:e.toJSON()};if(Fe.isDecimal(e))return{prisma__type:"decimal",prisma__value:e.toJSON()};if(Buffer.isBuffer(e))return{prisma__type:"bytes",prisma__value:e.toString("base64")};if(Ef(e))return{prisma__type:"bytes",prisma__value:Buffer.from(e).toString("base64")};if(ArrayBuffer.isView(e)){let{buffer:t,byteOffset:n,byteLength:i}=e;return{prisma__type:"bytes",prisma__value:Buffer.from(t,n,i).toString("base64")}}return typeof e=="object"&&r==="slow"?Ll(e):e}function Ef(e){return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&&e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}function Ll(e){if(typeof e!="object"||e===null)return e;if(typeof e.toJSON=="function")return e.toJSON();if(Array.isArray(e))return e.map(_l);let r={};for(let t of Object.keys(e))r[t]=_l(e[t]);return r}function _l(e){return typeof e=="bigint"?e.toString():Ll(e)}var wf=/^(\s*alter\s)/i,Fl=L("prisma:client");function bo(e,r,t,n){if(!(e!=="postgresql"&&e!=="cockroachdb")&&t.length>0&&wf.exec(r))throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`)}var Eo=({clientMethod:e,activeProvider:r})=>t=>{let n="",i;if(On(t))n=t.sql,i={values:Gr(t.values),__prismaRawParameters__:!0};else if(Array.isArray(t)){let[o,...s]=t;n=o,i={values:Gr(s||[]),__prismaRawParameters__:!0}}else switch(r){case"sqlite":case"mysql":{n=t.sql,i={values:Gr(t.values),__prismaRawParameters__:!0};break}case"cockroachdb":case"postgresql":case"postgres":{n=t.text,i={values:Gr(t.values),__prismaRawParameters__:!0};break}case"sqlserver":{n=Dl(t),i={values:Gr(t.values),__prismaRawParameters__:!0};break}default:throw new Error(`The ${r} provider does not support ${e}`)}return i?.values?Fl(`prisma.${e}(${n}, ${i.values})`):Fl(`prisma.${e}(${n})`),{query:n,parameters:i}},Ml={requestArgsToMiddlewareArgs(e){return[e.strings,...e.values]},middlewareArgsToRequestArgs(e){let[r,...t]=e;return new le(r,t)}},$l={requestArgsToMiddlewareArgs(e){return[e]},middlewareArgsToRequestArgs(e){return e[0]}};function wo(e){return function(t,n){let i,o=(s=e)=>{try{return s===void 0||s?.kind==="itx"?i??=ql(t(s)):ql(t(s))}catch(a){return Promise.reject(a)}};return{get spec(){return n},then(s,a){return o().then(s,a)},catch(s){return o().catch(s)},finally(s){return o().finally(s)},requestTransaction(s){let a=o(s);return a.requestTransaction?a.requestTransaction(s):a},[Symbol.toStringTag]:"PrismaPromise"}}}function ql(e){return typeof e.then=="function"?e:Promise.resolve(e)}var xf=mi.split(".")[0],vf={isEnabled(){return!1},getTraceParent(){return"00-10-10-00"},dispatchEngineSpans(){},getActiveContext(){},runInChildSpan(e,r){return r()}},xo=class{isEnabled(){return this.getGlobalTracingHelper().isEnabled()}getTraceParent(r){return this.getGlobalTracingHelper().getTraceParent(r)}dispatchEngineSpans(r){return this.getGlobalTracingHelper().dispatchEngineSpans(r)}getActiveContext(){return this.getGlobalTracingHelper().getActiveContext()}runInChildSpan(r,t){return this.getGlobalTracingHelper().runInChildSpan(r,t)}getGlobalTracingHelper(){let r=globalThis[`V${xf}_PRISMA_INSTRUMENTATION`],t=globalThis.PRISMA_INSTRUMENTATION;return r?.helper??t?.helper??vf}};function jl(){return new xo}function Vl(e,r=()=>{}){let t,n=new Promise(i=>t=i);return{then(i){return--e===0&&t(r()),i?.(n)}}}function Bl(e){return typeof e=="string"?e:e.reduce((r,t)=>{let n=typeof t=="string"?t:t.level;return n==="query"?r:r&&(t==="info"||r==="info")?"info":n},void 0)}var Gn=class{_middlewares=[];use(r){this._middlewares.push(r)}get(r){return this._middlewares[r]}has(r){return!!this._middlewares[r]}length(){return this._middlewares.length}};var Gl=ne(Si());function Qn(e){return typeof e.batchRequestIdx=="number"}function Ul(e){if(e.action!=="findUnique"&&e.action!=="findUniqueOrThrow")return;let r=[];return e.modelName&&r.push(e.modelName),e.query.arguments&&r.push(vo(e.query.arguments)),r.push(vo(e.query.selection)),r.join("")}function vo(e){return`(${Object.keys(e).sort().map(t=>{let n=e[t];return typeof n=="object"&&n!==null?`(${t} ${vo(n)})`:t}).join(" ")})`}var Pf={aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};function Po(e){return Pf[e]}var Wn=class{constructor(r){this.options=r;this.batches={}}batches;tickActive=!1;request(r){let t=this.options.batchBy(r);return t?(this.batches[t]||(this.batches[t]=[],this.tickActive||(this.tickActive=!0,node_process__WEBPACK_IMPORTED_MODULE_2__.nextTick(()=>{this.dispatchBatches(),this.tickActive=!1}))),new Promise((n,i)=>{this.batches[t].push({request:r,resolve:n,reject:i})})):this.options.singleLoader(r)}dispatchBatches(){for(let r in this.batches){let t=this.batches[r];delete this.batches[r],t.length===1?this.options.singleLoader(t[0].request).then(n=>{n instanceof Error?t[0].reject(n):t[0].resolve(n)}).catch(n=>{t[0].reject(n)}):(t.sort((n,i)=>this.options.batchOrder(n.request,i.request)),this.options.batchLoader(t.map(n=>n.request)).then(n=>{if(n instanceof Error)for(let i=0;i<t.length;i++)t[i].reject(n);else for(let i=0;i<t.length;i++){let o=n[i];o instanceof Error?t[i].reject(o):t[i].resolve(o)}}).catch(n=>{for(let i=0;i<t.length;i++)t[i].reject(n)}))}}get[Symbol.toStringTag](){return"DataLoader"}};function dr(e,r){if(r===null)return r;switch(e){case"bigint":return BigInt(r);case"bytes":{let{buffer:t,byteOffset:n,byteLength:i}=Buffer.from(r,"base64");return new Uint8Array(t,n,i)}case"decimal":return new Fe(r);case"datetime":case"date":return new Date(r);case"time":return new Date(`1970-01-01T${r}Z`);case"bigint-array":return r.map(t=>dr("bigint",t));case"bytes-array":return r.map(t=>dr("bytes",t));case"decimal-array":return r.map(t=>dr("decimal",t));case"datetime-array":return r.map(t=>dr("datetime",t));case"date-array":return r.map(t=>dr("date",t));case"time-array":return r.map(t=>dr("time",t));default:return r}}function To(e){let r=[],t=Tf(e);for(let n=0;n<e.rows.length;n++){let i=e.rows[n],o={...t};for(let s=0;s<i.length;s++)o[e.columns[s]]=dr(e.types[s],i[s]);r.push(o)}return r}function Tf(e){let r={};for(let t=0;t<e.columns.length;t++)r[e.columns[t]]=null;return r}var Sf=L("prisma:client:request_handler"),Jn=class{client;dataloader;logEmitter;constructor(r,t){this.logEmitter=t,this.client=r,this.dataloader=new Wn({batchLoader:Ka(async({requests:n,customDataProxyFetch:i})=>{let{transaction:o,otelParentCtx:s}=n[0],a=n.map(p=>p.protocolQuery),l=this.client._tracingHelper.getTraceParent(s),u=n.some(p=>Po(p.protocolQuery.action));return(await this.client._engine.requestBatch(a,{traceparent:l,transaction:Rf(o),containsWrite:u,customDataProxyFetch:i})).map((p,d)=>{if(p instanceof Error)return p;try{return this.mapQueryEngineResult(n[d],p)}catch(f){return f}})}),singleLoader:async n=>{let i=n.transaction?.kind==="itx"?Ql(n.transaction):void 0,o=await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:Po(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});return this.mapQueryEngineResult(n,o)},batchBy:n=>n.transaction?.id?`transaction-${n.transaction.id}`:Ul(n.protocolQuery),batchOrder(n,i){return n.transaction?.kind==="batch"&&i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}})}async request(r){try{return await this.dataloader.request(r)}catch(t){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=r;this.handleAndLogRequestError({error:t,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:r.globalOmit})}}mapQueryEngineResult({dataPath:r,unpacker:t},n){let i=n?.data,o=this.unpack(i,r,t);return node_process__WEBPACK_IMPORTED_MODULE_2__.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}handleAndLogRequestError(r){try{this.handleRequestError(r)}catch(t){throw this.logEmitter&&this.logEmitter.emit("error",{message:t.message,target:r.clientMethod,timestamp:new Date}),t}}handleRequestError({error:r,clientMethod:t,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){if(Sf(r),Af(r,i))throw r;if(r instanceof Z&&Cf(r)){let u=Wl(r.meta);Cn({args:o,errors:[u],callsite:n,errorFormat:this.client._errorFormat,originalMethod:t,clientVersion:this.client._clientVersion,globalOmit:a})}let l=r.message;if(n&&(l=En({callsite:n,originalMethod:t,isPanic:r.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),r.code){let u=s?{modelName:s,...r.meta}:r.meta;throw new Z(l,{code:r.code,clientVersion:this.client._clientVersion,meta:u,batchRequestIdx:r.batchRequestIdx})}else{if(r.isPanic)throw new de(l,this.client._clientVersion);if(r instanceof q)throw new q(l,{clientVersion:this.client._clientVersion,batchRequestIdx:r.batchRequestIdx});if(r instanceof T)throw new T(l,this.client._clientVersion);if(r instanceof de)throw new de(l,this.client._clientVersion)}throw r.clientVersion=this.client._clientVersion,r}sanitizeMessage(r){return this.client._errorFormat&&this.client._errorFormat!=="pretty"?(0,Gl.default)(r):r}unpack(r,t,n){if(!r||(r.data&&(r=r.data),!r))return r;let i=Object.keys(r)[0],o=Object.values(r)[0],s=t.filter(u=>u!=="select"&&u!=="include"),a=eo(o,s),l=i==="queryRaw"?To(a):st(a);return n?n(l):l}get[Symbol.toStringTag](){return"RequestHandler"}};function Rf(e){if(e){if(e.kind==="batch")return{kind:"batch",options:{isolationLevel:e.isolationLevel}};if(e.kind==="itx")return{kind:"itx",options:Ql(e)};_e(e,"Unknown transaction kind")}}function Ql(e){return{id:e.id,payload:e.payload}}function Af(e,r){return Qn(e)&&r?.kind==="batch"&&e.batchRequestIdx!==r.index}function Cf(e){return e.code==="P2009"||e.code==="P2012"}function Wl(e){if(e.kind==="Union")return{kind:"Union",errors:e.errors.map(Wl)};if(Array.isArray(e.selectionPath)){let[,...r]=e.selectionPath;return{...e,selectionPath:r}}return e}var Jl=ml;var Zl=ne(ji());var D=class extends Error{constructor(r){super(r+`
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}get[Symbol.toStringTag](){return"PrismaClientConstructorValidationError"}};x(D,"PrismaClientConstructorValidationError");var Hl=["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],Kl=["pretty","colorless","minimal"],Yl=["info","query","warn","error"],If={datasources:(e,{datasourceNames:r})=>{if(e){if(typeof e!="object"||Array.isArray(e))throw new D(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);for(let[t,n]of Object.entries(e)){if(!r.includes(t)){let i=Qr(t,r)||` Available datasources: ${r.join(", ")}`;throw new D(`Unknown datasource ${t} provided to PrismaClient constructor.${i}`)}if(typeof n!="object"||Array.isArray(n))throw new D(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(n&&typeof n=="object")for(let[i,o]of Object.entries(n)){if(i!=="url")throw new D(`Invalid value ${JSON.stringify(e)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);if(typeof o!="string")throw new D(`Invalid value ${JSON.stringify(o)} for datasource "${t}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:(e,r)=>{if(!e&&wr(r.generator)==="client")throw new D('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');if(e===null)return;if(e===void 0)throw new D('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');if(!Un(r).includes("driverAdapters"))throw new D('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');if(wr(r.generator)==="binary")throw new D('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')},datasourceUrl:e=>{if(typeof e<"u"&&typeof e!="string")throw new D(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`)},errorFormat:e=>{if(e){if(typeof e!="string")throw new D(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);if(!Kl.includes(e)){let r=Qr(e,Kl);throw new D(`Invalid errorFormat ${e} provided to PrismaClient constructor.${r}`)}}},log:e=>{if(!e)return;if(!Array.isArray(e))throw new D(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);function r(t){if(typeof t=="string"&&!Yl.includes(t)){let n=Qr(t,Yl);throw new D(`Invalid log level "${t}" provided to PrismaClient constructor.${n}`)}}for(let t of e){r(t);let n={level:r,emit:i=>{let o=["stdout","event"];if(!o.includes(i)){let s=Qr(i,o);throw new D(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}}};if(t&&typeof t=="object")for(let[i,o]of Object.entries(t))if(n[i])n[i](o);else throw new D(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}},transactionOptions:e=>{if(!e)return;let r=e.maxWait;if(r!=null&&r<=0)throw new D(`Invalid value ${r} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);let t=e.timeout;if(t!=null&&t<=0)throw new D(`Invalid value ${t} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)},omit:(e,r)=>{if(typeof e!="object")throw new D('"omit" option is expected to be an object.');if(e===null)throw new D('"omit" option can not be `null`');let t=[];for(let[n,i]of Object.entries(e)){let o=Df(n,r.runtimeDataModel);if(!o){t.push({kind:"UnknownModel",modelKey:n});continue}for(let[s,a]of Object.entries(i)){let l=o.fields.find(u=>u.name===s);if(!l){t.push({kind:"UnknownField",modelKey:n,fieldName:s});continue}if(l.relationName){t.push({kind:"RelationInOmit",modelKey:n,fieldName:s});continue}typeof a!="boolean"&&t.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}}if(t.length>0)throw new D(Of(e,t))},__internal:e=>{if(!e)return;let r=["debug","engine","configOverride"];if(typeof e!="object")throw new D(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);for(let[t]of Object.entries(e))if(!r.includes(t)){let n=Qr(t,r);throw new D(`Invalid property ${JSON.stringify(t)} for "__internal" provided to PrismaClient constructor.${n}`)}}};function Xl(e,r){for(let[t,n]of Object.entries(e)){if(!Hl.includes(t)){let i=Qr(t,Hl);throw new D(`Unknown property ${t} provided to PrismaClient constructor.${i}`)}If[t](n,r)}if(e.datasourceUrl&&e.datasources)throw new D('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}function Qr(e,r){if(r.length===0||typeof e!="string")return"";let t=kf(e,r);return t?` Did you mean "${t}"?`:""}function kf(e,r){if(r.length===0)return null;let t=r.map(i=>({value:i,distance:(0,Zl.default)(e,i)}));t.sort((i,o)=>i.distance<o.distance?-1:1);let n=t[0];return n.distance<3?n.value:null}function Df(e,r){return zl(r.models,e)??zl(r.types,e)}function zl(e,r){let t=Object.keys(e).find(n=>Ye(n)===r);if(t)return e[t]}function Of(e,r){let t=_r(e);for(let o of r)switch(o.kind){case"UnknownModel":t.arguments.getField(o.modelKey)?.markAsError(),t.addErrorMessage(()=>`Unknown model name: ${o.modelKey}.`);break;case"UnknownField":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>`Model "${o.modelKey}" does not have a field named "${o.fieldName}".`);break;case"RelationInOmit":t.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>'Relations are already excluded by default and can not be specified in "omit".');break;case"InvalidFieldValue":t.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),t.addErrorMessage(()=>"Omit field option value must be a boolean.");break}let{message:n,args:i}=An(t,"colorless");return`Error validating "omit" option:

${i}

${n}`}function eu(e){return e.length===0?Promise.resolve([]):new Promise((r,t)=>{let n=new Array(e.length),i=null,o=!1,s=0,a=()=>{o||(s++,s===e.length&&(o=!0,i?t(i):r(n)))},l=u=>{o||(o=!0,t(u))};for(let u=0;u<e.length;u++)e[u].then(c=>{n[u]=c,a()},c=>{if(!Qn(c)){l(c);return}c.batchRequestIdx===u?l(c):(i||(i=c),a())})})}var rr=L("prisma:client");typeof globalThis=="object"&&(globalThis.NODE_CLIENT=!0);var Ff={requestArgsToMiddlewareArgs:e=>e,middlewareArgsToRequestArgs:e=>e},Mf=Symbol.for("prisma.client.transaction.id"),$f={id:0,nextId(){return++this.id}};function qf(e){class r{_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;_middlewares=new Gn;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;_createPrismaPromise=wo();constructor(n){e=n?.__internal?.configOverride?.(e)??e,el(e),n&&Xl(n,e);let i=new node_events__WEBPACK_IMPORTED_MODULE_10__.EventEmitter().on("error",()=>{});this._extensions=Nr.empty(),this._previewFeatures=Un(e),this._clientVersion=e.clientVersion??Jl,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=jl();let o=e.relativeEnvPaths&&{rootEnvPath:e.relativeEnvPaths.rootEnvPath&&node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&&node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s;if(n?.adapter){s=n.adapter;let l=e.activeProvider==="postgresql"||e.activeProvider==="cockroachdb"?"postgres":e.activeProvider;if(s.provider!==l)throw new T(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);if(n.datasources||n.datasourceUrl!==void 0)throw new T("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}let a=!s&&o&&it(o,{conflictCheck:"none"})||e.injectableEdgeEnv?.();try{let l=n??{},u=l.__internal??{},c=u.debug===!0;c&&L.enable("prisma:client");let p=node_path__WEBPACK_IMPORTED_MODULE_1__.resolve(e.dirname,e.relativePath);node_fs__WEBPACK_IMPORTED_MODULE_4__.existsSync(p)||(p=e.dirname),rr("dirname",e.dirname),rr("relativePath",e.relativePath),rr("cwd",p);let d=u.engine||{};if(l.errorFormat?this._errorFormat=l.errorFormat: false?0:node_process__WEBPACK_IMPORTED_MODULE_2__.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:p,dirname:e.dirname,enableDebugLogs:c,allowTriggerPanic:d.allowTriggerPanic,prismaPath:d.binaryPath??void 0,engineEndpoint:d.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&&Bl(l.log),logQueries:l.log&&!!(typeof l.log=="string"?l.log==="query":l.log.find(f=>typeof f=="string"?f==="query":f.level==="query")),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:rl(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:qr,getBatchRequestPayload:Fr,prismaGraphQLToJSError:Mr,PrismaClientUnknownRequestError:q,PrismaClientInitializationError:T,PrismaClientKnownRequestError:Z,debug:L("prisma:client:accelerateEngine"),engineVersion:tu.version,clientVersion:e.clientVersion}},rr("clientVersion",e.clientVersion),this._engine=Il(e,this._engineConfig),this._requestHandler=new Jn(this,i),l.log)for(let f of l.log){let h=typeof f=="string"?f:f.emit==="stdout"?f.level:null;h&&this.$on(h,g=>{rt.log(`${rt.tags[h]??""}`,g.message||g.query)})}}catch(l){throw l.clientVersion=this._clientVersion,l}return this._appliedParent=xt(this)}get[Symbol.toStringTag](){return"PrismaClient"}$use(n){this._middlewares.use(n)}$on(n,i){return n==="beforeExit"?this._engine.onBeforeExit(i):n&&this._engineConfig.logEmitter.on(n,i),this}$connect(){try{return this._engine.start()}catch(n){throw n.clientVersion=this._clientVersion,n}}async $disconnect(){try{await this._engine.stop()}catch(n){throw n.clientVersion=this._clientVersion,n}finally{jo()}}$executeRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:Eo({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$executeRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0){let[s,a]=ru(n,i);return bo(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`<SQL>`":"prisma.$executeRaw(sql`<SQL>`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})})}$executeRawUnsafe(n,...i){return this._createPrismaPromise(o=>(bo(this._activeProvider,n,i,"prisma.$executeRawUnsafe(<SQL>, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}$runCommandRaw(n){if(e.activeProvider!=="mongodb")throw new X(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});return this._createPrismaPromise(i=>this._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:kl,callsite:Ze(this._errorFormat),transaction:i}))}async $queryRawInternal(n,i,o,s){let a=this._activeProvider;return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:Eo({clientMethod:i,activeProvider:a}),callsite:Ze(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}$queryRaw(n,...i){return this._createPrismaPromise(o=>{if(n.raw!==void 0||n.sql!==void 0)return this.$queryRawInternal(o,"$queryRaw",...ru(n,i));throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})})}$queryRawTyped(n){return this._createPrismaPromise(i=>{if(!this._hasPreviewFlag("typedSql"))throw new X("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});return this.$queryRawInternal(i,"$queryRawTyped",n)})}$queryRawUnsafe(n,...i){return this._createPrismaPromise(o=>this.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}_transactionWithArray({promises:n,options:i}){let o=$f.nextId(),s=Vl(n.length),a=n.map((l,u)=>{if(l?.[Symbol.toStringTag]!=="PrismaPromise")throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");let c=i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,p={kind:"batch",id:o,index:u,isolationLevel:c,lock:s};return l.requestTransaction?.(p)??l});return eu(a)}async _transactionWithCallback({callback:n,options:i}){let o={traceparent:this._tracingHelper.getTraceParent()},s={maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a=await this._engine.transaction("start",o,s),l;try{let u={kind:"itx",...a};l=await n(this._createItxClient(u)),await this._engine.transaction("commit",o,a)}catch(u){throw await this._engine.transaction("rollback",o,a).catch(()=>{}),u}return l}_createItxClient(n){return he(xt(he(qa(this),[ee("_appliedParent",()=>this._appliedParent._createItxClient(n)),ee("_createPrismaPromise",()=>wo(n)),ee(Mf,()=>n.id)])),[Lr(Ga)])}$transaction(n,i){let o;typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=()=>{throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}:o=()=>this._transactionWithCallback({callback:n,options:i}):o=()=>this._transactionWithArray({promises:n,options:i});let s={name:"transaction",attributes:{method:"$transaction"}};return this._tracingHelper.runInChildSpan(s,o)}_request(n){n.otelParentCtx=this._tracingHelper.getActiveContext();let i=n.middlewareArgsMapper??Ff,o={args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s={middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a=-1,l=async u=>{let c=this._middlewares.get(++a);if(c)return this._tracingHelper.runInChildSpan(s.middleware,S=>c(u,P=>(S?.end(),l(P))));let{runInTransaction:p,args:d,...f}=u,h={...n,...f};d&&(h.args=i.middlewareArgsToRequestArgs(d)),n.transaction!==void 0&&p===!1&&delete h.transaction;let g=await Ha(this,h);return h.model?Ua({result:g,modelName:h.model,args:h.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):g};return this._tracingHelper.runInChildSpan(s.operation,()=>new node_async_hooks__WEBPACK_IMPORTED_MODULE_9__.AsyncResource("prisma-client-request").runInAsyncScope(()=>l(o)))}async _executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:u,transaction:c,unpacker:p,otelParentCtx:d,customDataProxyFetch:f}){try{n=u?u(n):n;let h={name:"serialize"},g=this._tracingHelper.runInChildSpan(h,()=>Hi({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));return L.enabled("prisma:client")&&(rr("Prisma Client call:"),rr(`prisma.${i}(${Ca(n)})`),rr("Generated request:"),rr(JSON.stringify(g,null,2)+`
`)),c?.kind==="batch"&&await c.lock,this._requestHandler.request({protocolQuery:g,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:c,unpacker:p,otelParentCtx:d,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:f})}catch(h){throw h.clientVersion=this._clientVersion,h}}$metrics=new yt(this);_hasPreviewFlag(n){return!!this._engineConfig.previewFeatures?.includes(n)}$applyPendingMigrations(){return this._engine.applyPendingMigrations()}$extends=ja}return r}function ru(e,r){return jf(e)?[new le(e,r),Ml]:[e,$l]}function jf(e){return Array.isArray(e)&&Array.isArray(e.raw)}var Vf=new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);function Bf(e){return new Proxy(e,{get(r,t){if(t in r)return r[t];if(!Vf.has(t))throw new TypeError(`Invalid enum value: ${String(t)}`)}})}function Uf(e){it(e,{conflictCheck:"warn"})}
/*! Bundled license information:

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.5.0
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=library.mjs.map


/***/ }),

/***/ "./node_modules/@dotenvx/dotenvx/package.json":
/*!****************************************************!*\
  !*** ./node_modules/@dotenvx/dotenvx/package.json ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"version":"1.48.4","name":"@dotenvx/dotenvx","description":"a secure dotenv–from the creator of `dotenv`","author":"@motdotla","keywords":["dotenv","env"],"homepage":"https://github.com/dotenvx/dotenvx","repository":{"type":"git","url":"git+https://github.com/dotenvx/dotenvx.git"},"license":"BSD-3-Clause","files":["src/**/*","CHANGELOG.md"],"main":"src/lib/main.js","types":"src/lib/main.d.ts","exports":{".":{"types":"./src/lib/main.d.ts","require":"./src/lib/main.js","default":"./src/lib/main.js"},"./config":"./src/lib/config.js","./config.js":"./src/lib/config.js","./package.json":"./package.json"},"bin":{"dotenvx":"./src/cli/dotenvx.js"},"scripts":{"standard":"standard","standard:fix":"standard --fix","test":"tap run --allow-empty-coverage --disable-coverage --timeout=60000","test-coverage":"tap run --show-full-coverage --timeout=60000","testshell":"bash shellspec","prerelease":"npm test && npm run testshell","release":"standard-version"},"funding":"https://dotenvx.com","dependencies":{"commander":"^11.1.0","dotenv":"^17.2.1","eciesjs":"^0.4.10","execa":"^5.1.1","fdir":"^6.2.0","ignore":"^5.3.0","object-treeify":"1.1.33","picomatch":"^4.0.2","which":"^4.0.0"},"devDependencies":{"@yao-pkg/pkg":"^5.14.2","capture-console":"^1.0.2","esbuild":"^0.24.0","proxyquire":"^2.1.3","sinon":"^14.0.1","standard":"^17.1.0","standard-version":"^9.5.0","tap":"^21.0.1"},"publishConfig":{"access":"public","provenance":true}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!****************************!*\
  !*** ./main/background.js ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _dotenvx_dotenvx_config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dotenvx/dotenvx/config */ "./node_modules/@dotenvx/dotenvx/src/lib/config.js");
/* harmony import */ var _dotenvx_dotenvx_config__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dotenvx_dotenvx_config__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! electron */ "electron");
/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var electron_serve__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron-serve */ "electron-serve");
/* harmony import */ var electron_serve__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron_serve__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _helpers_appEvents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/appEvents */ "./main/helpers/appEvents.js");
/* harmony import */ var _helpers_electronBuilderBootstrap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/electronBuilderBootstrap */ "./main/helpers/electronBuilderBootstrap.js");
/* harmony import */ var _helpers_ipcEvents__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers/ipcEvents */ "./main/helpers/ipcEvents.js");
/* harmony import */ var _helpers_ipcHandlers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/ipcHandlers */ "./main/helpers/ipcHandlers.js");
/* harmony import */ var _helpers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/utils */ "./main/helpers/utils.js");
/* harmony import */ var _helpers_windows__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/windows */ "./main/helpers/windows.js");










const isProd = "development" === "production";
const {
  autoUpdater,
  AppUpdater
} = __webpack_require__(/*! electron-updater */ "electron-updater");
console.log(`\n\nApplication Started\n\n`);
if (isProd) {
  electron_serve__WEBPACK_IMPORTED_MODULE_2___default()({
    directory: "app"
  });
  autoUpdater.updateConfigPath = process.resourcesPath;
} else {
  electron__WEBPACK_IMPORTED_MODULE_1__.app.setPath("userData", `${electron__WEBPACK_IMPORTED_MODULE_1__.app.getPath("userData")} (development)`);
  autoUpdater.updateConfigPath = path__WEBPACK_IMPORTED_MODULE_3___default().join(__dirname, "../resources/app-update.yml");
}
console.log(`\n\nStarting Background\n\n`);
autoUpdater.autoDownload = false;
autoUpdater.autoInstallOnAppQuit = true;
autoUpdater.forceDevUpdateConfig = true;
autoUpdater.channel = "latest";
autoUpdater.setFeedUrl = "https://github.com/DexDevLab/nextron-autoupdate-app";
console.log(`\n\nBootstrapping Electron Builder Config\n\n`);
(0,_helpers_electronBuilderBootstrap__WEBPACK_IMPORTED_MODULE_5__.electronBuilderBootstrap)();
(async () => {
  // Trigger 'Ready' Event
  await electron__WEBPACK_IMPORTED_MODULE_1__.app.whenReady();
  console.log(`\n\nReady Events Triggered\n\n`);

  // Instantiate and show Splash Window
  await _helpers_windows__WEBPACK_IMPORTED_MODULE_9__.instantiateWindow.splash();
  console.log(`\n\nSplash Screen Instantiated\n\n`);

  // Instantiate Electron Store
  await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.instantiateElectronStore)(true);
  console.log(`\n\nElectron Store Instantiated\n\n`);

  // Instantiate Logger
  await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.instantiateElectronStore)(true, {
    name: "log"
  });
  console.log(`\n\nLogger Store Instantiated\n\n`);

  // Registering Events and Functions
  (0,_helpers_appEvents__WEBPACK_IMPORTED_MODULE_4__.appEvents)();
  await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.logger)(`App Events Registered`);

  // Global exception handler
  process.on("uncaughtException", error => {
    console.log(error);
    (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.logger)(error);
  });
  (0,_helpers_ipcEvents__WEBPACK_IMPORTED_MODULE_6__.ipcEvents)();
  await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.logger)(`IPC Events and Functions Registered`);
  (0,_helpers_ipcHandlers__WEBPACK_IMPORTED_MODULE_7__.ipcHandlers)();
  await (0,_helpers_utils__WEBPACK_IMPORTED_MODULE_8__.logger)(`IPC API Handlers Registered`);
  autoUpdater.checkForUpdates();
  electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
    status: 102,
    data: "Checking for updates..."
  });
  autoUpdater.on("update-available", info => {
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 200,
      data: "Update available"
    });
    let pth = autoUpdater.downloadUpdate();
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 200,
      data: pth
    });
  });
  autoUpdater.on("update-not-available", info => {
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 200,
      data: "No update available"
    });
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 200,
      data: pth
    });
  });
  autoUpdater.on("update-downloaded", info => {
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 200,
      data: "Update downloaded"
    });
  });
  autoUpdater.on("error", info => {
    electron__WEBPACK_IMPORTED_MODULE_1__.ipcMain.emit("update-msg", null, {
      status: 500,
      data: info
    });
  });
})();
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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UUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUVBQWlFO0FBQy9FO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsaUNBQWlDO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMzbkJBLDBDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLDZDOzs7Ozs7Ozs7OztBQ0FBLCtDOzs7Ozs7Ozs7OztBQ0FBLHdDOzs7Ozs7Ozs7OztBQ0FBLHdDOzs7Ozs7Ozs7OztBQ0FBLG9DOzs7Ozs7Ozs7OztBQ0FBLDZDOzs7Ozs7Ozs7OztBQ0FBLHdDOzs7Ozs7Ozs7OztBQ0FBLG9DOzs7Ozs7Ozs7OztBQ0FBLHNDOzs7Ozs7Ozs7OztBQ0FBLHlDOzs7Ozs7Ozs7OztBQ0FBLHFDOzs7Ozs7Ozs7OztBQ0FBLHNDOzs7Ozs7Ozs7OztBQ0FBLCtCOzs7Ozs7Ozs7OztBQ0FBLGlDOzs7Ozs7Ozs7OztBQ0FBLGdDOzs7Ozs7Ozs7OztBQ0FBLG9EOzs7Ozs7Ozs7OztBQ0FBLHlEOzs7Ozs7Ozs7OztBQ0FBLDREOzs7Ozs7Ozs7OztBQ0FBLDREOzs7Ozs7Ozs7OztBQ0FBLDhEOzs7Ozs7Ozs7OztBQ0FBLG9EOzs7Ozs7Ozs7O0FDQUEsd0lBQStELEM7Ozs7Ozs7Ozs7QUNBL0QsNElBQWlFLEM7Ozs7Ozs7Ozs7QUNBakUsOElBQWtFLEM7Ozs7Ozs7Ozs7QUNBbEUsMElBQWdFLEM7Ozs7Ozs7Ozs7QUNBaEUsb0lBQTZELEM7Ozs7Ozs7Ozs7QUNBN0Qsb0lBQTZELEM7Ozs7Ozs7Ozs7QUNBN0QsMEpBQXdFLEM7Ozs7Ozs7Ozs7QUNBeEUsc0pBQXNFLEM7Ozs7Ozs7Ozs7QUNBdEUsOEtBQWtGLEM7Ozs7Ozs7Ozs7QUNBbEYsZ0xBQW1GLEM7Ozs7Ozs7Ozs7QUNBbkYsd0tBQStFLEM7Ozs7Ozs7Ozs7QUNBL0UsZ0lBQTJELEM7Ozs7Ozs7Ozs7QUNBM0QsZ0lBQTJELEM7Ozs7Ozs7Ozs7QUNBM0QsNkJBQTZCLG1CQUFPLENBQUMsdUhBQWlEO0FBQ3RGLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxrQ0FBa0MseUJBQXlCLFNBQVMseUJBQXlCLGtCOzs7Ozs7Ozs7O0FDVjdGLDBCQUEw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dHJvbi1hdXRvdXBkYXRlLWFwcC93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L25vZGVfbW9kdWxlcy9mZGlyL2Rpc3QvYXBpL2FzeW5jLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvZmRpci9kaXN0L2FwaS9jb3VudGVyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvZmRpci9kaXN0L2FwaS9mdW5jdGlvbnMvZ2V0LWFycmF5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvZmRpci9kaXN0L2FwaS9mdW5jdGlvbnMvZ3JvdXAtZmlsZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L25vZGVfbW9kdWxlcy9mZGlyL2Rpc3QvYXBpL2Z1bmN0aW9ucy9pbnZva2UtY2FsbGJhY2suanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L25vZGVfbW9kdWxlcy9mZGlyL2Rpc3QvYXBpL2Z1bmN0aW9ucy9qb2luLXBhdGguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L25vZGVfbW9kdWxlcy9mZGlyL2Rpc3QvYXBpL2Z1bmN0aW9ucy9wdXNoLWRpcmVjdG9yeS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9hcGkvZnVuY3Rpb25zL3B1c2gtZmlsZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9hcGkvZnVuY3Rpb25zL3Jlc29sdmUtc3ltbGluay5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9hcGkvZnVuY3Rpb25zL3dhbGstZGlyZWN0b3J5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvZmRpci9kaXN0L2FwaS9xdWV1ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9hcGkvc3luYy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9hcGkvd2Fsa2VyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvZmRpci9kaXN0L2J1aWxkZXIvYXBpLWJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L25vZGVfbW9kdWxlcy9mZGlyL2Rpc3QvYnVpbGRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC90eXBlcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL2ZkaXIvZGlzdC91dGlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL3BpY29tYXRjaC9pbmRleC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9wYXJzZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvbm9kZV9tb2R1bGVzL3BpY29tYXRjaC9saWIvcGljb21hdGNoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi9zY2FuLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9ub2RlX21vZHVsZXMvcGljb21hdGNoL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9jb25maWcuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9idWlsZEVudnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9jaG9tcC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2NvbG9yRGVwdGguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9jb252ZW50aW9ucy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2RlY3J5cHQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9kZWNyeXB0S2V5VmFsdWUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9kZXByZWNhdGlvbk5vdGljZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2RldGVjdEVuY29kaW5nLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZGV0ZXJtaW5lRW52cy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2RvdGVudk9wdGlvblBhdGhzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZG90ZW52UGFyc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9kb3RlbnZQcml2YXRlS2V5TmFtZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9lbmNyeXB0VmFsdWUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9lc2NhcGVEb2xsYXJTaWducy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2VzY2FwZUZvclJlZ2V4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZXZhbEtleVZhbHVlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZmluZEVudkZpbGVzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZmluZFByaXZhdGVLZXkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9maW5kUHVibGljS2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZnN4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZ3Vlc3NFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2d1ZXNzUHJpdmF0ZUtleUZpbGVuYW1lLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvZ3Vlc3NQcml2YXRlS2V5TmFtZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2d1ZXNzUHVibGljS2V5TmFtZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL2lzRW5jcnlwdGVkLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvaXNJZ25vcmluZ0RvdGVudktleXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9rZXlwYWlyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvcGFja2FnZUpzb24uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9wYXJzZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL3BhcnNlRW5jcnlwdGlvbktleUZyb21Eb3RlbnZLZXkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9wYXJzZUVudmlyb25tZW50RnJvbURvdGVudktleS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL3Byb0tleXBhaXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9xdW90ZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy9yZXBsYWNlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvcmVzb2x2ZUVzY2FwZVNlcXVlbmNlcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9oZWxwZXJzL3Jlc29sdmVIb21lLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvc21hcnREb3RlbnZQcml2YXRlS2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL2hlbHBlcnMvc21hcnREb3RlbnZQdWJsaWNLZXkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvaGVscGVycy90cnVuY2F0ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bkb3RlbnZ4L2RvdGVudngvc3JjL2xpYi9tYWluLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL3NlcnZpY2VzL2dlbmV4YW1wbGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvc2VydmljZXMvZ2V0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL3NlcnZpY2VzL2tleXBhaXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvc2VydmljZXMvbHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvc2VydmljZXMvcmFkYXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9saWIvc2VydmljZXMvcnVuLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvbGliL3NlcnZpY2VzL3NldHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AZG90ZW52eC9kb3RlbnZ4L3NyYy9zaGFyZWQvY29sb3JzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGRvdGVudngvZG90ZW52eC9zcmMvc2hhcmVkL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BlY2llcy9jaXBoZXJzL2Rpc3QvX25vZGUvY29tcGF0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGVjaWVzL2NpcGhlcnMvZGlzdC9fbm9kZS9oY2hhY2hhLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGVjaWVzL2NpcGhlcnMvZGlzdC9hZXMvbm9kZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BlY2llcy9jaXBoZXJzL2Rpc3QvY2hhY2hhL25vZGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy9jcnlwdG9Ob2RlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2NpcGhlcnMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY2lwaGVycy93ZWJjcnlwdG8uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL19zaG9ydHdfdXRpbHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L2N1cnZlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9lZHdhcmRzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb250Z29tZXJ5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy91dGlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX21kLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ob2RlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9oa2RmLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9obWFjLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbWFpbi9jb250cm9sbGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbWFpbi9jb250cm9sbGVycy9sYXVuY2hlci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbWFpbi9jb250cm9sbGVycy9zdG9yZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbWFpbi9jb250cm9sbGVycy90ZXN0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9tYWluL2hlbHBlcnMvYXBwRXZlbnRzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9tYWluL2hlbHBlcnMvY3JlYXRlV2luZG93LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9tYWluL2hlbHBlcnMvZWxlY3Ryb25CdWlsZGVyQm9vdHN0cmFwLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9tYWluL2hlbHBlcnMvaXBjRXZlbnRzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9tYWluL2hlbHBlcnMvaXBjSGFuZGxlcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL21haW4vaGVscGVycy91dGlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbWFpbi9oZWxwZXJzL3dpbmRvd3MuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL21haW4vc2VydmljZXMvcHJpc21hLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9yZXNvdXJjZXMvZ2VuZXJhdGVkL3ByaXNtYS9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL3Jlc291cmNlcy9nZW5lcmF0ZWQvcHJpc21hL2VudW1zLnRzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9yZXNvdXJjZXMvZ2VuZXJhdGVkL3ByaXNtYS9pbnRlcm5hbC9jbGFzcy50cyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vcmVzb3VyY2VzL2dlbmVyYXRlZC9wcmlzbWEvaW50ZXJuYWwvcHJpc21hTmFtZXNwYWNlLnRzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvZWNpZXNqcy9kaXN0L2NvbmZpZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2VjaWVzanMvZGlzdC9jb25zdHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3Qva2V5cy9Qcml2YXRlS2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvZWNpZXNqcy9kaXN0L2tleXMvUHVibGljS2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvZWNpZXNqcy9kaXN0L2tleXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3QvdXRpbHMvZWxsaXB0aWMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3QvdXRpbHMvaGFzaC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2VjaWVzanMvZGlzdC91dGlscy9oZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3QvdXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9lY2llc2pzL2Rpc3QvdXRpbHMvc3ltbWV0cmljLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvaWdub3JlL2luZGV4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImNoaWxkX3Byb2Nlc3NcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJlbGVjdHJvblwiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImZzXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTphc3luY19ob29rc1wiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6Y3J5cHRvXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTpldmVudHNcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJub2RlOmZzXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTpmcy9wcm9taXNlc1wiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6bW9kdWxlXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTpvc1wiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6cGF0aFwiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6cHJvY2Vzc1wiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcIm5vZGU6dXJsXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwibm9kZTp1dGlsXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwib3NcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidHR5XCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCB1bWQgXCJkb3RlbnZcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIHVtZCBcImVsZWN0cm9uLWRsXCIiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC9leHRlcm5hbCB1bWQgXCJlbGVjdHJvbi1zZXJ2ZVwiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvZXh0ZXJuYWwgdW1kIFwiZWxlY3Ryb24tc3RvcmVcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIHVtZCBcImVsZWN0cm9uLXVwZGF0ZXJcIiIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL2V4dGVybmFsIHVtZCBcImxvZGFzaFwiIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL2Zvci1lYWNoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9pbnN0YW5jZS9wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL2luc3RhbmNlL3NvbWUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvY29yZS1qcy1zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS1jb3JlanMzL2NvcmUtanMtc3RhYmxlL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9jb3JlLWpzLXN0YWJsZS9zZXQtdGltZW91dC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy90b1ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lLWNvcmVqczMvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUtY29yZWpzMy9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9hY3R1YWwvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9hY3R1YWwvc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2FjdHVhbC9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvYWN0dWFsL3N5bWJvbC90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9hcnJheS92aXJ0dWFsL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvYXJyYXkvdmlydHVhbC9zb21lLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL2luc3RhbmNlL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvaW5zdGFuY2UvcmV2ZXJzZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9pbnN0YW5jZS9zb21lLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N0cmluZy92aXJ0dWFsL3BhZC1zdGFydC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9lcy9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZXMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2VzL3N5bWJvbC90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9mZWF0dXJlcy9zeW1ib2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3N5bWJvbC90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvZnVsbC9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2Z1bGwvc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2Z1bGwvc3ltYm9sL2l0ZXJhdG9yLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2Z1bGwvc3ltYm9sL3RvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1jYWxsYWJsZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2FycmF5LXNsaWNlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLWl0ZXItcmVzdWx0LW9iamVjdC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4tYWNjZXNzb3IuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZGVmaW5lLWdsb2JhbC1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kb2VzLW5vdC1leGNlZWQtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9lbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZXhwb3J0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9mYWlscy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tYXBwbHkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1uYXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLW5hbWUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9nZXQtYnVpbHQtaW4tcHJvdG90eXBlLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9nZXQtanNvbi1yZXBsYWNlci1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2V0LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9odG1sLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLWNhbGxhYmxlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pcy1wb3NzaWJsZS1wcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2lzLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvaXRlcmF0b3ItY3JlYXRlLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL2xlbmd0aC1vZi1hcnJheS1saWtlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9tYXRoLXRydW5jLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1rZXlzLWludGVybmFsLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL293bi1rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9wYXRoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3NjaGVkdWxlcnMtZml4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zaGFyZWQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N0cmluZy1wYWQtd2Via2l0LWJ1Zy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3RyaW5nLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3N5bWJvbC1pcy1yZWdpc3RlcmVkLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy9zeW1ib2wtaXMtd2VsbC1rbm93bi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvc3ltYm9sLXJlZ2lzdHJ5LWRldGVjdGlvbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy90cnktdG8tc3RyaW5nLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy91aWQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy92OC1wcm90b3R5cGUtZGVmaW5lLWJ1Zy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvdmFsaWRhdGUtYXJndW1lbnRzLWxlbmd0aC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9pbnRlcm5hbHMvd2Vhay1tYXAtYmFzaWMtZGV0ZWN0aW9uLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2guanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5hcnJheS5zb21lLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5qc29uLnN0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLmpzb24udG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm1hdGgudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnJlZmxlY3QudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN0cmluZy5wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuYXN5bmMtZGlzcG9zZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5kaXNwb3NlLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXMuc3ltYm9sLmZvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuaXMtY29uY2F0LXNwcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wua2V5LWZvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5tYXRjaC1hbGwuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wubWF0Y2guanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zZWFyY2guanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC5zcGxpdC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzLnN5bWJvbC51bnNjb3BhYmxlcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5mdW5jdGlvbi5tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuYXN5bmMtZGlzcG9zZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuY3VzdG9tLW1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLmRpc3Bvc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy9lc25leHQuc3ltYm9sLmlzLXJlZ2lzdGVyZWQtc3ltYm9sLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5pcy1yZWdpc3RlcmVkLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5pcy13ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuaXMtd2VsbC1rbm93bi5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wubWF0Y2hlci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wubWV0YWRhdGEta2V5LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucGF0dGVybi1tYXRjaC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucmVwbGFjZS1hbGwuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9tb2R1bGVzL3dlYi5zZXQtaW50ZXJ2YWwuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy93ZWIuc2V0LXRpbWVvdXQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9hcnJheS92aXJ0dWFsL2Zvci1lYWNoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL2Zvci1lYWNoLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9wYWQtc3RhcnQuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3NvbWUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllcy5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9rZXlzLmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9zZXQtdGltZW91dC5qcyIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMtcHVyZS9zdGFibGUvc3ltYm9sL2luZGV4LmpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvLi9ub2RlX21vZHVsZXMvY29yZS1qcy1wdXJlL3N0YWJsZS9zeW1ib2wvaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9jb3JlLWpzLXB1cmUvc3RhYmxlL3N5bWJvbC90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL25vZGVfbW9kdWxlcy9AcHJpc21hL2NsaWVudC9ydW50aW1lL2xpYnJhcnkubWpzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL3dlYnBhY2svcnVudGltZS9jcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL25leHRyb24tYXV0b3VwZGF0ZS1hcHAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9uZXh0cm9uLWF1dG91cGRhdGUtYXBwL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vbmV4dHJvbi1hdXRvdXBkYXRlLWFwcC8uL21haW4vYmFja2dyb3VuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJkb3RlbnZcIiksIHJlcXVpcmUoXCJlbGVjdHJvbi1zZXJ2ZVwiKSwgcmVxdWlyZShcImVsZWN0cm9uLXN0b3JlXCIpLCByZXF1aXJlKFwibG9kYXNoXCIpLCByZXF1aXJlKFwiZWxlY3Ryb24tZGxcIiksIHJlcXVpcmUoXCJlbGVjdHJvbi11cGRhdGVyXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImRvdGVudlwiLCBcImVsZWN0cm9uLXNlcnZlXCIsIFwiZWxlY3Ryb24tc3RvcmVcIiwgXCJsb2Rhc2hcIiwgXCJlbGVjdHJvbi1kbFwiLCBcImVsZWN0cm9uLXVwZGF0ZXJcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGZhY3RvcnkocmVxdWlyZShcImRvdGVudlwiKSwgcmVxdWlyZShcImVsZWN0cm9uLXNlcnZlXCIpLCByZXF1aXJlKFwiZWxlY3Ryb24tc3RvcmVcIiksIHJlcXVpcmUoXCJsb2Rhc2hcIiksIHJlcXVpcmUoXCJlbGVjdHJvbi1kbFwiKSwgcmVxdWlyZShcImVsZWN0cm9uLXVwZGF0ZXJcIikpIDogZmFjdG9yeShyb290W1wiZG90ZW52XCJdLCByb290W1wiZWxlY3Ryb24tc2VydmVcIl0sIHJvb3RbXCJlbGVjdHJvbi1zdG9yZVwiXSwgcm9vdFtcImxvZGFzaFwiXSwgcm9vdFtcImVsZWN0cm9uLWRsXCJdLCByb290W1wiZWxlY3Ryb24tdXBkYXRlclwiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KShnbG9iYWwsIChfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2RvdGVudl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX3NlcnZlX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZWxlY3Ryb25fc3RvcmVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9sb2Rhc2hfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9lbGVjdHJvbl9kbF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX3VwZGF0ZXJfXykgPT4ge1xucmV0dXJuICIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxsYmFjayA9IGV4cG9ydHMucHJvbWlzZSA9IHZvaWQgMDtcbmNvbnN0IHdhbGtlcl8xID0gcmVxdWlyZShcIi4vd2Fsa2VyXCIpO1xuZnVuY3Rpb24gcHJvbWlzZShyb290LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2FsbGJhY2socm9vdCwgb3B0aW9ucywgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnByb21pc2UgPSBwcm9taXNlO1xuZnVuY3Rpb24gY2FsbGJhY2socm9vdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBsZXQgd2Fsa2VyID0gbmV3IHdhbGtlcl8xLldhbGtlcihyb290LCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgd2Fsa2VyLnN0YXJ0KCk7XG59XG5leHBvcnRzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ291bnRlciA9IHZvaWQgMDtcbmNsYXNzIENvdW50ZXIge1xuICAgIF9maWxlcyA9IDA7XG4gICAgX2RpcmVjdG9yaWVzID0gMDtcbiAgICBzZXQgZmlsZXMobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZpbGVzID0gbnVtO1xuICAgIH1cbiAgICBnZXQgZmlsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxlcztcbiAgICB9XG4gICAgc2V0IGRpcmVjdG9yaWVzKG51bSkge1xuICAgICAgICB0aGlzLl9kaXJlY3RvcmllcyA9IG51bTtcbiAgICB9XG4gICAgZ2V0IGRpcmVjdG9yaWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0b3JpZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSBgZGlyZWN0b3JpZXNgIGluc3RlYWRcbiAgICAgKi9cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgZ2V0IGRpcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJlY3RvcmllcztcbiAgICB9XG59XG5leHBvcnRzLkNvdW50ZXIgPSBDb3VudGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkID0gdm9pZCAwO1xuY29uc3QgZ2V0QXJyYXkgPSAocGF0aHMpID0+IHtcbiAgICByZXR1cm4gcGF0aHM7XG59O1xuY29uc3QgZ2V0QXJyYXlHcm91cCA9ICgpID0+IHtcbiAgICByZXR1cm4gW1wiXCJdLnNsaWNlKDAsIDApO1xufTtcbmZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ncm91cCA/IGdldEFycmF5R3JvdXAgOiBnZXRBcnJheTtcbn1cbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmNvbnN0IGdyb3VwRmlsZXMgPSAoZ3JvdXBzLCBkaXJlY3RvcnksIGZpbGVzKSA9PiB7XG4gICAgZ3JvdXBzLnB1c2goeyBkaXJlY3RvcnksIGZpbGVzLCBkaXI6IGRpcmVjdG9yeSB9KTtcbn07XG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5ncm91cCA/IGdyb3VwRmlsZXMgOiBlbXB0eTtcbn1cbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmNvbnN0IG9ubHlDb3VudHNTeW5jID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmNvdW50cztcbn07XG5jb25zdCBncm91cHNTeW5jID0gKHN0YXRlKSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLmdyb3Vwcztcbn07XG5jb25zdCBkZWZhdWx0U3luYyA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5wYXRocztcbn07XG5jb25zdCBsaW1pdEZpbGVzU3luYyA9IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5wYXRocy5zbGljZSgwLCBzdGF0ZS5vcHRpb25zLm1heEZpbGVzKTtcbn07XG5jb25zdCBvbmx5Q291bnRzQXN5bmMgPSAoc3RhdGUsIGVycm9yLCBjYWxsYmFjaykgPT4ge1xuICAgIHJlcG9ydChlcnJvciwgY2FsbGJhY2ssIHN0YXRlLmNvdW50cywgc3RhdGUub3B0aW9ucy5zdXBwcmVzc0Vycm9ycyk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZGVmYXVsdEFzeW5jID0gKHN0YXRlLCBlcnJvciwgY2FsbGJhY2spID0+IHtcbiAgICByZXBvcnQoZXJyb3IsIGNhbGxiYWNrLCBzdGF0ZS5wYXRocywgc3RhdGUub3B0aW9ucy5zdXBwcmVzc0Vycm9ycyk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgbGltaXRGaWxlc0FzeW5jID0gKHN0YXRlLCBlcnJvciwgY2FsbGJhY2spID0+IHtcbiAgICByZXBvcnQoZXJyb3IsIGNhbGxiYWNrLCBzdGF0ZS5wYXRocy5zbGljZSgwLCBzdGF0ZS5vcHRpb25zLm1heEZpbGVzKSwgc3RhdGUub3B0aW9ucy5zdXBwcmVzc0Vycm9ycyk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgZ3JvdXBzQXN5bmMgPSAoc3RhdGUsIGVycm9yLCBjYWxsYmFjaykgPT4ge1xuICAgIHJlcG9ydChlcnJvciwgY2FsbGJhY2ssIHN0YXRlLmdyb3Vwcywgc3RhdGUub3B0aW9ucy5zdXBwcmVzc0Vycm9ycyk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZnVuY3Rpb24gcmVwb3J0KGVycm9yLCBjYWxsYmFjaywgb3V0cHV0LCBzdXBwcmVzc0Vycm9ycykge1xuICAgIGlmIChlcnJvciAmJiAhc3VwcHJlc3NFcnJvcnMpXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCBvdXRwdXQpO1xuICAgIGVsc2VcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgb3V0cHV0KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMsIGlzU3luY2hyb25vdXMpIHtcbiAgICBjb25zdCB7IG9ubHlDb3VudHMsIGdyb3VwLCBtYXhGaWxlcyB9ID0gb3B0aW9ucztcbiAgICBpZiAob25seUNvdW50cylcbiAgICAgICAgcmV0dXJuIGlzU3luY2hyb25vdXNcbiAgICAgICAgICAgID8gb25seUNvdW50c1N5bmNcbiAgICAgICAgICAgIDogb25seUNvdW50c0FzeW5jO1xuICAgIGVsc2UgaWYgKGdyb3VwKVxuICAgICAgICByZXR1cm4gaXNTeW5jaHJvbm91c1xuICAgICAgICAgICAgPyBncm91cHNTeW5jXG4gICAgICAgICAgICA6IGdyb3Vwc0FzeW5jO1xuICAgIGVsc2UgaWYgKG1heEZpbGVzKVxuICAgICAgICByZXR1cm4gaXNTeW5jaHJvbm91c1xuICAgICAgICAgICAgPyBsaW1pdEZpbGVzU3luY1xuICAgICAgICAgICAgOiBsaW1pdEZpbGVzQXN5bmM7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gaXNTeW5jaHJvbm91c1xuICAgICAgICAgICAgPyBkZWZhdWx0U3luY1xuICAgICAgICAgICAgOiBkZWZhdWx0QXN5bmM7XG59XG5leHBvcnRzLmJ1aWxkID0gYnVpbGQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGQgPSBleHBvcnRzLmpvaW5EaXJlY3RvcnlQYXRoID0gZXhwb3J0cy5qb2luUGF0aFdpdGhCYXNlUGF0aCA9IHZvaWQgMDtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGpvaW5QYXRoV2l0aEJhc2VQYXRoKGZpbGVuYW1lLCBkaXJlY3RvcnlQYXRoKSB7XG4gICAgcmV0dXJuIGRpcmVjdG9yeVBhdGggKyBmaWxlbmFtZTtcbn1cbmV4cG9ydHMuam9pblBhdGhXaXRoQmFzZVBhdGggPSBqb2luUGF0aFdpdGhCYXNlUGF0aDtcbmZ1bmN0aW9uIGpvaW5QYXRoV2l0aFJlbGF0aXZlUGF0aChyb290LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChmaWxlbmFtZSwgZGlyZWN0b3J5UGF0aCkge1xuICAgICAgICBjb25zdCBzYW1lUm9vdCA9IGRpcmVjdG9yeVBhdGguc3RhcnRzV2l0aChyb290KTtcbiAgICAgICAgaWYgKHNhbWVSb290KVxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdG9yeVBhdGgucmVwbGFjZShyb290LCBcIlwiKSArIGZpbGVuYW1lO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gKCgwLCB1dGlsc18xLmNvbnZlcnRTbGFzaGVzKSgoMCwgcGF0aF8xLnJlbGF0aXZlKShyb290LCBkaXJlY3RvcnlQYXRoKSwgb3B0aW9ucy5wYXRoU2VwYXJhdG9yKSArXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoU2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGpvaW5QYXRoKGZpbGVuYW1lKSB7XG4gICAgcmV0dXJuIGZpbGVuYW1lO1xufVxuZnVuY3Rpb24gam9pbkRpcmVjdG9yeVBhdGgoZmlsZW5hbWUsIGRpcmVjdG9yeVBhdGgsIHNlcGFyYXRvcikge1xuICAgIHJldHVybiBkaXJlY3RvcnlQYXRoICsgZmlsZW5hbWUgKyBzZXBhcmF0b3I7XG59XG5leHBvcnRzLmpvaW5EaXJlY3RvcnlQYXRoID0gam9pbkRpcmVjdG9yeVBhdGg7XG5mdW5jdGlvbiBidWlsZChyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZWxhdGl2ZVBhdGhzLCBpbmNsdWRlQmFzZVBhdGggfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlbGF0aXZlUGF0aHMgJiYgcm9vdFxuICAgICAgICA/IGpvaW5QYXRoV2l0aFJlbGF0aXZlUGF0aChyb290LCBvcHRpb25zKVxuICAgICAgICA6IGluY2x1ZGVCYXNlUGF0aFxuICAgICAgICAgICAgPyBqb2luUGF0aFdpdGhCYXNlUGF0aFxuICAgICAgICAgICAgOiBqb2luUGF0aDtcbn1cbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHB1c2hEaXJlY3RvcnlXaXRoUmVsYXRpdmVQYXRoKHJvb3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGRpcmVjdG9yeVBhdGgsIHBhdGhzKSB7XG4gICAgICAgIHBhdGhzLnB1c2goZGlyZWN0b3J5UGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGgpIHx8IFwiLlwiKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcHVzaERpcmVjdG9yeUZpbHRlcldpdGhSZWxhdGl2ZVBhdGgocm9vdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZGlyZWN0b3J5UGF0aCwgcGF0aHMsIGZpbHRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gZGlyZWN0b3J5UGF0aC5zdWJzdHJpbmcocm9vdC5sZW5ndGgpIHx8IFwiLlwiO1xuICAgICAgICBpZiAoZmlsdGVycy5ldmVyeSgoZmlsdGVyKSA9PiBmaWx0ZXIocmVsYXRpdmVQYXRoLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBwdXNoRGlyZWN0b3J5ID0gKGRpcmVjdG9yeVBhdGgsIHBhdGhzKSA9PiB7XG4gICAgcGF0aHMucHVzaChkaXJlY3RvcnlQYXRoIHx8IFwiLlwiKTtcbn07XG5jb25zdCBwdXNoRGlyZWN0b3J5RmlsdGVyID0gKGRpcmVjdG9yeVBhdGgsIHBhdGhzLCBmaWx0ZXJzKSA9PiB7XG4gICAgY29uc3QgcGF0aCA9IGRpcmVjdG9yeVBhdGggfHwgXCIuXCI7XG4gICAgaWYgKGZpbHRlcnMuZXZlcnkoKGZpbHRlcikgPT4gZmlsdGVyKHBhdGgsIHRydWUpKSkge1xuICAgICAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgIH1cbn07XG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmZ1bmN0aW9uIGJ1aWxkKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGluY2x1ZGVEaXJzLCBmaWx0ZXJzLCByZWxhdGl2ZVBhdGhzIH0gPSBvcHRpb25zO1xuICAgIGlmICghaW5jbHVkZURpcnMpXG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICBpZiAocmVsYXRpdmVQYXRocylcbiAgICAgICAgcmV0dXJuIGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGhcbiAgICAgICAgICAgID8gcHVzaERpcmVjdG9yeUZpbHRlcldpdGhSZWxhdGl2ZVBhdGgocm9vdClcbiAgICAgICAgICAgIDogcHVzaERpcmVjdG9yeVdpdGhSZWxhdGl2ZVBhdGgocm9vdCk7XG4gICAgcmV0dXJuIGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGggPyBwdXNoRGlyZWN0b3J5RmlsdGVyIDogcHVzaERpcmVjdG9yeTtcbn1cbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZCA9IHZvaWQgMDtcbmNvbnN0IHB1c2hGaWxlRmlsdGVyQW5kQ291bnQgPSAoZmlsZW5hbWUsIF9wYXRocywgY291bnRzLCBmaWx0ZXJzKSA9PiB7XG4gICAgaWYgKGZpbHRlcnMuZXZlcnkoKGZpbHRlcikgPT4gZmlsdGVyKGZpbGVuYW1lLCBmYWxzZSkpKVxuICAgICAgICBjb3VudHMuZmlsZXMrKztcbn07XG5jb25zdCBwdXNoRmlsZUZpbHRlciA9IChmaWxlbmFtZSwgcGF0aHMsIF9jb3VudHMsIGZpbHRlcnMpID0+IHtcbiAgICBpZiAoZmlsdGVycy5ldmVyeSgoZmlsdGVyKSA9PiBmaWx0ZXIoZmlsZW5hbWUsIGZhbHNlKSkpXG4gICAgICAgIHBhdGhzLnB1c2goZmlsZW5hbWUpO1xufTtcbmNvbnN0IHB1c2hGaWxlQ291bnQgPSAoX2ZpbGVuYW1lLCBfcGF0aHMsIGNvdW50cywgX2ZpbHRlcnMpID0+IHtcbiAgICBjb3VudHMuZmlsZXMrKztcbn07XG5jb25zdCBwdXNoRmlsZSA9IChmaWxlbmFtZSwgcGF0aHMpID0+IHtcbiAgICBwYXRocy5wdXNoKGZpbGVuYW1lKTtcbn07XG5jb25zdCBlbXB0eSA9ICgpID0+IHsgfTtcbmZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4Y2x1ZGVGaWxlcywgZmlsdGVycywgb25seUNvdW50cyB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXhjbHVkZUZpbGVzKVxuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgaWYgKGZpbHRlcnMgJiYgZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG9ubHlDb3VudHMgPyBwdXNoRmlsZUZpbHRlckFuZENvdW50IDogcHVzaEZpbGVGaWx0ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9ubHlDb3VudHMpIHtcbiAgICAgICAgcmV0dXJuIHB1c2hGaWxlQ291bnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcHVzaEZpbGU7XG4gICAgfVxufVxuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWxkID0gdm9pZCAwO1xuY29uc3QgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCByZXNvbHZlU3ltbGlua3NBc3luYyA9IGZ1bmN0aW9uIChwYXRoLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB7IHF1ZXVlLCBvcHRpb25zOiB7IHN1cHByZXNzRXJyb3JzIH0sIH0gPSBzdGF0ZTtcbiAgICBxdWV1ZS5lbnF1ZXVlKCk7XG4gICAgZnNfMS5kZWZhdWx0LnJlYWxwYXRoKHBhdGgsIChlcnJvciwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZS5kZXF1ZXVlKHN1cHByZXNzRXJyb3JzID8gbnVsbCA6IGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIGZzXzEuZGVmYXVsdC5zdGF0KHJlc29sdmVkUGF0aCwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLmRlcXVldWUoc3VwcHJlc3NFcnJvcnMgPyBudWxsIDogZXJyb3IsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkgJiYgaXNSZWN1cnNpdmUocGF0aCwgcmVzb2x2ZWRQYXRoLCBzdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXVlLmRlcXVldWUobnVsbCwgc3RhdGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdCwgcmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgICAgIHF1ZXVlLmRlcXVldWUobnVsbCwgc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCByZXNvbHZlU3ltbGlua3MgPSBmdW5jdGlvbiAocGF0aCwgc3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBxdWV1ZSwgb3B0aW9uczogeyBzdXBwcmVzc0Vycm9ycyB9LCB9ID0gc3RhdGU7XG4gICAgcXVldWUuZW5xdWV1ZSgpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IGZzXzEuZGVmYXVsdC5yZWFscGF0aFN5bmMocGF0aCk7XG4gICAgICAgIGNvbnN0IHN0YXQgPSBmc18xLmRlZmF1bHQuc3RhdFN5bmMocmVzb2x2ZWRQYXRoKTtcbiAgICAgICAgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSAmJiBpc1JlY3Vyc2l2ZShwYXRoLCByZXNvbHZlZFBhdGgsIHN0YXRlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FsbGJhY2soc3RhdCwgcmVzb2x2ZWRQYXRoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCFzdXBwcmVzc0Vycm9ycylcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgfVxufTtcbmZ1bmN0aW9uIGJ1aWxkKG9wdGlvbnMsIGlzU3luY2hyb25vdXMpIHtcbiAgICBpZiAoIW9wdGlvbnMucmVzb2x2ZVN5bWxpbmtzIHx8IG9wdGlvbnMuZXhjbHVkZVN5bWxpbmtzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaXNTeW5jaHJvbm91cyA/IHJlc29sdmVTeW1saW5rcyA6IHJlc29sdmVTeW1saW5rc0FzeW5jO1xufVxuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xuZnVuY3Rpb24gaXNSZWN1cnNpdmUocGF0aCwgcmVzb2x2ZWQsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLm9wdGlvbnMudXNlUmVhbFBhdGhzKVxuICAgICAgICByZXR1cm4gaXNSZWN1cnNpdmVVc2luZ1JlYWxQYXRocyhyZXNvbHZlZCwgc3RhdGUpO1xuICAgIGxldCBwYXJlbnQgPSAoMCwgcGF0aF8xLmRpcm5hbWUpKHBhdGgpO1xuICAgIGxldCBkZXB0aCA9IDE7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gc3RhdGUucm9vdCAmJiBkZXB0aCA8IDIpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRoID0gc3RhdGUuc3ltbGlua3MuZ2V0KHBhcmVudCk7XG4gICAgICAgIGNvbnN0IGlzU2FtZVJvb3QgPSAhIXJlc29sdmVkUGF0aCAmJlxuICAgICAgICAgICAgKHJlc29sdmVkUGF0aCA9PT0gcmVzb2x2ZWQgfHxcbiAgICAgICAgICAgICAgICByZXNvbHZlZFBhdGguc3RhcnRzV2l0aChyZXNvbHZlZCkgfHxcbiAgICAgICAgICAgICAgICByZXNvbHZlZC5zdGFydHNXaXRoKHJlc29sdmVkUGF0aCkpO1xuICAgICAgICBpZiAoaXNTYW1lUm9vdClcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBhcmVudCA9ICgwLCBwYXRoXzEuZGlybmFtZSkocGFyZW50KTtcbiAgICB9XG4gICAgc3RhdGUuc3ltbGlua3Muc2V0KHBhdGgsIHJlc29sdmVkKTtcbiAgICByZXR1cm4gZGVwdGggPiAxO1xufVxuZnVuY3Rpb24gaXNSZWN1cnNpdmVVc2luZ1JlYWxQYXRocyhyZXNvbHZlZCwgc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUudmlzaXRlZC5pbmNsdWRlcyhyZXNvbHZlZCArIHN0YXRlLm9wdGlvbnMucGF0aFNlcGFyYXRvcik7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnVpbGQgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCByZWFkZGlyT3B0cyA9IHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9O1xuY29uc3Qgd2Fsa0FzeW5jID0gKHN0YXRlLCBjcmF3bFBhdGgsIGRpcmVjdG9yeVBhdGgsIGN1cnJlbnREZXB0aCwgY2FsbGJhY2spID0+IHtcbiAgICBzdGF0ZS5xdWV1ZS5lbnF1ZXVlKCk7XG4gICAgaWYgKGN1cnJlbnREZXB0aCA8IDApXG4gICAgICAgIHJldHVybiBzdGF0ZS5xdWV1ZS5kZXF1ZXVlKG51bGwsIHN0YXRlKTtcbiAgICBzdGF0ZS52aXNpdGVkLnB1c2goY3Jhd2xQYXRoKTtcbiAgICBzdGF0ZS5jb3VudHMuZGlyZWN0b3JpZXMrKztcbiAgICAvLyBQZXJmOiBOb2RlID49IDEwIGludHJvZHVjZWQgd2l0aEZpbGVUeXBlcyB0aGF0IGhlbHBzIHVzXG4gICAgLy8gc2tpcCBhbiBleHRyYSBmcy5zdGF0IGNhbGwuXG4gICAgZnNfMS5kZWZhdWx0LnJlYWRkaXIoY3Jhd2xQYXRoIHx8IFwiLlwiLCByZWFkZGlyT3B0cywgKGVycm9yLCBlbnRyaWVzID0gW10pID0+IHtcbiAgICAgICAgY2FsbGJhY2soZW50cmllcywgZGlyZWN0b3J5UGF0aCwgY3VycmVudERlcHRoKTtcbiAgICAgICAgc3RhdGUucXVldWUuZGVxdWV1ZShzdGF0ZS5vcHRpb25zLnN1cHByZXNzRXJyb3JzID8gbnVsbCA6IGVycm9yLCBzdGF0ZSk7XG4gICAgfSk7XG59O1xuY29uc3Qgd2Fsa1N5bmMgPSAoc3RhdGUsIGNyYXdsUGF0aCwgZGlyZWN0b3J5UGF0aCwgY3VycmVudERlcHRoLCBjYWxsYmFjaykgPT4ge1xuICAgIGlmIChjdXJyZW50RGVwdGggPCAwKVxuICAgICAgICByZXR1cm47XG4gICAgc3RhdGUudmlzaXRlZC5wdXNoKGNyYXdsUGF0aCk7XG4gICAgc3RhdGUuY291bnRzLmRpcmVjdG9yaWVzKys7XG4gICAgbGV0IGVudHJpZXMgPSBbXTtcbiAgICB0cnkge1xuICAgICAgICBlbnRyaWVzID0gZnNfMS5kZWZhdWx0LnJlYWRkaXJTeW5jKGNyYXdsUGF0aCB8fCBcIi5cIiwgcmVhZGRpck9wdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXN0YXRlLm9wdGlvbnMuc3VwcHJlc3NFcnJvcnMpXG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBjYWxsYmFjayhlbnRyaWVzLCBkaXJlY3RvcnlQYXRoLCBjdXJyZW50RGVwdGgpO1xufTtcbmZ1bmN0aW9uIGJ1aWxkKGlzU3luY2hyb25vdXMpIHtcbiAgICByZXR1cm4gaXNTeW5jaHJvbm91cyA/IHdhbGtTeW5jIDogd2Fsa0FzeW5jO1xufVxuZXhwb3J0cy5idWlsZCA9IGJ1aWxkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1ZXVlID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIGlzIGEgY3VzdG9tIHN0YXRlbGVzcyBxdWV1ZSB0byB0cmFjayBjb25jdXJyZW50IGFzeW5jIGZzIGNhbGxzLlxuICogSXQgaW5jcmVtZW50cyBhIGNvdW50ZXIgd2hlbmV2ZXIgYSBjYWxsIGlzIHF1ZXVlZCBhbmQgZGVjcmVtZW50cyBpdFxuICogYXMgc29vbiBhcyBpdCBjb21wbGV0ZXMuIFdoZW4gdGhlIGNvdW50ZXIgaGl0cyAwLCBpdCBjYWxscyBvblF1ZXVlRW1wdHkuXG4gKi9cbmNsYXNzIFF1ZXVlIHtcbiAgICBvblF1ZXVlRW1wdHk7XG4gICAgY291bnQgPSAwO1xuICAgIGNvbnN0cnVjdG9yKG9uUXVldWVFbXB0eSkge1xuICAgICAgICB0aGlzLm9uUXVldWVFbXB0eSA9IG9uUXVldWVFbXB0eTtcbiAgICB9XG4gICAgZW5xdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcbiAgICB9XG4gICAgZGVxdWV1ZShlcnJvciwgb3V0cHV0KSB7XG4gICAgICAgIGlmICh0aGlzLm9uUXVldWVFbXB0eSAmJiAoLS10aGlzLmNvdW50IDw9IDAgfHwgZXJyb3IpKSB7XG4gICAgICAgICAgICB0aGlzLm9uUXVldWVFbXB0eShlcnJvciwgb3V0cHV0KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG91dHB1dC5jb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblF1ZXVlRW1wdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlF1ZXVlID0gUXVldWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3luYyA9IHZvaWQgMDtcbmNvbnN0IHdhbGtlcl8xID0gcmVxdWlyZShcIi4vd2Fsa2VyXCIpO1xuZnVuY3Rpb24gc3luYyhyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3Qgd2Fsa2VyID0gbmV3IHdhbGtlcl8xLldhbGtlcihyb290LCBvcHRpb25zKTtcbiAgICByZXR1cm4gd2Fsa2VyLnN0YXJ0KCk7XG59XG5leHBvcnRzLnN5bmMgPSBzeW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2Fsa2VyID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3Qgam9pblBhdGggPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZnVuY3Rpb25zL2pvaW4tcGF0aFwiKSk7XG5jb25zdCBwdXNoRGlyZWN0b3J5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9wdXNoLWRpcmVjdG9yeVwiKSk7XG5jb25zdCBwdXNoRmlsZSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvbnMvcHVzaC1maWxlXCIpKTtcbmNvbnN0IGdldEFycmF5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Z1bmN0aW9ucy9nZXQtYXJyYXlcIikpO1xuY29uc3QgZ3JvdXBGaWxlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvbnMvZ3JvdXAtZmlsZXNcIikpO1xuY29uc3QgcmVzb2x2ZVN5bWxpbmsgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZnVuY3Rpb25zL3Jlc29sdmUtc3ltbGlua1wiKSk7XG5jb25zdCBpbnZva2VDYWxsYmFjayA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9mdW5jdGlvbnMvaW52b2tlLWNhbGxiYWNrXCIpKTtcbmNvbnN0IHdhbGtEaXJlY3RvcnkgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vZnVuY3Rpb25zL3dhbGstZGlyZWN0b3J5XCIpKTtcbmNvbnN0IHF1ZXVlXzEgPSByZXF1aXJlKFwiLi9xdWV1ZVwiKTtcbmNvbnN0IGNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL2NvdW50ZXJcIik7XG5jbGFzcyBXYWxrZXIge1xuICAgIHJvb3Q7XG4gICAgaXNTeW5jaHJvbm91cztcbiAgICBzdGF0ZTtcbiAgICBqb2luUGF0aDtcbiAgICBwdXNoRGlyZWN0b3J5O1xuICAgIHB1c2hGaWxlO1xuICAgIGdldEFycmF5O1xuICAgIGdyb3VwRmlsZXM7XG4gICAgcmVzb2x2ZVN5bWxpbms7XG4gICAgd2Fsa0RpcmVjdG9yeTtcbiAgICBjYWxsYmFja0ludm9rZXI7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pc1N5bmNocm9ub3VzID0gIWNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNhbGxiYWNrSW52b2tlciA9IGludm9rZUNhbGxiYWNrLmJ1aWxkKG9wdGlvbnMsIHRoaXMuaXNTeW5jaHJvbm91cyk7XG4gICAgICAgIHRoaXMucm9vdCA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZVBhdGgpKHJvb3QsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm9vdDogKDAsIHV0aWxzXzEuaXNSb290RGlyZWN0b3J5KSh0aGlzLnJvb3QpID8gdGhpcy5yb290IDogdGhpcy5yb290LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICAgIC8vIFBlcmY6IHdlIGV4cGxpY2l0bHkgdGVsbCB0aGUgY29tcGlsZXIgdG8gb3B0aW1pemUgZm9yIFN0cmluZyBhcnJheXNcbiAgICAgICAgICAgIHBhdGhzOiBbXCJcIl0uc2xpY2UoMCwgMCksXG4gICAgICAgICAgICBncm91cHM6IFtdLFxuICAgICAgICAgICAgY291bnRzOiBuZXcgY291bnRlcl8xLkNvdW50ZXIoKSxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBxdWV1ZTogbmV3IHF1ZXVlXzEuUXVldWUoKGVycm9yLCBzdGF0ZSkgPT4gdGhpcy5jYWxsYmFja0ludm9rZXIoc3RhdGUsIGVycm9yLCBjYWxsYmFjaykpLFxuICAgICAgICAgICAgc3ltbGlua3M6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIHZpc2l0ZWQ6IFtcIlwiXS5zbGljZSgwLCAwKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLypcbiAgICAgICAgICogUGVyZjogV2UgY29uZGl0aW9uYWxseSBjaGFuZ2UgZnVuY3Rpb25zIGFjY29yZGluZyB0byBvcHRpb25zLiBUaGlzIGdpdmVzIGEgc2xpZ2h0XG4gICAgICAgICAqIHBlcmZvcm1hbmNlIGJvb3N0LiBTaW5jZSB0aGVzZSBmdW5jdGlvbnMgYXJlIHNvIHNtYWxsLCB0aGV5IGFyZSBhdXRvbWF0aWNhbGx5IGlubGluZWRcbiAgICAgICAgICogYnkgdGhlIGphdmFzY3JpcHQgZW5naW5lIHNvIHRoZXJlJ3Mgbm8gZnVuY3Rpb24gY2FsbCBvdmVyaGVhZCAoaW4gbW9zdCBjYXNlcykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmpvaW5QYXRoID0gam9pblBhdGguYnVpbGQodGhpcy5yb290LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wdXNoRGlyZWN0b3J5ID0gcHVzaERpcmVjdG9yeS5idWlsZCh0aGlzLnJvb3QsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnB1c2hGaWxlID0gcHVzaEZpbGUuYnVpbGQob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ2V0QXJyYXkgPSBnZXRBcnJheS5idWlsZChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncm91cEZpbGVzID0gZ3JvdXBGaWxlcy5idWlsZChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlU3ltbGluayA9IHJlc29sdmVTeW1saW5rLmJ1aWxkKG9wdGlvbnMsIHRoaXMuaXNTeW5jaHJvbm91cyk7XG4gICAgICAgIHRoaXMud2Fsa0RpcmVjdG9yeSA9IHdhbGtEaXJlY3RvcnkuYnVpbGQodGhpcy5pc1N5bmNocm9ub3VzKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMucHVzaERpcmVjdG9yeSh0aGlzLnJvb3QsIHRoaXMuc3RhdGUucGF0aHMsIHRoaXMuc3RhdGUub3B0aW9ucy5maWx0ZXJzKTtcbiAgICAgICAgdGhpcy53YWxrRGlyZWN0b3J5KHRoaXMuc3RhdGUsIHRoaXMucm9vdCwgdGhpcy5yb290LCB0aGlzLnN0YXRlLm9wdGlvbnMubWF4RGVwdGgsIHRoaXMud2Fsayk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU3luY2hyb25vdXMgPyB0aGlzLmNhbGxiYWNrSW52b2tlcih0aGlzLnN0YXRlLCBudWxsKSA6IG51bGw7XG4gICAgfVxuICAgIHdhbGsgPSAoZW50cmllcywgZGlyZWN0b3J5UGF0aCwgZGVwdGgpID0+IHtcbiAgICAgICAgY29uc3QgeyBwYXRocywgb3B0aW9uczogeyBmaWx0ZXJzLCByZXNvbHZlU3ltbGlua3MsIGV4Y2x1ZGVTeW1saW5rcywgZXhjbHVkZSwgbWF4RmlsZXMsIHNpZ25hbCwgdXNlUmVhbFBhdGhzLCBwYXRoU2VwYXJhdG9yLCB9LCBjb250cm9sbGVyLCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQgfHxcbiAgICAgICAgICAgIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHx8XG4gICAgICAgICAgICAobWF4RmlsZXMgJiYgcGF0aHMubGVuZ3RoID4gbWF4RmlsZXMpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0QXJyYXkodGhpcy5zdGF0ZS5wYXRocyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgICAgICAgICAgaWYgKGVudHJ5LmlzRmlsZSgpIHx8XG4gICAgICAgICAgICAgICAgKGVudHJ5LmlzU3ltYm9saWNMaW5rKCkgJiYgIXJlc29sdmVTeW1saW5rcyAmJiAhZXhjbHVkZVN5bWxpbmtzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gdGhpcy5qb2luUGF0aChlbnRyeS5uYW1lLCBkaXJlY3RvcnlQYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hGaWxlKGZpbGVuYW1lLCBmaWxlcywgdGhpcy5zdGF0ZS5jb3VudHMsIGZpbHRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gam9pblBhdGguam9pbkRpcmVjdG9yeVBhdGgoZW50cnkubmFtZSwgZGlyZWN0b3J5UGF0aCwgdGhpcy5zdGF0ZS5vcHRpb25zLnBhdGhTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlICYmIGV4Y2x1ZGUoZW50cnkubmFtZSwgcGF0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaERpcmVjdG9yeShwYXRoLCBwYXRocywgZmlsdGVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrRGlyZWN0b3J5KHRoaXMuc3RhdGUsIHBhdGgsIHBhdGgsIGRlcHRoIC0gMSwgdGhpcy53YWxrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucmVzb2x2ZVN5bWxpbmsgJiYgZW50cnkuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXRoID0gam9pblBhdGguam9pblBhdGhXaXRoQmFzZVBhdGgoZW50cnkubmFtZSwgZGlyZWN0b3J5UGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3ltbGluayhwYXRoLCB0aGlzLnN0YXRlLCAoc3RhdCwgcmVzb2x2ZWRQYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZVBhdGgpKHJlc29sdmVkUGF0aCwgdGhpcy5zdGF0ZS5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGNsdWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZShlbnRyeS5uYW1lLCB1c2VSZWFsUGF0aHMgPyByZXNvbHZlZFBhdGggOiBwYXRoICsgcGF0aFNlcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxrRGlyZWN0b3J5KHRoaXMuc3RhdGUsIHJlc29sdmVkUGF0aCwgdXNlUmVhbFBhdGhzID8gcmVzb2x2ZWRQYXRoIDogcGF0aCArIHBhdGhTZXBhcmF0b3IsIGRlcHRoIC0gMSwgdGhpcy53YWxrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IHVzZVJlYWxQYXRocyA/IHJlc29sdmVkUGF0aCA6IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9ICgwLCBwYXRoXzEuYmFzZW5hbWUpKHJlc29sdmVkUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3RvcnlQYXRoID0gKDAsIHV0aWxzXzEubm9ybWFsaXplUGF0aCkoKDAsIHBhdGhfMS5kaXJuYW1lKShyZXNvbHZlZFBhdGgpLCB0aGlzLnN0YXRlLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRQYXRoID0gdGhpcy5qb2luUGF0aChmaWxlbmFtZSwgZGlyZWN0b3J5UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hGaWxlKHJlc29sdmVkUGF0aCwgZmlsZXMsIHRoaXMuc3RhdGUuY291bnRzLCBmaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ3JvdXBGaWxlcyh0aGlzLnN0YXRlLmdyb3VwcywgZGlyZWN0b3J5UGF0aCwgZmlsZXMpO1xuICAgIH07XG59XG5leHBvcnRzLldhbGtlciA9IFdhbGtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BUElCdWlsZGVyID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfMSA9IHJlcXVpcmUoXCIuLi9hcGkvYXN5bmNcIik7XG5jb25zdCBzeW5jXzEgPSByZXF1aXJlKFwiLi4vYXBpL3N5bmNcIik7XG5jbGFzcyBBUElCdWlsZGVyIHtcbiAgICByb290O1xuICAgIG9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iocm9vdCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnJvb3QgPSByb290O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICB3aXRoUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCBhc3luY18xLnByb21pc2UpKHRoaXMucm9vdCwgdGhpcy5vcHRpb25zKTtcbiAgICB9XG4gICAgd2l0aENhbGxiYWNrKGNiKSB7XG4gICAgICAgICgwLCBhc3luY18xLmNhbGxiYWNrKSh0aGlzLnJvb3QsIHRoaXMub3B0aW9ucywgY2IpO1xuICAgIH1cbiAgICBzeW5jKCkge1xuICAgICAgICByZXR1cm4gKDAsIHN5bmNfMS5zeW5jKSh0aGlzLnJvb3QsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5BUElCdWlsZGVyID0gQVBJQnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CdWlsZGVyID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBhcGlfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vYXBpLWJ1aWxkZXJcIik7XG52YXIgcG0gPSBudWxsO1xuLyogYzggaWdub3JlIG5leHQgNiAqL1xudHJ5IHtcbiAgICByZXF1aXJlLnJlc29sdmUoXCJwaWNvbWF0Y2hcIik7XG4gICAgcG0gPSByZXF1aXJlKFwicGljb21hdGNoXCIpO1xufVxuY2F0Y2ggKF9lKSB7XG4gICAgLy8gZG8gbm90aGluZ1xufVxuY2xhc3MgQnVpbGRlciB7XG4gICAgZ2xvYkNhY2hlID0ge307XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgbWF4RGVwdGg6IEluZmluaXR5LFxuICAgICAgICBzdXBwcmVzc0Vycm9yczogdHJ1ZSxcbiAgICAgICAgcGF0aFNlcGFyYXRvcjogcGF0aF8xLnNlcCxcbiAgICAgICAgZmlsdGVyczogW10sXG4gICAgfTtcbiAgICBnbG9iRnVuY3Rpb247XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICB0aGlzLmdsb2JGdW5jdGlvbiA9IHRoaXMub3B0aW9ucy5nbG9iRnVuY3Rpb247XG4gICAgfVxuICAgIGdyb3VwKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZ3JvdXAgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFBhdGhTZXBhcmF0b3Ioc2VwYXJhdG9yKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wYXRoU2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aEJhc2VQYXRoKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW5jbHVkZUJhc2VQYXRoID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhSZWxhdGl2ZVBhdGhzKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMucmVsYXRpdmVQYXRocyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoRGlycygpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmluY2x1ZGVEaXJzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhNYXhEZXB0aChkZXB0aCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubWF4RGVwdGggPSBkZXB0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhNYXhGaWxlcyhsaW1pdCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubWF4RmlsZXMgPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhGdWxsUGF0aHMoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZXNvbHZlUGF0aHMgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaW5jbHVkZUJhc2VQYXRoID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhFcnJvcnMoKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdXBwcmVzc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFN5bWxpbmtzKHsgcmVzb2x2ZVBhdGhzID0gdHJ1ZSB9ID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnJlc29sdmVTeW1saW5rcyA9IHRydWU7XG4gICAgICAgIHRoaXMub3B0aW9ucy51c2VSZWFsUGF0aHMgPSByZXNvbHZlUGF0aHM7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhGdWxsUGF0aHMoKTtcbiAgICB9XG4gICAgd2l0aEFib3J0U2lnbmFsKHNpZ25hbCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbm9ybWFsaXplKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubm9ybWFsaXplUGF0aCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXJzLnB1c2gocHJlZGljYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9ubHlEaXJzKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuZXhjbHVkZUZpbGVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zLmluY2x1ZGVEaXJzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGV4Y2x1ZGUocHJlZGljYXRlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5leGNsdWRlID0gcHJlZGljYXRlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25seUNvdW50cygpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9ubHlDb3VudHMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY3Jhd2wocm9vdCkge1xuICAgICAgICByZXR1cm4gbmV3IGFwaV9idWlsZGVyXzEuQVBJQnVpbGRlcihyb290IHx8IFwiLlwiLCB0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICB3aXRoR2xvYkZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIC8vIGNhc3QgdGhpcyBzaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBuZXcgdHlwZSBwYXJhbXMgeWV0XG4gICAgICAgIHRoaXMuZ2xvYkZ1bmN0aW9uID0gZm47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBQYXNzIG9wdGlvbnMgdXNpbmcgdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQ6XG4gICAgICogYGBgdHNcbiAgICAgKiBuZXcgZmRpcihvcHRpb25zKS5jcmF3bChcIi9wYXRoL3RvL3Jvb3RcIik7XG4gICAgICogYGBgXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSByZW1vdmVkIGluIHY3LjBcbiAgICAgKi9cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCA0ICovXG4gICAgY3Jhd2xXaXRoT3B0aW9ucyhyb290LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgIHJldHVybiBuZXcgYXBpX2J1aWxkZXJfMS5BUElCdWlsZGVyKHJvb3QgfHwgXCIuXCIsIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIGdsb2IoLi4ucGF0dGVybnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2xvYkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbG9iV2l0aE9wdGlvbnMocGF0dGVybnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdsb2JXaXRoT3B0aW9ucyhwYXR0ZXJucywgLi4uW3sgZG90OiB0cnVlIH1dKTtcbiAgICB9XG4gICAgZ2xvYldpdGhPcHRpb25zKHBhdHRlcm5zLCAuLi5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGdsb2JGbiA9ICh0aGlzLmdsb2JGdW5jdGlvbiB8fCBwbSk7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDUgKi9cbiAgICAgICAgaWYgKCFnbG9iRm4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgZ2xvYiBmdW5jdGlvbiB0byB1c2UgZ2xvYiBtYXRjaGluZy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTWF0Y2ggPSB0aGlzLmdsb2JDYWNoZVtwYXR0ZXJucy5qb2luKFwiXFwwXCIpXTtcbiAgICAgICAgaWYgKCFpc01hdGNoKSB7XG4gICAgICAgICAgICBpc01hdGNoID0gZ2xvYkZuKHBhdHRlcm5zLCAuLi5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZ2xvYkNhY2hlW3BhdHRlcm5zLmpvaW4oXCJcXDBcIildID0gaXNNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVycy5wdXNoKChwYXRoKSA9PiBpc01hdGNoKHBhdGgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5CdWlsZGVyID0gQnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZkaXIgPSB2b2lkIDA7XG5jb25zdCBidWlsZGVyXzEgPSByZXF1aXJlKFwiLi9idWlsZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZmRpclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnVpbGRlcl8xLkJ1aWxkZXI7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplUGF0aCA9IGV4cG9ydHMuaXNSb290RGlyZWN0b3J5ID0gZXhwb3J0cy5jb252ZXJ0U2xhc2hlcyA9IGV4cG9ydHMuY2xlYW5QYXRoID0gdm9pZCAwO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5mdW5jdGlvbiBjbGVhblBhdGgocGF0aCkge1xuICAgIGxldCBub3JtYWxpemVkID0gKDAsIHBhdGhfMS5ub3JtYWxpemUpKHBhdGgpO1xuICAgIC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBsYXN0IHBhdGggc2VwYXJhdG9yXG4gICAgLy8gdG8gYWNjb3VudCBmb3IgLyByb290IHBhdGhcbiAgICBpZiAobm9ybWFsaXplZC5sZW5ndGggPiAxICYmIG5vcm1hbGl6ZWRbbm9ybWFsaXplZC5sZW5ndGggLSAxXSA9PT0gcGF0aF8xLnNlcClcbiAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQuc3Vic3RyaW5nKDAsIG5vcm1hbGl6ZWQubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5leHBvcnRzLmNsZWFuUGF0aCA9IGNsZWFuUGF0aDtcbmNvbnN0IFNMQVNIRVNfUkVHRVggPSAvW1xcXFwvXS9nO1xuZnVuY3Rpb24gY29udmVydFNsYXNoZXMocGF0aCwgc2VwYXJhdG9yKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZShTTEFTSEVTX1JFR0VYLCBzZXBhcmF0b3IpO1xufVxuZXhwb3J0cy5jb252ZXJ0U2xhc2hlcyA9IGNvbnZlcnRTbGFzaGVzO1xuY29uc3QgV0lORE9XU19ST09UX0RJUl9SRUdFWCA9IC9eW2Etel06W1xcXFwvXSQvaTtcbmZ1bmN0aW9uIGlzUm9vdERpcmVjdG9yeShwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGggPT09IFwiL1wiIHx8IFdJTkRPV1NfUk9PVF9ESVJfUkVHRVgudGVzdChwYXRoKTtcbn1cbmV4cG9ydHMuaXNSb290RGlyZWN0b3J5ID0gaXNSb290RGlyZWN0b3J5O1xuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXNvbHZlUGF0aHMsIG5vcm1hbGl6ZVBhdGgsIHBhdGhTZXBhcmF0b3IgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcGF0aE5lZWRzQ2xlYW5pbmcgPSAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiICYmIHBhdGguaW5jbHVkZXMoXCIvXCIpKSB8fFxuICAgICAgICBwYXRoLnN0YXJ0c1dpdGgoXCIuXCIpO1xuICAgIGlmIChyZXNvbHZlUGF0aHMpXG4gICAgICAgIHBhdGggPSAoMCwgcGF0aF8xLnJlc29sdmUpKHBhdGgpO1xuICAgIGlmIChub3JtYWxpemVQYXRoIHx8IHBhdGhOZWVkc0NsZWFuaW5nKVxuICAgICAgICBwYXRoID0gY2xlYW5QYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoID09PSBcIi5cIilcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgY29uc3QgbmVlZHNTZXBlcmF0b3IgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gIT09IHBhdGhTZXBhcmF0b3I7XG4gICAgcmV0dXJuIGNvbnZlcnRTbGFzaGVzKG5lZWRzU2VwZXJhdG9yID8gcGF0aCArIHBhdGhTZXBhcmF0b3IgOiBwYXRoLCBwYXRoU2VwYXJhdG9yKTtcbn1cbmV4cG9ydHMubm9ybWFsaXplUGF0aCA9IG5vcm1hbGl6ZVBhdGg7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBpY28gPSByZXF1aXJlKCcuL2xpYi9waWNvbWF0Y2gnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcblxuZnVuY3Rpb24gcGljb21hdGNoKGdsb2IsIG9wdGlvbnMsIHJldHVyblN0YXRlID0gZmFsc2UpIHtcbiAgLy8gZGVmYXVsdCB0byBvcy5wbGF0Zm9ybSgpXG4gIGlmIChvcHRpb25zICYmIChvcHRpb25zLndpbmRvd3MgPT09IG51bGwgfHwgb3B0aW9ucy53aW5kb3dzID09PSB1bmRlZmluZWQpKSB7XG4gICAgLy8gZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBvcHRpb25zIG9iamVjdFxuICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHdpbmRvd3M6IHV0aWxzLmlzV2luZG93cygpIH07XG4gIH1cblxuICByZXR1cm4gcGljbyhnbG9iLCBvcHRpb25zLCByZXR1cm5TdGF0ZSk7XG59XG5cbk9iamVjdC5hc3NpZ24ocGljb21hdGNoLCBwaWNvKTtcbm1vZHVsZS5leHBvcnRzID0gcGljb21hdGNoO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXSU5fU0xBU0ggPSAnXFxcXFxcXFwvJztcbmNvbnN0IFdJTl9OT19TTEFTSCA9IGBbXiR7V0lOX1NMQVNIfV1gO1xuXG4vKipcbiAqIFBvc2l4IGdsb2IgcmVnZXhcbiAqL1xuXG5jb25zdCBET1RfTElURVJBTCA9ICdcXFxcLic7XG5jb25zdCBQTFVTX0xJVEVSQUwgPSAnXFxcXCsnO1xuY29uc3QgUU1BUktfTElURVJBTCA9ICdcXFxcPyc7XG5jb25zdCBTTEFTSF9MSVRFUkFMID0gJ1xcXFwvJztcbmNvbnN0IE9ORV9DSEFSID0gJyg/PS4pJztcbmNvbnN0IFFNQVJLID0gJ1teL10nO1xuY29uc3QgRU5EX0FOQ0hPUiA9IGAoPzoke1NMQVNIX0xJVEVSQUx9fCQpYDtcbmNvbnN0IFNUQVJUX0FOQ0hPUiA9IGAoPzpefCR7U0xBU0hfTElURVJBTH0pYDtcbmNvbnN0IERPVFNfU0xBU0ggPSBgJHtET1RfTElURVJBTH17MSwyfSR7RU5EX0FOQ0hPUn1gO1xuY29uc3QgTk9fRE9UID0gYCg/ISR7RE9UX0xJVEVSQUx9KWA7XG5jb25zdCBOT19ET1RTID0gYCg/ISR7U1RBUlRfQU5DSE9SfSR7RE9UU19TTEFTSH0pYDtcbmNvbnN0IE5PX0RPVF9TTEFTSCA9IGAoPyEke0RPVF9MSVRFUkFMfXswLDF9JHtFTkRfQU5DSE9SfSlgO1xuY29uc3QgTk9fRE9UU19TTEFTSCA9IGAoPyEke0RPVFNfU0xBU0h9KWA7XG5jb25zdCBRTUFSS19OT19ET1QgPSBgW14uJHtTTEFTSF9MSVRFUkFMfV1gO1xuY29uc3QgU1RBUiA9IGAke1FNQVJLfSo/YDtcbmNvbnN0IFNFUCA9ICcvJztcblxuY29uc3QgUE9TSVhfQ0hBUlMgPSB7XG4gIERPVF9MSVRFUkFMLFxuICBQTFVTX0xJVEVSQUwsXG4gIFFNQVJLX0xJVEVSQUwsXG4gIFNMQVNIX0xJVEVSQUwsXG4gIE9ORV9DSEFSLFxuICBRTUFSSyxcbiAgRU5EX0FOQ0hPUixcbiAgRE9UU19TTEFTSCxcbiAgTk9fRE9ULFxuICBOT19ET1RTLFxuICBOT19ET1RfU0xBU0gsXG4gIE5PX0RPVFNfU0xBU0gsXG4gIFFNQVJLX05PX0RPVCxcbiAgU1RBUixcbiAgU1RBUlRfQU5DSE9SLFxuICBTRVBcbn07XG5cbi8qKlxuICogV2luZG93cyBnbG9iIHJlZ2V4XG4gKi9cblxuY29uc3QgV0lORE9XU19DSEFSUyA9IHtcbiAgLi4uUE9TSVhfQ0hBUlMsXG5cbiAgU0xBU0hfTElURVJBTDogYFske1dJTl9TTEFTSH1dYCxcbiAgUU1BUks6IFdJTl9OT19TTEFTSCxcbiAgU1RBUjogYCR7V0lOX05PX1NMQVNIfSo/YCxcbiAgRE9UU19TTEFTSDogYCR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKWAsXG4gIE5PX0RPVDogYCg/ISR7RE9UX0xJVEVSQUx9KWAsXG4gIE5PX0RPVFM6IGAoPyEoPzpefFske1dJTl9TTEFTSH1dKSR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBOT19ET1RfU0xBU0g6IGAoPyEke0RPVF9MSVRFUkFMfXswLDF9KD86WyR7V0lOX1NMQVNIfV18JCkpYCxcbiAgTk9fRE9UU19TTEFTSDogYCg/ISR7RE9UX0xJVEVSQUx9ezEsMn0oPzpbJHtXSU5fU0xBU0h9XXwkKSlgLFxuICBRTUFSS19OT19ET1Q6IGBbXi4ke1dJTl9TTEFTSH1dYCxcbiAgU1RBUlRfQU5DSE9SOiBgKD86XnxbJHtXSU5fU0xBU0h9XSlgLFxuICBFTkRfQU5DSE9SOiBgKD86WyR7V0lOX1NMQVNIfV18JClgLFxuICBTRVA6ICdcXFxcJ1xufTtcblxuLyoqXG4gKiBQT1NJWCBCcmFja2V0IFJlZ2V4XG4gKi9cblxuY29uc3QgUE9TSVhfUkVHRVhfU09VUkNFID0ge1xuICBhbG51bTogJ2EtekEtWjAtOScsXG4gIGFscGhhOiAnYS16QS1aJyxcbiAgYXNjaWk6ICdcXFxceDAwLVxcXFx4N0YnLFxuICBibGFuazogJyBcXFxcdCcsXG4gIGNudHJsOiAnXFxcXHgwMC1cXFxceDFGXFxcXHg3RicsXG4gIGRpZ2l0OiAnMC05JyxcbiAgZ3JhcGg6ICdcXFxceDIxLVxcXFx4N0UnLFxuICBsb3dlcjogJ2EteicsXG4gIHByaW50OiAnXFxcXHgyMC1cXFxceDdFICcsXG4gIHB1bmN0OiAnXFxcXC0hXCIjJCUmXFwnKClcXFxcKissLi86Ozw9Pj9AW1xcXFxdXl9ge3x9ficsXG4gIHNwYWNlOiAnIFxcXFx0XFxcXHJcXFxcblxcXFx2XFxcXGYnLFxuICB1cHBlcjogJ0EtWicsXG4gIHdvcmQ6ICdBLVphLXowLTlfJyxcbiAgeGRpZ2l0OiAnQS1GYS1mMC05J1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1BWF9MRU5HVEg6IDEwMjQgKiA2NCxcbiAgUE9TSVhfUkVHRVhfU09VUkNFLFxuXG4gIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgUkVHRVhfQkFDS1NMQVNIOiAvXFxcXCg/IVsqKz9eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOiAvXlteQCFbXFxdLiwkKis/Xnt9KCl8XFxcXC9dKy8sXG4gIFJFR0VYX1NQRUNJQUxfQ0hBUlM6IC9bLSorPy5eJHt9KHwpW1xcXV0vLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUY6IC8oXFxcXD8pKChcXFcpKFxcMyopKS9nLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDogLyhbLSorPy5eJHt9KHwpW1xcXV0pL2csXG4gIFJFR0VYX1JFTU9WRV9CQUNLU0xBU0g6IC8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxcblxuICAvLyBSZXBsYWNlIGdsb2JzIHdpdGggZXF1aXZhbGVudCBwYXR0ZXJucyB0byByZWR1Y2UgcGFyc2luZyB0aW1lLlxuICBSRVBMQUNFTUVOVFM6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgJyoqKic6ICcqJyxcbiAgICAnKiovKionOiAnKionLFxuICAgICcqKi8qKi8qKic6ICcqKidcbiAgfSxcblxuICAvLyBEaWdpdHNcbiAgQ0hBUl8wOiA0OCwgLyogMCAqL1xuICBDSEFSXzk6IDU3LCAvKiA5ICovXG5cbiAgLy8gQWxwaGFiZXQgY2hhcnMuXG4gIENIQVJfVVBQRVJDQVNFX0E6IDY1LCAvKiBBICovXG4gIENIQVJfTE9XRVJDQVNFX0E6IDk3LCAvKiBhICovXG4gIENIQVJfVVBQRVJDQVNFX1o6IDkwLCAvKiBaICovXG4gIENIQVJfTE9XRVJDQVNFX1o6IDEyMiwgLyogeiAqL1xuXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUzogNDAsIC8qICggKi9cbiAgQ0hBUl9SSUdIVF9QQVJFTlRIRVNFUzogNDEsIC8qICkgKi9cblxuICBDSEFSX0FTVEVSSVNLOiA0MiwgLyogKiAqL1xuXG4gIC8vIE5vbi1hbHBoYWJldGljIGNoYXJzLlxuICBDSEFSX0FNUEVSU0FORDogMzgsIC8qICYgKi9cbiAgQ0hBUl9BVDogNjQsIC8qIEAgKi9cbiAgQ0hBUl9CQUNLV0FSRF9TTEFTSDogOTIsIC8qIFxcICovXG4gIENIQVJfQ0FSUklBR0VfUkVUVVJOOiAxMywgLyogXFxyICovXG4gIENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6IDk0LCAvKiBeICovXG4gIENIQVJfQ09MT046IDU4LCAvKiA6ICovXG4gIENIQVJfQ09NTUE6IDQ0LCAvKiAsICovXG4gIENIQVJfRE9UOiA0NiwgLyogLiAqL1xuICBDSEFSX0RPVUJMRV9RVU9URTogMzQsIC8qIFwiICovXG4gIENIQVJfRVFVQUw6IDYxLCAvKiA9ICovXG4gIENIQVJfRVhDTEFNQVRJT05fTUFSSzogMzMsIC8qICEgKi9cbiAgQ0hBUl9GT1JNX0ZFRUQ6IDEyLCAvKiBcXGYgKi9cbiAgQ0hBUl9GT1JXQVJEX1NMQVNIOiA0NywgLyogLyAqL1xuICBDSEFSX0dSQVZFX0FDQ0VOVDogOTYsIC8qIGAgKi9cbiAgQ0hBUl9IQVNIOiAzNSwgLyogIyAqL1xuICBDSEFSX0hZUEhFTl9NSU5VUzogNDUsIC8qIC0gKi9cbiAgQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6IDYwLCAvKiA8ICovXG4gIENIQVJfTEVGVF9DVVJMWV9CUkFDRTogMTIzLCAvKiB7ICovXG4gIENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDogOTEsIC8qIFsgKi9cbiAgQ0hBUl9MSU5FX0ZFRUQ6IDEwLCAvKiBcXG4gKi9cbiAgQ0hBUl9OT19CUkVBS19TUEFDRTogMTYwLCAvKiBcXHUwMEEwICovXG4gIENIQVJfUEVSQ0VOVDogMzcsIC8qICUgKi9cbiAgQ0hBUl9QTFVTOiA0MywgLyogKyAqL1xuICBDSEFSX1FVRVNUSU9OX01BUks6IDYzLCAvKiA/ICovXG4gIENIQVJfUklHSFRfQU5HTEVfQlJBQ0tFVDogNjIsIC8qID4gKi9cbiAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTogMTI1LCAvKiB9ICovXG4gIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6IDkzLCAvKiBdICovXG4gIENIQVJfU0VNSUNPTE9OOiA1OSwgLyogOyAqL1xuICBDSEFSX1NJTkdMRV9RVU9URTogMzksIC8qICcgKi9cbiAgQ0hBUl9TUEFDRTogMzIsIC8qICAgKi9cbiAgQ0hBUl9UQUI6IDksIC8qIFxcdCAqL1xuICBDSEFSX1VOREVSU0NPUkU6IDk1LCAvKiBfICovXG4gIENIQVJfVkVSVElDQUxfTElORTogMTI0LCAvKiB8ICovXG4gIENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOiA2NTI3OSwgLyogXFx1RkVGRiAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgRVhUR0xPQl9DSEFSU1xuICAgKi9cblxuICBleHRnbG9iQ2hhcnMoY2hhcnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJyEnOiB7IHR5cGU6ICduZWdhdGUnLCBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6IGApKSR7Y2hhcnMuU1RBUn0pYCB9LFxuICAgICAgJz8nOiB7IHR5cGU6ICdxbWFyaycsIG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAgICAgJysnOiB7IHR5cGU6ICdwbHVzJywgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICAgICAnKic6IHsgdHlwZTogJ3N0YXInLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgICAgICdAJzogeyB0eXBlOiAnYXQnLCBvcGVuOiAnKD86JywgY2xvc2U6ICcpJyB9XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlIEdMT0JfQ0hBUlNcbiAgICovXG5cbiAgZ2xvYkNoYXJzKHdpbjMyKSB7XG4gICAgcmV0dXJuIHdpbjMyID09PSB0cnVlID8gV0lORE9XU19DSEFSUyA6IFBPU0lYX0NIQVJTO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3Qge1xuICBNQVhfTEVOR1RILFxuICBQT1NJWF9SRUdFWF9TT1VSQ0UsXG4gIFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0JBQ0tSRUYsXG4gIFJFUExBQ0VNRU5UU1xufSA9IGNvbnN0YW50cztcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuY29uc3QgZXhwYW5kUmFuZ2UgPSAoYXJncywgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIG9wdGlvbnMuZXhwYW5kUmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5leHBhbmRSYW5nZSguLi5hcmdzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFyZ3Muc29ydCgpO1xuICBjb25zdCB2YWx1ZSA9IGBbJHthcmdzLmpvaW4oJy0nKX1dYDtcblxuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXcgKi9cbiAgICBuZXcgUmVnRXhwKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICByZXR1cm4gYXJncy5tYXAodiA9PiB1dGlscy5lc2NhcGVSZWdleCh2KSkuam9pbignLi4nKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIHRoZSBtZXNzYWdlIGZvciBhIHN5bnRheCBlcnJvclxuICovXG5cbmNvbnN0IHN5bnRheEVycm9yID0gKHR5cGUsIGNoYXIpID0+IHtcbiAgcmV0dXJuIGBNaXNzaW5nICR7dHlwZX06IFwiJHtjaGFyfVwiIC0gdXNlIFwiXFxcXFxcXFwke2NoYXJ9XCIgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzYDtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGlucHV0IHN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5jb25zdCBwYXJzZSA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpbnB1dCA9IFJFUExBQ0VNRU5UU1tpbnB1dF0gfHwgaW5wdXQ7XG5cbiAgY29uc3Qgb3B0cyA9IHsgLi4ub3B0aW9ucyB9O1xuICBjb25zdCBtYXggPSB0eXBlb2Ygb3B0cy5tYXhMZW5ndGggPT09ICdudW1iZXInID8gTWF0aC5taW4oTUFYX0xFTkdUSCwgb3B0cy5tYXhMZW5ndGgpIDogTUFYX0xFTkdUSDtcblxuICBsZXQgbGVuID0gaW5wdXQubGVuZ3RoO1xuICBpZiAobGVuID4gbWF4KSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7bGVufSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke21heH1gKTtcbiAgfVxuXG4gIGNvbnN0IGJvcyA9IHsgdHlwZTogJ2JvcycsIHZhbHVlOiAnJywgb3V0cHV0OiBvcHRzLnByZXBlbmQgfHwgJycgfTtcbiAgY29uc3QgdG9rZW5zID0gW2Jvc107XG5cbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcblxuICAvLyBjcmVhdGUgY29uc3RhbnRzIGJhc2VkIG9uIHBsYXRmb3JtLCBmb3Igd2luZG93cyBvciBwb3NpeFxuICBjb25zdCBQTEFURk9STV9DSEFSUyA9IGNvbnN0YW50cy5nbG9iQ2hhcnMob3B0cy53aW5kb3dzKTtcbiAgY29uc3QgRVhUR0xPQl9DSEFSUyA9IGNvbnN0YW50cy5leHRnbG9iQ2hhcnMoUExBVEZPUk1fQ0hBUlMpO1xuXG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBQTFVTX0xJVEVSQUwsXG4gICAgU0xBU0hfTElURVJBTCxcbiAgICBPTkVfQ0hBUixcbiAgICBET1RTX1NMQVNILFxuICAgIE5PX0RPVCxcbiAgICBOT19ET1RfU0xBU0gsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBRTUFSSyxcbiAgICBRTUFSS19OT19ET1QsXG4gICAgU1RBUixcbiAgICBTVEFSVF9BTkNIT1JcbiAgfSA9IFBMQVRGT1JNX0NIQVJTO1xuXG4gIGNvbnN0IGdsb2JzdGFyID0gb3B0cyA9PiB7XG4gICAgcmV0dXJuIGAoJHtjYXB0dXJlfSg/Oig/ISR7U1RBUlRfQU5DSE9SfSR7b3B0cy5kb3QgPyBET1RTX1NMQVNIIDogRE9UX0xJVEVSQUx9KS4pKj8pYDtcbiAgfTtcblxuICBjb25zdCBub2RvdCA9IG9wdHMuZG90ID8gJycgOiBOT19ET1Q7XG4gIGNvbnN0IHFtYXJrTm9Eb3QgPSBvcHRzLmRvdCA/IFFNQVJLIDogUU1BUktfTk9fRE9UO1xuICBsZXQgc3RhciA9IG9wdHMuYmFzaCA9PT0gdHJ1ZSA/IGdsb2JzdGFyKG9wdHMpIDogU1RBUjtcblxuICBpZiAob3B0cy5jYXB0dXJlKSB7XG4gICAgc3RhciA9IGAoJHtzdGFyfSlgO1xuICB9XG5cbiAgLy8gbWluaW1hdGNoIG9wdGlvbnMgc3VwcG9ydFxuICBpZiAodHlwZW9mIG9wdHMubm9leHQgPT09ICdib29sZWFuJykge1xuICAgIG9wdHMubm9leHRnbG9iID0gb3B0cy5ub2V4dDtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0ge1xuICAgIGlucHV0LFxuICAgIGluZGV4OiAtMSxcbiAgICBzdGFydDogMCxcbiAgICBkb3Q6IG9wdHMuZG90ID09PSB0cnVlLFxuICAgIGNvbnN1bWVkOiAnJyxcbiAgICBvdXRwdXQ6ICcnLFxuICAgIHByZWZpeDogJycsXG4gICAgYmFja3RyYWNrOiBmYWxzZSxcbiAgICBuZWdhdGVkOiBmYWxzZSxcbiAgICBicmFja2V0czogMCxcbiAgICBicmFjZXM6IDAsXG4gICAgcGFyZW5zOiAwLFxuICAgIHF1b3RlczogMCxcbiAgICBnbG9ic3RhcjogZmFsc2UsXG4gICAgdG9rZW5zXG4gIH07XG5cbiAgaW5wdXQgPSB1dGlscy5yZW1vdmVQcmVmaXgoaW5wdXQsIHN0YXRlKTtcbiAgbGVuID0gaW5wdXQubGVuZ3RoO1xuXG4gIGNvbnN0IGV4dGdsb2JzID0gW107XG4gIGNvbnN0IGJyYWNlcyA9IFtdO1xuICBjb25zdCBzdGFjayA9IFtdO1xuICBsZXQgcHJldiA9IGJvcztcbiAgbGV0IHZhbHVlO1xuXG4gIC8qKlxuICAgKiBUb2tlbml6aW5nIGhlbHBlcnNcbiAgICovXG5cbiAgY29uc3QgZW9zID0gKCkgPT4gc3RhdGUuaW5kZXggPT09IGxlbiAtIDE7XG4gIGNvbnN0IHBlZWsgPSBzdGF0ZS5wZWVrID0gKG4gPSAxKSA9PiBpbnB1dFtzdGF0ZS5pbmRleCArIG5dO1xuICBjb25zdCBhZHZhbmNlID0gc3RhdGUuYWR2YW5jZSA9ICgpID0+IGlucHV0Wysrc3RhdGUuaW5kZXhdIHx8ICcnO1xuICBjb25zdCByZW1haW5pbmcgPSAoKSA9PiBpbnB1dC5zbGljZShzdGF0ZS5pbmRleCArIDEpO1xuICBjb25zdCBjb25zdW1lID0gKHZhbHVlID0gJycsIG51bSA9IDApID0+IHtcbiAgICBzdGF0ZS5jb25zdW1lZCArPSB2YWx1ZTtcbiAgICBzdGF0ZS5pbmRleCArPSBudW07XG4gIH07XG5cbiAgY29uc3QgYXBwZW5kID0gdG9rZW4gPT4ge1xuICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuICAgIGNvbnN1bWUodG9rZW4udmFsdWUpO1xuICB9O1xuXG4gIGNvbnN0IG5lZ2F0ZSA9ICgpID0+IHtcbiAgICBsZXQgY291bnQgPSAxO1xuXG4gICAgd2hpbGUgKHBlZWsoKSA9PT0gJyEnICYmIChwZWVrKDIpICE9PSAnKCcgfHwgcGVlaygzKSA9PT0gJz8nKSkge1xuICAgICAgYWR2YW5jZSgpO1xuICAgICAgc3RhdGUuc3RhcnQrKztcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHN0YXRlLm5lZ2F0ZWQgPSB0cnVlO1xuICAgIHN0YXRlLnN0YXJ0Kys7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgY29uc3QgaW5jcmVtZW50ID0gdHlwZSA9PiB7XG4gICAgc3RhdGVbdHlwZV0rKztcbiAgICBzdGFjay5wdXNoKHR5cGUpO1xuICB9O1xuXG4gIGNvbnN0IGRlY3JlbWVudCA9IHR5cGUgPT4ge1xuICAgIHN0YXRlW3R5cGVdLS07XG4gICAgc3RhY2sucG9wKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFB1c2ggdG9rZW5zIG9udG8gdGhlIHRva2VucyBhcnJheS4gVGhpcyBoZWxwZXIgc3BlZWRzIHVwXG4gICAqIHRva2VuaXppbmcgYnkgMSkgaGVscGluZyB1cyBhdm9pZCBiYWNrdHJhY2tpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSxcbiAgICogYW5kIDIpIGhlbHBpbmcgdXMgYXZvaWQgY3JlYXRpbmcgZXh0cmEgdG9rZW5zIHdoZW4gY29uc2VjdXRpdmVcbiAgICogY2hhcmFjdGVycyBhcmUgcGxhaW4gdGV4dC4gVGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBhbmQgc2ltcGxpZmllc1xuICAgKiBsb29rYmVoaW5kcy5cbiAgICovXG5cbiAgY29uc3QgcHVzaCA9IHRvayA9PiB7XG4gICAgaWYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJykge1xuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHRvay50eXBlID09PSAnY29tbWEnIHx8IHRvay50eXBlID09PSAnYnJhY2UnKTtcbiAgICAgIGNvbnN0IGlzRXh0Z2xvYiA9IHRvay5leHRnbG9iID09PSB0cnVlIHx8IChleHRnbG9icy5sZW5ndGggJiYgKHRvay50eXBlID09PSAncGlwZScgfHwgdG9rLnR5cGUgPT09ICdwYXJlbicpKTtcblxuICAgICAgaWYgKHRvay50eXBlICE9PSAnc2xhc2gnICYmIHRvay50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2Lm91dHB1dC5sZW5ndGgpO1xuICAgICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgPSAnKic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByZXYub3V0cHV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHRnbG9icy5sZW5ndGggJiYgdG9rLnR5cGUgIT09ICdwYXJlbicpIHtcbiAgICAgIGV4dGdsb2JzW2V4dGdsb2JzLmxlbmd0aCAtIDFdLmlubmVyICs9IHRvay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodG9rLnZhbHVlIHx8IHRvay5vdXRwdXQpIGFwcGVuZCh0b2spO1xuICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3RleHQnICYmIHRvay50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHByZXYub3V0cHV0ID0gKHByZXYub3V0cHV0IHx8IHByZXYudmFsdWUpICsgdG9rLnZhbHVlO1xuICAgICAgcHJldi52YWx1ZSArPSB0b2sudmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rLnByZXYgPSBwcmV2O1xuICAgIHRva2Vucy5wdXNoKHRvayk7XG4gICAgcHJldiA9IHRvaztcbiAgfTtcblxuICBjb25zdCBleHRnbG9iT3BlbiA9ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHRva2VuID0geyAuLi5FWFRHTE9CX0NIQVJTW3ZhbHVlXSwgY29uZGl0aW9uczogMSwgaW5uZXI6ICcnIH07XG5cbiAgICB0b2tlbi5wcmV2ID0gcHJldjtcbiAgICB0b2tlbi5wYXJlbnMgPSBzdGF0ZS5wYXJlbnM7XG4gICAgdG9rZW4ub3V0cHV0ID0gc3RhdGUub3V0cHV0O1xuICAgIGNvbnN0IG91dHB1dCA9IChvcHRzLmNhcHR1cmUgPyAnKCcgOiAnJykgKyB0b2tlbi5vcGVuO1xuXG4gICAgaW5jcmVtZW50KCdwYXJlbnMnKTtcbiAgICBwdXNoKHsgdHlwZSwgdmFsdWUsIG91dHB1dDogc3RhdGUub3V0cHV0ID8gJycgOiBPTkVfQ0hBUiB9KTtcbiAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWU6IGFkdmFuY2UoKSwgb3V0cHV0IH0pO1xuICAgIGV4dGdsb2JzLnB1c2godG9rZW4pO1xuICB9O1xuXG4gIGNvbnN0IGV4dGdsb2JDbG9zZSA9IHRva2VuID0+IHtcbiAgICBsZXQgb3V0cHV0ID0gdG9rZW4uY2xvc2UgKyAob3B0cy5jYXB0dXJlID8gJyknIDogJycpO1xuICAgIGxldCByZXN0O1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICduZWdhdGUnKSB7XG4gICAgICBsZXQgZXh0Z2xvYlN0YXIgPSBzdGFyO1xuXG4gICAgICBpZiAodG9rZW4uaW5uZXIgJiYgdG9rZW4uaW5uZXIubGVuZ3RoID4gMSAmJiB0b2tlbi5pbm5lci5pbmNsdWRlcygnLycpKSB7XG4gICAgICAgIGV4dGdsb2JTdGFyID0gZ2xvYnN0YXIob3B0cyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHRnbG9iU3RhciAhPT0gc3RhciB8fCBlb3MoKSB8fCAvXlxcKSskLy50ZXN0KHJlbWFpbmluZygpKSkge1xuICAgICAgICBvdXRwdXQgPSB0b2tlbi5jbG9zZSA9IGApJCkpJHtleHRnbG9iU3Rhcn1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4uaW5uZXIuaW5jbHVkZXMoJyonKSAmJiAocmVzdCA9IHJlbWFpbmluZygpKSAmJiAvXlxcLlteXFxcXC8uXSskLy50ZXN0KHJlc3QpKSB7XG4gICAgICAgIC8vIEFueSBub24tbWFnaWNhbCBzdHJpbmcgKGAudHNgKSBvciBldmVuIG5lc3RlZCBleHByZXNzaW9uIChgLnt0cyx0c3h9YCkgY2FuIGZvbGxvdyBhZnRlciB0aGUgY2xvc2luZyBwYXJlbnRoZXNpcy5cbiAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBuZWVkIHRvIHBhcnNlIHRoZSBzdHJpbmcgYW5kIHVzZSBpdCBpbiB0aGUgb3V0cHV0IG9mIHRoZSBvcmlnaW5hbCBwYXR0ZXJuLlxuICAgICAgICAvLyBTdWl0YWJsZSBwYXR0ZXJuczogYC8hKCouZCkudHNgLCBgLyEoKi5kKS57dHMsdHN4fWAsIGAqKi8hKCotZGJnKS5AKGpzKWAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIERpc2FibGluZyB0aGUgYGZhc3RwYXRoc2Agb3B0aW9uIGR1ZSB0byBhIHByb2JsZW0gd2l0aCBwYXJzaW5nIHN0cmluZ3MgYXMgYC50c2AgaW4gdGhlIHBhdHRlcm4gbGlrZSBgKiovISgqLmQpLnRzYC5cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhcnNlKHJlc3QsIHsgLi4ub3B0aW9ucywgZmFzdHBhdGhzOiBmYWxzZSB9KS5vdXRwdXQ7XG5cbiAgICAgICAgb3V0cHV0ID0gdG9rZW4uY2xvc2UgPSBgKSR7ZXhwcmVzc2lvbn0pJHtleHRnbG9iU3Rhcn0pYDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnByZXYudHlwZSA9PT0gJ2JvcycpIHtcbiAgICAgICAgc3RhdGUubmVnYXRlZEV4dGdsb2IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1c2goeyB0eXBlOiAncGFyZW4nLCBleHRnbG9iOiB0cnVlLCB2YWx1ZSwgb3V0cHV0IH0pO1xuICAgIGRlY3JlbWVudCgncGFyZW5zJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZhc3QgcGF0aHNcbiAgICovXG5cbiAgaWYgKG9wdHMuZmFzdHBhdGhzICE9PSBmYWxzZSAmJiAhLyheWyohXXxbLygpW1xcXXt9XCJdKS8udGVzdChpbnB1dCkpIHtcbiAgICBsZXQgYmFja3NsYXNoZXMgPSBmYWxzZTtcblxuICAgIGxldCBvdXRwdXQgPSBpbnB1dC5yZXBsYWNlKFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiwgKG0sIGVzYywgY2hhcnMsIGZpcnN0LCByZXN0LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGZpcnN0ID09PSAnXFxcXCcpIHtcbiAgICAgICAgYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ID09PSAnPycpIHtcbiAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gcW1hcmtOb0RvdCArIChyZXN0ID8gUU1BUksucmVwZWF0KHJlc3QubGVuZ3RoKSA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUU1BUksucmVwZWF0KGNoYXJzLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdCA9PT0gJy4nKSB7XG4gICAgICAgIHJldHVybiBET1RfTElURVJBTC5yZXBlYXQoY2hhcnMubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0ID09PSAnKicpIHtcbiAgICAgICAgaWYgKGVzYykge1xuICAgICAgICAgIHJldHVybiBlc2MgKyBmaXJzdCArIChyZXN0ID8gc3RhciA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlc2MgPyBtIDogYFxcXFwke219YDtcbiAgICB9KTtcblxuICAgIGlmIChiYWNrc2xhc2hlcyA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoL1xcXFwrL2csIG0gPT4ge1xuICAgICAgICAgIHJldHVybiBtLmxlbmd0aCAlIDIgPT09IDAgPyAnXFxcXFxcXFwnIDogKG0gPyAnXFxcXCcgOiAnJyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvdXRwdXQgPT09IGlucHV0ICYmIG9wdHMuY29udGFpbnMgPT09IHRydWUpIHtcbiAgICAgIHN0YXRlLm91dHB1dCA9IGlucHV0O1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLndyYXBPdXRwdXQob3V0cHV0LCBzdGF0ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRva2VuaXplIGlucHV0IHVudGlsIHdlIHJlYWNoIGVuZC1vZi1zdHJpbmdcbiAgICovXG5cbiAgd2hpbGUgKCFlb3MoKSkge1xuICAgIHZhbHVlID0gYWR2YW5jZSgpO1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFx1MDAwMCcpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzY2FwZWQgY2hhcmFjdGVyc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnXFxcXCcpIHtcbiAgICAgIGNvbnN0IG5leHQgPSBwZWVrKCk7XG5cbiAgICAgIGlmIChuZXh0ID09PSAnLycgJiYgb3B0cy5iYXNoICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dCA9PT0gJy4nIHx8IG5leHQgPT09ICc7Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgIHZhbHVlICs9ICdcXFxcJztcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb2xsYXBzZSBzbGFzaGVzIHRvIHJlZHVjZSBwb3RlbnRpYWwgZm9yIGV4cGxvaXRzXG4gICAgICBjb25zdCBtYXRjaCA9IC9eXFxcXCsvLmV4ZWMocmVtYWluaW5nKCkpO1xuICAgICAgbGV0IHNsYXNoZXMgPSAwO1xuXG4gICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbMF0ubGVuZ3RoID4gMikge1xuICAgICAgICBzbGFzaGVzID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5pbmRleCArPSBzbGFzaGVzO1xuICAgICAgICBpZiAoc2xhc2hlcyAlIDIgIT09IDApIHtcbiAgICAgICAgICB2YWx1ZSArPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMudW5lc2NhcGUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSBhZHZhbmNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSArPSBhZHZhbmNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5icmFja2V0cyA9PT0gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW5zaWRlIGEgcmVnZXggY2hhcmFjdGVyIGNsYXNzLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGJyYWNrZXQuXG4gICAgICovXG5cbiAgICBpZiAoc3RhdGUuYnJhY2tldHMgPiAwICYmICh2YWx1ZSAhPT0gJ10nIHx8IHByZXYudmFsdWUgPT09ICdbJyB8fCBwcmV2LnZhbHVlID09PSAnW14nKSkge1xuICAgICAgaWYgKG9wdHMucG9zaXggIT09IGZhbHNlICYmIHZhbHVlID09PSAnOicpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBwcmV2LnZhbHVlLnNsaWNlKDEpO1xuICAgICAgICBpZiAoaW5uZXIuaW5jbHVkZXMoJ1snKSkge1xuICAgICAgICAgIHByZXYucG9zaXggPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKGlubmVyLmluY2x1ZGVzKCc6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHByZXYudmFsdWUubGFzdEluZGV4T2YoJ1snKTtcbiAgICAgICAgICAgIGNvbnN0IHByZSA9IHByZXYudmFsdWUuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBwcmV2LnZhbHVlLnNsaWNlKGlkeCArIDIpO1xuICAgICAgICAgICAgY29uc3QgcG9zaXggPSBQT1NJWF9SRUdFWF9TT1VSQ0VbcmVzdF07XG4gICAgICAgICAgICBpZiAocG9zaXgpIHtcbiAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IHByZSArIHBvc2l4O1xuICAgICAgICAgICAgICBzdGF0ZS5iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICBhZHZhbmNlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKCFib3Mub3V0cHV0ICYmIHRva2Vucy5pbmRleE9mKHByZXYpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgYm9zLm91dHB1dCA9IE9ORV9DSEFSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoKHZhbHVlID09PSAnWycgJiYgcGVlaygpICE9PSAnOicpIHx8ICh2YWx1ZSA9PT0gJy0nICYmIHBlZWsoKSA9PT0gJ10nKSkge1xuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPT09ICddJyAmJiAocHJldi52YWx1ZSA9PT0gJ1snIHx8IHByZXYudmFsdWUgPT09ICdbXicpKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRzLnBvc2l4ID09PSB0cnVlICYmIHZhbHVlID09PSAnIScgJiYgcHJldi52YWx1ZSA9PT0gJ1snKSB7XG4gICAgICAgIHZhbHVlID0gJ14nO1xuICAgICAgfVxuXG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbnNpZGUgYSBxdW90ZWQgc3RyaW5nLCBjb250aW51ZVxuICAgICAqIHVudGlsIHdlIHJlYWNoIHRoZSBjbG9zaW5nIGRvdWJsZSBxdW90ZS5cbiAgICAgKi9cblxuICAgIGlmIChzdGF0ZS5xdW90ZXMgPT09IDEgJiYgdmFsdWUgIT09ICdcIicpIHtcbiAgICAgIHZhbHVlID0gdXRpbHMuZXNjYXBlUmVnZXgodmFsdWUpO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIGFwcGVuZCh7IHZhbHVlIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG91YmxlIHF1b3Rlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnXCInKSB7XG4gICAgICBzdGF0ZS5xdW90ZXMgPSBzdGF0ZS5xdW90ZXMgPT09IDEgPyAwIDogMTtcbiAgICAgIGlmIChvcHRzLmtlZXBRdW90ZXMgPT09IHRydWUpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnRoZXNlc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnKCcpIHtcbiAgICAgIGluY3JlbWVudCgncGFyZW5zJyk7XG4gICAgICBwdXNoKHsgdHlwZTogJ3BhcmVuJywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICcpJykge1xuICAgICAgaWYgKHN0YXRlLnBhcmVucyA9PT0gMCAmJiBvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignb3BlbmluZycsICcoJykpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRnbG9iID0gZXh0Z2xvYnNbZXh0Z2xvYnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoZXh0Z2xvYiAmJiBzdGF0ZS5wYXJlbnMgPT09IGV4dGdsb2IucGFyZW5zICsgMSkge1xuICAgICAgICBleHRnbG9iQ2xvc2UoZXh0Z2xvYnMucG9wKCkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdwYXJlbicsIHZhbHVlLCBvdXRwdXQ6IHN0YXRlLnBhcmVucyA/ICcpJyA6ICdcXFxcKScgfSk7XG4gICAgICBkZWNyZW1lbnQoJ3BhcmVucycpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3F1YXJlIGJyYWNrZXRzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdbJykge1xuICAgICAgaWYgKG9wdHMubm9icmFja2V0ID09PSB0cnVlIHx8ICFyZW1haW5pbmcoKS5pbmNsdWRlcygnXScpKSB7XG4gICAgICAgIGlmIChvcHRzLm5vYnJhY2tldCAhPT0gdHJ1ZSAmJiBvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ10nKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IGBcXFxcJHt2YWx1ZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5jcmVtZW50KCdicmFja2V0cycpO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2JyYWNrZXQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA9PT0gJ10nKSB7XG4gICAgICBpZiAob3B0cy5ub2JyYWNrZXQgPT09IHRydWUgfHwgKHByZXYgJiYgcHJldi50eXBlID09PSAnYnJhY2tldCcgJiYgcHJldi52YWx1ZS5sZW5ndGggPT09IDEpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQ6IGBcXFxcJHt2YWx1ZX1gIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmJyYWNrZXRzID09PSAwKSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdEJyYWNrZXRzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdvcGVuaW5nJywgJ1snKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiBgXFxcXCR7dmFsdWV9YCB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRlY3JlbWVudCgnYnJhY2tldHMnKTtcblxuICAgICAgY29uc3QgcHJldlZhbHVlID0gcHJldi52YWx1ZS5zbGljZSgxKTtcbiAgICAgIGlmIChwcmV2LnBvc2l4ICE9PSB0cnVlICYmIHByZXZWYWx1ZVswXSA9PT0gJ14nICYmICFwcmV2VmFsdWUuaW5jbHVkZXMoJy8nKSkge1xuICAgICAgICB2YWx1ZSA9IGAvJHt2YWx1ZX1gO1xuICAgICAgfVxuXG4gICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgYXBwZW5kKHsgdmFsdWUgfSk7XG5cbiAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZFxuICAgICAgLy8gYXNzdW1lIHdlIHNob3VsZCBtYXRjaCB3aXRoIGEgcmVnZXggY2hhcmFjdGVyIGNsYXNzXG4gICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IGZhbHNlIHx8IHV0aWxzLmhhc1JlZ2V4Q2hhcnMocHJldlZhbHVlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZVJlZ2V4KHByZXYudmFsdWUpO1xuICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC1wcmV2LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgIC8vIHdoZW4gbGl0ZXJhbCBicmFja2V0cyBhcmUgZXhwbGljaXRseSBlbmFibGVkXG4gICAgICAvLyBhc3N1bWUgd2Ugc2hvdWxkIGVzY2FwZSB0aGUgYnJhY2tldHMgdG8gbWF0Y2ggbGl0ZXJhbCBjaGFyYWN0ZXJzXG4gICAgICBpZiAob3B0cy5saXRlcmFsQnJhY2tldHMgPT09IHRydWUpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IGVzY2FwZWQ7XG4gICAgICAgIHByZXYudmFsdWUgPSBlc2NhcGVkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgdXNlciBzcGVjaWZpZXMgbm90aGluZywgdHJ5IHRvIG1hdGNoIGJvdGhcbiAgICAgIHByZXYudmFsdWUgPSBgKCR7Y2FwdHVyZX0ke2VzY2FwZWR9fCR7cHJldi52YWx1ZX0pYDtcbiAgICAgIHN0YXRlLm91dHB1dCArPSBwcmV2LnZhbHVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnJhY2VzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICd7JyAmJiBvcHRzLm5vYnJhY2UgIT09IHRydWUpIHtcbiAgICAgIGluY3JlbWVudCgnYnJhY2VzJyk7XG5cbiAgICAgIGNvbnN0IG9wZW4gPSB7XG4gICAgICAgIHR5cGU6ICdicmFjZScsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvdXRwdXQ6ICcoJyxcbiAgICAgICAgb3V0cHV0SW5kZXg6IHN0YXRlLm91dHB1dC5sZW5ndGgsXG4gICAgICAgIHRva2Vuc0luZGV4OiBzdGF0ZS50b2tlbnMubGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICBicmFjZXMucHVzaChvcGVuKTtcbiAgICAgIHB1c2gob3Blbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPT09ICd9Jykge1xuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAob3B0cy5ub2JyYWNlID09PSB0cnVlIHx8ICFicmFjZSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSwgb3V0cHV0OiB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXQgPSAnKSc7XG5cbiAgICAgIGlmIChicmFjZS5kb3RzID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHRva2Vucy5zbGljZSgpO1xuICAgICAgICBjb25zdCByYW5nZSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0b2tlbnMucG9wKCk7XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlID09PSAnYnJhY2UnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFycltpXS50eXBlICE9PSAnZG90cycpIHtcbiAgICAgICAgICAgIHJhbmdlLnVuc2hpZnQoYXJyW2ldLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgPSBleHBhbmRSYW5nZShyYW5nZSwgb3B0cyk7XG4gICAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChicmFjZS5jb21tYSAhPT0gdHJ1ZSAmJiBicmFjZS5kb3RzICE9PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IHN0YXRlLm91dHB1dC5zbGljZSgwLCBicmFjZS5vdXRwdXRJbmRleCk7XG4gICAgICAgIGNvbnN0IHRva3MgPSBzdGF0ZS50b2tlbnMuc2xpY2UoYnJhY2UudG9rZW5zSW5kZXgpO1xuICAgICAgICBicmFjZS52YWx1ZSA9IGJyYWNlLm91dHB1dCA9ICdcXFxceyc7XG4gICAgICAgIHZhbHVlID0gb3V0cHV0ID0gJ1xcXFx9JztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gb3V0O1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdG9rcykge1xuICAgICAgICAgIHN0YXRlLm91dHB1dCArPSAodC5vdXRwdXQgfHwgdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdicmFjZScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBkZWNyZW1lbnQoJ2JyYWNlcycpO1xuICAgICAgYnJhY2VzLnBvcCgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGlwZXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJ3wnKSB7XG4gICAgICBpZiAoZXh0Z2xvYnMubGVuZ3RoID4gMCkge1xuICAgICAgICBleHRnbG9ic1tleHRnbG9icy5sZW5ndGggLSAxXS5jb25kaXRpb25zKys7XG4gICAgICB9XG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbW1hc1xuICAgICAqL1xuXG4gICAgaWYgKHZhbHVlID09PSAnLCcpIHtcbiAgICAgIGxldCBvdXRwdXQgPSB2YWx1ZTtcblxuICAgICAgY29uc3QgYnJhY2UgPSBicmFjZXNbYnJhY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGJyYWNlICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSAnYnJhY2VzJykge1xuICAgICAgICBicmFjZS5jb21tYSA9IHRydWU7XG4gICAgICAgIG91dHB1dCA9ICd8JztcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdjb21tYScsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTbGFzaGVzXG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICcvJykge1xuICAgICAgLy8gaWYgdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2xvYiBpcyBcIi4vXCIsIGFkdmFuY2UgdGhlIHN0YXJ0XG4gICAgICAvLyB0byB0aGUgY3VycmVudCBpbmRleCwgYW5kIGRvbid0IGFkZCB0aGUgXCIuL1wiIGNoYXJhY3RlcnNcbiAgICAgIC8vIHRvIHRoZSBzdGF0ZS4gVGhpcyBncmVhdGx5IHNpbXBsaWZpZXMgbG9va2JlaGluZHMgd2hlblxuICAgICAgLy8gY2hlY2tpbmcgZm9yIEJPUyBjaGFyYWN0ZXJzIGxpa2UgXCIhXCIgYW5kIFwiLlwiIChub3QgXCIuL1wiKVxuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcgJiYgc3RhdGUuaW5kZXggPT09IHN0YXRlLnN0YXJ0ICsgMSkge1xuICAgICAgICBzdGF0ZS5zdGFydCA9IHN0YXRlLmluZGV4ICsgMTtcbiAgICAgICAgc3RhdGUuY29uc3VtZWQgPSAnJztcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gJyc7XG4gICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgcHJldiA9IGJvczsgLy8gcmVzZXQgXCJwcmV2XCIgdG8gdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3NsYXNoJywgdmFsdWUsIG91dHB1dDogU0xBU0hfTElURVJBTCB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvdHNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJy4nKSB7XG4gICAgICBpZiAoc3RhdGUuYnJhY2VzID4gMCAmJiBwcmV2LnR5cGUgPT09ICdkb3QnKSB7XG4gICAgICAgIGlmIChwcmV2LnZhbHVlID09PSAnLicpIHByZXYub3V0cHV0ID0gRE9UX0xJVEVSQUw7XG4gICAgICAgIGNvbnN0IGJyYWNlID0gYnJhY2VzW2JyYWNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcHJldi50eXBlID0gJ2RvdHMnO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSB2YWx1ZTtcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgYnJhY2UuZG90cyA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHN0YXRlLmJyYWNlcyArIHN0YXRlLnBhcmVucykgPT09IDAgJiYgcHJldi50eXBlICE9PSAnYm9zJyAmJiBwcmV2LnR5cGUgIT09ICdzbGFzaCcpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUsIG91dHB1dDogRE9UX0xJVEVSQUwgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ2RvdCcsIHZhbHVlLCBvdXRwdXQ6IERPVF9MSVRFUkFMIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUXVlc3Rpb24gbWFya3NcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJz8nKSB7XG4gICAgICBjb25zdCBpc0dyb3VwID0gcHJldiAmJiBwcmV2LnZhbHVlID09PSAnKCc7XG4gICAgICBpZiAoIWlzR3JvdXAgJiYgb3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdxbWFyaycsIHZhbHVlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcmV2ICYmIHByZXYudHlwZSA9PT0gJ3BhcmVuJykge1xuICAgICAgICBjb25zdCBuZXh0ID0gcGVlaygpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKChwcmV2LnZhbHVlID09PSAnKCcgJiYgIS9bIT08Ol0vLnRlc3QobmV4dCkpIHx8IChuZXh0ID09PSAnPCcgJiYgIS88KFshPV18XFx3Kz4pLy50ZXN0KHJlbWFpbmluZygpKSkpIHtcbiAgICAgICAgICBvdXRwdXQgPSBgXFxcXCR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2goeyB0eXBlOiAndGV4dCcsIHZhbHVlLCBvdXRwdXQgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5kb3QgIT09IHRydWUgJiYgKHByZXYudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmV2LnR5cGUgPT09ICdib3MnKSkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3FtYXJrJywgdmFsdWUsIG91dHB1dDogUU1BUktfTk9fRE9UIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICdxbWFyaycsIHZhbHVlLCBvdXRwdXQ6IFFNQVJLIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhjbGFtYXRpb25cbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJyEnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcpIHtcbiAgICAgICAgaWYgKHBlZWsoMikgIT09ICc/JyB8fCAhL1shPTw6XS8udGVzdChwZWVrKDMpKSkge1xuICAgICAgICAgIGV4dGdsb2JPcGVuKCduZWdhdGUnLCB2YWx1ZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubm9uZWdhdGUgIT09IHRydWUgJiYgc3RhdGUuaW5kZXggPT09IDApIHtcbiAgICAgICAgbmVnYXRlKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsdXNcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSA9PT0gJysnKSB7XG4gICAgICBpZiAob3B0cy5ub2V4dGdsb2IgIT09IHRydWUgJiYgcGVlaygpID09PSAnKCcgJiYgcGVlaygyKSAhPT0gJz8nKSB7XG4gICAgICAgIGV4dGdsb2JPcGVuKCdwbHVzJywgdmFsdWUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIHByZXYudmFsdWUgPT09ICcoJykgfHwgb3B0cy5yZWdleCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdwbHVzJywgdmFsdWUsIG91dHB1dDogUExVU19MSVRFUkFMIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChwcmV2ICYmIChwcmV2LnR5cGUgPT09ICdicmFja2V0JyB8fCBwcmV2LnR5cGUgPT09ICdwYXJlbicgfHwgcHJldi50eXBlID09PSAnYnJhY2UnKSkgfHwgc3RhdGUucGFyZW5zID4gMCkge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ3BsdXMnLCB2YWx1ZSB9KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHB1c2goeyB0eXBlOiAncGx1cycsIHZhbHVlOiBQTFVTX0xJVEVSQUwgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0XG4gICAgICovXG5cbiAgICBpZiAodmFsdWUgPT09ICdAJykge1xuICAgICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIHBlZWsoKSA9PT0gJygnICYmIHBlZWsoMikgIT09ICc/Jykge1xuICAgICAgICBwdXNoKHsgdHlwZTogJ2F0JywgZXh0Z2xvYjogdHJ1ZSwgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwdXNoKHsgdHlwZTogJ3RleHQnLCB2YWx1ZSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHRcbiAgICAgKi9cblxuICAgIGlmICh2YWx1ZSAhPT0gJyonKSB7XG4gICAgICBpZiAodmFsdWUgPT09ICckJyB8fCB2YWx1ZSA9PT0gJ14nKSB7XG4gICAgICAgIHZhbHVlID0gYFxcXFwke3ZhbHVlfWA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gUkVHRVhfTk9OX1NQRUNJQUxfQ0hBUlMuZXhlYyhyZW1haW5pbmcoKSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFsdWUgKz0gbWF0Y2hbMF07XG4gICAgICAgIHN0YXRlLmluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcHVzaCh7IHR5cGU6ICd0ZXh0JywgdmFsdWUgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFyc1xuICAgICAqL1xuXG4gICAgaWYgKHByZXYgJiYgKHByZXYudHlwZSA9PT0gJ2dsb2JzdGFyJyB8fCBwcmV2LnN0YXIgPT09IHRydWUpKSB7XG4gICAgICBwcmV2LnR5cGUgPSAnc3Rhcic7XG4gICAgICBwcmV2LnN0YXIgPSB0cnVlO1xuICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgIHByZXYub3V0cHV0ID0gc3RhcjtcbiAgICAgIHN0YXRlLmJhY2t0cmFjayA9IHRydWU7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCByZXN0ID0gcmVtYWluaW5nKCk7XG4gICAgaWYgKG9wdHMubm9leHRnbG9iICE9PSB0cnVlICYmIC9eXFwoW14/XS8udGVzdChyZXN0KSkge1xuICAgICAgZXh0Z2xvYk9wZW4oJ3N0YXInLCB2YWx1ZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldi50eXBlID09PSAnc3RhcicpIHtcbiAgICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcmlvciA9IHByZXYucHJldjtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IHByaW9yLnByZXY7XG4gICAgICBjb25zdCBpc1N0YXJ0ID0gcHJpb3IudHlwZSA9PT0gJ3NsYXNoJyB8fCBwcmlvci50eXBlID09PSAnYm9zJztcbiAgICAgIGNvbnN0IGFmdGVyU3RhciA9IGJlZm9yZSAmJiAoYmVmb3JlLnR5cGUgPT09ICdzdGFyJyB8fCBiZWZvcmUudHlwZSA9PT0gJ2dsb2JzdGFyJyk7XG5cbiAgICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUgJiYgKCFpc1N0YXJ0IHx8IChyZXN0WzBdICYmIHJlc3RbMF0gIT09ICcvJykpKSB7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNCcmFjZSA9IHN0YXRlLmJyYWNlcyA+IDAgJiYgKHByaW9yLnR5cGUgPT09ICdjb21tYScgfHwgcHJpb3IudHlwZSA9PT0gJ2JyYWNlJyk7XG4gICAgICBjb25zdCBpc0V4dGdsb2IgPSBleHRnbG9icy5sZW5ndGggJiYgKHByaW9yLnR5cGUgPT09ICdwaXBlJyB8fCBwcmlvci50eXBlID09PSAncGFyZW4nKTtcbiAgICAgIGlmICghaXNTdGFydCAmJiBwcmlvci50eXBlICE9PSAncGFyZW4nICYmICFpc0JyYWNlICYmICFpc0V4dGdsb2IpIHtcbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzdGFyJywgdmFsdWUsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdHJpcCBjb25zZWN1dGl2ZSBgLyoqL2BcbiAgICAgIHdoaWxlIChyZXN0LnNsaWNlKDAsIDMpID09PSAnLyoqJykge1xuICAgICAgICBjb25zdCBhZnRlciA9IGlucHV0W3N0YXRlLmluZGV4ICsgNF07XG4gICAgICAgIGlmIChhZnRlciAmJiBhZnRlciAhPT0gJy8nKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoMyk7XG4gICAgICAgIGNvbnN1bWUoJy8qKicsIDMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgZW9zKCkpIHtcbiAgICAgICAgcHJldi50eXBlID0gJ2dsb2JzdGFyJztcbiAgICAgICAgcHJldi52YWx1ZSArPSB2YWx1ZTtcbiAgICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmICFhZnRlclN0YXIgJiYgZW9zKCkpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gZ2xvYnN0YXIob3B0cykgKyAob3B0cy5zdHJpY3RTbGFzaGVzID8gJyknIDogJ3wkKScpO1xuICAgICAgICBwcmV2LnZhbHVlICs9IHZhbHVlO1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBwcmlvci5vdXRwdXQgKyBwcmV2Lm91dHB1dDtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ3NsYXNoJyAmJiBwcmlvci5wcmV2LnR5cGUgIT09ICdib3MnICYmIHJlc3RbMF0gPT09ICcvJykge1xuICAgICAgICBjb25zdCBlbmQgPSByZXN0WzFdICE9PSB2b2lkIDAgPyAnfCQnIDogJyc7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ID0gc3RhdGUub3V0cHV0LnNsaWNlKDAsIC0ocHJpb3Iub3V0cHV0ICsgcHJldi5vdXRwdXQpLmxlbmd0aCk7XG4gICAgICAgIHByaW9yLm91dHB1dCA9IGAoPzoke3ByaW9yLm91dHB1dH1gO1xuXG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfXwke1NMQVNIX0xJVEVSQUx9JHtlbmR9KWA7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IHByaW9yLm91dHB1dCArIHByZXYub3V0cHV0O1xuICAgICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG5cbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG5cbiAgICAgICAgcHVzaCh7IHR5cGU6ICdzbGFzaCcsIHZhbHVlOiAnLycsIG91dHB1dDogJycgfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJpb3IudHlwZSA9PT0gJ2JvcycgJiYgcmVzdFswXSA9PT0gJy8nKSB7XG4gICAgICAgIHByZXYudHlwZSA9ICdnbG9ic3Rhcic7XG4gICAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG4gICAgICAgIHByZXYub3V0cHV0ID0gYCg/Ol58JHtTTEFTSF9MSVRFUkFMfXwke2dsb2JzdGFyKG9wdHMpfSR7U0xBU0hfTElURVJBTH0pYDtcbiAgICAgICAgc3RhdGUub3V0cHV0ID0gcHJldi5vdXRwdXQ7XG4gICAgICAgIHN0YXRlLmdsb2JzdGFyID0gdHJ1ZTtcbiAgICAgICAgY29uc3VtZSh2YWx1ZSArIGFkdmFuY2UoKSk7XG4gICAgICAgIHB1c2goeyB0eXBlOiAnc2xhc2gnLCB2YWx1ZTogJy8nLCBvdXRwdXQ6ICcnIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHNpbmdsZSBzdGFyIGZyb20gb3V0cHV0XG4gICAgICBzdGF0ZS5vdXRwdXQgPSBzdGF0ZS5vdXRwdXQuc2xpY2UoMCwgLXByZXYub3V0cHV0Lmxlbmd0aCk7XG5cbiAgICAgIC8vIHJlc2V0IHByZXZpb3VzIHRva2VuIHRvIGdsb2JzdGFyXG4gICAgICBwcmV2LnR5cGUgPSAnZ2xvYnN0YXInO1xuICAgICAgcHJldi5vdXRwdXQgPSBnbG9ic3RhcihvcHRzKTtcbiAgICAgIHByZXYudmFsdWUgKz0gdmFsdWU7XG5cbiAgICAgIC8vIHJlc2V0IG91dHB1dCB3aXRoIGdsb2JzdGFyXG4gICAgICBzdGF0ZS5vdXRwdXQgKz0gcHJldi5vdXRwdXQ7XG4gICAgICBzdGF0ZS5nbG9ic3RhciA9IHRydWU7XG4gICAgICBjb25zdW1lKHZhbHVlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0geyB0eXBlOiAnc3RhcicsIHZhbHVlLCBvdXRwdXQ6IHN0YXIgfTtcblxuICAgIGlmIChvcHRzLmJhc2ggPT09IHRydWUpIHtcbiAgICAgIHRva2VuLm91dHB1dCA9ICcuKj8nO1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2JvcycgfHwgcHJldi50eXBlID09PSAnc2xhc2gnKSB7XG4gICAgICAgIHRva2VuLm91dHB1dCA9IG5vZG90ICsgdG9rZW4ub3V0cHV0O1xuICAgICAgfVxuICAgICAgcHVzaCh0b2tlbik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJldiAmJiAocHJldi50eXBlID09PSAnYnJhY2tldCcgfHwgcHJldi50eXBlID09PSAncGFyZW4nKSAmJiBvcHRzLnJlZ2V4ID09PSB0cnVlKSB7XG4gICAgICB0b2tlbi5vdXRwdXQgPSB2YWx1ZTtcbiAgICAgIHB1c2godG9rZW4pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluZGV4ID09PSBzdGF0ZS5zdGFydCB8fCBwcmV2LnR5cGUgPT09ICdzbGFzaCcgfHwgcHJldi50eXBlID09PSAnZG90Jykge1xuICAgICAgaWYgKHByZXYudHlwZSA9PT0gJ2RvdCcpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE5PX0RPVF9TTEFTSDtcbiAgICAgICAgcHJldi5vdXRwdXQgKz0gTk9fRE9UX1NMQVNIO1xuXG4gICAgICB9IGVsc2UgaWYgKG9wdHMuZG90ID09PSB0cnVlKSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBOT19ET1RTX1NMQVNIO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5vdXRwdXQgKz0gbm9kb3Q7XG4gICAgICAgIHByZXYub3V0cHV0ICs9IG5vZG90O1xuICAgICAgfVxuXG4gICAgICBpZiAocGVlaygpICE9PSAnKicpIHtcbiAgICAgICAgc3RhdGUub3V0cHV0ICs9IE9ORV9DSEFSO1xuICAgICAgICBwcmV2Lm91dHB1dCArPSBPTkVfQ0hBUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoKHRva2VuKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFja2V0cyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJ10nKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICdbJyk7XG4gICAgZGVjcmVtZW50KCdicmFja2V0cycpO1xuICB9XG5cbiAgd2hpbGUgKHN0YXRlLnBhcmVucyA+IDApIHtcbiAgICBpZiAob3B0cy5zdHJpY3RCcmFja2V0cyA9PT0gdHJ1ZSkgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKCdjbG9zaW5nJywgJyknKSk7XG4gICAgc3RhdGUub3V0cHV0ID0gdXRpbHMuZXNjYXBlTGFzdChzdGF0ZS5vdXRwdXQsICcoJyk7XG4gICAgZGVjcmVtZW50KCdwYXJlbnMnKTtcbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5icmFjZXMgPiAwKSB7XG4gICAgaWYgKG9wdHMuc3RyaWN0QnJhY2tldHMgPT09IHRydWUpIHRocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcignY2xvc2luZycsICd9JykpO1xuICAgIHN0YXRlLm91dHB1dCA9IHV0aWxzLmVzY2FwZUxhc3Qoc3RhdGUub3V0cHV0LCAneycpO1xuICAgIGRlY3JlbWVudCgnYnJhY2VzJyk7XG4gIH1cblxuICBpZiAob3B0cy5zdHJpY3RTbGFzaGVzICE9PSB0cnVlICYmIChwcmV2LnR5cGUgPT09ICdzdGFyJyB8fCBwcmV2LnR5cGUgPT09ICdicmFja2V0JykpIHtcbiAgICBwdXNoKHsgdHlwZTogJ21heWJlX3NsYXNoJywgdmFsdWU6ICcnLCBvdXRwdXQ6IGAke1NMQVNIX0xJVEVSQUx9P2AgfSk7XG4gIH1cblxuICAvLyByZWJ1aWxkIHRoZSBvdXRwdXQgaWYgd2UgaGFkIHRvIGJhY2t0cmFjayBhdCBhbnkgcG9pbnRcbiAgaWYgKHN0YXRlLmJhY2t0cmFjayA9PT0gdHJ1ZSkge1xuICAgIHN0YXRlLm91dHB1dCA9ICcnO1xuXG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiBzdGF0ZS50b2tlbnMpIHtcbiAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5vdXRwdXQgIT0gbnVsbCA/IHRva2VuLm91dHB1dCA6IHRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodG9rZW4uc3VmZml4KSB7XG4gICAgICAgIHN0YXRlLm91dHB1dCArPSB0b2tlbi5zdWZmaXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufTtcblxuLyoqXG4gKiBGYXN0IHBhdGhzIGZvciBjcmVhdGluZyByZWd1bGFyIGV4cHJlc3Npb25zIGZvciBjb21tb24gZ2xvYiBwYXR0ZXJucy5cbiAqIFRoaXMgY2FuIHNpZ25pZmljYW50bHkgc3BlZWQgdXAgcHJvY2Vzc2luZyBhbmQgaGFzIHZlcnkgbGl0dGxlIGRvd25zaWRlXG4gKiBpbXBhY3Qgd2hlbiBub25lIG9mIHRoZSBmYXN0IHBhdGhzIG1hdGNoLlxuICovXG5cbnBhcnNlLmZhc3RwYXRocyA9IChpbnB1dCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBvcHRzID0geyAuLi5vcHRpb25zIH07XG4gIGNvbnN0IG1heCA9IHR5cGVvZiBvcHRzLm1heExlbmd0aCA9PT0gJ251bWJlcicgPyBNYXRoLm1pbihNQVhfTEVOR1RILCBvcHRzLm1heExlbmd0aCkgOiBNQVhfTEVOR1RIO1xuICBjb25zdCBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGlmIChsZW4gPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtsZW59LCBleGNlZWRzIG1heGltdW0gYWxsb3dlZCBsZW5ndGg6ICR7bWF4fWApO1xuICB9XG5cbiAgaW5wdXQgPSBSRVBMQUNFTUVOVFNbaW5wdXRdIHx8IGlucHV0O1xuXG4gIC8vIGNyZWF0ZSBjb25zdGFudHMgYmFzZWQgb24gcGxhdGZvcm0sIGZvciB3aW5kb3dzIG9yIHBvc2l4XG4gIGNvbnN0IHtcbiAgICBET1RfTElURVJBTCxcbiAgICBTTEFTSF9MSVRFUkFMLFxuICAgIE9ORV9DSEFSLFxuICAgIERPVFNfU0xBU0gsXG4gICAgTk9fRE9ULFxuICAgIE5PX0RPVFMsXG4gICAgTk9fRE9UU19TTEFTSCxcbiAgICBTVEFSLFxuICAgIFNUQVJUX0FOQ0hPUlxuICB9ID0gY29uc3RhbnRzLmdsb2JDaGFycyhvcHRzLndpbmRvd3MpO1xuXG4gIGNvbnN0IG5vZG90ID0gb3B0cy5kb3QgPyBOT19ET1RTIDogTk9fRE9UO1xuICBjb25zdCBzbGFzaERvdCA9IG9wdHMuZG90ID8gTk9fRE9UU19TTEFTSCA6IE5PX0RPVDtcbiAgY29uc3QgY2FwdHVyZSA9IG9wdHMuY2FwdHVyZSA/ICcnIDogJz86JztcbiAgY29uc3Qgc3RhdGUgPSB7IG5lZ2F0ZWQ6IGZhbHNlLCBwcmVmaXg6ICcnIH07XG4gIGxldCBzdGFyID0gb3B0cy5iYXNoID09PSB0cnVlID8gJy4qPycgOiBTVEFSO1xuXG4gIGlmIChvcHRzLmNhcHR1cmUpIHtcbiAgICBzdGFyID0gYCgke3N0YXJ9KWA7XG4gIH1cblxuICBjb25zdCBnbG9ic3RhciA9IG9wdHMgPT4ge1xuICAgIGlmIChvcHRzLm5vZ2xvYnN0YXIgPT09IHRydWUpIHJldHVybiBzdGFyO1xuICAgIHJldHVybiBgKCR7Y2FwdHVyZX0oPzooPyEke1NUQVJUX0FOQ0hPUn0ke29wdHMuZG90ID8gRE9UU19TTEFTSCA6IERPVF9MSVRFUkFMfSkuKSo/KWA7XG4gIH07XG5cbiAgY29uc3QgY3JlYXRlID0gc3RyID0+IHtcbiAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgY2FzZSAnKic6XG4gICAgICAgIHJldHVybiBgJHtub2RvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcuKic6XG4gICAgICAgIHJldHVybiBgJHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqLionOlxuICAgICAgICByZXR1cm4gYCR7bm9kb3R9JHtzdGFyfSR7RE9UX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3N0YXJ9YDtcblxuICAgICAgY2FzZSAnKi8qJzpcbiAgICAgICAgcmV0dXJuIGAke25vZG90fSR7c3Rhcn0ke1NMQVNIX0xJVEVSQUx9JHtPTkVfQ0hBUn0ke3NsYXNoRG90fSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKic6XG4gICAgICAgIHJldHVybiBub2RvdCArIGdsb2JzdGFyKG9wdHMpO1xuXG4gICAgICBjYXNlICcqKi8qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtzbGFzaERvdH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBjYXNlICcqKi8qLionOlxuICAgICAgICByZXR1cm4gYCg/OiR7bm9kb3R9JHtnbG9ic3RhcihvcHRzKX0ke1NMQVNIX0xJVEVSQUx9KT8ke3NsYXNoRG90fSR7c3Rhcn0ke0RPVF9MSVRFUkFMfSR7T05FX0NIQVJ9JHtzdGFyfWA7XG5cbiAgICAgIGNhc2UgJyoqLy4qJzpcbiAgICAgICAgcmV0dXJuIGAoPzoke25vZG90fSR7Z2xvYnN0YXIob3B0cyl9JHtTTEFTSF9MSVRFUkFMfSk/JHtET1RfTElURVJBTH0ke09ORV9DSEFSfSR7c3Rhcn1gO1xuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gL14oLio/KVxcLihcXHcrKSQvLmV4ZWMoc3RyKTtcbiAgICAgICAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGNyZWF0ZShtYXRjaFsxXSk7XG4gICAgICAgIGlmICghc291cmNlKSByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIHNvdXJjZSArIERPVF9MSVRFUkFMICsgbWF0Y2hbMl07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG91dHB1dCA9IHV0aWxzLnJlbW92ZVByZWZpeChpbnB1dCwgc3RhdGUpO1xuICBsZXQgc291cmNlID0gY3JlYXRlKG91dHB1dCk7XG5cbiAgaWYgKHNvdXJjZSAmJiBvcHRzLnN0cmljdFNsYXNoZXMgIT09IHRydWUpIHtcbiAgICBzb3VyY2UgKz0gYCR7U0xBU0hfTElURVJBTH0/YDtcbiAgfVxuXG4gIHJldHVybiBzb3VyY2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzY2FuID0gcmVxdWlyZSgnLi9zY2FuJyk7XG5jb25zdCBwYXJzZSA9IHJlcXVpcmUoJy4vcGFyc2UnKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IGlzT2JqZWN0ID0gdmFsID0+IHZhbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRjaGVyIGZ1bmN0aW9uIGZyb20gb25lIG9yIG1vcmUgZ2xvYiBwYXR0ZXJucy4gVGhlXG4gKiByZXR1cm5lZCBmdW5jdGlvbiB0YWtlcyBhIHN0cmluZyB0byBtYXRjaCBhcyBpdHMgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJpbmcgaXMgYSBtYXRjaC4gVGhlIHJldHVybmVkIG1hdGNoZXJcbiAqIGZ1bmN0aW9uIGFsc28gdGFrZXMgYSBib29sZWFuIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdGhhdCwgd2hlbiB0cnVlLFxuICogcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaChnbG9iWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IGlzTWF0Y2ggPSBwaWNvbWF0Y2goJyouISgqYSknKTtcbiAqIGNvbnNvbGUubG9nKGlzTWF0Y2goJ2EuYScpKTsgLy89PiBmYWxzZVxuICogY29uc29sZS5sb2coaXNNYXRjaCgnYS5iJykpOyAvLz0+IHRydWVcbiAqIGBgYFxuICogQG5hbWUgcGljb21hdGNoXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gYGdsb2JzYCBPbmUgb3IgbW9yZSBnbG9iIHBhdHRlcm5zLlxuICogQHBhcmFtIHtPYmplY3Q9fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge0Z1bmN0aW9uPX0gUmV0dXJucyBhIG1hdGNoZXIgZnVuY3Rpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmNvbnN0IHBpY29tYXRjaCA9IChnbG9iLCBvcHRpb25zLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KGdsb2IpKSB7XG4gICAgY29uc3QgZm5zID0gZ2xvYi5tYXAoaW5wdXQgPT4gcGljb21hdGNoKGlucHV0LCBvcHRpb25zLCByZXR1cm5TdGF0ZSkpO1xuICAgIGNvbnN0IGFycmF5TWF0Y2hlciA9IHN0ciA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGlzTWF0Y2ggb2YgZm5zKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gaXNNYXRjaChzdHIpO1xuICAgICAgICBpZiAoc3RhdGUpIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheU1hdGNoZXI7XG4gIH1cblxuICBjb25zdCBpc1N0YXRlID0gaXNPYmplY3QoZ2xvYikgJiYgZ2xvYi50b2tlbnMgJiYgZ2xvYi5pbnB1dDtcblxuICBpZiAoZ2xvYiA9PT0gJycgfHwgKHR5cGVvZiBnbG9iICE9PSAnc3RyaW5nJyAmJiAhaXNTdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBwYXR0ZXJuIHRvIGJlIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHBvc2l4ID0gb3B0cy53aW5kb3dzO1xuICBjb25zdCByZWdleCA9IGlzU3RhdGVcbiAgICA/IHBpY29tYXRjaC5jb21waWxlUmUoZ2xvYiwgb3B0aW9ucylcbiAgICA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucywgZmFsc2UsIHRydWUpO1xuXG4gIGNvbnN0IHN0YXRlID0gcmVnZXguc3RhdGU7XG4gIGRlbGV0ZSByZWdleC5zdGF0ZTtcblxuICBsZXQgaXNJZ25vcmVkID0gKCkgPT4gZmFsc2U7XG4gIGlmIChvcHRzLmlnbm9yZSkge1xuICAgIGNvbnN0IGlnbm9yZU9wdHMgPSB7IC4uLm9wdGlvbnMsIGlnbm9yZTogbnVsbCwgb25NYXRjaDogbnVsbCwgb25SZXN1bHQ6IG51bGwgfTtcbiAgICBpc0lnbm9yZWQgPSBwaWNvbWF0Y2gob3B0cy5pZ25vcmUsIGlnbm9yZU9wdHMsIHJldHVyblN0YXRlKTtcbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXIgPSAoaW5wdXQsIHJldHVybk9iamVjdCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3QgeyBpc01hdGNoLCBtYXRjaCwgb3V0cHV0IH0gPSBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXgsIG9wdGlvbnMsIHsgZ2xvYiwgcG9zaXggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0geyBnbG9iLCBzdGF0ZSwgcmVnZXgsIHBvc2l4LCBpbnB1dCwgb3V0cHV0LCBtYXRjaCwgaXNNYXRjaCB9O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRzLm9uUmVzdWx0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRzLm9uUmVzdWx0KHJlc3VsdCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTWF0Y2ggPT09IGZhbHNlKSB7XG4gICAgICByZXN1bHQuaXNNYXRjaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHJldHVybk9iamVjdCA/IHJlc3VsdCA6IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0lnbm9yZWQoaW5wdXQpKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMub25JZ25vcmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cy5vbklnbm9yZShyZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmlzTWF0Y2ggPSBmYWxzZTtcbiAgICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdHMub25NYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0cy5vbk1hdGNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5PYmplY3QgPyByZXN1bHQgOiB0cnVlO1xuICB9O1xuXG4gIGlmIChyZXR1cm5TdGF0ZSkge1xuICAgIG1hdGNoZXIuc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVyO1xufTtcblxuLyoqXG4gKiBUZXN0IGBpbnB1dGAgd2l0aCB0aGUgZ2l2ZW4gYHJlZ2V4YC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBtYWluXG4gKiBgcGljb21hdGNoKClgIGZ1bmN0aW9uIHRvIHRlc3QgdGhlIGlucHV0IHN0cmluZy5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2gudGVzdChpbnB1dCwgcmVnZXhbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLnRlc3QoJ2Zvby9iYXInLCAvXig/OihbXi9dKj8pXFwvKFteL10qPykpJC8pKTtcbiAqIC8vIHsgaXNNYXRjaDogdHJ1ZSwgbWF0Y2g6IFsgJ2Zvby8nLCAnZm9vJywgJ2JhcicgXSwgb3V0cHV0OiAnZm9vL2JhcicgfVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfSBgcmVnZXhgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggbWF0Y2hpbmcgaW5mby5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucGljb21hdGNoLnRlc3QgPSAoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCB7IGdsb2IsIHBvc2l4IH0gPSB7fSkgPT4ge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGlucHV0IHRvIGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoaW5wdXQgPT09ICcnKSB7XG4gICAgcmV0dXJuIHsgaXNNYXRjaDogZmFsc2UsIG91dHB1dDogJycgfTtcbiAgfVxuXG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBmb3JtYXQgPSBvcHRzLmZvcm1hdCB8fCAocG9zaXggPyB1dGlscy50b1Bvc2l4U2xhc2hlcyA6IG51bGwpO1xuICBsZXQgbWF0Y2ggPSBpbnB1dCA9PT0gZ2xvYjtcbiAgbGV0IG91dHB1dCA9IChtYXRjaCAmJiBmb3JtYXQpID8gZm9ybWF0KGlucHV0KSA6IGlucHV0O1xuXG4gIGlmIChtYXRjaCA9PT0gZmFsc2UpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXQgPyBmb3JtYXQoaW5wdXQpIDogaW5wdXQ7XG4gICAgbWF0Y2ggPSBvdXRwdXQgPT09IGdsb2I7XG4gIH1cblxuICBpZiAobWF0Y2ggPT09IGZhbHNlIHx8IG9wdHMuY2FwdHVyZSA9PT0gdHJ1ZSkge1xuICAgIGlmIChvcHRzLm1hdGNoQmFzZSA9PT0gdHJ1ZSB8fCBvcHRzLmJhc2VuYW1lID09PSB0cnVlKSB7XG4gICAgICBtYXRjaCA9IHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIHJlZ2V4LCBvcHRpb25zLCBwb3NpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hdGNoID0gcmVnZXguZXhlYyhvdXRwdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGlzTWF0Y2g6IEJvb2xlYW4obWF0Y2gpLCBtYXRjaCwgb3V0cHV0IH07XG59O1xuXG4vKipcbiAqIE1hdGNoIHRoZSBiYXNlbmFtZSBvZiBhIGZpbGVwYXRoLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5tYXRjaEJhc2UoaW5wdXQsIGdsb2JbLCBvcHRpb25zXSk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gubWF0Y2hCYXNlKCdmb28vYmFyLmpzJywgJyouanMnKTsgLy8gdHJ1ZVxuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYGlucHV0YCBTdHJpbmcgdG8gdGVzdC5cbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gYGdsb2JgIEdsb2IgcGF0dGVybiBvciByZWdleCBjcmVhdGVkIGJ5IFsubWFrZVJlXSgjbWFrZVJlKS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5tYXRjaEJhc2UgPSAoaW5wdXQsIGdsb2IsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVnZXggPSBnbG9iIGluc3RhbmNlb2YgUmVnRXhwID8gZ2xvYiA6IHBpY29tYXRjaC5tYWtlUmUoZ2xvYiwgb3B0aW9ucyk7XG4gIHJldHVybiByZWdleC50ZXN0KHV0aWxzLmJhc2VuYW1lKGlucHV0KSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiAqKmFueSoqIG9mIHRoZSBnaXZlbiBnbG9iIGBwYXR0ZXJuc2AgbWF0Y2ggdGhlIHNwZWNpZmllZCBgc3RyaW5nYC5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcGljb21hdGNoID0gcmVxdWlyZSgncGljb21hdGNoJyk7XG4gKiAvLyBwaWNvbWF0Y2guaXNNYXRjaChzdHJpbmcsIHBhdHRlcm5zWywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCBbJ2IuKicsICcqLmEnXSkpOyAvLz0+IHRydWVcbiAqIGNvbnNvbGUubG9nKHBpY29tYXRjaC5pc01hdGNoKCdhLmEnLCAnYi4qJykpOyAvLz0+IGZhbHNlXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBzdHIgVGhlIHN0cmluZyB0byB0ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBhdHRlcm5zIE9uZSBvciBtb3JlIGdsb2IgcGF0dGVybnMgdG8gdXNlIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gU2VlIGF2YWlsYWJsZSBbb3B0aW9uc10oI29wdGlvbnMpLlxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwYXR0ZXJucyBtYXRjaCBgc3RyYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2guaXNNYXRjaCA9IChzdHIsIHBhdHRlcm5zLCBvcHRpb25zKSA9PiBwaWNvbWF0Y2gocGF0dGVybnMsIG9wdGlvbnMpKHN0cik7XG5cbi8qKlxuICogUGFyc2UgYSBnbG9iIHBhdHRlcm4gdG8gY3JlYXRlIHRoZSBzb3VyY2Ugc3RyaW5nIGZvciBhIHJlZ3VsYXJcbiAqIGV4cHJlc3Npb24uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3QgcmVzdWx0ID0gcGljb21hdGNoLnBhcnNlKHBhdHRlcm5bLCBvcHRpb25zXSk7XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgcGF0dGVybmBcbiAqIEBwYXJhbSB7T2JqZWN0fSBgb3B0aW9uc2BcbiAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB1c2VmdWwgcHJvcGVydGllcyBhbmQgb3V0cHV0IHRvIGJlIHVzZWQgYXMgYSByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gucGFyc2UgPSAocGF0dGVybiwgb3B0aW9ucykgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXR0ZXJuKSkgcmV0dXJuIHBhdHRlcm4ubWFwKHAgPT4gcGljb21hdGNoLnBhcnNlKHAsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHBhcnNlKHBhdHRlcm4sIHsgLi4ub3B0aW9ucywgZmFzdHBhdGhzOiBmYWxzZSB9KTtcbn07XG5cbi8qKlxuICogU2NhbiBhIGdsb2IgcGF0dGVybiB0byBzZXBhcmF0ZSB0aGUgcGF0dGVybiBpbnRvIHNlZ21lbnRzLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC5zY2FuKGlucHV0Wywgb3B0aW9uc10pO1xuICpcbiAqIGNvbnN0IHJlc3VsdCA9IHBpY29tYXRjaC5zY2FuKCchLi9mb28vKi5qcycpO1xuICogY29uc29sZS5sb2cocmVzdWx0KTtcbiAqIHsgcHJlZml4OiAnIS4vJyxcbiAqICAgaW5wdXQ6ICchLi9mb28vKi5qcycsXG4gKiAgIHN0YXJ0OiAzLFxuICogICBiYXNlOiAnZm9vJyxcbiAqICAgZ2xvYjogJyouanMnLFxuICogICBpc0JyYWNlOiBmYWxzZSxcbiAqICAgaXNCcmFja2V0OiBmYWxzZSxcbiAqICAgaXNHbG9iOiB0cnVlLFxuICogICBpc0V4dGdsb2I6IGZhbHNlLFxuICogICBpc0dsb2JzdGFyOiBmYWxzZSxcbiAqICAgbmVnYXRlZDogdHJ1ZSB9XG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgaW5wdXRgIEdsb2IgcGF0dGVybiB0byBzY2FuLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5zY2FuID0gKGlucHV0LCBvcHRpb25zKSA9PiBzY2FuKGlucHV0LCBvcHRpb25zKTtcblxuLyoqXG4gKiBDb21waWxlIGEgcmVndWxhciBleHByZXNzaW9uIGZyb20gdGhlIGBzdGF0ZWAgb2JqZWN0IHJldHVybmVkIGJ5IHRoZVxuICogW3BhcnNlKCldKCNwYXJzZSkgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBgc3RhdGVgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGByZXR1cm5PdXRwdXRgIEludGVuZGVkIGZvciBpbXBsZW1lbnRvcnMsIHRoaXMgYXJndW1lbnQgYWxsb3dzIHlvdSB0byByZXR1cm4gdGhlIHJhdyBvdXRwdXQgZnJvbSB0aGUgcGFyc2VyLlxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuU3RhdGVgIEFkZHMgdGhlIHN0YXRlIHRvIGEgYHN0YXRlYCBwcm9wZXJ0eSBvbiB0aGUgcmV0dXJuZWQgcmVnZXguIFVzZWZ1bCBmb3IgaW1wbGVtZW50b3JzIGFuZCBkZWJ1Z2dpbmcuXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC5jb21waWxlUmUgPSAoc3RhdGUsIG9wdGlvbnMsIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChyZXR1cm5PdXRwdXQgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3RhdGUub3V0cHV0O1xuICB9XG5cbiAgY29uc3Qgb3B0cyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRzLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdHMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgc291cmNlID0gYCR7cHJlcGVuZH0oPzoke3N0YXRlLm91dHB1dH0pJHthcHBlbmR9YDtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLm5lZ2F0ZWQgPT09IHRydWUpIHtcbiAgICBzb3VyY2UgPSBgXig/ISR7c291cmNlfSkuKiRgO1xuICB9XG5cbiAgY29uc3QgcmVnZXggPSBwaWNvbWF0Y2gudG9SZWdleChzb3VyY2UsIG9wdGlvbnMpO1xuICBpZiAocmV0dXJuU3RhdGUgPT09IHRydWUpIHtcbiAgICByZWdleC5zdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAgcmV0dXJuIHJlZ2V4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSBhIHBhcnNlZCBnbG9iIHBhdHRlcm4uXG4gKlxuICogYGBganNcbiAqIGNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpO1xuICogY29uc3Qgc3RhdGUgPSBwaWNvbWF0Y2gucGFyc2UoJyouanMnKTtcbiAqIC8vIHBpY29tYXRjaC5jb21waWxlUmUoc3RhdGVbLCBvcHRpb25zXSk7XG4gKlxuICogY29uc29sZS5sb2cocGljb21hdGNoLmNvbXBpbGVSZShzdGF0ZSkpO1xuICogLy89PiAvXig/Oig/IVxcLikoPz0uKVteL10qP1xcLmpzKSQvXG4gKiBgYGBcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RhdGVgIFRoZSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGUgYC5wYXJzZWAgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IGBvcHRpb25zYFxuICogQHBhcmFtIHtCb29sZWFufSBgcmV0dXJuT3V0cHV0YCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgY29tcGlsZWQgb3V0cHV0LCBpbnN0ZWFkIG9mIGEgcmVndWxhciBleHByZXNzaW9uLiBUaGlzIGlzIG5vdCBleHBvc2VkIG9uIHRoZSBvcHRpb25zIHRvIHByZXZlbnQgZW5kLXVzZXJzIGZyb20gbXV0YXRpbmcgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYHJldHVyblN0YXRlYCBJbXBsZW1lbnRvcnMgbWF5IHVzZSB0aGlzIGFyZ3VtZW50IHRvIHJldHVybiB0aGUgc3RhdGUgZnJvbSB0aGUgcGFyc2VkIGdsb2Igd2l0aCB0aGUgcmV0dXJuZWQgcmVndWxhciBleHByZXNzaW9uLlxuICogQHJldHVybiB7UmVnRXhwfSBSZXR1cm5zIGEgcmVnZXggY3JlYXRlZCBmcm9tIHRoZSBnaXZlbiBwYXR0ZXJuLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5waWNvbWF0Y2gubWFrZVJlID0gKGlucHV0LCBvcHRpb25zID0ge30sIHJldHVybk91dHB1dCA9IGZhbHNlLCByZXR1cm5TdGF0ZSA9IGZhbHNlKSA9PiB7XG4gIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZycpO1xuICB9XG5cbiAgbGV0IHBhcnNlZCA9IHsgbmVnYXRlZDogZmFsc2UsIGZhc3RwYXRoczogdHJ1ZSB9O1xuXG4gIGlmIChvcHRpb25zLmZhc3RwYXRocyAhPT0gZmFsc2UgJiYgKGlucHV0WzBdID09PSAnLicgfHwgaW5wdXRbMF0gPT09ICcqJykpIHtcbiAgICBwYXJzZWQub3V0cHV0ID0gcGFyc2UuZmFzdHBhdGhzKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghcGFyc2VkLm91dHB1dCkge1xuICAgIHBhcnNlZCA9IHBhcnNlKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBwaWNvbWF0Y2guY29tcGlsZVJlKHBhcnNlZCwgb3B0aW9ucywgcmV0dXJuT3V0cHV0LCByZXR1cm5TdGF0ZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmcm9tIHRoZSBnaXZlbiByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBwaWNvbWF0Y2ggPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIC8vIHBpY29tYXRjaC50b1JlZ2V4KHNvdXJjZVssIG9wdGlvbnNdKTtcbiAqXG4gKiBjb25zdCB7IG91dHB1dCB9ID0gcGljb21hdGNoLnBhcnNlKCcqLmpzJyk7XG4gKiBjb25zb2xlLmxvZyhwaWNvbWF0Y2gudG9SZWdleChvdXRwdXQpKTtcbiAqIC8vPT4gL14oPzooPyFcXC4pKD89LilbXi9dKj9cXC5qcykkL1xuICogYGBgXG4gKiBAcGFyYW0ge1N0cmluZ30gYHNvdXJjZWAgUmVndWxhciBleHByZXNzaW9uIHNvdXJjZSBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtSZWdFeHB9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnBpY29tYXRjaC50b1JlZ2V4ID0gKHNvdXJjZSwgb3B0aW9ucykgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgb3B0cy5mbGFncyB8fCAob3B0cy5ub2Nhc2UgPyAnaScgOiAnJykpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnID09PSB0cnVlKSB0aHJvdyBlcnI7XG4gICAgcmV0dXJuIC8kXi87XG4gIH1cbn07XG5cbi8qKlxuICogUGljb21hdGNoIGNvbnN0YW50cy5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5waWNvbWF0Y2guY29uc3RhbnRzID0gY29uc3RhbnRzO1xuXG4vKipcbiAqIEV4cG9zZSBcInBpY29tYXRjaFwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwaWNvbWF0Y2g7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuY29uc3Qge1xuICBDSEFSX0FTVEVSSVNLLCAgICAgICAgICAgICAvKiAqICovXG4gIENIQVJfQVQsICAgICAgICAgICAgICAgICAgIC8qIEAgKi9cbiAgQ0hBUl9CQUNLV0FSRF9TTEFTSCwgICAgICAgLyogXFwgKi9cbiAgQ0hBUl9DT01NQSwgICAgICAgICAgICAgICAgLyogLCAqL1xuICBDSEFSX0RPVCwgICAgICAgICAgICAgICAgICAvKiAuICovXG4gIENIQVJfRVhDTEFNQVRJT05fTUFSSywgICAgIC8qICEgKi9cbiAgQ0hBUl9GT1JXQVJEX1NMQVNILCAgICAgICAgLyogLyAqL1xuICBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UsICAgICAvKiB7ICovXG4gIENIQVJfTEVGVF9QQVJFTlRIRVNFUywgICAgIC8qICggKi9cbiAgQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VULCAgLyogWyAqL1xuICBDSEFSX1BMVVMsICAgICAgICAgICAgICAgICAvKiArICovXG4gIENIQVJfUVVFU1RJT05fTUFSSywgICAgICAgIC8qID8gKi9cbiAgQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSwgICAgLyogfSAqL1xuICBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTLCAgICAvKiApICovXG4gIENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQgIC8qIF0gKi9cbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBpc1BhdGhTZXBhcmF0b3IgPSBjb2RlID0+IHtcbiAgcmV0dXJuIGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCB8fCBjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIO1xufTtcblxuY29uc3QgZGVwdGggPSB0b2tlbiA9PiB7XG4gIGlmICh0b2tlbi5pc1ByZWZpeCAhPT0gdHJ1ZSkge1xuICAgIHRva2VuLmRlcHRoID0gdG9rZW4uaXNHbG9ic3RhciA/IEluZmluaXR5IDogMTtcbiAgfVxufTtcblxuLyoqXG4gKiBRdWlja2x5IHNjYW5zIGEgZ2xvYiBwYXR0ZXJuIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgaGFuZGZ1bCBvZlxuICogdXNlZnVsIHByb3BlcnRpZXMsIGxpa2UgYGlzR2xvYmAsIGBwYXRoYCAodGhlIGxlYWRpbmcgbm9uLWdsb2IsIGlmIGl0IGV4aXN0cyksXG4gKiBgZ2xvYmAgKHRoZSBhY3R1YWwgcGF0dGVybiksIGBuZWdhdGVkYCAodHJ1ZSBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBgIWAgYnV0IG5vdFxuICogd2l0aCBgIShgKSBhbmQgYG5lZ2F0ZWRFeHRnbG9iYCAodHJ1ZSBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBgIShgKS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgcG0gPSByZXF1aXJlKCdwaWNvbWF0Y2gnKTtcbiAqIGNvbnNvbGUubG9nKHBtLnNjYW4oJ2Zvby9iYXIvKi5qcycpKTtcbiAqIHsgaXNHbG9iOiB0cnVlLCBpbnB1dDogJ2Zvby9iYXIvKi5qcycsIGJhc2U6ICdmb28vYmFyJywgZ2xvYjogJyouanMnIH1cbiAqIGBgYFxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJgXG4gKiBAcGFyYW0ge09iamVjdH0gYG9wdGlvbnNgXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggdG9rZW5zIGFuZCByZWdleCBzb3VyY2Ugc3RyaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5jb25zdCBzY2FuID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IG9wdHMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aCAtIDE7XG4gIGNvbnN0IHNjYW5Ub0VuZCA9IG9wdHMucGFydHMgPT09IHRydWUgfHwgb3B0cy5zY2FuVG9FbmQgPT09IHRydWU7XG4gIGNvbnN0IHNsYXNoZXMgPSBbXTtcbiAgY29uc3QgdG9rZW5zID0gW107XG4gIGNvbnN0IHBhcnRzID0gW107XG5cbiAgbGV0IHN0ciA9IGlucHV0O1xuICBsZXQgaW5kZXggPSAtMTtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGxhc3RJbmRleCA9IDA7XG4gIGxldCBpc0JyYWNlID0gZmFsc2U7XG4gIGxldCBpc0JyYWNrZXQgPSBmYWxzZTtcbiAgbGV0IGlzR2xvYiA9IGZhbHNlO1xuICBsZXQgaXNFeHRnbG9iID0gZmFsc2U7XG4gIGxldCBpc0dsb2JzdGFyID0gZmFsc2U7XG4gIGxldCBicmFjZUVzY2FwZWQgPSBmYWxzZTtcbiAgbGV0IGJhY2tzbGFzaGVzID0gZmFsc2U7XG4gIGxldCBuZWdhdGVkID0gZmFsc2U7XG4gIGxldCBuZWdhdGVkRXh0Z2xvYiA9IGZhbHNlO1xuICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgbGV0IGJyYWNlcyA9IDA7XG4gIGxldCBwcmV2O1xuICBsZXQgY29kZTtcbiAgbGV0IHRva2VuID0geyB2YWx1ZTogJycsIGRlcHRoOiAwLCBpc0dsb2I6IGZhbHNlIH07XG5cbiAgY29uc3QgZW9zID0gKCkgPT4gaW5kZXggPj0gbGVuZ3RoO1xuICBjb25zdCBwZWVrID0gKCkgPT4gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgY29uc3QgYWR2YW5jZSA9ICgpID0+IHtcbiAgICBwcmV2ID0gY29kZTtcbiAgICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH07XG5cbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY29kZSA9IGFkdmFuY2UoKTtcbiAgICBsZXQgbmV4dDtcblxuICAgIGlmIChjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgIGNvZGUgPSBhZHZhbmNlKCk7XG5cbiAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgICAgYnJhY2VFc2NhcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChicmFjZUVzY2FwZWQgPT09IHRydWUgfHwgY29kZSA9PT0gQ0hBUl9MRUZUX0NVUkxZX0JSQUNFKSB7XG4gICAgICBicmFjZXMrKztcblxuICAgICAgd2hpbGUgKGVvcygpICE9PSB0cnVlICYmIChjb2RlID0gYWR2YW5jZSgpKSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgIGJhY2tzbGFzaGVzID0gdG9rZW4uYmFja3NsYXNoZXMgPSB0cnVlO1xuICAgICAgICAgIGFkdmFuY2UoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb2RlID09PSBDSEFSX0xFRlRfQ1VSTFlfQlJBQ0UpIHtcbiAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChicmFjZUVzY2FwZWQgIT09IHRydWUgJiYgY29kZSA9PT0gQ0hBUl9ET1QgJiYgKGNvZGUgPSBhZHZhbmNlKCkpID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgIGlzQnJhY2UgPSB0b2tlbi5pc0JyYWNlID0gdHJ1ZTtcbiAgICAgICAgICBpc0dsb2IgPSB0b2tlbi5pc0dsb2IgPSB0cnVlO1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJyYWNlRXNjYXBlZCAhPT0gdHJ1ZSAmJiBjb2RlID09PSBDSEFSX0NPTU1BKSB7XG4gICAgICAgICAgaXNCcmFjZSA9IHRva2VuLmlzQnJhY2UgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSkge1xuICAgICAgICAgIGJyYWNlcy0tO1xuXG4gICAgICAgICAgaWYgKGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgYnJhY2VFc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpc0JyYWNlID0gdG9rZW4uaXNCcmFjZSA9IHRydWU7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgc2xhc2hlcy5wdXNoKGluZGV4KTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIHRva2VuID0geyB2YWx1ZTogJycsIGRlcHRoOiAwLCBpc0dsb2I6IGZhbHNlIH07XG5cbiAgICAgIGlmIChmaW5pc2hlZCA9PT0gdHJ1ZSkgY29udGludWU7XG4gICAgICBpZiAocHJldiA9PT0gQ0hBUl9ET1QgJiYgaW5kZXggPT09IChzdGFydCArIDEpKSB7XG4gICAgICAgIHN0YXJ0ICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub2V4dCAhPT0gdHJ1ZSkge1xuICAgICAgY29uc3QgaXNFeHRnbG9iQ2hhciA9IGNvZGUgPT09IENIQVJfUExVU1xuICAgICAgICB8fCBjb2RlID09PSBDSEFSX0FUXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfQVNURVJJU0tcbiAgICAgICAgfHwgY29kZSA9PT0gQ0hBUl9RVUVTVElPTl9NQVJLXG4gICAgICAgIHx8IGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSztcblxuICAgICAgaWYgKGlzRXh0Z2xvYkNoYXIgPT09IHRydWUgJiYgcGVlaygpID09PSBDSEFSX0xFRlRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgICAgaXNFeHRnbG9iID0gdG9rZW4uaXNFeHRnbG9iID0gdHJ1ZTtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9FWENMQU1BVElPTl9NQVJLICYmIGluZGV4ID09PSBzdGFydCkge1xuICAgICAgICAgIG5lZ2F0ZWRFeHRnbG9iID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICBiYWNrc2xhc2hlcyA9IHRva2VuLmJhY2tzbGFzaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29kZSA9IGFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX1JJR0hUX1BBUkVOVEhFU0VTKSB7XG4gICAgICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX0FTVEVSSVNLKSB7XG4gICAgICBpZiAocHJldiA9PT0gQ0hBUl9BU1RFUklTSykgaXNHbG9ic3RhciA9IHRva2VuLmlzR2xvYnN0YXIgPSB0cnVlO1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChjb2RlID09PSBDSEFSX1FVRVNUSU9OX01BUkspIHtcbiAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUKSB7XG4gICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKG5leHQgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgIGlmIChuZXh0ID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHQgPT09IENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQpIHtcbiAgICAgICAgICBpc0JyYWNrZXQgPSB0b2tlbi5pc0JyYWNrZXQgPSB0cnVlO1xuICAgICAgICAgIGlzR2xvYiA9IHRva2VuLmlzR2xvYiA9IHRydWU7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzY2FuVG9FbmQgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm5vbmVnYXRlICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfRVhDTEFNQVRJT05fTUFSSyAmJiBpbmRleCA9PT0gc3RhcnQpIHtcbiAgICAgIG5lZ2F0ZWQgPSB0b2tlbi5uZWdhdGVkID0gdHJ1ZTtcbiAgICAgIHN0YXJ0Kys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5ub3BhcmVuICE9PSB0cnVlICYmIGNvZGUgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgaXNHbG9iID0gdG9rZW4uaXNHbG9iID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICB3aGlsZSAoZW9zKCkgIT09IHRydWUgJiYgKGNvZGUgPSBhZHZhbmNlKCkpKSB7XG4gICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfTEVGVF9QQVJFTlRIRVNFUykge1xuICAgICAgICAgICAgYmFja3NsYXNoZXMgPSB0b2tlbi5iYWNrc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgICBjb2RlID0gYWR2YW5jZSgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvZGUgPT09IENIQVJfUklHSFRfUEFSRU5USEVTRVMpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc0dsb2IgPT09IHRydWUpIHtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKHNjYW5Ub0VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMubm9leHQgPT09IHRydWUpIHtcbiAgICBpc0V4dGdsb2IgPSBmYWxzZTtcbiAgICBpc0dsb2IgPSBmYWxzZTtcbiAgfVxuXG4gIGxldCBiYXNlID0gc3RyO1xuICBsZXQgcHJlZml4ID0gJyc7XG4gIGxldCBnbG9iID0gJyc7XG5cbiAgaWYgKHN0YXJ0ID4gMCkge1xuICAgIHByZWZpeCA9IHN0ci5zbGljZSgwLCBzdGFydCk7XG4gICAgc3RyID0gc3RyLnNsaWNlKHN0YXJ0KTtcbiAgICBsYXN0SW5kZXggLT0gc3RhcnQ7XG4gIH1cblxuICBpZiAoYmFzZSAmJiBpc0dsb2IgPT09IHRydWUgJiYgbGFzdEluZGV4ID4gMCkge1xuICAgIGJhc2UgPSBzdHIuc2xpY2UoMCwgbGFzdEluZGV4KTtcbiAgICBnbG9iID0gc3RyLnNsaWNlKGxhc3RJbmRleCk7XG4gIH0gZWxzZSBpZiAoaXNHbG9iID09PSB0cnVlKSB7XG4gICAgYmFzZSA9ICcnO1xuICAgIGdsb2IgPSBzdHI7XG4gIH0gZWxzZSB7XG4gICAgYmFzZSA9IHN0cjtcbiAgfVxuXG4gIGlmIChiYXNlICYmIGJhc2UgIT09ICcnICYmIGJhc2UgIT09ICcvJyAmJiBiYXNlICE9PSBzdHIpIHtcbiAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGJhc2UuY2hhckNvZGVBdChiYXNlLmxlbmd0aCAtIDEpKSkge1xuICAgICAgYmFzZSA9IGJhc2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLnVuZXNjYXBlID09PSB0cnVlKSB7XG4gICAgaWYgKGdsb2IpIGdsb2IgPSB1dGlscy5yZW1vdmVCYWNrc2xhc2hlcyhnbG9iKTtcblxuICAgIGlmIChiYXNlICYmIGJhY2tzbGFzaGVzID09PSB0cnVlKSB7XG4gICAgICBiYXNlID0gdXRpbHMucmVtb3ZlQmFja3NsYXNoZXMoYmFzZSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgcHJlZml4LFxuICAgIGlucHV0LFxuICAgIHN0YXJ0LFxuICAgIGJhc2UsXG4gICAgZ2xvYixcbiAgICBpc0JyYWNlLFxuICAgIGlzQnJhY2tldCxcbiAgICBpc0dsb2IsXG4gICAgaXNFeHRnbG9iLFxuICAgIGlzR2xvYnN0YXIsXG4gICAgbmVnYXRlZCxcbiAgICBuZWdhdGVkRXh0Z2xvYlxuICB9O1xuXG4gIGlmIChvcHRzLnRva2VucyA9PT0gdHJ1ZSkge1xuICAgIHN0YXRlLm1heERlcHRoID0gMDtcbiAgICBpZiAoIWlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgICBzdGF0ZS50b2tlbnMgPSB0b2tlbnM7XG4gIH1cblxuICBpZiAob3B0cy5wYXJ0cyA9PT0gdHJ1ZSB8fCBvcHRzLnRva2VucyA9PT0gdHJ1ZSkge1xuICAgIGxldCBwcmV2SW5kZXg7XG5cbiAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzbGFzaGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgIGNvbnN0IG4gPSBwcmV2SW5kZXggPyBwcmV2SW5kZXggKyAxIDogc3RhcnQ7XG4gICAgICBjb25zdCBpID0gc2xhc2hlc1tpZHhdO1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnB1dC5zbGljZShuLCBpKTtcbiAgICAgIGlmIChvcHRzLnRva2Vucykge1xuICAgICAgICBpZiAoaWR4ID09PSAwICYmIHN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgdG9rZW5zW2lkeF0uaXNQcmVmaXggPSB0cnVlO1xuICAgICAgICAgIHRva2Vuc1tpZHhdLnZhbHVlID0gcHJlZml4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vuc1tpZHhdLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGgodG9rZW5zW2lkeF0pO1xuICAgICAgICBzdGF0ZS5tYXhEZXB0aCArPSB0b2tlbnNbaWR4XS5kZXB0aDtcbiAgICAgIH1cbiAgICAgIGlmIChpZHggIT09IDAgfHwgdmFsdWUgIT09ICcnKSB7XG4gICAgICAgIHBhcnRzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgcHJldkluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBpZiAocHJldkluZGV4ICYmIHByZXZJbmRleCArIDEgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5wdXQuc2xpY2UocHJldkluZGV4ICsgMSk7XG4gICAgICBwYXJ0cy5wdXNoKHZhbHVlKTtcblxuICAgICAgaWYgKG9wdHMudG9rZW5zKSB7XG4gICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZGVwdGgodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHN0YXRlLm1heERlcHRoICs9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0uZGVwdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuc2xhc2hlcyA9IHNsYXNoZXM7XG4gICAgc3RhdGUucGFydHMgPSBwYXJ0cztcbiAgfVxuXG4gIHJldHVybiBzdGF0ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc2NhbjtcbiIsIi8qZ2xvYmFsIG5hdmlnYXRvciovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHtcbiAgUkVHRVhfQkFDS1NMQVNILFxuICBSRUdFWF9SRU1PVkVfQkFDS1NMQVNILFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTLFxuICBSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTFxufSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmV4cG9ydHMuaXNPYmplY3QgPSB2YWwgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG5leHBvcnRzLmhhc1JlZ2V4Q2hhcnMgPSBzdHIgPT4gUkVHRVhfU1BFQ0lBTF9DSEFSUy50ZXN0KHN0cik7XG5leHBvcnRzLmlzUmVnZXhDaGFyID0gc3RyID0+IHN0ci5sZW5ndGggPT09IDEgJiYgZXhwb3J0cy5oYXNSZWdleENoYXJzKHN0cik7XG5leHBvcnRzLmVzY2FwZVJlZ2V4ID0gc3RyID0+IHN0ci5yZXBsYWNlKFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMLCAnXFxcXCQxJyk7XG5leHBvcnRzLnRvUG9zaXhTbGFzaGVzID0gc3RyID0+IHN0ci5yZXBsYWNlKFJFR0VYX0JBQ0tTTEFTSCwgJy8nKTtcblxuZXhwb3J0cy5pc1dpbmRvd3MgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucGxhdGZvcm0pIHtcbiAgICBjb25zdCBwbGF0Zm9ybSA9IG5hdmlnYXRvci5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBwbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fCBwbGF0Zm9ybSA9PT0gJ3dpbmRvd3MnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnBsYXRmb3JtKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMic7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5leHBvcnRzLnJlbW92ZUJhY2tzbGFzaGVzID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR0VYX1JFTU9WRV9CQUNLU0xBU0gsIG1hdGNoID0+IHtcbiAgICByZXR1cm4gbWF0Y2ggPT09ICdcXFxcJyA/ICcnIDogbWF0Y2g7XG4gIH0pO1xufTtcblxuZXhwb3J0cy5lc2NhcGVMYXN0ID0gKGlucHV0LCBjaGFyLCBsYXN0SWR4KSA9PiB7XG4gIGNvbnN0IGlkeCA9IGlucHV0Lmxhc3RJbmRleE9mKGNoYXIsIGxhc3RJZHgpO1xuICBpZiAoaWR4ID09PSAtMSkgcmV0dXJuIGlucHV0O1xuICBpZiAoaW5wdXRbaWR4IC0gMV0gPT09ICdcXFxcJykgcmV0dXJuIGV4cG9ydHMuZXNjYXBlTGFzdChpbnB1dCwgY2hhciwgaWR4IC0gMSk7XG4gIHJldHVybiBgJHtpbnB1dC5zbGljZSgwLCBpZHgpfVxcXFwke2lucHV0LnNsaWNlKGlkeCl9YDtcbn07XG5cbmV4cG9ydHMucmVtb3ZlUHJlZml4ID0gKGlucHV0LCBzdGF0ZSA9IHt9KSA9PiB7XG4gIGxldCBvdXRwdXQgPSBpbnB1dDtcbiAgaWYgKG91dHB1dC5zdGFydHNXaXRoKCcuLycpKSB7XG4gICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDIpO1xuICAgIHN0YXRlLnByZWZpeCA9ICcuLyc7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmV4cG9ydHMud3JhcE91dHB1dCA9IChpbnB1dCwgc3RhdGUgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHByZXBlbmQgPSBvcHRpb25zLmNvbnRhaW5zID8gJycgOiAnXic7XG4gIGNvbnN0IGFwcGVuZCA9IG9wdGlvbnMuY29udGFpbnMgPyAnJyA6ICckJztcblxuICBsZXQgb3V0cHV0ID0gYCR7cHJlcGVuZH0oPzoke2lucHV0fSkke2FwcGVuZH1gO1xuICBpZiAoc3RhdGUubmVnYXRlZCA9PT0gdHJ1ZSkge1xuICAgIG91dHB1dCA9IGAoPzpeKD8hJHtvdXRwdXR9KS4qJClgO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5leHBvcnRzLmJhc2VuYW1lID0gKHBhdGgsIHsgd2luZG93cyB9ID0ge30pID0+IHtcbiAgY29uc3Qgc2VncyA9IHBhdGguc3BsaXQod2luZG93cyA/IC9bXFxcXC9dLyA6ICcvJyk7XG4gIGNvbnN0IGxhc3QgPSBzZWdzW3NlZ3MubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGxhc3QgPT09ICcnKSB7XG4gICAgcmV0dXJuIHNlZ3Nbc2Vncy5sZW5ndGggLSAyXTtcbiAgfVxuXG4gIHJldHVybiBsYXN0O1xufTtcbiIsInJlcXVpcmUoJy4vbWFpbi5qcycpLmNvbmZpZygpXG4iLCJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IGNvbnZlbnRpb25zID0gcmVxdWlyZSgnLi9jb252ZW50aW9ucycpXG5jb25zdCBkb3RlbnZPcHRpb25QYXRocyA9IHJlcXVpcmUoJy4vZG90ZW52T3B0aW9uUGF0aHMnKVxuY29uc3QgRGVwcmVjYXRpb25Ob3RpY2UgPSByZXF1aXJlKCcuL2RlcHJlY2F0aW9uTm90aWNlJylcblxuZnVuY3Rpb24gYnVpbGRFbnZzIChvcHRpb25zLCBET1RFTlZfS0VZID0gdW5kZWZpbmVkKSB7XG4gIC8vIGJ1aWxkIGVudnMgdXNpbmcgdXNlciBzZXQgb3B0aW9uLnBhdGhcbiAgY29uc3Qgb3B0aW9uUGF0aHMgPSBkb3RlbnZPcHRpb25QYXRocyhvcHRpb25zKSAvLyBbICcuZW52JyBdXG5cbiAgbGV0IGVudnMgPSBbXVxuICBpZiAob3B0aW9ucy5jb252ZW50aW9uKSB7IC8vIGhhbmRsZSBzaG9ydGhhbmQgY29udmVudGlvbnNcbiAgICBlbnZzID0gY29udmVudGlvbnMob3B0aW9ucy5jb252ZW50aW9uKS5jb25jYXQoZW52cylcbiAgfVxuXG4gIG5ldyBEZXByZWNhdGlvbk5vdGljZSh7IERPVEVOVl9LRVkgfSkuZG90ZW52S2V5KCkgLy8gREVQUkVDQVRJT04gTk9USUNFXG5cbiAgZm9yIChjb25zdCBvcHRpb25QYXRoIG9mIG9wdGlvblBhdGhzKSB7XG4gICAgLy8gaWYgRE9URU5WX0tFWSBpcyBzZXQgdGhlbiBhc3N1bWUgd2UgYXJlIGNoZWNraW5nIGVudlZhdWx0RmlsZVxuICAgIGlmIChET1RFTlZfS0VZKSB7XG4gICAgICBlbnZzLnB1c2goe1xuICAgICAgICB0eXBlOiAnZW52VmF1bHRGaWxlJyxcbiAgICAgICAgdmFsdWU6IHBhdGguam9pbihwYXRoLmRpcm5hbWUob3B0aW9uUGF0aCksICcuZW52LnZhdWx0JylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudnMucHVzaCh7IHR5cGU6ICdlbnZGaWxlJywgdmFsdWU6IG9wdGlvblBhdGggfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW52c1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkRW52c1xuIiwiZnVuY3Rpb24gY2hvbXAgKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bXFxyXFxuXSskLywgJycpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hvbXBcbiIsImNvbnN0IHsgV3JpdGVTdHJlYW0gfSA9IHJlcXVpcmUoJ3R0eScpXG5cbmNvbnN0IGdldENvbG9yRGVwdGggPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFdyaXRlU3RyZWFtLnByb3RvdHlwZS5nZXRDb2xvckRlcHRoKClcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCB0ZXJtID0gcHJvY2Vzcy5lbnYuVEVSTVxuXG4gICAgaWYgKHRlcm0gJiYgKHRlcm0uaW5jbHVkZXMoJzI1NmNvbG9yJykgfHwgdGVybS5pbmNsdWRlcygneHRlcm0nKSkpIHtcbiAgICAgIHJldHVybiA4IC8vIDI1NiBjb2xvcnNcbiAgICB9XG5cbiAgICByZXR1cm4gNFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBnZXRDb2xvckRlcHRoIH1cbiIsImZ1bmN0aW9uIGNvbnZlbnRpb25zIChjb252ZW50aW9uKSB7XG4gIGNvbnN0IGVudiA9IHByb2Nlc3MuZW52LkRPVEVOVl9FTlYgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgJ2RldmVsb3BtZW50J1xuXG4gIGlmIChjb252ZW50aW9uID09PSAnbmV4dGpzJykge1xuICAgIGNvbnN0IGNhbm9uaWNhbEVudiA9IFsnZGV2ZWxvcG1lbnQnLCAndGVzdCcsICdwcm9kdWN0aW9uJ10uaW5jbHVkZXMoZW52KSAmJiBlbnZcblxuICAgIHJldHVybiBbXG4gICAgICBjYW5vbmljYWxFbnYgJiYgeyB0eXBlOiAnZW52RmlsZScsIHZhbHVlOiBgLmVudi4ke2Nhbm9uaWNhbEVudn0ubG9jYWxgIH0sXG4gICAgICBjYW5vbmljYWxFbnYgIT09ICd0ZXN0JyAmJiB7IHR5cGU6ICdlbnZGaWxlJywgdmFsdWU6ICcuZW52LmxvY2FsJyB9LFxuICAgICAgY2Fub25pY2FsRW52ICYmIHsgdHlwZTogJ2VudkZpbGUnLCB2YWx1ZTogYC5lbnYuJHtjYW5vbmljYWxFbnZ9YCB9LFxuICAgICAgeyB0eXBlOiAnZW52RmlsZScsIHZhbHVlOiAnLmVudicgfVxuICAgIF0uZmlsdGVyKEJvb2xlYW4pXG4gIH0gZWxzZSBpZiAoY29udmVudGlvbiA9PT0gJ2Zsb3cnKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgdHlwZTogJ2VudkZpbGUnLCB2YWx1ZTogYC5lbnYuJHtlbnZ9LmxvY2FsYCB9LFxuICAgICAgeyB0eXBlOiAnZW52RmlsZScsIHZhbHVlOiBgLmVudi4ke2Vudn1gIH0sXG4gICAgICB7IHR5cGU6ICdlbnZGaWxlJywgdmFsdWU6ICcuZW52LmxvY2FsJyB9LFxuICAgICAgeyB0eXBlOiAnZW52RmlsZScsIHZhbHVlOiAnLmVudicgfSxcbiAgICAgIHsgdHlwZTogJ2VudkZpbGUnLCB2YWx1ZTogJy5lbnYuZGVmYXVsdHMnIH1cbiAgICBdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJTlZBTElEX0NPTlZFTlRJT046ICcke2NvbnZlbnRpb259Jy4gcGVybWl0dGVkIGNvbnZlbnRpb25zOiBbJ25leHRqcycsICdmbG93J11gKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVudGlvbnNcbiIsImNvbnN0IGRvdGVudiA9IHJlcXVpcmUoJ2RvdGVudicpXG5cbmNvbnN0IHBhcnNlRW5jcnlwdGlvbktleUZyb21Eb3RlbnZLZXkgPSByZXF1aXJlKCcuL3BhcnNlRW5jcnlwdGlvbktleUZyb21Eb3RlbnZLZXknKVxuXG5mdW5jdGlvbiBkZWNyeXB0IChjaXBoZXJ0ZXh0LCBkb3RlbnZLZXkpIHtcbiAgY29uc3Qga2V5ID0gcGFyc2VFbmNyeXB0aW9uS2V5RnJvbURvdGVudktleShkb3RlbnZLZXkpXG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG90ZW52LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5KVxuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUuY29kZSA9PT0gJ0RFQ1JZUFRJT05fRkFJTEVEJykge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1tERUNSWVBUSU9OX0ZBSUxFRF0gVW5hYmxlIHRvIGRlY3J5cHQgLmVudi52YXVsdCB3aXRoIERPVEVOVl9LRVkuJylcbiAgICAgIGVycm9yLmNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgICBlcnJvci5oZWxwID0gJ1tERUNSWVBUSU9OX0ZBSUxFRF0gUnVuIHdpdGggZGVidWcgZmxhZyBbZG90ZW52eCBydW4gLS1kZWJ1ZyAtLSB5b3VyY29tbWFuZF0gb3IgbWFudWFsbHkgcnVuIFtlY2hvICRET1RFTlZfS0VZXSB0byBjb21wYXJlIGl0IHRvIHRoZSBvbmUgaW4gLmVudi5rZXlzLidcbiAgICAgIGVycm9yLmRlYnVnID0gYFtERUNSWVBUSU9OX0ZBSUxFRF0gRE9URU5WX0tFWSBpcyAke2RvdGVudktleX1gXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChlLmNvZGUgPT09ICdFUlJfQ1JZUFRPX0lOVkFMSURfQVVUSF9UQUcnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignW0lOVkFMSURfQ0lQSEVSVEVYVF0gVW5hYmxlIHRvIGRlY3J5cHQgd2hhdCBhcHBlYXJzIHRvIGJlIGludmFsaWQgY2lwaGVydGV4dC4nKVxuICAgICAgZXJyb3IuY29kZSA9ICdJTlZBTElEX0NJUEhFUlRFWFQnXG4gICAgICBlcnJvci5oZWxwID0gJ1tJTlZBTElEX0NJUEhFUlRFWFRdIFJ1biB3aXRoIGRlYnVnIGZsYWcgW2RvdGVudnggcnVuIC0tZGVidWcgLS0geW91cmNvbW1hbmRdIG9yIG1hbnVhbGx5IGNoZWNrIC5lbnYudmF1bHQuJ1xuICAgICAgZXJyb3IuZGVidWcgPSBgW0lOVkFMSURfQ0lQSEVSVEVYVF0gY2lwaGVydGV4dCBpcyAnJHtjaXBoZXJ0ZXh0fSdgXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIHRocm93IGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlY3J5cHRcbiIsImNvbnN0IHsgZGVjcnlwdCB9ID0gcmVxdWlyZSgnZWNpZXNqcycpXG5cbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuY29uc3QgUFJFRklYID0gJ2VuY3J5cHRlZDonXG5cbmZ1bmN0aW9uIGRlY3J5cHRLZXlWYWx1ZSAoa2V5LCB2YWx1ZSwgcHJpdmF0ZUtleU5hbWUsIHByaXZhdGVLZXkpIHtcbiAgbGV0IGRlY3J5cHRlZFZhbHVlXG4gIGxldCBkZWNyeXB0aW9uRXJyb3JcblxuICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoUFJFRklYKSkge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXkgfHwgJydcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoIDw9IDApIHtcbiAgICBkZWNyeXB0aW9uRXJyb3IgPSBuZXcgRXJyb3JzKHsga2V5LCBwcml2YXRlS2V5TmFtZSwgcHJpdmF0ZUtleSB9KS5taXNzaW5nUHJpdmF0ZUtleSgpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleXMgPSBwcml2YXRlS2V5LnNwbGl0KCcsJylcbiAgICBmb3IgKGNvbnN0IHByaXZLZXkgb2YgcHJpdmF0ZUtleXMpIHtcbiAgICAgIGNvbnN0IHNlY3JldCA9IEJ1ZmZlci5mcm9tKHByaXZLZXksICdoZXgnKVxuICAgICAgY29uc3QgZW5jb2RlZCA9IHZhbHVlLnN1YnN0cmluZyhQUkVGSVgubGVuZ3RoKVxuICAgICAgY29uc3QgY2lwaGVydGV4dCA9IEJ1ZmZlci5mcm9tKGVuY29kZWQsICdiYXNlNjQnKVxuXG4gICAgICB0cnkge1xuICAgICAgICBkZWNyeXB0ZWRWYWx1ZSA9IGRlY3J5cHQoc2VjcmV0LCBjaXBoZXJ0ZXh0KS50b1N0cmluZygpXG4gICAgICAgIGRlY3J5cHRpb25FcnJvciA9IG51bGwgLy8gcmVzZXQgdG8gbnVsbCBlcnJvciAoc2NlbmFyaW8gZm9yIG11bHRpcGxlIHByaXZhdGUga2V5cylcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUubWVzc2FnZSA9PT0gJ0ludmFsaWQgcHJpdmF0ZSBrZXknKSB7XG4gICAgICAgICAgZGVjcnlwdGlvbkVycm9yID0gbmV3IEVycm9ycyh7IGtleSwgcHJpdmF0ZUtleU5hbWUsIHByaXZhdGVLZXkgfSkuaW52YWxpZFByaXZhdGVLZXkoKVxuICAgICAgICB9IGVsc2UgaWYgKGUubWVzc2FnZSA9PT0gJ1Vuc3VwcG9ydGVkIHN0YXRlIG9yIHVuYWJsZSB0byBhdXRoZW50aWNhdGUgZGF0YScpIHtcbiAgICAgICAgICBkZWNyeXB0aW9uRXJyb3IgPSBuZXcgRXJyb3JzKHsga2V5LCBwcml2YXRlS2V5TmFtZSwgcHJpdmF0ZUtleSB9KS5sb29rc1dyb25nUHJpdmF0ZUtleSgpXG4gICAgICAgIH0gZWxzZSBpZiAoZS5tZXNzYWdlID09PSAnUG9pbnQgb2YgbGVuZ3RoIDY1IHdhcyBpbnZhbGlkLiBFeHBlY3RlZCAzMyBjb21wcmVzc2VkIGJ5dGVzIG9yIDY1IHVuY29tcHJlc3NlZCBieXRlcycpIHtcbiAgICAgICAgICBkZWNyeXB0aW9uRXJyb3IgPSBuZXcgRXJyb3JzKHsga2V5LCBwcml2YXRlS2V5TmFtZSwgcHJpdmF0ZUtleSB9KS5tYWxmb3JtZWRFbmNyeXB0ZWREYXRhKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWNyeXB0aW9uRXJyb3IgPSBuZXcgRXJyb3JzKHsga2V5LCBwcml2YXRlS2V5TmFtZSwgcHJpdmF0ZUtleSwgbWVzc2FnZTogZS5tZXNzYWdlIH0pLmRlY3J5cHRpb25GYWlsZWQoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRlY3J5cHRpb25FcnJvcikge1xuICAgIHRocm93IGRlY3J5cHRpb25FcnJvclxuICB9XG5cbiAgcmV0dXJuIGRlY3J5cHRlZFZhbHVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVjcnlwdEtleVZhbHVlXG4iLCJjb25zdCB7IGxvZ2dlciB9ID0gcmVxdWlyZSgnLi8uLi8uLi9zaGFyZWQvbG9nZ2VyJylcblxuY2xhc3MgRGVwcmVjYXRpb25Ob3RpY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5ET1RFTlZfS0VZID0gb3B0aW9ucy5ET1RFTlZfS0VZIHx8IHByb2Nlc3MuZW52LkRPVEVOVl9LRVlcbiAgfVxuXG4gIGRvdGVudktleSAoKSB7XG4gICAgaWYgKHRoaXMuRE9URU5WX0tFWSkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1tERVBSRUNBVElPTiBOT1RJQ0VdIFNldHRpbmcgRE9URU5WX0tFWSB3aXRoIC5lbnYudmF1bHQgaXMgZGVwcmVjYXRlZC4nKVxuICAgICAgbG9nZ2VyLndhcm4oJ1tERVBSRUNBVElPTiBOT1RJQ0VdIFJ1biBbZG90ZW52eCBleHQgdmF1bHQgbWlncmF0ZV0gZm9yIGluc3RydWN0aW9ucyBvbiBjb252ZXJ0aW5nIHlvdXIgLmVudi52YXVsdCBmaWxlIHRvIGVuY3J5cHRlZCAuZW52IGZpbGVzICh1c2luZyBwdWJsaWMga2V5IGVuY3J5cHRpb24gYWxnb3JpdGhtIHNlY3AyNTZrMSknKVxuICAgICAgbG9nZ2VyLndhcm4oJ1tERVBSRUNBVElPTiBOT1RJQ0VdIFJlYWQgbW9yZSBhdCBbaHR0cHM6Ly9naXRodWIuY29tL2RvdGVudngvZG90ZW52eC9ibG9iL21haW4vQ0hBTkdFTE9HLm1kIzAzODBdJylcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEZXByZWNhdGlvbk5vdGljZVxuIiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbmZ1bmN0aW9uIGRldGVjdEVuY29kaW5nIChmaWxlcGF0aCkge1xuICBjb25zdCBidWZmZXIgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZXBhdGgpXG5cbiAgLy8gY2hlY2sgZm9yIFVURi0xNkxFIEJPTSAoQnl0ZSBPcmRlciBNYXJrKVxuICBpZiAoYnVmZmVyLmxlbmd0aCA+PSAyICYmIGJ1ZmZlclswXSA9PT0gMHhGRiAmJiBidWZmZXJbMV0gPT09IDB4RkUpIHtcbiAgICByZXR1cm4gJ3V0ZjE2bGUnXG4gIH1cblxuICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgLy8gY2hlY2sgZm9yIFVURi04IEJPTVxuICBpZiAoYnVmZmVyLmxlbmd0aCA+PSAzICYmIGJ1ZmZlclswXSA9PT0gMHhFRiAmJiBidWZmZXJbMV0gPT09IDB4QkIgJiYgYnVmZmVyWzJdID09PSAweEJGKSB7XG4gICAgcmV0dXJuICd1dGY4J1xuICB9XG5cbiAgLyogYzggaWdub3JlIHN0b3AgKi9cblxuICByZXR1cm4gJ3V0ZjgnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGV0ZWN0RW5jb2RpbmdcbiIsImNvbnN0IGRvdGVudlByaXZhdGVLZXlOYW1lcyA9IHJlcXVpcmUoJy4vZG90ZW52UHJpdmF0ZUtleU5hbWVzJylcbmNvbnN0IGd1ZXNzUHJpdmF0ZUtleUZpbGVuYW1lID0gcmVxdWlyZSgnLi9ndWVzc1ByaXZhdGVLZXlGaWxlbmFtZScpXG5cbmNvbnN0IFRZUEVfRU5WX0ZJTEUgPSAnZW52RmlsZSdcbmNvbnN0IFRZUEVfRU5WX1ZBVUxUX0ZJTEUgPSAnZW52VmF1bHRGaWxlJ1xuY29uc3QgREVGQVVMVF9FTlZTID0gW3sgdHlwZTogVFlQRV9FTlZfRklMRSwgdmFsdWU6ICcuZW52JyB9XVxuY29uc3QgREVGQVVMVF9FTlZfVkFVTFRTID0gW3sgdHlwZTogVFlQRV9FTlZfVkFVTFRfRklMRSwgdmFsdWU6ICcuZW52LnZhdWx0JyB9XVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVFbnZzRnJvbURvdGVudlByaXZhdGVLZXkgKHByaXZhdGVLZXlOYW1lcykge1xuICBjb25zdCBlbnZzID0gW11cblxuICBmb3IgKGNvbnN0IHByaXZhdGVLZXlOYW1lIG9mIHByaXZhdGVLZXlOYW1lcykge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gZ3Vlc3NQcml2YXRlS2V5RmlsZW5hbWUocHJpdmF0ZUtleU5hbWUpXG4gICAgZW52cy5wdXNoKHsgdHlwZTogVFlQRV9FTlZfRklMRSwgdmFsdWU6IGZpbGVuYW1lIH0pXG4gIH1cblxuICByZXR1cm4gZW52c1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVFbnZzIChlbnZzID0gW10sIHByb2Nlc3NFbnYsIERPVEVOVl9LRVkgPSAnJykge1xuICBjb25zdCBwcml2YXRlS2V5TmFtZXMgPSBkb3RlbnZQcml2YXRlS2V5TmFtZXMocHJvY2Vzc0VudilcbiAgaWYgKCFlbnZzIHx8IGVudnMubGVuZ3RoIDw9IDApIHtcbiAgICAvLyBpZiBwcm9jZXNzLmVudi5ET1RFTlZfUFJJVkFURV9LRVkgb3IgcHJvY2Vzcy5lbnYuRE9URU5WX1BSSVZBVEVfS0VZXyR7ZW52aXJvbm1lbnR9IGlzIHNldCwgYXNzdW1lIGlubGluZSBlbmNyeXB0aW9uIG1ldGhvZG9sb2d5XG4gICAgaWYgKHByaXZhdGVLZXlOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZGV0ZXJtaW5lRW52c0Zyb21Eb3RlbnZQcml2YXRlS2V5KHByaXZhdGVLZXlOYW1lcylcbiAgICB9XG5cbiAgICBpZiAoRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBpZiBET1RFTlZfS0VZIGlzIHNldCB0aGVuIGRlZmF1bHQgdG8gbG9vayBmb3IgLmVudi52YXVsdCBmaWxlXG4gICAgICByZXR1cm4gREVGQVVMVF9FTlZfVkFVTFRTXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBERUZBVUxUX0VOVlMgLy8gZGVmYXVsdCB0byAuZW52IGZpbGUgZXhwZWN0YXRpb25cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZpbGVBbHJlYWR5U3BlY2lmaWVkID0gZmFsc2UgLy8gY2FuIGJlIC5lbnYgb3IgLmVudi52YXVsdCB0eXBlXG5cbiAgICBmb3IgKGNvbnN0IGVudiBvZiBlbnZzKSB7XG4gICAgICAvLyBpZiBET1RFTlZfS0VZIHNldCB0aGVuIHdlIGFyZSBjaGVja2luZyBpZiBhIC5lbnYudmF1bHQgZmlsZSBpcyBhbHJlYWR5IHNwZWNpZmllZFxuICAgICAgaWYgKERPVEVOVl9LRVkubGVuZ3RoID4gMCAmJiBlbnYudHlwZSA9PT0gVFlQRV9FTlZfVkFVTFRfRklMRSkge1xuICAgICAgICBmaWxlQWxyZWFkeVNwZWNpZmllZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgLy8gaWYgRE9URU5WX0tFWSBub3Qgc2V0IHRoZW4gd2UgYXJlIGNoZWNraW5nIGlmIGEgLmVudiBmaWxlIGlzIGFscmVhZHkgc3BlY2lmaWVkXG4gICAgICBpZiAoRE9URU5WX0tFWS5sZW5ndGggPD0gMCAmJiBlbnYudHlwZSA9PT0gVFlQRV9FTlZfRklMRSkge1xuICAgICAgICBmaWxlQWxyZWFkeVNwZWNpZmllZCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gZWFybHkgc2luY2UgZW52cyBhcnJheSBvYmplY3RzIGFscmVhZHkgY29udGFpbiAxIC5lbnYudmF1bHQgb3IgLmVudiBmaWxlXG4gICAgaWYgKGZpbGVBbHJlYWR5U3BlY2lmaWVkKSB7XG4gICAgICByZXR1cm4gZW52c1xuICAgIH1cblxuICAgIC8vIG5vIC5lbnYudmF1bHQgb3IgLmVudiBmaWxlIHNwZWNpZmllZCBhcyBhIGZsYWcgc28gd2UgYXNzdW1lIGVpdGhlciAuZW52LnZhdWx0IChpZiBkb3RlbnYga2V5IGlzIHNldCkgb3IgYSAuZW52IGZpbGVcbiAgICBpZiAoRE9URU5WX0tFWS5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBpZiBET1RFTlZfS0VZIGlzIHNldCB0aGVuIGRlZmF1bHQgdG8gbG9vayBmb3IgLmVudi52YXVsdCBmaWxlXG4gICAgICByZXR1cm4gWy4uLkRFRkFVTFRfRU5WX1ZBVUxUUywgLi4uZW52c11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgbm8gRE9URU5WX0tFWSB0aGVuIGRlZmF1bHQgdG8gbG9vayBmb3IgLmVudiBmaWxlXG4gICAgICByZXR1cm4gWy4uLkRFRkFVTFRfRU5WUywgLi4uZW52c11cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXRlcm1pbmVFbnZzXG4iLCJjb25zdCByZXNvbHZlSG9tZSA9IHJlcXVpcmUoJy4vcmVzb2x2ZUhvbWUnKVxuXG5mdW5jdGlvbiBkb3RlbnZPcHRpb25QYXRocyAob3B0aW9ucykge1xuICBsZXQgb3B0aW9uUGF0aHMgPSBbXVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtyZXNvbHZlSG9tZShvcHRpb25zLnBhdGgpXVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtdIC8vIHJlc2V0IGRlZmF1bHRcblxuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgb3B0aW9uUGF0aHMucHVzaChyZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvblBhdGhzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG90ZW52T3B0aW9uUGF0aHNcbiIsIi8vIGhpc3RvcmljYWwgZG90ZW52LnBhcnNlIC0gaHR0cHM6Ly9naXRodWIuY29tL21vdGRvdGxhL2RvdGVudilcbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG5mdW5jdGlvbiBkb3RlbnZQYXJzZSAoc3JjLCBza2lwRXhwYW5kRm9yRG91YmxlUXVvdGVzID0gZmFsc2UsIHNraXBDb252ZXJ0aW5nV2luZG93c05ld2xpbmVzID0gZmFsc2UsIGNvbGxlY3RBbGxWYWx1ZXMgPSBmYWxzZSkge1xuICBjb25zdCBvYmogPSB7fVxuXG4gIC8vIENvbnZlcnQgYnVmZmVyIHRvIHN0cmluZ1xuICBsZXQgbGluZXMgPSBzcmMudG9TdHJpbmcoKVxuXG4gIC8vIENvbnZlcnQgbGluZSBicmVha3MgdG8gc2FtZSBmb3JtYXRcbiAgaWYgKCFza2lwQ29udmVydGluZ1dpbmRvd3NOZXdsaW5lcykge1xuICAgIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG4gIH1cblxuICBsZXQgbWF0Y2hcbiAgd2hpbGUgKChtYXRjaCA9IExJTkUuZXhlYyhsaW5lcykpICE9IG51bGwpIHtcbiAgICBjb25zdCBrZXkgPSBtYXRjaFsxXVxuXG4gICAgLy8gRGVmYXVsdCB1bmRlZmluZWQgb3IgbnVsbCB0byBlbXB0eSBzdHJpbmdcbiAgICBsZXQgdmFsdWUgPSAobWF0Y2hbMl0gfHwgJycpXG5cbiAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZVxuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICAvLyBDaGVjayBpZiBkb3VibGUgcXVvdGVkXG4gICAgY29uc3QgbWF5YmVRdW90ZSA9IHZhbHVlWzBdXG5cbiAgICAvLyBSZW1vdmUgc3Vycm91bmRpbmcgcXVvdGVzXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFsnXCJgXSkoW1xcc1xcU10qKVxcMSQvbWcsICckMicpXG5cbiAgICAvLyBFeHBhbmQgbmV3bGluZXMgaWYgZG91YmxlIHF1b3RlZFxuICAgIGlmIChtYXliZVF1b3RlID09PSAnXCInICYmICFza2lwRXhwYW5kRm9yRG91YmxlUXVvdGVzKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKSAvLyBuZXdsaW5lXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcXFxyL2csICdcXHInKSAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHQvZywgJ1xcdCcpIC8vIHRhYnNcbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdEFsbFZhbHVlcykge1xuICAgICAgLy8gaGFuZGxlIHNjZW5hcmlvIHdoZXJlIHVzZXIgbWlzdGFrZW5seSBpbmNsdWRlcyBwbGFpbnRleHQgZHVwbGljYXRlIGluIC5lbnY6XG4gICAgICAvL1xuICAgICAgLy8gIyAuZW52XG4gICAgICAvLyBIRUxMTz1cIldvcmxkXCJcbiAgICAgIC8vIEhFTExPPVwiZW5yeXB0ZWQ6MTIzNFwiXG4gICAgICBvYmpba2V5XSA9IG9ialtrZXldIHx8IFtdXG4gICAgICBvYmpba2V5XS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgdG8gb2JqZWN0XG4gICAgICBvYmpba2V5XSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvdGVudlBhcnNlXG4iLCJjb25zdCBQUklWQVRFX0tFWV9OQU1FX1NDSEVNQSA9ICdET1RFTlZfUFJJVkFURV9LRVknXG5cbmZ1bmN0aW9uIGRvdGVudlByaXZhdGVLZXlOYW1lcyAocHJvY2Vzc0Vudikge1xuICByZXR1cm4gT2JqZWN0LmtleXMocHJvY2Vzc0VudikuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aChQUklWQVRFX0tFWV9OQU1FX1NDSEVNQSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZG90ZW52UHJpdmF0ZUtleU5hbWVzXG4iLCJjb25zdCB7IGVuY3J5cHQgfSA9IHJlcXVpcmUoJ2VjaWVzanMnKVxuXG5jb25zdCBQUkVGSVggPSAnZW5jcnlwdGVkOidcblxuZnVuY3Rpb24gZW5jcnlwdFZhbHVlICh2YWx1ZSwgcHVibGljS2V5KSB7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBlbmNyeXB0KHB1YmxpY0tleSwgQnVmZmVyLmZyb20odmFsdWUpKVxuICBjb25zdCBlbmNvZGVkID0gQnVmZmVyLmZyb20oY2lwaGVydGV4dCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKSAvLyBiYXNlNjQgZW5jb2RlIGNpcGhlcnRleHRcblxuICByZXR1cm4gYCR7UFJFRklYfSR7ZW5jb2RlZH1gXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW5jcnlwdFZhbHVlXG4iLCJjb25zdCB0cnVuY2F0ZSA9IHJlcXVpcmUoJy4vdHJ1bmNhdGUnKVxuXG5jbGFzcyBFcnJvcnMge1xuICBjb25zdHJ1Y3RvciAob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5maWxlcGF0aCA9IG9wdGlvbnMuZmlsZXBhdGhcbiAgICB0aGlzLmVudkZpbGVwYXRoID0gb3B0aW9ucy5lbnZGaWxlcGF0aFxuXG4gICAgdGhpcy5rZXkgPSBvcHRpb25zLmtleVxuICAgIHRoaXMucHJpdmF0ZUtleSA9IG9wdGlvbnMucHJpdmF0ZUtleVxuICAgIHRoaXMucHJpdmF0ZUtleU5hbWUgPSBvcHRpb25zLnByaXZhdGVLZXlOYW1lXG4gICAgdGhpcy5jb21tYW5kID0gb3B0aW9ucy5jb21tYW5kXG5cbiAgICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2VcbiAgfVxuXG4gIG1pc3NpbmdFbnZGaWxlICgpIHtcbiAgICBjb25zdCBjb2RlID0gJ01JU1NJTkdfRU5WX0ZJTEUnXG4gICAgY29uc3QgbWVzc2FnZSA9IGBbJHtjb2RlfV0gbWlzc2luZyAke3RoaXMuZW52RmlsZXBhdGh9IGZpbGUgKCR7dGhpcy5maWxlcGF0aH0pYFxuICAgIGNvbnN0IGhlbHAgPSBgWyR7Y29kZX1dIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3RlbnZ4L2RvdGVudngvaXNzdWVzLzQ4NGBcblxuICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICBlLmNvZGUgPSBjb2RlXG4gICAgZS5oZWxwID0gaGVscFxuICAgIHJldHVybiBlXG4gIH1cblxuICBtaXNzaW5nS2V5ICgpIHtcbiAgICBjb25zdCBjb2RlID0gJ01JU1NJTkdfS0VZJ1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgWyR7Y29kZX1dIG1pc3NpbmcgJHt0aGlzLmtleX0ga2V5YFxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgbWlzc2luZ1ByaXZhdGVLZXkgKCkge1xuICAgIGNvbnN0IGNvZGUgPSAnTUlTU0lOR19QUklWQVRFX0tFWSdcbiAgICBjb25zdCBtZXNzYWdlID0gYFske2NvZGV9XSBjb3VsZCBub3QgZGVjcnlwdCAke3RoaXMua2V5fSB1c2luZyBwcml2YXRlIGtleSAnJHt0aGlzLnByaXZhdGVLZXlOYW1lfT0ke3RydW5jYXRlKHRoaXMucHJpdmF0ZUtleSl9J2BcbiAgICBjb25zdCBoZWxwID0gYFske2NvZGV9XSBodHRwczovL2dpdGh1Yi5jb20vZG90ZW52eC9kb3RlbnZ4L2lzc3Vlcy80NjRgXG5cbiAgICBjb25zdCBlID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgZS5jb2RlID0gY29kZVxuICAgIGUuaGVscCA9IGhlbHBcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgaW52YWxpZFByaXZhdGVLZXkgKCkge1xuICAgIGNvbnN0IGNvZGUgPSAnSU5WQUxJRF9QUklWQVRFX0tFWSdcbiAgICBjb25zdCBtZXNzYWdlID0gYFske2NvZGV9XSBjb3VsZCBub3QgZGVjcnlwdCAke3RoaXMua2V5fSB1c2luZyBwcml2YXRlIGtleSAnJHt0aGlzLnByaXZhdGVLZXlOYW1lfT0ke3RydW5jYXRlKHRoaXMucHJpdmF0ZUtleSl9J2BcbiAgICBjb25zdCBoZWxwID0gYFske2NvZGV9XSBodHRwczovL2dpdGh1Yi5jb20vZG90ZW52eC9kb3RlbnZ4L2lzc3Vlcy80NjVgXG5cbiAgICBjb25zdCBlID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgZS5jb2RlID0gY29kZVxuICAgIGUuaGVscCA9IGhlbHBcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgbG9va3NXcm9uZ1ByaXZhdGVLZXkgKCkge1xuICAgIGNvbnN0IGNvZGUgPSAnV1JPTkdfUFJJVkFURV9LRVknXG4gICAgY29uc3QgbWVzc2FnZSA9IGBbJHtjb2RlfV0gY291bGQgbm90IGRlY3J5cHQgJHt0aGlzLmtleX0gdXNpbmcgcHJpdmF0ZSBrZXkgJyR7dGhpcy5wcml2YXRlS2V5TmFtZX09JHt0cnVuY2F0ZSh0aGlzLnByaXZhdGVLZXkpfSdgXG4gICAgY29uc3QgaGVscCA9IGBbJHtjb2RlfV0gaHR0cHM6Ly9naXRodWIuY29tL2RvdGVudngvZG90ZW52eC9pc3N1ZXMvNDY2YFxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICBlLmhlbHAgPSBoZWxwXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIG1hbGZvcm1lZEVuY3J5cHRlZERhdGEgKCkge1xuICAgIGNvbnN0IGNvZGUgPSAnTUFMRk9STUVEX0VOQ1JZUFRFRF9EQVRBJ1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgWyR7Y29kZX1dIGNvdWxkIG5vdCBkZWNyeXB0ICR7dGhpcy5rZXl9IGJlY2F1c2UgZW5jcnlwdGVkIGRhdGEgYXBwZWFycyBtYWxmb3JtZWRgXG4gICAgY29uc3QgaGVscCA9IGBbJHtjb2RlfV0gaHR0cHM6Ly9naXRodWIuY29tL2RvdGVudngvZG90ZW52eC9pc3N1ZXMvNDY3YFxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICBlLmhlbHAgPSBoZWxwXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGRlY3J5cHRpb25GYWlsZWQgKCkge1xuICAgIGNvbnN0IGNvZGUgPSAnREVDUllQVElPTl9GQUlMRUQnXG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZVxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgY29tbWFuZFN1YnN0aXR1dGlvbkZhaWxlZCAoKSB7XG4gICAgY29uc3QgY29kZSA9ICdDT01NQU5EX1NVQlNUSVRVVElPTl9GQUlMRUQnXG4gICAgY29uc3QgbWVzc2FnZSA9IGBbJHtjb2RlfV0gY291bGQgbm90IGV2YWwgJHt0aGlzLmtleX0gY29udGFpbmluZyBjb21tYW5kICcke3RoaXMuY29tbWFuZH0nOiAke3RoaXMubWVzc2FnZX1gXG4gICAgY29uc3QgaGVscCA9IGBbJHtjb2RlfV0gaHR0cHM6Ly9naXRodWIuY29tL2RvdGVudngvZG90ZW52eC9pc3N1ZXMvNTMyYFxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICBlLmhlbHAgPSBoZWxwXG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGRhbmdlcm91c0RlcGVuZGVuY3lIb2lzdCAoKSB7XG4gICAgY29uc3QgY29kZSA9ICdEQU5HRVJPVVNfREVQRU5ERU5DWV9IT0lTVCdcbiAgICBjb25zdCBtZXNzYWdlID0gYFske2NvZGV9XSB5b3VyIGVudmlyb25tZW50IGhhcyBob2lzdGVkIGFuIGluY29tcGF0aWJsZSB2ZXJzaW9uIG9mIGEgZG90ZW52eCBkZXBlbmRlbmN5OiAke3RoaXMubWVzc2FnZX1gXG4gICAgY29uc3QgaGVscCA9IGBbJHtjb2RlfV0gaHR0cHM6Ly9naXRodWIuY29tL2RvdGVudngvZG90ZW52eC9pc3N1ZXMvNjIyYFxuXG4gICAgY29uc3QgZSA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIGUuY29kZSA9IGNvZGVcbiAgICBlLmhlbHAgPSBoZWxwXG4gICAgcmV0dXJuIGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVycm9yc1xuIiwiZnVuY3Rpb24gZXNjYXBlRG9sbGFyU2lnbnMgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcJC9nLCAnJCQkJCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXNjYXBlRG9sbGFyU2lnbnNcbiIsImZ1bmN0aW9uIGVzY2FwZUZvclJlZ2V4IChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZywgJ1xcXFwkJicpLnJlcGxhY2UoLy0vZywgJ1xcXFx4MmQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVzY2FwZUZvclJlZ2V4XG4iLCJjb25zdCB7IGV4ZWNTeW5jIH0gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcbmNvbnN0IGNob21wID0gcmVxdWlyZSgnLi9jaG9tcCcpXG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpXG5cbmZ1bmN0aW9uIGV2YWxLZXlWYWx1ZSAoa2V5LCB2YWx1ZSwgcHJvY2Vzc0VudiwgcnVubmluZ1BhcnNlZCkge1xuICAvLyBNYXRjaCBldmVyeXRoaW5nIGJldHdlZW4gdGhlIG91dGVybW9zdCAkKCkgdXNpbmcgYSByZWdleCB3aXRoIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZS5tYXRjaCgvXFwkXFwoKFteKV0rKD86XFwpW14oXSopKilcXCkvZykgfHwgW11cbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlKChuZXdWYWx1ZSwgbWF0Y2gpID0+IHtcbiAgICBjb25zdCBjb21tYW5kID0gbWF0Y2guc2xpY2UoMiwgLTEpIC8vIEV4dHJhY3QgY29tbWFuZCBieSByZW1vdmluZyAkKCkgd3JhcHBlclxuICAgIGxldCByZXN1bHRcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBleGVjU3luYyhjb21tYW5kLCB7IGVudjogeyAuLi5wcm9jZXNzRW52LCAuLi5ydW5uaW5nUGFyc2VkIH0gfSkudG9TdHJpbmcoKSAvLyBleGVjdXRlIGNvbW1hbmQgKGluY2x1ZGluZyBydW5uaW5nUGFyc2VkKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMoeyBrZXksIGNvbW1hbmQsIG1lc3NhZ2U6IGUubWVzc2FnZS50cmltKCkgfSkuY29tbWFuZFN1YnN0aXR1dGlvbkZhaWxlZCgpXG4gICAgfVxuXG4gICAgcmVzdWx0ID0gY2hvbXAocmVzdWx0KSAvLyBjaG9tcCBpdFxuICAgIHJldHVybiBuZXdWYWx1ZS5yZXBsYWNlKG1hdGNoLCByZXN1bHQpIC8vIFJlcGxhY2UgbWF0Y2ggd2l0aCByZXN1bHRcbiAgfSwgdmFsdWUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXZhbEtleVZhbHVlXG4iLCJjb25zdCBmc3ggPSByZXF1aXJlKCcuL2ZzeCcpXG5cbmNvbnN0IFJFU0VSVkVEX0VOVl9GSUxFUyA9IFsnLmVudi52YXVsdCcsICcuZW52LnByb2plY3QnLCAnLmVudi5rZXlzJywgJy5lbnYubWUnLCAnLmVudi54JywgJy5lbnYuZXhhbXBsZSddXG5cbmZ1bmN0aW9uIGZpbmRFbnZGaWxlcyAoZGlyZWN0b3J5KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgZmlsZXMgPSBmc3gucmVhZGRpclN5bmMoZGlyZWN0b3J5KVxuICAgIGNvbnN0IGVudkZpbGVzID0gZmlsZXMuZmlsdGVyKGZpbGUgPT5cbiAgICAgIGZpbGUuc3RhcnRzV2l0aCgnLmVudicpICYmXG4gICAgICAhZmlsZS5lbmRzV2l0aCgnLnByZXZpb3VzJykgJiZcbiAgICAgICFSRVNFUlZFRF9FTlZfRklMRVMuaW5jbHVkZXMoZmlsZSlcbiAgICApXG5cbiAgICByZXR1cm4gZW52RmlsZXNcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLmNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgbWlzc2luZyBkaXJlY3RvcnkgKCR7ZGlyZWN0b3J5fSlgKVxuICAgICAgZXJyb3IuY29kZSA9ICdNSVNTSU5HX0RJUkVDVE9SWSdcblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbmRFbnZGaWxlc1xuIiwiLy8gaGVscGVyc1xuY29uc3QgZ3Vlc3NQcml2YXRlS2V5TmFtZSA9IHJlcXVpcmUoJy4vZ3Vlc3NQcml2YXRlS2V5TmFtZScpXG5jb25zdCBQcm9LZXlwYWlyID0gcmVxdWlyZSgnLi9wcm9LZXlwYWlyJylcblxuLy8gc2VydmljZXNcbmNvbnN0IEtleXBhaXIgPSByZXF1aXJlKCcuLy4uL3NlcnZpY2VzL2tleXBhaXInKVxuXG5mdW5jdGlvbiBmaW5kUHJpdmF0ZUtleSAoZW52RmlsZXBhdGgsIGVudktleXNGaWxlcGF0aCA9IG51bGwpIHtcbiAgLy8gdXNlIHBhdGgvdG8vLmVudi4ke2Vudmlyb25tZW50fSB0byBnZW5lcmF0ZSBwcml2YXRlS2V5TmFtZVxuICBjb25zdCBwcml2YXRlS2V5TmFtZSA9IGd1ZXNzUHJpdmF0ZUtleU5hbWUoZW52RmlsZXBhdGgpXG5cbiAgY29uc3QgcHJvS2V5cGFpcnMgPSBuZXcgUHJvS2V5cGFpcihlbnZGaWxlcGF0aCkucnVuKCkgLy8gVE9ETzogaW1wbGVtZW50IGN1c3RvbSBlbnZLZXlzRmlsZXBhdGhcbiAgY29uc3Qga2V5cGFpcnMgPSBuZXcgS2V5cGFpcihlbnZGaWxlcGF0aCwgZW52S2V5c0ZpbGVwYXRoKS5ydW4oKVxuXG4gIHJldHVybiBwcm9LZXlwYWlyc1twcml2YXRlS2V5TmFtZV0gfHwga2V5cGFpcnNbcHJpdmF0ZUtleU5hbWVdXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmaW5kUHJpdmF0ZUtleSB9XG4iLCIvLyBoZWxwZXJzXG5jb25zdCBndWVzc1B1YmxpY0tleU5hbWUgPSByZXF1aXJlKCcuL2d1ZXNzUHVibGljS2V5TmFtZScpXG5jb25zdCBQcm9LZXlwYWlyID0gcmVxdWlyZSgnLi9wcm9LZXlwYWlyJylcblxuLy8gc2VydmljZXNcbmNvbnN0IEtleXBhaXIgPSByZXF1aXJlKCcuLy4uL3NlcnZpY2VzL2tleXBhaXInKVxuXG5mdW5jdGlvbiBmaW5kUHVibGljS2V5IChlbnZGaWxlcGF0aCkge1xuICBjb25zdCBwdWJsaWNLZXlOYW1lID0gZ3Vlc3NQdWJsaWNLZXlOYW1lKGVudkZpbGVwYXRoKVxuXG4gIGNvbnN0IHByb0tleXBhaXJzID0gbmV3IFByb0tleXBhaXIoZW52RmlsZXBhdGgpLnJ1bigpXG4gIGNvbnN0IGtleXBhaXJzID0gbmV3IEtleXBhaXIoZW52RmlsZXBhdGgpLnJ1bigpXG5cbiAgcmV0dXJuIHByb0tleXBhaXJzW3B1YmxpY0tleU5hbWVdIHx8IGtleXBhaXJzW3B1YmxpY0tleU5hbWVdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZFB1YmxpY0tleVxuIiwiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5cbmNvbnN0IEVOQ09ESU5HID0gJ3V0ZjgnXG5cbmZ1bmN0aW9uIHJlYWRGaWxlWCAoZmlsZXBhdGgsIGVuY29kaW5nID0gbnVsbCkge1xuICBpZiAoIWVuY29kaW5nKSB7XG4gICAgZW5jb2RpbmcgPSBFTkNPRElOR1xuICB9XG5cbiAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlcGF0aCwgZW5jb2RpbmcpIC8vIHV0ZjggZGVmYXVsdCBzbyBpdCByZXR1cm5zIGEgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmlsZVggKGZpbGVwYXRoLCBzdHIpIHtcbiAgcmV0dXJuIGZzLndyaXRlRmlsZVN5bmMoZmlsZXBhdGgsIHN0ciwgRU5DT0RJTkcpIC8vIHV0ZjggYWx3YXlzXG59XG5cbmNvbnN0IGZzeCA9IHtcbiAgY2htb2RTeW5jOiBmcy5jaG1vZFN5bmMsXG4gIGV4aXN0c1N5bmM6IGZzLmV4aXN0c1N5bmMsXG4gIHJlYWRkaXJTeW5jOiBmcy5yZWFkZGlyU3luYyxcbiAgcmVhZEZpbGVTeW5jOiBmcy5yZWFkRmlsZVN5bmMsXG4gIHdyaXRlRmlsZVN5bmM6IGZzLndyaXRlRmlsZVN5bmMsXG4gIGFwcGVuZEZpbGVTeW5jOiBmcy5hcHBlbmRGaWxlU3luYyxcblxuICAvLyBmc3ggc3BlY2lhbCBjb21tYW5kc1xuICByZWFkRmlsZVgsXG4gIHdyaXRlRmlsZVhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmc3hcbiIsImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuZnVuY3Rpb24gZ3Vlc3NFbnZpcm9ubWVudCAoZmlsZXBhdGgpIHtcbiAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKVxuXG4gIGNvbnN0IHBhcnRzID0gZmlsZW5hbWUuc3BsaXQoJy4nKVxuICBjb25zdCBwb3NzaWJsZUVudmlyb25tZW50TGlzdCA9IFsuLi5wYXJ0cy5zbGljZSgyKV1cblxuICBpZiAocG9zc2libGVFbnZpcm9ubWVudExpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gaGFuZGxlIC5lbnYxIC0+IGRldmVsb3BtZW50MVxuICAgIGNvbnN0IGVudmlyb25tZW50ID0gZmlsZW5hbWUucmVwbGFjZSgnLmVudicsICdkZXZlbG9wbWVudCcpXG5cbiAgICByZXR1cm4gZW52aXJvbm1lbnRcbiAgfVxuXG4gIGlmIChwb3NzaWJsZUVudmlyb25tZW50TGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcG9zc2libGVFbnZpcm9ubWVudExpc3RbMF1cbiAgfVxuXG4gIGlmIChcbiAgICBwb3NzaWJsZUVudmlyb25tZW50TGlzdC5sZW5ndGggPT09IDJcbiAgKSB7XG4gICAgcmV0dXJuIHBvc3NpYmxlRW52aXJvbm1lbnRMaXN0LmpvaW4oJ18nKVxuICB9XG5cbiAgcmV0dXJuIHBvc3NpYmxlRW52aXJvbm1lbnRMaXN0LnNsaWNlKDAsIDIpLmpvaW4oJ18nKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGd1ZXNzRW52aXJvbm1lbnRcbiIsImNvbnN0IFBSRUZJWCA9ICdET1RFTlZfUFJJVkFURV9LRVknXG5cbmZ1bmN0aW9uIGd1ZXNzUHJpdmF0ZUtleUZpbGVuYW1lIChwcml2YXRlS2V5TmFtZSkge1xuICAvLyAuZW52XG4gIGlmIChwcml2YXRlS2V5TmFtZSA9PT0gUFJFRklYKSB7XG4gICAgcmV0dXJuICcuZW52J1xuICB9XG5cbiAgY29uc3QgZmlsZW5hbWVTdWZmaXggPSBwcml2YXRlS2V5TmFtZS5zdWJzdHJpbmcoYCR7UFJFRklYfV9gLmxlbmd0aCkuc3BsaXQoJ18nKS5qb2luKCcuJykudG9Mb3dlckNhc2UoKVxuICAvLyAuZW52LkVOVklST05NRU5UXG5cbiAgcmV0dXJuIGAuZW52LiR7ZmlsZW5hbWVTdWZmaXh9YFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGd1ZXNzUHJpdmF0ZUtleUZpbGVuYW1lXG4iLCJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBndWVzc0Vudmlyb25tZW50ID0gcmVxdWlyZSgnLi9ndWVzc0Vudmlyb25tZW50JylcblxuZnVuY3Rpb24gZ3Vlc3NQcml2YXRlS2V5TmFtZSAoZmlsZXBhdGgpIHtcbiAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVwYXRoKS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gLmVudlxuICBpZiAoZmlsZW5hbWUgPT09ICcuZW52Jykge1xuICAgIHJldHVybiAnRE9URU5WX1BSSVZBVEVfS0VZJ1xuICB9XG5cbiAgLy8gLmVudi5FTlZJUk9OTUVOVFxuICBjb25zdCBlbnZpcm9ubWVudCA9IGd1ZXNzRW52aXJvbm1lbnQoZmlsZW5hbWUpXG5cbiAgcmV0dXJuIGBET1RFTlZfUFJJVkFURV9LRVlfJHtlbnZpcm9ubWVudC50b1VwcGVyQ2FzZSgpfWBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBndWVzc1ByaXZhdGVLZXlOYW1lXG4iLCJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBndWVzc0Vudmlyb25tZW50ID0gcmVxdWlyZSgnLi9ndWVzc0Vudmlyb25tZW50JylcblxuZnVuY3Rpb24gZ3Vlc3NQdWJsaWNLZXlOYW1lIChmaWxlcGF0aCkge1xuICBjb25zdCBmaWxlbmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZXBhdGgpLnRvTG93ZXJDYXNlKClcblxuICAvLyAuZW52XG4gIGlmIChmaWxlbmFtZSA9PT0gJy5lbnYnKSB7XG4gICAgcmV0dXJuICdET1RFTlZfUFVCTElDX0tFWSdcbiAgfVxuXG4gIC8vIC5lbnYuRU5WSVJPTk1FTlRcbiAgY29uc3QgZW52aXJvbm1lbnQgPSBndWVzc0Vudmlyb25tZW50KGZpbGVuYW1lKVxuXG4gIHJldHVybiBgRE9URU5WX1BVQkxJQ19LRVlfJHtlbnZpcm9ubWVudC50b1VwcGVyQ2FzZSgpfWBcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBndWVzc1B1YmxpY0tleU5hbWVcbiIsImNvbnN0IEVOQ1JZUFRJT05fUEFUVEVSTiA9IC9eZW5jcnlwdGVkOi4rL1xuXG5mdW5jdGlvbiBpc0VuY3J5cHRlZCAodmFsdWUpIHtcbiAgcmV0dXJuIEVOQ1JZUFRJT05fUEFUVEVSTi50ZXN0KHZhbHVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW5jcnlwdGVkXG4iLCJjb25zdCBmc3ggPSByZXF1aXJlKCcuL2ZzeCcpXG5jb25zdCBpZ25vcmUgPSByZXF1aXJlKCdpZ25vcmUnKVxuXG5mdW5jdGlvbiBpc0lnbm9yaW5nRG90ZW52S2V5cyAoKSB7XG4gIGlmICghZnN4LmV4aXN0c1N5bmMoJy5naXRpZ25vcmUnKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgZ2l0aWdub3JlID0gZnN4LnJlYWRGaWxlWCgnLmdpdGlnbm9yZScpXG4gIGNvbnN0IGlnID0gaWdub3JlKGdpdGlnbm9yZSkuYWRkKGdpdGlnbm9yZSlcblxuICBpZiAoIWlnLmlnbm9yZXMoJy5lbnYua2V5cycpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSWdub3JpbmdEb3RlbnZLZXlzXG4iLCJjb25zdCB7IFByaXZhdGVLZXkgfSA9IHJlcXVpcmUoJ2VjaWVzanMnKVxuXG5mdW5jdGlvbiBrZXlwYWlyIChleGlzdGluZ1ByaXZhdGVLZXkpIHtcbiAgbGV0IGtwXG5cbiAgaWYgKGV4aXN0aW5nUHJpdmF0ZUtleSkge1xuICAgIGtwID0gbmV3IFByaXZhdGVLZXkoQnVmZmVyLmZyb20oZXhpc3RpbmdQcml2YXRlS2V5LCAnaGV4JykpXG4gIH0gZWxzZSB7XG4gICAga3AgPSBuZXcgUHJpdmF0ZUtleSgpXG4gIH1cblxuICBjb25zdCBwdWJsaWNLZXkgPSBrcC5wdWJsaWNLZXkudG9IZXgoKVxuICBjb25zdCBwcml2YXRlS2V5ID0ga3Auc2VjcmV0LnRvU3RyaW5nKCdoZXgnKVxuXG4gIHJldHVybiB7XG4gICAgcHVibGljS2V5LFxuICAgIHByaXZhdGVLZXlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXBhaXJcbiIsImNvbnN0IHsgbmFtZSwgdmVyc2lvbiwgZGVzY3JpcHRpb24gfSA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhY2thZ2UuanNvbicpXG5cbm1vZHVsZS5leHBvcnRzID0geyBuYW1lLCB2ZXJzaW9uLCBkZXNjcmlwdGlvbiB9XG4iLCJjb25zdCBkZWNyeXB0S2V5VmFsdWUgPSByZXF1aXJlKCcuL2RlY3J5cHRLZXlWYWx1ZScpXG5jb25zdCBldmFsS2V5VmFsdWUgPSByZXF1aXJlKCcuL2V2YWxLZXlWYWx1ZScpXG5jb25zdCByZXNvbHZlRXNjYXBlU2VxdWVuY2VzID0gcmVxdWlyZSgnLi9yZXNvbHZlRXNjYXBlU2VxdWVuY2VzJylcblxuY2xhc3MgUGFyc2Uge1xuICBzdGF0aWMgTElORSA9IC8oPzpefF4pXFxzKig/OmV4cG9ydFxccyspPyhbXFx3Li1dKykoPzpcXHMqPVxccyo/fDpcXHMrPykoXFxzKicoPzpcXFxcJ3xbXiddKSonfFxccypcIig/OlxcXFxcInxbXlwiXSkqXCJ8XFxzKmAoPzpcXFxcYHxbXmBdKSpgfFteI1xcclxcbl0rKT9cXHMqKD86Iy4qKT8oPzokfCQpL21nXG5cbiAgY29uc3RydWN0b3IgKHNyYywgcHJpdmF0ZUtleSA9IG51bGwsIHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudiwgb3ZlcmxvYWQgPSBmYWxzZSwgcHJpdmF0ZUtleU5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5zcmMgPSBzcmNcbiAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5XG4gICAgdGhpcy5wcml2YXRlS2V5TmFtZSA9IHByaXZhdGVLZXlOYW1lXG4gICAgdGhpcy5wcm9jZXNzRW52ID0gcHJvY2Vzc0VudlxuICAgIHRoaXMub3ZlcmxvYWQgPSBvdmVybG9hZFxuXG4gICAgdGhpcy5wYXJzZWQgPSB7fVxuICAgIHRoaXMucHJlRXhpc3RlZCA9IHt9XG4gICAgdGhpcy5pbmplY3RlZCA9IHt9XG4gICAgdGhpcy5lcnJvcnMgPSBbXVxuXG4gICAgLy8gZm9yIHVzZSB3aXRoIHByb2dyZXNzaXZlIGV4cGFuc2lvblxuICAgIHRoaXMucnVubmluZ1BhcnNlZCA9IHt9XG4gICAgLy8gZm9yIHVzZSB3aXRoIHN0b3BwaW5nIGV4cGFuc2lvbiBmb3IgbGl0ZXJhbHNcbiAgICB0aGlzLmxpdGVyYWxzID0ge31cbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgY29uc3QgbGluZXMgPSB0aGlzLmdldExpbmVzKClcblxuICAgIGxldCBtYXRjaFxuICAgIHdoaWxlICgobWF0Y2ggPSBQYXJzZS5MSU5FLmV4ZWMobGluZXMpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cbiAgICAgIGNvbnN0IHZhbHVlID0gbWF0Y2hbMl1cbiAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5xdW90ZSh2YWx1ZSkgLy8gbXVzdCBiZSByYXcgbWF0Y2hcbiAgICAgIHRoaXMucGFyc2VkW2tleV0gPSB0aGlzLmNsZWFuKHZhbHVlLCBxdW90ZSkgLy8gZmlsZSB2YWx1ZVxuXG4gICAgICBpZiAoIXRoaXMub3ZlcmxvYWQgJiYgdGhpcy5pblByb2Nlc3NFbnYoa2V5KSkge1xuICAgICAgICB0aGlzLnBhcnNlZFtrZXldID0gdGhpcy5wcm9jZXNzRW52W2tleV0gLy8gdXNlIHByb2Nlc3MuZW52IHByZS1leGlzdGluZyB2YWx1ZVxuICAgICAgfVxuXG4gICAgICAvLyBkZWNyeXB0XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBhcnNlZFtrZXldID0gdGhpcy5kZWNyeXB0KGtleSwgdGhpcy5wYXJzZWRba2V5XSlcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlKVxuICAgICAgfVxuXG4gICAgICAvLyBldmFsIGVtcHR5LCBkb3VibGUsIG9yIGJhY2t0aWNrc1xuICAgICAgbGV0IGV2YWxlZCA9IGZhbHNlXG4gICAgICBpZiAocXVvdGUgIT09IFwiJ1wiICYmICghdGhpcy5pblByb2Nlc3NFbnYoa2V5KSB8fCB0aGlzLnByb2Nlc3NFbnZba2V5XSA9PT0gdGhpcy5wYXJzZWRba2V5XSkpIHtcbiAgICAgICAgY29uc3QgcHJpb3JFdmFsZWQgPSB0aGlzLnBhcnNlZFtrZXldXG4gICAgICAgIC8vIGV2YWxcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnBhcnNlZFtrZXldID0gdGhpcy5ldmFsKGtleSwgcHJpb3JFdmFsZWQpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yRXZhbGVkICE9PSB0aGlzLnBhcnNlZFtrZXldKSB7XG4gICAgICAgICAgZXZhbGVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGV4cGFuZCBlbXB0eSwgZG91YmxlLCBvciBiYWNrdGlja3NcbiAgICAgIGlmICghZXZhbGVkICYmIHF1b3RlICE9PSBcIidcIiAmJiAoIXRoaXMucHJvY2Vzc0VudltrZXldIHx8IHRoaXMub3ZlcmxvYWQpKSB7XG4gICAgICAgIHRoaXMucGFyc2VkW2tleV0gPSByZXNvbHZlRXNjYXBlU2VxdWVuY2VzKHRoaXMuZXhwYW5kKHRoaXMucGFyc2VkW2tleV0pKVxuICAgICAgfVxuXG4gICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgIHRoaXMubGl0ZXJhbHNba2V5XSA9IHRoaXMucGFyc2VkW2tleV1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHVzZSB3aXRoIHByb2dyZXNzaXZlIGV4cGFuc2lvblxuICAgICAgdGhpcy5ydW5uaW5nUGFyc2VkW2tleV0gPSB0aGlzLnBhcnNlZFtrZXldXG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9jZXNzRW52LCBrZXkpICYmICF0aGlzLm92ZXJsb2FkKSB7XG4gICAgICAgIHRoaXMucHJlRXhpc3RlZFtrZXldID0gdGhpcy5wcm9jZXNzRW52W2tleV0gLy8gdHJhY2sgcHJlRXhpc3RlZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbmplY3RlZFtrZXldID0gdGhpcy5wYXJzZWRba2V5XSAvLyB0cmFjayBpbmplY3RlZFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXJzZWQ6IHRoaXMucGFyc2VkLFxuICAgICAgcHJvY2Vzc0VudjogdGhpcy5wcm9jZXNzRW52LFxuICAgICAgaW5qZWN0ZWQ6IHRoaXMuaW5qZWN0ZWQsXG4gICAgICBwcmVFeGlzdGVkOiB0aGlzLnByZUV4aXN0ZWQsXG4gICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzXG4gICAgfVxuICB9XG5cbiAgdHJpbW1lciAodmFsdWUpIHtcbiAgICAvLyBEZWZhdWx0IHVuZGVmaW5lZCBvciBudWxsIHRvIGVtcHR5IHN0cmluZ1xuICAgIHJldHVybiAodmFsdWUgfHwgJycpLnRyaW0oKVxuICB9XG5cbiAgcXVvdGUgKHZhbHVlKSB7XG4gICAgY29uc3QgdiA9IHRoaXMudHJpbW1lcih2YWx1ZSlcbiAgICBjb25zdCBtYXliZVF1b3RlID0gdlswXVxuICAgIGxldCBxID0gJydcbiAgICBzd2l0Y2ggKG1heWJlUXVvdGUpIHtcbiAgICAgIC8vIHNpbmdsZVxuICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgcSA9IFwiJ1wiXG4gICAgICAgIGJyZWFrXG4gICAgICAvLyBkb3VibGVcbiAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcSA9ICdcIidcbiAgICAgICAgYnJlYWtcbiAgICAgIC8vIGJhY2t0aWNrXG4gICAgICBjYXNlICdgJzpcbiAgICAgICAgcSA9ICdgJ1xuICAgICAgICBicmVha1xuICAgICAgLy8gZW1wdHlcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHEgPSAnJ1xuICAgIH1cblxuICAgIHJldHVybiBxXG4gIH1cblxuICBjbGVhbiAodmFsdWUsIF9xdW90ZSkge1xuICAgIGxldCB2ID0gdGhpcy50cmltbWVyKHZhbHVlKVxuXG4gICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgIHYgPSB2LnJlcGxhY2UoL14oWydcImBdKShbXFxzXFxTXSopXFwxJC9tZywgJyQyJylcblxuICAgIC8vIEV4cGFuZCBuZXdsaW5lcyBpZiBkb3VibGUgcXVvdGVkXG4gICAgaWYgKF9xdW90ZSA9PT0gJ1wiJykge1xuICAgICAgdiA9IHYucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpIC8vIG5ld2xpbmVcbiAgICAgIHYgPSB2LnJlcGxhY2UoL1xcXFxyL2csICdcXHInKSAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAgIHYgPSB2LnJlcGxhY2UoL1xcXFx0L2csICdcXHQnKSAvLyB0YWJzXG4gICAgfVxuXG4gICAgcmV0dXJuIHZcbiAgfVxuXG4gIGRlY3J5cHQgKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGVjcnlwdEtleVZhbHVlKGtleSwgdmFsdWUsIHRoaXMucHJpdmF0ZUtleU5hbWUsIHRoaXMucHJpdmF0ZUtleSlcbiAgfVxuXG4gIGV2YWwgKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZXZhbEtleVZhbHVlKGtleSwgdmFsdWUsIHRoaXMucHJvY2Vzc0VudiwgdGhpcy5ydW5uaW5nUGFyc2VkKVxuICB9XG5cbiAgZXhwYW5kICh2YWx1ZSkge1xuICAgIGxldCBlbnYgPSB7IC4uLnRoaXMucnVubmluZ1BhcnNlZCwgLi4udGhpcy5wcm9jZXNzRW52IH0gLy8gdHlwaWNhbGx5IHByb2Nlc3MuZW52IHdpbnNcbiAgICBpZiAodGhpcy5vdmVybG9hZCkge1xuICAgICAgZW52ID0geyAuLi50aGlzLnByb2Nlc3NFbnYsIC4uLnRoaXMucnVubmluZ1BhcnNlZCB9IC8vIHBhcnNlZCB3aW5zXG4gICAgfVxuXG4gICAgY29uc3QgcmVnZXggPSAvKD88IVxcXFwpXFwkeyhbXnt9XSspfXwoPzwhXFxcXClcXCQoW0EtWmEtel9dW0EtWmEtejAtOV9dKikvZ1xuXG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlXG4gICAgbGV0IG1hdGNoXG5cbiAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhyZXN1bHQpKSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgW3RlbXBsYXRlLCBicmFjZWRFeHByZXNzaW9uLCB1bmJyYWNlZEV4cHJlc3Npb25dID0gbWF0Y2hcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBicmFjZWRFeHByZXNzaW9uIHx8IHVuYnJhY2VkRXhwcmVzc2lvblxuXG4gICAgICAvLyBtYXRjaCB0aGUgb3BlcmF0b3JzIGA6K2AsIGArYCwgYDotYCwgYW5kIGAtYFxuICAgICAgY29uc3Qgb3BSZWdleCA9IC8oOlxcK3xcXCt8Oi18LSkvXG4gICAgICAvLyBmaW5kIGZpcnN0IG1hdGNoXG4gICAgICBjb25zdCBvcE1hdGNoID0gZXhwcmVzc2lvbi5tYXRjaChvcFJlZ2V4KVxuICAgICAgY29uc3Qgc3BsaXR0ZXIgPSBvcE1hdGNoID8gb3BNYXRjaFswXSA6IG51bGxcblxuICAgICAgY29uc3QgciA9IGV4cHJlc3Npb24uc3BsaXQoc3BsaXR0ZXIpXG5cbiAgICAgIGxldCBkZWZhdWx0VmFsdWVcbiAgICAgIGxldCB2YWx1ZVxuICAgICAgY29uc3Qga2V5ID0gci5zaGlmdCgpXG5cbiAgICAgIGlmIChbJzorJywgJysnXS5pbmNsdWRlcyhzcGxpdHRlcikpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gZW52W2tleV0gPyByLmpvaW4oc3BsaXR0ZXIpIDogJydcbiAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSByLmpvaW4oc3BsaXR0ZXIpXG4gICAgICAgIHZhbHVlID0gZW52W2tleV1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHRlbXBsYXRlLCB2YWx1ZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKHRlbXBsYXRlLCBkZWZhdWx0VmFsdWUpXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSByZXN1bHQgZXF1YWxlZCB3aGF0IHdhcyBpbiBlbnYgdGhlbiBzdG9wIGV4cGFuZGluZyAtIGhhbmRsZSBzZWxmLXJlZmVyZW50aWFsIGNoZWNrIGFzIHdlbGxcbiAgICAgIGlmIChyZXN1bHQgPT09IGVudltrZXldKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoZSByZXN1bHQgY2FtZSBmcm9tIHdoYXQgd2FzIGEgbGl0ZXJhbCB2YWx1ZSB0aGVuIHN0b3AgZXhwYW5kaW5nXG4gICAgICBpZiAodGhpcy5saXRlcmFsc1trZXldKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIHJlZ2V4Lmxhc3RJbmRleCA9IDAgLy8gcmVzZXQgcmVnZXggc2VhcmNoIHBvc2l0aW9uIHRvIHJlLWV2YWx1YXRlIGFmdGVyIGVhY2ggcmVwbGFjZW1lbnRcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBpblByb2Nlc3NFbnYgKGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5wcm9jZXNzRW52LCBrZXkpXG4gIH1cblxuICBnZXRMaW5lcyAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNyYyB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHJcXG4/L21nLCAnXFxuJykgLy8gQ29udmVydCBidWZmZXIgdG8gc3RyaW5nIGFuZCBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZVxuIiwiZnVuY3Rpb24gcGFyc2VFbmNyeXB0aW9uS2V5RnJvbURvdGVudktleSAoZG90ZW52S2V5KSB7XG4gIC8vIFBhcnNlIERPVEVOVl9LRVkuIEZvcm1hdCBpcyBhIFVSSVxuICBsZXQgdXJpXG4gIHRyeSB7XG4gICAgdXJpID0gbmV3IFVSTChkb3RlbnZLZXkpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogSW5jb21wbGV0ZSBmb3JtYXQuIEl0IHNob3VsZCBiZSBhIGRvdGVudiB1cmkuIChkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1kZXZlbG9wbWVudCknKVxuICB9XG5cbiAgLy8gR2V0IGRlY3J5cHQga2V5XG4gIGNvbnN0IGtleSA9IHVyaS5wYXNzd29yZFxuICBpZiAoIWtleSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGtleSBwYXJ0JylcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShrZXkuc2xpY2UoLTY0KSwgJ2hleCcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VFbmNyeXB0aW9uS2V5RnJvbURvdGVudktleVxuIiwiZnVuY3Rpb24gcGFyc2VFbnZpcm9ubWVudEZyb21Eb3RlbnZLZXkgKGRvdGVudktleSkge1xuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcbiAgbGV0IHVyaVxuICB0cnkge1xuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJTlZBTElEX0RPVEVOVl9LRVk6ICR7ZS5tZXNzYWdlfWApXG4gIH1cblxuICAvLyBHZXQgZW52aXJvbm1lbnRcbiAgY29uc3QgZW52aXJvbm1lbnQgPSB1cmkuc2VhcmNoUGFyYW1zLmdldCgnZW52aXJvbm1lbnQnKVxuICBpZiAoIWVudmlyb25tZW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IE1pc3NpbmcgZW52aXJvbm1lbnQgcGFydCcpXG4gIH1cblxuICByZXR1cm4gZW52aXJvbm1lbnRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZUVudmlyb25tZW50RnJvbURvdGVudktleVxuIiwiY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgY2hpbGRQcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpXG5cbmNvbnN0IGd1ZXNzUHJpdmF0ZUtleU5hbWUgPSByZXF1aXJlKCcuL2d1ZXNzUHJpdmF0ZUtleU5hbWUnKVxuY29uc3QgZ3Vlc3NQdWJsaWNLZXlOYW1lID0gcmVxdWlyZSgnLi9ndWVzc1B1YmxpY0tleU5hbWUnKVxuXG5jbGFzcyBQcm9LZXlwYWlyIHtcbiAgY29uc3RydWN0b3IgKGVudkZpbGVwYXRoKSB7XG4gICAgdGhpcy5lbnZGaWxlcGF0aCA9IGVudkZpbGVwYXRoXG4gIH1cblxuICBydW4gKCkge1xuICAgIGxldCByZXN1bHQgPSB7fVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrQmluID0gcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksICdub2RlX21vZHVsZXMvLmJpbi9kb3RlbnZ4LXBybycpXG4gICAgICBjb25zdCBvdXRwdXQgPSBjaGlsZFByb2Nlc3MuZXhlY1N5bmMoYCR7ZmFsbGJhY2tCaW59IGtleXBhaXIgLWYgJHt0aGlzLmVudkZpbGVwYXRofWAsIHsgc3RkaW86IFsncGlwZScsICdwaXBlJywgJ2lnbm9yZSddIH0pLnRvU3RyaW5nKCkudHJpbSgpXG4gICAgICByZXN1bHQgPSBKU09OLnBhcnNlKG91dHB1dClcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gaWYgaW5zdGFsbGVkIGFzIGJpbmFyeSBjbGlcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gY2hpbGRQcm9jZXNzLmV4ZWNTeW5jKGBkb3RlbnZ4LXBybyBrZXlwYWlyIC1mICR7dGhpcy5lbnZGaWxlcGF0aH1gLCB7IHN0ZGlvOiBbJ3BpcGUnLCAncGlwZScsICdpZ25vcmUnXSB9KS50b1N0cmluZygpLnRyaW0oKVxuXG4gICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2Uob3V0cHV0KVxuICAgICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleU5hbWUgPSBndWVzc1ByaXZhdGVLZXlOYW1lKHRoaXMuZW52RmlsZXBhdGgpXG4gICAgICAgIGNvbnN0IHB1YmxpY0tleU5hbWUgPSBndWVzc1B1YmxpY0tleU5hbWUodGhpcy5lbnZGaWxlcGF0aClcblxuICAgICAgICAvLyBtYXRjaCBmb3JtYXQgb2YgZG90ZW52eC1wcm9cbiAgICAgICAgcmVzdWx0W3ByaXZhdGVLZXlOYW1lXSA9IG51bGxcbiAgICAgICAgcmVzdWx0W3B1YmxpY0tleU5hbWVdID0gbnVsbFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb0tleXBhaXJcbiIsImNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG5mdW5jdGlvbiBxdW90ZXMgKHNyYykge1xuICBjb25zdCBvYmogPSB7fVxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcbiAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKClcblxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG5cbiAgbGV0IG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cblxuICAgIC8vIERlZmF1bHQgdW5kZWZpbmVkIG9yIG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbGV0IHZhbHVlID0gKG1hdGNoWzJdIHx8ICcnKVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgLy8gQ2hlY2sgaWYgZG91YmxlIHF1b3RlZFxuICAgIGNvbnN0IG1heWJlUXVvdGUgPSB2YWx1ZVswXVxuXG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9eKFsnXCJgXSkoW1xcc1xcU10qKVxcMSQvbWcsICckMicpXG5cbiAgICBpZiAobWF5YmVRdW90ZSA9PT0gdmFsdWVbMF0pIHtcbiAgICAgIG9ialtrZXldID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSBtYXliZVF1b3RlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1b3Rlc1xuIiwiY29uc3QgcXVvdGVzID0gcmVxdWlyZSgnLi9xdW90ZXMnKVxuY29uc3QgZG90ZW52UGFyc2UgPSByZXF1aXJlKCcuL2RvdGVudlBhcnNlJylcbmNvbnN0IGVzY2FwZUZvclJlZ2V4ID0gcmVxdWlyZSgnLi9lc2NhcGVGb3JSZWdleCcpXG5jb25zdCBlc2NhcGVEb2xsYXJTaWducyA9IHJlcXVpcmUoJy4vZXNjYXBlRG9sbGFyU2lnbnMnKVxuXG5mdW5jdGlvbiByZXBsYWNlIChzcmMsIGtleSwgcmVwbGFjZVZhbHVlKSB7XG4gIGxldCBvdXRwdXRcbiAgbGV0IG5ld1BhcnQgPSAnJ1xuXG4gIGNvbnN0IHBhcnNlZCA9IGRvdGVudlBhcnNlKHNyYywgdHJ1ZSwgdHJ1ZSkgLy8gc2tpcCBleHBhbmRpbmcgXFxuIGFuZCBza2lwIGNvbnZlcnRpbmcgXFxyXFxuXG4gIGNvbnN0IF9xdW90ZXMgPSBxdW90ZXMoc3JjKVxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcnNlZCwga2V5KSkge1xuICAgIGNvbnN0IHF1b3RlID0gX3F1b3Rlc1trZXldXG4gICAgbmV3UGFydCArPSBgJHtrZXl9PSR7cXVvdGV9JHtyZXBsYWNlVmFsdWV9JHtxdW90ZX1gXG5cbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gcGFyc2VkW2tleV1cbiAgICBjb25zdCBlc2NhcGVkT3JpZ2luYWxWYWx1ZSA9IGVzY2FwZUZvclJlZ2V4KG9yaWdpbmFsVmFsdWUpXG5cbiAgICAvLyBjb25kaXRpb25hbGx5IGVuZm9yY2UgZW5kIG9mIGxpbmVcbiAgICBsZXQgZW5mb3JjZUVuZE9mTGluZSA9ICcnXG4gICAgaWYgKGVzY2FwZWRPcmlnaW5hbFZhbHVlID09PSAnJykge1xuICAgICAgZW5mb3JjZUVuZE9mTGluZSA9ICckJyAvLyBFTVBUWSBzY2VuYXJpb1xuXG4gICAgICAvLyBpZiBlbXB0eSBxdW90ZSBhbmQgY29uc2VjdXRpdmUgbmV3bGluZXNcbiAgICAgIGNvbnN0IG5ld2xpbmVNYXRjaCA9IHNyYy5tYXRjaChuZXcgUmVnRXhwKGAke2tleX1cXFxccyo9XFxcXHMqXFxuXFxuYCwgJ20nKSkgLy8gbWF0Y2ggYW55IGNvbnNlY3V0aXZlIG5ld2xpbmUgc2NlbmFyaW8gZm9yIGEgYmxhbmsgdmFsdWVcbiAgICAgIGlmIChxdW90ZSA9PT0gJycgJiYgbmV3bGluZU1hdGNoKSB7XG4gICAgICAgIGNvbnN0IG5ld2xpbmVDb3VudCA9IChuZXdsaW5lTWF0Y2hbMF0ubWF0Y2goL1xcbi9nKSkubGVuZ3RoIC0gMVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld2xpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgbmV3UGFydCArPSAnXFxuJyAvLyByZS1hcHBlbmQgdGhlIGV4dHJhIG5ld2xpbmUgdG8gcHJlc2VydmUgdXNlcidzIGZvcm1hdCBjaG9pY2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gbmV3IFJlZ0V4cChcbiAgICAgICdeJyArIC8vIHN0YXJ0IG9mIGxpbmVcbiAgICAgICcoXFxcXHMqKT8nICsgLy8gc3BhY2VzXG4gICAgICAnKGV4cG9ydFxcXFxzKyk/JyArIC8vIGV4cG9ydFxuICAgICAga2V5ICsgLy8gS0VZXG4gICAgICAnXFxcXHMqPVxcXFxzKicgKyAvLyBzcGFjZXMgKEtFWSA9IHZhbHVlKVxuICAgICAgJ1tcIlxcJ2BdPycgKyAvLyBvcGVuIHF1b3RlXG4gICAgICBlc2NhcGVkT3JpZ2luYWxWYWx1ZSArIC8vIGVzY2FwZWQgdmFsdWVcbiAgICAgICdbXCJcXCdgXT8nICsgLy8gY2xvc2UgcXVvdGVcbiAgICAgIGVuZm9yY2VFbmRPZkxpbmVcbiAgICAgICxcbiAgICAgICdnbScgLy8gKGcpbG9iYWwgKG0pdWx0aWxpbmVcbiAgICApXG5cbiAgICBjb25zdCBzYWZlcklucHV0ID0gZXNjYXBlRG9sbGFyU2lnbnMobmV3UGFydCkgLy8gY2xlYW5zZSB1c2VyIGlucHV0dGVkIGNhcHR1cmUgZ3JvdXBzICgkMSwgJDIgZXRjKVxuXG4gICAgLy8gJDEgcHJlc2VydmVzIHNwYWNlc1xuICAgIC8vICQyIHByZXNlcnZlcyBleHBvcnRcbiAgICBvdXRwdXQgPSBzcmMucmVwbGFjZShjdXJyZW50UGFydCwgYCQxJDIke3NhZmVySW5wdXR9YClcbiAgfSBlbHNlIHtcbiAgICBuZXdQYXJ0ICs9IGAke2tleX09XCIke3JlcGxhY2VWYWx1ZX1cImBcblxuICAgIC8vIGFwcGVuZFxuICAgIGlmIChzcmMuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICBuZXdQYXJ0ID0gbmV3UGFydCArICdcXG4nXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1BhcnQgPSAnXFxuJyArIG5ld1BhcnRcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBzcmMgKyBuZXdQYXJ0XG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVwbGFjZVxuIiwiZnVuY3Rpb24gcmVzb2x2ZUVzY2FwZVNlcXVlbmNlcyAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcXFxcXCQvZywgJyQnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVFc2NhcGVTZXF1ZW5jZXNcbiIsImNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5mdW5jdGlvbiByZXNvbHZlSG9tZSAoZmlsZXBhdGgpIHtcbiAgaWYgKGZpbGVwYXRoWzBdID09PSAnficpIHtcbiAgICByZXR1cm4gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgZmlsZXBhdGguc2xpY2UoMSkpXG4gIH1cblxuICByZXR1cm4gZmlsZXBhdGhcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlSG9tZVxuIiwiY29uc3QgZnN4ID0gcmVxdWlyZSgnLi9mc3gnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCBQVUJMSUNfS0VZX1NDSEVNQSA9ICdET1RFTlZfUFVCTElDX0tFWSdcbmNvbnN0IFBSSVZBVEVfS0VZX1NDSEVNQSA9ICdET1RFTlZfUFJJVkFURV9LRVknXG5cbmNvbnN0IGRvdGVudlBhcnNlID0gcmVxdWlyZSgnLi9kb3RlbnZQYXJzZScpXG5jb25zdCBndWVzc1ByaXZhdGVLZXlOYW1lID0gcmVxdWlyZSgnLi9ndWVzc1ByaXZhdGVLZXlOYW1lJylcblxuZnVuY3Rpb24gc2VhcmNoUHJvY2Vzc0VudiAocHJpdmF0ZUtleU5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52W3ByaXZhdGVLZXlOYW1lXSAmJiBwcm9jZXNzLmVudltwcml2YXRlS2V5TmFtZV0ubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudltwcml2YXRlS2V5TmFtZV1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZWFyY2hLZXlzRmlsZSAocHJpdmF0ZUtleU5hbWUsIGVudkZpbGVwYXRoLCBlbnZLZXlzRmlsZXBhdGggPSBudWxsKSB7XG4gIGxldCBrZXlzRmlsZXBhdGggPSBwYXRoLnJlc29sdmUocGF0aC5kaXJuYW1lKGVudkZpbGVwYXRoKSwgJy5lbnYua2V5cycpIC8vIHR5cGljYWwgc2NlbmFyaW9cbiAgaWYgKGVudktleXNGaWxlcGF0aCkgeyAvLyB1c2VyIHNwZWNpZmllZCAtZmsgZmxhZ1xuICAgIGtleXNGaWxlcGF0aCA9IHBhdGgucmVzb2x2ZShlbnZLZXlzRmlsZXBhdGgpXG4gIH1cblxuICBpZiAoZnN4LmV4aXN0c1N5bmMoa2V5c0ZpbGVwYXRoKSkge1xuICAgIGNvbnN0IGtleXNTcmMgPSBmc3gucmVhZEZpbGVYKGtleXNGaWxlcGF0aClcbiAgICBjb25zdCBrZXlzUGFyc2VkID0gZG90ZW52UGFyc2Uoa2V5c1NyYylcblxuICAgIGlmIChrZXlzUGFyc2VkW3ByaXZhdGVLZXlOYW1lXSAmJiBrZXlzUGFyc2VkW3ByaXZhdGVLZXlOYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4ga2V5c1BhcnNlZFtwcml2YXRlS2V5TmFtZV1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52ZXJ0Rm9yUHJpdmF0ZUtleU5hbWUgKGVudkZpbGVwYXRoKSB7XG4gIGlmICghZnN4LmV4aXN0c1N5bmMoZW52RmlsZXBhdGgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGNvbnN0IGVudlNyYyA9IGZzeC5yZWFkRmlsZVgoZW52RmlsZXBhdGgpXG4gIGNvbnN0IGVudlBhcnNlZCA9IGRvdGVudlBhcnNlKGVudlNyYylcblxuICBsZXQgcHVibGljS2V5TmFtZVxuICBmb3IgKGNvbnN0IGtleU5hbWUgb2YgT2JqZWN0LmtleXMoZW52UGFyc2VkKSkge1xuICAgIGlmIChrZXlOYW1lID09PSBQVUJMSUNfS0VZX1NDSEVNQSB8fCBrZXlOYW1lLnN0YXJ0c1dpdGgoUFVCTElDX0tFWV9TQ0hFTUEpKSB7XG4gICAgICBwdWJsaWNLZXlOYW1lID0ga2V5TmFtZSAvLyBmaW5kIERPVEVOVl9QVUJMSUNfS0VZKiBpbiBmaWxlbmFtZVxuICAgIH1cbiAgfVxuXG4gIGlmIChwdWJsaWNLZXlOYW1lKSB7XG4gICAgcmV0dXJuIHB1YmxpY0tleU5hbWUucmVwbGFjZShQVUJMSUNfS0VZX1NDSEVNQSwgUFJJVkFURV9LRVlfU0NIRU1BKSAvLyByZXR1cm4gaW52ZXJ0ZWQgKERPVEVOVl9QVUJMSUNfS0VZKiAtPiBET1RFTlZfUFJJVkFURV9LRVkqKSBpZiBmb3VuZFxuICB9XG5cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gc21hcnREb3RlbnZQcml2YXRlS2V5IChlbnZGaWxlcGF0aCwgZW52S2V5c0ZpbGVwYXRoID0gbnVsbCkge1xuICBsZXQgcHJpdmF0ZUtleSA9IG51bGxcbiAgbGV0IHByaXZhdGVLZXlOYW1lID0gZ3Vlc3NQcml2YXRlS2V5TmFtZShlbnZGaWxlcGF0aCkgLy8gRE9URU5WX1BSSVZBVEVfS0VZXyR7RU5WSVJPTk1FTlR9XG5cbiAgLy8gMS4gYXR0ZW1wdCBwcm9jZXNzLmVudiBmaXJzdFxuICBwcml2YXRlS2V5ID0gc2VhcmNoUHJvY2Vzc0Vudihwcml2YXRlS2V5TmFtZSlcbiAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICByZXR1cm4gcHJpdmF0ZUtleVxuICB9XG5cbiAgLy8gMi4gYXR0ZW1wdCAuZW52LmtleXMgc2Vjb25kIChwYXRoL3RvLy5lbnYua2V5cylcbiAgcHJpdmF0ZUtleSA9IHNlYXJjaEtleXNGaWxlKHByaXZhdGVLZXlOYW1lLCBlbnZGaWxlcGF0aCwgZW52S2V5c0ZpbGVwYXRoKVxuICBpZiAocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5XG4gIH1cblxuICAvLyAzLiBhdHRlbXB0IGludmVydGluZyBgRE9URU5WX1BVQkxJQ19LRVkqYCBuYW1lIGluc2lkZSBmaWxlICh1bmxvY2tzIGN1c3RvbSBmaWxlbmFtZXMgbm90IG1hdGNoaW5nIC5lbnYuJHtFTlZJUk9OTUVOVH0gcGF0dGVybilcbiAgcHJpdmF0ZUtleU5hbWUgPSBpbnZlcnRGb3JQcml2YXRlS2V5TmFtZShlbnZGaWxlcGF0aClcbiAgaWYgKHByaXZhdGVLZXlOYW1lKSB7XG4gICAgLy8gMy4xIGF0dGVtcHQgcHJvY2Vzcy5lbnYgZmlyc3RcbiAgICBwcml2YXRlS2V5ID0gc2VhcmNoUHJvY2Vzc0Vudihwcml2YXRlS2V5TmFtZSlcbiAgICBpZiAocHJpdmF0ZUtleSkge1xuICAgICAgcmV0dXJuIHByaXZhdGVLZXlcbiAgICB9XG5cbiAgICAvLyAzLjIuIGF0dGVtcHQgLmVudi5rZXlzIHNlY29uZCAocGF0aC90by8uZW52LmtleXMpXG4gICAgcHJpdmF0ZUtleSA9IHNlYXJjaEtleXNGaWxlKHByaXZhdGVLZXlOYW1lLCBlbnZGaWxlcGF0aCwgZW52S2V5c0ZpbGVwYXRoKVxuICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICByZXR1cm4gcHJpdmF0ZUtleVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc21hcnREb3RlbnZQcml2YXRlS2V5XG4iLCJjb25zdCBmc3ggPSByZXF1aXJlKCcuL2ZzeCcpXG5jb25zdCBkb3RlbnZQYXJzZSA9IHJlcXVpcmUoJy4vZG90ZW52UGFyc2UnKVxuXG5jb25zdCBndWVzc1B1YmxpY0tleU5hbWUgPSByZXF1aXJlKCcuL2d1ZXNzUHVibGljS2V5TmFtZScpXG5cbmZ1bmN0aW9uIHNlYXJjaFByb2Nlc3NFbnYgKHB1YmxpY0tleU5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52W3B1YmxpY0tleU5hbWVdICYmIHByb2Nlc3MuZW52W3B1YmxpY0tleU5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnZbcHVibGljS2V5TmFtZV1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZWFyY2hFbnZGaWxlIChwdWJsaWNLZXlOYW1lLCBlbnZGaWxlcGF0aCkge1xuICBpZiAoZnN4LmV4aXN0c1N5bmMoZW52RmlsZXBhdGgpKSB7XG4gICAgY29uc3Qga2V5c1NyYyA9IGZzeC5yZWFkRmlsZVgoZW52RmlsZXBhdGgpXG4gICAgY29uc3Qga2V5c1BhcnNlZCA9IGRvdGVudlBhcnNlKGtleXNTcmMpXG5cbiAgICBpZiAoa2V5c1BhcnNlZFtwdWJsaWNLZXlOYW1lXSAmJiBrZXlzUGFyc2VkW3B1YmxpY0tleU5hbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBrZXlzUGFyc2VkW3B1YmxpY0tleU5hbWVdXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNtYXJ0RG90ZW52UHVibGljS2V5IChlbnZGaWxlcGF0aCkge1xuICBsZXQgcHVibGljS2V5ID0gbnVsbFxuICBjb25zdCBwdWJsaWNLZXlOYW1lID0gZ3Vlc3NQdWJsaWNLZXlOYW1lKGVudkZpbGVwYXRoKSAvLyBET1RFTlZfUFVCTElDX0tFWV8ke0VOVklST05NRU5UfVxuXG4gIC8vIDEuIGF0dGVtcHQgcHJvY2Vzcy5lbnYgZmlyc3RcbiAgcHVibGljS2V5ID0gc2VhcmNoUHJvY2Vzc0VudihwdWJsaWNLZXlOYW1lKVxuICBpZiAocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHB1YmxpY0tleVxuICB9XG5cbiAgLy8gMi4gYXR0ZW1wdCAuZW52LmtleXMgc2Vjb25kIChwYXRoL3RvLy5lbnYua2V5cylcbiAgcHVibGljS2V5ID0gc2VhcmNoRW52RmlsZShwdWJsaWNLZXlOYW1lLCBlbnZGaWxlcGF0aClcbiAgaWYgKHB1YmxpY0tleSkge1xuICAgIHJldHVybiBwdWJsaWNLZXlcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0gc21hcnREb3RlbnZQdWJsaWNLZXlcbiIsImZ1bmN0aW9uIHRydW5jYXRlIChzdHIsIHNob3dDaGFyID0gNykge1xuICBpZiAoc3RyICYmIHN0ci5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdmlzaWJsZVBhcnQgPSBzdHIuc2xpY2UoMCwgc2hvd0NoYXIpXG4gICAgcmV0dXJuIHZpc2libGVQYXJ0ICsgJ+KApidcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRydW5jYXRlXG4iLCIvLyBAdHMtY2hlY2tcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLy8gc2hhcmVkXG5jb25zdCB7IHNldExvZ0xldmVsLCBzZXRMb2dOYW1lLCBzZXRMb2dWZXJzaW9uLCBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vLi4vc2hhcmVkL2xvZ2dlcicpXG5jb25zdCB7IGdldENvbG9yLCBib2xkIH0gPSByZXF1aXJlKCcuLy4uL3NoYXJlZC9jb2xvcnMnKVxuXG4vLyBzZXJ2aWNlc1xuY29uc3QgTHMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL2xzJylcbmNvbnN0IFJ1biA9IHJlcXVpcmUoJy4vc2VydmljZXMvcnVuJylcbmNvbnN0IFNldHMgPSByZXF1aXJlKCcuL3NlcnZpY2VzL3NldHMnKVxuY29uc3QgR2V0ID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9nZXQnKVxuY29uc3QgS2V5cGFpciA9IHJlcXVpcmUoJy4vc2VydmljZXMva2V5cGFpcicpXG5jb25zdCBHZW5leGFtcGxlID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9nZW5leGFtcGxlJylcbmNvbnN0IFJhZGFyID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy9yYWRhcicpXG5cbi8vIGhlbHBlcnNcbmNvbnN0IGJ1aWxkRW52cyA9IHJlcXVpcmUoJy4vaGVscGVycy9idWlsZEVudnMnKVxuY29uc3QgUGFyc2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvcGFyc2UnKVxuY29uc3QgZnN4ID0gcmVxdWlyZSgnLi9oZWxwZXJzL2ZzeCcpXG5jb25zdCBpc0lnbm9yaW5nRG90ZW52S2V5cyA9IHJlcXVpcmUoJy4vaGVscGVycy9pc0lnbm9yaW5nRG90ZW52S2V5cycpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21haW4nKS5jb25maWd9ICovXG5jb25zdCBjb25maWcgPSBmdW5jdGlvbiAob3B0aW9ucyA9IHt9KSB7XG4gIC8vIGFsbG93IHVzZXIgdG8gc2V0IHByb2Nlc3NFbnYgdG8gd3JpdGUgdG9cbiAgbGV0IHByb2Nlc3NFbnYgPSBwcm9jZXNzLmVudlxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnByb2Nlc3NFbnYgIT0gbnVsbCkge1xuICAgIHByb2Nlc3NFbnYgPSBvcHRpb25zLnByb2Nlc3NFbnZcbiAgfVxuXG4gIC8vIG92ZXJsb2FkXG4gIGNvbnN0IG92ZXJsb2FkID0gb3B0aW9ucy5vdmVybG9hZCB8fCBvcHRpb25zLm92ZXJyaWRlXG5cbiAgLy8gaWdub3JlXG4gIGNvbnN0IGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlIHx8IFtdXG5cbiAgLy8gc3RyaWN0XG4gIGNvbnN0IHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG5cbiAgLy8gZW52S2V5c0ZpbGVcbiAgY29uc3QgZW52S2V5c0ZpbGUgPSBvcHRpb25zLmVudktleXNGaWxlXG5cbiAgLy8gRE9URU5WX0tFWSAoREVQUkVDQVRFRClcbiAgbGV0IERPVEVOVl9LRVkgPSBwcm9jZXNzLmVudi5ET1RFTlZfS0VZXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuRE9URU5WX0tFWSkge1xuICAgIERPVEVOVl9LRVkgPSBvcHRpb25zLkRPVEVOVl9LRVlcbiAgfVxuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc2V0TG9nTGV2ZWwob3B0aW9ucylcbiAgICBzZXRMb2dOYW1lKG9wdGlvbnMpXG4gICAgc2V0TG9nVmVyc2lvbihvcHRpb25zKVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlbnZzID0gYnVpbGRFbnZzKG9wdGlvbnMsIERPVEVOVl9LRVkpXG4gICAgY29uc3Qge1xuICAgICAgYmVmb3JlRW52LFxuICAgICAgYWZ0ZXJFbnYsXG4gICAgICBwcm9jZXNzZWRFbnZzLFxuICAgICAgcmVhZGFibGVGaWxlcGF0aHMsXG4gICAgICB1bmlxdWVJbmplY3RlZEtleXNcbiAgICB9ID0gbmV3IFJ1bihlbnZzLCBvdmVybG9hZCwgRE9URU5WX0tFWSwgcHJvY2Vzc0VudiwgZW52S2V5c0ZpbGUpLnJ1bigpXG5cbiAgICB0cnkgeyBuZXcgUmFkYXIoKS5vYnNlcnZlKHsgYmVmb3JlRW52LCBwcm9jZXNzZWRFbnZzLCBhZnRlckVudiB9KSB9IGNhdGNoIHt9XG5cbiAgICBsZXQgbGFzdEVycm9yXG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHBhcnNlZEFsbCA9IHt9XG4gICAgZm9yIChjb25zdCBwcm9jZXNzZWRFbnYgb2YgcHJvY2Vzc2VkRW52cykge1xuICAgICAgaWYgKHByb2Nlc3NlZEVudi50eXBlID09PSAnZW52VmF1bHRGaWxlJykge1xuICAgICAgICBsb2dnZXIudmVyYm9zZShgbG9hZGluZyBlbnYgZnJvbSBlbmNyeXB0ZWQgJHtwcm9jZXNzZWRFbnYuZmlsZXBhdGh9ICgke3BhdGgucmVzb2x2ZShwcm9jZXNzZWRFbnYuZmlsZXBhdGgpfSlgKVxuICAgICAgICBsb2dnZXIuZGVidWcoYGRlY3J5cHRpbmcgZW5jcnlwdGVkIGVudiBmcm9tICR7cHJvY2Vzc2VkRW52LmZpbGVwYXRofSAoJHtwYXRoLnJlc29sdmUocHJvY2Vzc2VkRW52LmZpbGVwYXRoKX0pYClcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3NlZEVudi50eXBlID09PSAnZW52RmlsZScpIHtcbiAgICAgICAgbG9nZ2VyLnZlcmJvc2UoYGxvYWRpbmcgZW52IGZyb20gJHtwcm9jZXNzZWRFbnYuZmlsZXBhdGh9ICgke3BhdGgucmVzb2x2ZShwcm9jZXNzZWRFbnYuZmlsZXBhdGgpfSlgKVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGVycm9yIG9mIHByb2Nlc3NlZEVudi5lcnJvcnMgfHwgW10pIHtcbiAgICAgICAgaWYgKGlnbm9yZS5pbmNsdWRlcyhlcnJvci5jb2RlKSkge1xuICAgICAgICAgIGxvZ2dlci52ZXJib3NlKGBpZ25vcmVkOiAke2Vycm9yLm1lc3NhZ2V9YClcbiAgICAgICAgICBjb250aW51ZSAvLyBpZ25vcmUgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHRocm93IGVycm9yIC8vIHRocm93IGlmIHN0cmljdCBhbmQgbm90IGlnbm9yZWRcblxuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciAvLyBzdXJmYWNlIGxhdGVyIGluIHsgZXJyb3IgfVxuXG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSAnTUlTU0lOR19FTlZfRklMRScpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuY29udmVudGlvbikgeyAvLyBkbyBub3Qgb3V0cHV0IGVycm9yIGZvciBjb252ZW50aW9ucyAodG9vIG5vaXN5KVxuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICBpZiAoZXJyb3IuaGVscCkge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IuaGVscClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgaWYgKGVycm9yLmhlbHApIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnJvci5oZWxwKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKHBhcnNlZEFsbCwgcHJvY2Vzc2VkRW52LmluamVjdGVkIHx8IHt9KVxuICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRBbGwsIHByb2Nlc3NlZEVudi5wcmVFeGlzdGVkIHx8IHt9KSAvLyBwcmVFeGlzdGVkICd3aW5zJ1xuXG4gICAgICAvLyBkZWJ1ZyBwYXJzZWRcbiAgICAgIGxvZ2dlci5kZWJ1Zyhwcm9jZXNzZWRFbnYucGFyc2VkKVxuXG4gICAgICAvLyB2ZXJib3NlL2RlYnVnIGluamVjdGVkIGtleS92YWx1ZVxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvY2Vzc2VkRW52LmluamVjdGVkIHx8IHt9KSkge1xuICAgICAgICBsb2dnZXIudmVyYm9zZShgJHtrZXl9IHNldGApXG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtrZXl9IHNldCB0byAke3ZhbHVlfWApXG4gICAgICB9XG5cbiAgICAgIC8vIHZlcmJvc2UvZGVidWcgcHJlRXhpc3RlZCBrZXkvdmFsdWVcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb2Nlc3NlZEVudi5wcmVFeGlzdGVkIHx8IHt9KSkge1xuICAgICAgICBsb2dnZXIudmVyYm9zZShgJHtrZXl9IHByZS1leGlzdHMgKHByb3RpcDogdXNlIC0tb3ZlcmxvYWQgdG8gb3ZlcnJpZGUpYClcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2tleX0gcHJlLWV4aXN0cyBhcyAke3ZhbHVlfSAocHJvdGlwOiB1c2UgLS1vdmVybG9hZCB0byBvdmVycmlkZSlgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBtc2cgPSBgaW5qZWN0aW5nIGVudiAoJHt1bmlxdWVJbmplY3RlZEtleXMubGVuZ3RofSlgXG4gICAgaWYgKHJlYWRhYmxlRmlsZXBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1zZyArPSBgIGZyb20gJHtyZWFkYWJsZUZpbGVwYXRocy5qb2luKCcsICcpfWBcbiAgICB9XG4gICAgbG9nZ2VyLnN1Y2Nlc3N2KG1zZylcblxuICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsLCBlcnJvcjogbGFzdEVycm9yIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWRBbGwgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoc3RyaWN0KSB0aHJvdyBlcnJvciAvLyB0aHJvdyBpbW1lZGlhdGVseSBpZiBzdHJpY3RcblxuICAgIGxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKVxuICAgIGlmIChlcnJvci5oZWxwKSB7XG4gICAgICBsb2dnZXIuaGVscChlcnJvci5oZWxwKVxuICAgIH1cblxuICAgIHJldHVybiB7IHBhcnNlZDoge30sIGVycm9yIH1cbiAgfVxufVxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9tYWluJykucGFyc2V9ICovXG5jb25zdCBwYXJzZSA9IGZ1bmN0aW9uIChzcmMsIG9wdGlvbnMgPSB7fSkge1xuICAvLyBhbGxvdyB1c2VyIHRvIHNldCBwcm9jZXNzRW52IHRvIHJlYWQgZnJvbVxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgLy8gcHJpdmF0ZSBkZWNyeXB0aW9uIGtleVxuICBjb25zdCBwcml2YXRlS2V5ID0gb3B0aW9ucy5wcml2YXRlS2V5IHx8IG51bGxcblxuICAvLyBvdmVybG9hZFxuICBjb25zdCBvdmVybG9hZCA9IG9wdGlvbnMub3ZlcmxvYWQgfHwgb3B0aW9ucy5vdmVycmlkZVxuXG4gIGNvbnN0IHsgcGFyc2VkLCBlcnJvcnMgfSA9IG5ldyBQYXJzZShzcmMsIHByaXZhdGVLZXksIHByb2Nlc3NFbnYsIG92ZXJsb2FkKS5ydW4oKVxuXG4gIC8vIGRpc3BsYXkgYW55IGVycm9yc1xuICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycykge1xuICAgIGxvZ2dlci5lcnJvcihlcnJvci5tZXNzYWdlKVxuICAgIGlmIChlcnJvci5oZWxwKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IuaGVscClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyc2VkXG59XG5cbi8qIEB0eXBlIHtpbXBvcnQoJy4vbWFpbicpLnNldH0gKi9cbmNvbnN0IHNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgLy8gZW5jcnlwdFxuICBsZXQgZW5jcnlwdCA9IHRydWVcbiAgaWYgKG9wdGlvbnMucGxhaW4pIHtcbiAgICBlbmNyeXB0ID0gZmFsc2VcbiAgfSBlbHNlIGlmIChvcHRpb25zLmVuY3J5cHQgPT09IGZhbHNlKSB7XG4gICAgZW5jcnlwdCA9IGZhbHNlXG4gIH1cblxuICBjb25zdCBlbnZzID0gYnVpbGRFbnZzKG9wdGlvbnMpXG4gIGNvbnN0IGVudktleXNGaWxlcGF0aCA9IG9wdGlvbnMuZW52S2V5c0ZpbGVcblxuICBjb25zdCB7XG4gICAgcHJvY2Vzc2VkRW52cyxcbiAgICBjaGFuZ2VkRmlsZXBhdGhzLFxuICAgIHVuY2hhbmdlZEZpbGVwYXRoc1xuICB9ID0gbmV3IFNldHMoa2V5LCB2YWx1ZSwgZW52cywgZW5jcnlwdCwgZW52S2V5c0ZpbGVwYXRoKS5ydW4oKVxuXG4gIGxldCB3aXRoRW5jcnlwdGlvbiA9ICcnXG5cbiAgaWYgKGVuY3J5cHQpIHtcbiAgICB3aXRoRW5jcnlwdGlvbiA9ICcgd2l0aCBlbmNyeXB0aW9uJ1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9jZXNzZWRFbnYgb2YgcHJvY2Vzc2VkRW52cykge1xuICAgIGxvZ2dlci52ZXJib3NlKGBzZXR0aW5nIGZvciAke3Byb2Nlc3NlZEVudi5lbnZGaWxlcGF0aH1gKVxuXG4gICAgaWYgKHByb2Nlc3NlZEVudi5lcnJvcikge1xuICAgICAgaWYgKHByb2Nlc3NlZEVudi5lcnJvci5jb2RlID09PSAnTUlTU0lOR19FTlZfRklMRScpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4ocHJvY2Vzc2VkRW52LmVycm9yLm1lc3NhZ2UpXG4gICAgICAgIGxvZ2dlci5oZWxwKGA/IGFkZCBvbmUgd2l0aCBbZWNobyBcIkhFTExPPVdvcmxkXCIgPiAke3Byb2Nlc3NlZEVudi5lbnZGaWxlcGF0aH1dIGFuZCByZS1ydW4gW2RvdGVudnggc2V0XWApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIud2Fybihwcm9jZXNzZWRFbnYuZXJyb3IubWVzc2FnZSlcbiAgICAgICAgaWYgKHByb2Nlc3NlZEVudi5lcnJvci5oZWxwKSB7XG4gICAgICAgICAgbG9nZ2VyLmhlbHAocHJvY2Vzc2VkRW52LmVycm9yLmhlbHApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZnN4LndyaXRlRmlsZVgocHJvY2Vzc2VkRW52LmZpbGVwYXRoLCBwcm9jZXNzZWRFbnYuZW52U3JjKVxuXG4gICAgICBsb2dnZXIudmVyYm9zZShgJHtwcm9jZXNzZWRFbnYua2V5fSBzZXQke3dpdGhFbmNyeXB0aW9ufSAoJHtwcm9jZXNzZWRFbnYuZW52RmlsZXBhdGh9KWApXG4gICAgICBsb2dnZXIuZGVidWcoYCR7cHJvY2Vzc2VkRW52LmtleX0gc2V0JHt3aXRoRW5jcnlwdGlvbn0gdG8gJHtwcm9jZXNzZWRFbnYudmFsdWV9ICgke3Byb2Nlc3NlZEVudi5lbnZGaWxlcGF0aH0pYClcbiAgICB9XG4gIH1cblxuICBpZiAoY2hhbmdlZEZpbGVwYXRocy5sZW5ndGggPiAwKSB7XG4gICAgbG9nZ2VyLnN1Y2Nlc3MoYOKclCBzZXQgJHtrZXl9JHt3aXRoRW5jcnlwdGlvbn0gKCR7Y2hhbmdlZEZpbGVwYXRocy5qb2luKCcsJyl9KWApXG4gIH0gZWxzZSBpZiAodW5jaGFuZ2VkRmlsZXBhdGhzLmxlbmd0aCA+IDApIHtcbiAgICBsb2dnZXIuaW5mbyhgbm8gY2hhbmdlcyAoJHt1bmNoYW5nZWRGaWxlcGF0aHN9KWApXG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgZm9yIChjb25zdCBwcm9jZXNzZWRFbnYgb2YgcHJvY2Vzc2VkRW52cykge1xuICAgIGlmIChwcm9jZXNzZWRFbnYucHJpdmF0ZUtleUFkZGVkKSB7XG4gICAgICBsb2dnZXIuc3VjY2Vzcyhg4pyUIGtleSBhZGRlZCB0byAke3Byb2Nlc3NlZEVudi5lbnZLZXlzRmlsZXBhdGh9ICgke3Byb2Nlc3NlZEVudi5wcml2YXRlS2V5TmFtZX0pYClcblxuICAgICAgaWYgKCFpc0lnbm9yaW5nRG90ZW52S2V5cygpKSB7XG4gICAgICAgIGxvZ2dlci5oZWxwKCfirpUgIG5leHQgcnVuIFtkb3RlbnZ4IGV4dCBnaXRpZ25vcmUgLS1wYXR0ZXJuIC5lbnYua2V5c10gdG8gZ2l0aWdub3JlIC5lbnYua2V5cycpXG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5oZWxwKGDirpUgIG5leHQgcnVuIFske3Byb2Nlc3NlZEVudi5wcml2YXRlS2V5TmFtZX09JyR7cHJvY2Vzc2VkRW52LnByaXZhdGVLZXl9JyBkb3RlbnZ4IGdldCAke2tleX1dIHRvIHRlc3QgZGVjcnlwdGlvbiBsb2NhbGx5YClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NlZEVudnMsXG4gICAgY2hhbmdlZEZpbGVwYXRocyxcbiAgICB1bmNoYW5nZWRGaWxlcGF0aHNcbiAgfVxufVxuXG4vKiBAdHlwZSB7aW1wb3J0KCcuL21haW4nKS5nZXR9ICovXG5jb25zdCBnZXQgPSBmdW5jdGlvbiAoa2V5LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgZW52cyA9IGJ1aWxkRW52cyhvcHRpb25zKVxuXG4gIC8vIGlnbm9yZVxuICBjb25zdCBpZ25vcmUgPSBvcHRpb25zLmlnbm9yZSB8fCBbXVxuXG4gIGNvbnN0IHsgcGFyc2VkLCBlcnJvcnMgfSA9IG5ldyBHZXQoa2V5LCBlbnZzLCBvcHRpb25zLm92ZXJsb2FkLCBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLCBvcHRpb25zLmFsbCwgb3B0aW9ucy5lbnZLZXlzRmlsZSkucnVuKClcblxuICBmb3IgKGNvbnN0IGVycm9yIG9mIGVycm9ycyB8fCBbXSkge1xuICAgIGlmIChpZ25vcmUuaW5jbHVkZXMoZXJyb3IuY29kZSkpIHtcbiAgICAgIGNvbnRpbnVlIC8vIGlnbm9yZSBlcnJvclxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnN0cmljdCkgdGhyb3cgZXJyb3IgLy8gdGhyb3cgaW1tZWRpYXRlbHkgaWYgc3RyaWN0XG5cbiAgICBsb2dnZXIuZXJyb3IoZXJyb3IubWVzc2FnZSlcbiAgICBpZiAoZXJyb3IuaGVscCkge1xuICAgICAgbG9nZ2VyLmVycm9yKGVycm9yLmhlbHApXG4gICAgfVxuICB9XG5cbiAgaWYgKGtleSkge1xuICAgIGNvbnN0IHNpbmdsZSA9IHBhcnNlZFtrZXldXG4gICAgaWYgKHNpbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaW5nbGVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnMuZm9ybWF0ID09PSAnZXZhbCcpIHtcbiAgICAgIGxldCBpbmxpbmUgPSAnJ1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyc2VkKSkge1xuICAgICAgICBpbmxpbmUgKz0gYCR7a2V5fT0ke2VzY2FwZSh2YWx1ZSl9XFxuYFxuICAgICAgfVxuICAgICAgaW5saW5lID0gaW5saW5lLnRyaW0oKVxuXG4gICAgICByZXR1cm4gaW5saW5lXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmZvcm1hdCA9PT0gJ3NoZWxsJykge1xuICAgICAgbGV0IGlubGluZSA9ICcnXG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJzZWQpKSB7XG4gICAgICAgIGlubGluZSArPSBgJHtrZXl9PSR7dmFsdWV9IGBcbiAgICAgIH1cbiAgICAgIGlubGluZSA9IGlubGluZS50cmltKClcblxuICAgICAgcmV0dXJuIGlubGluZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFyc2VkXG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21haW4nKS5sc30gKi9cbmNvbnN0IGxzID0gZnVuY3Rpb24gKGRpcmVjdG9yeSwgZW52RmlsZSwgZXhjbHVkZUVudkZpbGUpIHtcbiAgcmV0dXJuIG5ldyBMcyhkaXJlY3RvcnksIGVudkZpbGUsIGV4Y2x1ZGVFbnZGaWxlKS5ydW4oKVxufVxuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9tYWluJykuZ2VuZXhhbXBsZX0gKi9cbmNvbnN0IGdlbmV4YW1wbGUgPSBmdW5jdGlvbiAoZGlyZWN0b3J5LCBlbnZGaWxlKSB7XG4gIHJldHVybiBuZXcgR2VuZXhhbXBsZShkaXJlY3RvcnksIGVudkZpbGUpLnJ1bigpXG59XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL21haW4nKS5rZXlwYWlyfSAqL1xuY29uc3Qga2V5cGFpciA9IGZ1bmN0aW9uIChlbnZGaWxlLCBrZXksIGVudktleXNGaWxlID0gbnVsbCkge1xuICBjb25zdCBrZXlwYWlycyA9IG5ldyBLZXlwYWlyKGVudkZpbGUsIGVudktleXNGaWxlKS5ydW4oKVxuICBpZiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleXBhaXJzW2tleV1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ga2V5cGFpcnNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gZG90ZW52IHByb3hpZXNcbiAgY29uZmlnLFxuICBwYXJzZSxcbiAgLy8gYWN0aW9ucyByZWxhdGVkXG4gIHNldCxcbiAgZ2V0LFxuICBscyxcbiAga2V5cGFpcixcbiAgZ2VuZXhhbXBsZSxcbiAgLy8gZXhwb3NlIGZvciBsaWJzIGRlcGVuZGluZyBvbiBAZG90ZW52eC9kb3RlbnZ4IC0gbGlrZSBkb3RlbnZ4LXJhZGFyXG4gIHNldExvZ0xldmVsLFxuICBsb2dnZXIsXG4gIGdldENvbG9yLFxuICBib2xkXG59XG4iLCJjb25zdCBmc3ggPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZnN4JylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vaGVscGVycy9lcnJvcnMnKVxuY29uc3QgZmluZEVudkZpbGVzID0gcmVxdWlyZSgnLi4vaGVscGVycy9maW5kRW52RmlsZXMnKVxuY29uc3QgcmVwbGFjZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvcmVwbGFjZScpXG5jb25zdCBkb3RlbnZQYXJzZSA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvZG90ZW52UGFyc2UnKVxuXG5jbGFzcyBHZW5leGFtcGxlIHtcbiAgY29uc3RydWN0b3IgKGRpcmVjdG9yeSA9ICcuJywgZW52RmlsZSkge1xuICAgIHRoaXMuZGlyZWN0b3J5ID0gZGlyZWN0b3J5XG4gICAgdGhpcy5lbnZGaWxlID0gZW52RmlsZSB8fCBmaW5kRW52RmlsZXMoZGlyZWN0b3J5KVxuXG4gICAgdGhpcy5leGFtcGxlRmlsZW5hbWUgPSAnLmVudi5leGFtcGxlJ1xuICAgIHRoaXMuZXhhbXBsZUZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuZGlyZWN0b3J5LCB0aGlzLmV4YW1wbGVGaWxlbmFtZSlcbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgaWYgKHRoaXMuZW52RmlsZS5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gJ01JU1NJTkdfRU5WX0ZJTEVTJ1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdubyAuZW52KiBmaWxlcyBmb3VuZCdcbiAgICAgIGNvbnN0IGhlbHAgPSAnPyBhZGQgb25lIHdpdGggW2VjaG8gXCJIRUxMTz1Xb3JsZFwiID4gLmVudl0gYW5kIHRoZW4gcnVuIFtkb3RlbnZ4IGdlbmV4YW1wbGVdJ1xuXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgZXJyb3IuY29kZSA9IGNvZGVcbiAgICAgIGVycm9yLmhlbHAgPSBoZWxwXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KClcbiAgICBjb25zdCBhZGRlZEtleXMgPSBuZXcgU2V0KClcbiAgICBjb25zdCBlbnZGaWxlcGF0aHMgPSB0aGlzLl9lbnZGaWxlcGF0aHMoKVxuICAgIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICBjb25zdCBpbmplY3RlZCA9IHt9XG4gICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHByZUV4aXN0ZWQgPSB7fVxuXG4gICAgbGV0IGV4YW1wbGVTcmMgPSBgIyAke3RoaXMuZXhhbXBsZUZpbGVuYW1lfSAtIGdlbmVyYXRlZCB3aXRoIGRvdGVudnhcXG5gXG5cbiAgICBmb3IgKGNvbnN0IGVudkZpbGVwYXRoIG9mIGVudkZpbGVwYXRocykge1xuICAgICAgY29uc3QgZmlsZXBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5kaXJlY3RvcnksIGVudkZpbGVwYXRoKVxuICAgICAgaWYgKCFmc3guZXhpc3RzU3luYyhmaWxlcGF0aCkpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3JzKHsgZW52RmlsZXBhdGgsIGZpbGVwYXRoIH0pLm1pc3NpbmdFbnZGaWxlKClcbiAgICAgICAgZXJyb3IuaGVscCA9IGA/IGFkZCBpdCB3aXRoIFtlY2hvIFwiSEVMTE89V29ybGRcIiA+ICR7ZW52RmlsZXBhdGh9XSBhbmQgdGhlbiBydW4gW2RvdGVudnggZ2VuZXhhbXBsZV1gXG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgc3JjXG4gICAgICBsZXQgc3JjID0gZnN4LnJlYWRGaWxlWChmaWxlcGF0aClcbiAgICAgIGNvbnN0IHBhcnNlZCA9IGRvdGVudlBhcnNlKHNyYylcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcnNlZCkge1xuICAgICAgICAvLyB1c2VkIGxhdGVyXG4gICAgICAgIGtleXMuYWRkKGtleSlcblxuICAgICAgICAvLyBvbmNlIG5ld1NyYyBpcyBidWlsdCB3cml0ZSBpdCBvdXRcbiAgICAgICAgc3JjID0gcmVwbGFjZShzcmMsIGtleSwgJycpIC8vIGVtcHR5IHZhbHVlXG4gICAgICB9XG5cbiAgICAgIGV4YW1wbGVTcmMgKz0gYFxcbiR7c3JjfWBcbiAgICB9XG5cbiAgICBpZiAoIWZzeC5leGlzdHNTeW5jKHRoaXMuZXhhbXBsZUZpbGVwYXRoKSkge1xuICAgICAgLy8gaXQgZG9lc24ndCBleGlzdCBzbyBqdXN0IHdyaXRlIHRoaXMgZmlyc3QgZ2VuZXJhdGVkIG9uZVxuICAgICAgLy8gZXhhbXBsZVNyYyAtIGFscmVhZHkgd3JpdHRlbiB0byBmcm9tIHRoZSBwcmlvciBsb29wXG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBbLi4ua2V5c10pIHtcbiAgICAgICAgLy8gZXZlcnkga2V5IGlzIGFkZGVkIHNpbmNlIGl0J3MgdGhlIGZpcnN0IHRpbWUgZ2VuZXJhdGluZyAuZW52LmV4YW1wbGVcbiAgICAgICAgYWRkZWRLZXlzLmFkZChrZXkpXG5cbiAgICAgICAgaW5qZWN0ZWRba2V5XSA9ICcnXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGl0IGFscmVhZHkgZXhpc3RzICh3aGljaCBtZWFucyB0aGUgdXNlciBtaWdodCBoYXZlIGl0IG1vZGlmaWVkIGEgd2F5IGluIHdoaWNoIHRoZXkgcHJlZmVyLCBzbyByZXBsYWNlIGV4YW1wbGVTcmMgd2l0aCB0aGVpciBleGlzdGluZyAuZW52LmV4YW1wbGUpXG4gICAgICBleGFtcGxlU3JjID0gZnN4LnJlYWRGaWxlWCh0aGlzLmV4YW1wbGVGaWxlcGF0aClcblxuICAgICAgY29uc3QgcGFyc2VkID0gZG90ZW52UGFyc2UoZXhhbXBsZVNyYylcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIFsuLi5rZXlzXSkge1xuICAgICAgICBpZiAoa2V5IGluIHBhcnNlZCkge1xuICAgICAgICAgIHByZUV4aXN0ZWRba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhhbXBsZVNyYyArPSBgJHtrZXl9PScnXFxuYFxuXG4gICAgICAgICAgYWRkZWRLZXlzLmFkZChrZXkpXG5cbiAgICAgICAgICBpbmplY3RlZFtrZXldID0gJydcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbnZFeGFtcGxlRmlsZTogZXhhbXBsZVNyYyxcbiAgICAgIGVudkZpbGU6IHRoaXMuZW52RmlsZSxcbiAgICAgIGV4YW1wbGVGaWxlcGF0aDogdGhpcy5leGFtcGxlRmlsZXBhdGgsXG4gICAgICBhZGRlZEtleXM6IFsuLi5hZGRlZEtleXNdLFxuICAgICAgaW5qZWN0ZWQsXG4gICAgICBwcmVFeGlzdGVkXG4gICAgfVxuICB9XG5cbiAgX2VudkZpbGVwYXRocyAoKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZW52RmlsZSkpIHtcbiAgICAgIHJldHVybiBbdGhpcy5lbnZGaWxlXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVudkZpbGVcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdlbmV4YW1wbGVcbiIsImNvbnN0IFJ1biA9IHJlcXVpcmUoJy4vcnVuJylcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9lcnJvcnMnKVxuXG5jbGFzcyBHZXQge1xuICBjb25zdHJ1Y3RvciAoa2V5LCBlbnZzID0gW10sIG92ZXJsb2FkID0gZmFsc2UsIERPVEVOVl9LRVkgPSAnJywgYWxsID0gZmFsc2UsIGVudktleXNGaWxlcGF0aCA9IG51bGwpIHtcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIHRoaXMuZW52cyA9IGVudnNcbiAgICB0aGlzLm92ZXJsb2FkID0gb3ZlcmxvYWRcbiAgICB0aGlzLkRPVEVOVl9LRVkgPSBET1RFTlZfS0VZXG4gICAgdGhpcy5hbGwgPSBhbGxcbiAgICB0aGlzLmVudktleXNGaWxlcGF0aCA9IGVudktleXNGaWxlcGF0aFxuICB9XG5cbiAgcnVuICgpIHtcbiAgICBjb25zdCBwcm9jZXNzRW52ID0geyAuLi5wcm9jZXNzLmVudiB9XG4gICAgY29uc3QgeyBwcm9jZXNzZWRFbnZzIH0gPSBuZXcgUnVuKHRoaXMuZW52cywgdGhpcy5vdmVybG9hZCwgdGhpcy5ET1RFTlZfS0VZLCBwcm9jZXNzRW52LCB0aGlzLmVudktleXNGaWxlcGF0aCkucnVuKClcblxuICAgIGNvbnN0IGVycm9ycyA9IFtdXG4gICAgZm9yIChjb25zdCBwcm9jZXNzZWRFbnYgb2YgcHJvY2Vzc2VkRW52cykge1xuICAgICAgZm9yIChjb25zdCBlcnJvciBvZiBwcm9jZXNzZWRFbnYuZXJyb3JzKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmtleSkge1xuICAgICAgY29uc3QgcGFyc2VkID0ge31cbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvY2Vzc0Vudlt0aGlzLmtleV1cbiAgICAgIHBhcnNlZFt0aGlzLmtleV0gPSB2YWx1ZVxuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgRXJyb3JzKHsga2V5OiB0aGlzLmtleSB9KS5taXNzaW5nS2V5KCkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHBhcnNlZCwgZXJyb3JzIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdXNlciB3YW50cyB0byByZXR1cm4gQUxMIGVudnMgKGV2ZW4gcHJpb3Igc2V0IG9uIG1hY2hpbmUpXG4gICAgICBpZiAodGhpcy5hbGwpIHtcbiAgICAgICAgcmV0dXJuIHsgcGFyc2VkOiBwcm9jZXNzRW52LCBlcnJvcnMgfVxuICAgICAgfVxuXG4gICAgICAvLyB0eXBpY2FsIHNjZW5hcmlvIC0gcmV0dXJuIG9ubHkgZW52cyB0aGF0IHdlcmUgaWRlbnRpZmllZCBpbiB0aGUgLmVudiBmaWxlXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIHByb2Nlc3NlZEVudnMucGFyc2VkIGFuZCBncmFiIGZyb20gcHJvY2Vzc0VudlxuICAgICAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgICAgY29uc3QgcGFyc2VkID0ge31cbiAgICAgIGZvciAoY29uc3QgcHJvY2Vzc2VkRW52IG9mIHByb2Nlc3NlZEVudnMpIHtcbiAgICAgICAgLy8gcGFyc2VkIG1lYW5zIHdlIHNhdyB0aGUga2V5IGluIGEgZmlsZSBvciAtLWVudiBmbGFnLiB0aGlzIGVmZmVjdGl2ZWx5IGZpbHRlcnMgb3V0IGFueSBwcmVzZXQgbWFjaGluZSBlbnZzIC0gd2hpbGUgc3RpbGwgcmVzcGVjdGluZyBjb21wbGV4IGV2YWx1YXRpbmcsIGV4cGFuc2lvbiwgYW5kIG92ZXJsb2FkLiBpbiBvdGhlciB3b3JkcywgdGhlIHZhbHVlIG1pZ2h0IGJlIHRoZSBtYWNoaW5lIHZhbHVlIGJlY2F1c2UgdGhlIGtleSB3YXMgZGlzcGxheWVkIGluIGEgLmVudiBmaWxlXG4gICAgICAgIGlmIChwcm9jZXNzZWRFbnYucGFyc2VkKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocHJvY2Vzc2VkRW52LnBhcnNlZCkpIHtcbiAgICAgICAgICAgIHBhcnNlZFtrZXldID0gcHJvY2Vzc0VudltrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHBhcnNlZCwgZXJyb3JzIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHZXRcbiIsImNvbnN0IGd1ZXNzUHVibGljS2V5TmFtZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9ndWVzc1B1YmxpY0tleU5hbWUnKVxuY29uc3Qgc21hcnREb3RlbnZQdWJsaWNLZXkgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvc21hcnREb3RlbnZQdWJsaWNLZXknKVxuY29uc3QgZ3Vlc3NQcml2YXRlS2V5TmFtZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9ndWVzc1ByaXZhdGVLZXlOYW1lJylcbmNvbnN0IHNtYXJ0RG90ZW52UHJpdmF0ZUtleSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9zbWFydERvdGVudlByaXZhdGVLZXknKVxuXG5jbGFzcyBLZXlwYWlyIHtcbiAgY29uc3RydWN0b3IgKGVudkZpbGUgPSAnLmVudicsIGVudktleXNGaWxlcGF0aCA9IG51bGwpIHtcbiAgICB0aGlzLmVudkZpbGUgPSBlbnZGaWxlXG4gICAgdGhpcy5lbnZLZXlzRmlsZXBhdGggPSBlbnZLZXlzRmlsZXBhdGhcbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgY29uc3Qgb3V0ID0ge31cblxuICAgIGNvbnN0IGVudkZpbGVwYXRocyA9IHRoaXMuX2VudkZpbGVwYXRocygpXG4gICAgZm9yIChjb25zdCBlbnZGaWxlcGF0aCBvZiBlbnZGaWxlcGF0aHMpIHtcbiAgICAgIC8vIHB1YmxpYyBrZXlcbiAgICAgIGNvbnN0IHB1YmxpY0tleU5hbWUgPSBndWVzc1B1YmxpY0tleU5hbWUoZW52RmlsZXBhdGgpXG4gICAgICBjb25zdCBwdWJsaWNLZXlWYWx1ZSA9IHNtYXJ0RG90ZW52UHVibGljS2V5KGVudkZpbGVwYXRoKVxuICAgICAgb3V0W3B1YmxpY0tleU5hbWVdID0gcHVibGljS2V5VmFsdWVcblxuICAgICAgLy8gcHJpdmF0ZSBrZXlcbiAgICAgIGNvbnN0IHByaXZhdGVLZXlOYW1lID0gZ3Vlc3NQcml2YXRlS2V5TmFtZShlbnZGaWxlcGF0aClcbiAgICAgIGNvbnN0IHByaXZhdGVLZXlWYWx1ZSA9IHNtYXJ0RG90ZW52UHJpdmF0ZUtleShlbnZGaWxlcGF0aCwgdGhpcy5lbnZLZXlzRmlsZXBhdGgpXG5cbiAgICAgIG91dFtwcml2YXRlS2V5TmFtZV0gPSBwcml2YXRlS2V5VmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBfZW52RmlsZXBhdGhzICgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5lbnZGaWxlKSkge1xuICAgICAgcmV0dXJuIFt0aGlzLmVudkZpbGVdXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZW52RmlsZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5cGFpclxuIiwiY29uc3QgeyBmZGlyOiBGZGlyIH0gPSByZXF1aXJlKCdmZGlyJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHBpY29tYXRjaCA9IHJlcXVpcmUoJ3BpY29tYXRjaCcpXG5cbmNsYXNzIExzIHtcbiAgY29uc3RydWN0b3IgKGRpcmVjdG9yeSA9ICcuLycsIGVudkZpbGUgPSBbJy5lbnYqJ10sIGV4Y2x1ZGVFbnZGaWxlID0gW10pIHtcbiAgICB0aGlzLmlnbm9yZSA9IFsnbm9kZV9tb2R1bGVzLyoqJywgJy5naXQvKionXVxuXG4gICAgdGhpcy5jd2QgPSBwYXRoLnJlc29sdmUoZGlyZWN0b3J5KVxuICAgIHRoaXMuZW52RmlsZSA9IGVudkZpbGVcbiAgICB0aGlzLmV4Y2x1ZGVFbnZGaWxlID0gZXhjbHVkZUVudkZpbGVcbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVwYXRocygpXG4gIH1cblxuICBfZmlsZXBhdGhzICgpIHtcbiAgICBjb25zdCBleGNsdWRlID0gcGljb21hdGNoKHRoaXMuX2V4Y2x1ZGUoKSlcbiAgICBjb25zdCBpbmNsdWRlID0gcGljb21hdGNoKHRoaXMuX3BhdHRlcm5zKCksIHtcbiAgICAgIGlnbm9yZTogdGhpcy5fZXhjbHVkZSgpXG4gICAgfSlcblxuICAgIHJldHVybiBuZXcgRmRpcigpXG4gICAgICAud2l0aFJlbGF0aXZlUGF0aHMoKVxuICAgICAgLmV4Y2x1ZGUoKGRpciwgcGF0aCkgPT4gZXhjbHVkZShwYXRoKSlcbiAgICAgIC5maWx0ZXIoKHBhdGgpID0+IGluY2x1ZGUocGF0aCkpXG4gICAgICAuY3Jhd2wodGhpcy5jd2QpXG4gICAgICAuc3luYygpXG4gIH1cblxuICBfcGF0dGVybnMgKCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmVudkZpbGUpKSB7XG4gICAgICByZXR1cm4gW2AqKi8ke3RoaXMuZW52RmlsZX1gXVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVudkZpbGUubWFwKHBhcnQgPT4gYCoqLyR7cGFydH1gKVxuICB9XG5cbiAgX2V4Y2x1ZGVQYXR0ZXJucyAoKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZXhjbHVkZUVudkZpbGUpKSB7XG4gICAgICByZXR1cm4gW2AqKi8ke3RoaXMuZXhjbHVkZUVudkZpbGV9YF1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5leGNsdWRlRW52RmlsZS5tYXAocGFydCA9PiBgKiovJHtwYXJ0fWApXG4gIH1cblxuICBfZXhjbHVkZSAoKSB7XG4gICAgaWYgKHRoaXMuX2V4Y2x1ZGVQYXR0ZXJucygpLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmlnbm9yZS5jb25jYXQodGhpcy5fZXhjbHVkZVBhdHRlcm5zKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmlnbm9yZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExzXG4iLCJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjaGlsZFByb2Nlc3MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJylcblxuY29uc3QgeyBsb2dnZXIgfSA9IHJlcXVpcmUoJy4vLi4vLi4vc2hhcmVkL2xvZ2dlcicpXG5cbmNsYXNzIFJhZGFyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmFkYXJMaWIgPSBudWxsXG5cbiAgICAvLyBjaGVjayBucG0gbGliXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmFkYXJMaWIgPSB0aGlzLl9yYWRhck5wbSgpXG4gICAgICBsb2dnZXIuc3VjY2Vzc3YoYPCfk6EgcmFkYXI6ICR7dGhpcy5yYWRhckxpYi5zdGF0dXN9YClcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBjaGVjayBiaW5hcnkgY2xpXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJhZGFyTGliID0gdGhpcy5fcmFkYXJDbGkoKVxuICAgICAgICBsb2dnZXIuc3VjY2Vzc3YoYPCfk6EgcmFkYXI6ICR7dGhpcy5yYWRhckxpYi5zdGF0dXN9YClcbiAgICAgIH0gY2F0Y2ggKF9lMikge1xuICAgICAgICAvLyBub29wXG4gICAgICB9XG4gICAgICAvLyBub29wXG4gICAgfVxuICB9XG5cbiAgb2JzZXJ2ZSAocGF5bG9hZCkge1xuICAgIGlmICh0aGlzLnJhZGFyTGliICYmIHRoaXMucmFkYXJMaWIuc3RhdHVzICE9PSAnb2ZmJykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuZW5jb2RlKHBheWxvYWQpXG4gICAgICB0aGlzLnJhZGFyTGliLm9ic2VydmUoZW5jb2RlZClcbiAgICB9XG4gIH1cblxuICBlbmNvZGUgKHBheWxvYWQpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpLnRvU3RyaW5nKCdiYXNlNjQnKVxuICB9XG5cbiAgX3JhZGFyTnBtICgpIHtcbiAgICBjb25zdCBmYWxsYmFja0JpbiA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnbm9kZV9tb2R1bGVzLy5iaW4vZG90ZW52eC1yYWRhcicpXG4gICAgY29uc3Qgc3RhdHVzID0gY2hpbGRQcm9jZXNzLmV4ZWNTeW5jKGAke2ZhbGxiYWNrQmlufSBzdGF0dXNgLCB7IHN0ZGlvOiBbJ3BpcGUnLCAncGlwZScsICdpZ25vcmUnXSB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogc3RhdHVzLnRvU3RyaW5nKCkudHJpbSgpLFxuICAgICAgb2JzZXJ2ZTogKGVuY29kZWQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdWJwcm9jZXNzID0gY2hpbGRQcm9jZXNzLnNwYXduKGZhbGxiYWNrQmluLCBbJ29ic2VydmUnLCBlbmNvZGVkXSwge1xuICAgICAgICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWVcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgc3VicHJvY2Vzcy51bnJlZigpIC8vIGxldCBpdCBydW4gaW5kZXBlbmRlbnRseVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3JhZGFyQ2xpICgpIHtcbiAgICBjb25zdCBzdGF0dXMgPSBjaGlsZFByb2Nlc3MuZXhlY1N5bmMoJ2RvdGVudngtcmFkYXIgc3RhdHVzJywgeyBzdGRpbzogWydwaXBlJywgJ3BpcGUnLCAnaWdub3JlJ10gfSlcblxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHN0YXR1cy50b1N0cmluZygpLnRyaW0oKSxcbiAgICAgIG9ic2VydmU6IChlbmNvZGVkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3VicHJvY2VzcyA9IGNoaWxkUHJvY2Vzcy5zcGF3bignZG90ZW52eC1yYWRhcicsIFsnb2JzZXJ2ZScsIGVuY29kZWRdLCB7XG4gICAgICAgICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgICAgICAgICBkZXRhY2hlZDogdHJ1ZVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICBzdWJwcm9jZXNzLnVucmVmKCkgLy8gbGV0IGl0IHJ1biBpbmRlcGVuZGVudGx5XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSYWRhclxuIiwiY29uc3QgZnN4ID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2ZzeCcpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IFRZUEVfRU5WID0gJ2VudidcbmNvbnN0IFRZUEVfRU5WX0ZJTEUgPSAnZW52RmlsZSdcbmNvbnN0IFRZUEVfRU5WX1ZBVUxUX0ZJTEUgPSAnZW52VmF1bHRGaWxlJ1xuXG5jb25zdCBkZWNyeXB0ID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RlY3J5cHQnKVxuY29uc3QgUGFyc2UgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2UnKVxuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Vycm9ycycpXG5jb25zdCBkb3RlbnZQYXJzZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kb3RlbnZQYXJzZScpXG5jb25zdCBwYXJzZUVudmlyb25tZW50RnJvbURvdGVudktleSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUVudmlyb25tZW50RnJvbURvdGVudktleScpXG5jb25zdCBkZXRlY3RFbmNvZGluZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZXRlY3RFbmNvZGluZycpXG5jb25zdCB7IGZpbmRQcml2YXRlS2V5IH0gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZmluZFByaXZhdGVLZXknKVxuY29uc3QgZ3Vlc3NQcml2YXRlS2V5TmFtZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9ndWVzc1ByaXZhdGVLZXlOYW1lJylcbmNvbnN0IGRldGVybWluZUVudnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGV0ZXJtaW5lRW52cycpXG5cbmNsYXNzIFJ1biB7XG4gIGNvbnN0cnVjdG9yIChlbnZzID0gW10sIG92ZXJsb2FkID0gZmFsc2UsIERPVEVOVl9LRVkgPSAnJywgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52LCBlbnZLZXlzRmlsZXBhdGggPSBudWxsKSB7XG4gICAgdGhpcy5lbnZzID0gZGV0ZXJtaW5lRW52cyhlbnZzLCBwcm9jZXNzRW52LCBET1RFTlZfS0VZKVxuICAgIHRoaXMub3ZlcmxvYWQgPSBvdmVybG9hZFxuICAgIHRoaXMuRE9URU5WX0tFWSA9IERPVEVOVl9LRVlcbiAgICB0aGlzLnByb2Nlc3NFbnYgPSBwcm9jZXNzRW52XG4gICAgdGhpcy5lbnZLZXlzRmlsZXBhdGggPSBlbnZLZXlzRmlsZXBhdGhcblxuICAgIHRoaXMucHJvY2Vzc2VkRW52cyA9IFtdXG4gICAgdGhpcy5yZWFkYWJsZUZpbGVwYXRocyA9IG5ldyBTZXQoKVxuICAgIHRoaXMucmVhZGFibGVTdHJpbmdzID0gbmV3IFNldCgpXG4gICAgdGhpcy51bmlxdWVJbmplY3RlZEtleXMgPSBuZXcgU2V0KClcbiAgICB0aGlzLmJlZm9yZUVudiA9IHsgLi4udGhpcy5wcm9jZXNzRW52IH1cbiAgfVxuXG4gIHJ1biAoKSB7XG4gICAgLy8gZXhhbXBsZVxuICAgIC8vIGVudnMgW1xuICAgIC8vICAgeyB0eXBlOiAnZW52VmF1bHRGaWxlJywgdmFsdWU6ICcuZW52LnZhdWx0JyB9LFxuICAgIC8vICAgeyB0eXBlOiAnZW52JywgdmFsdWU6ICdIRUxMTz1vbmUnIH0sXG4gICAgLy8gICB7IHR5cGU6ICdlbnZGaWxlJywgdmFsdWU6ICcuZW52JyB9LFxuICAgIC8vICAgeyB0eXBlOiAnZW52JywgdmFsdWU6ICdIRUxMTz10aHJlZScgfVxuICAgIC8vIF1cblxuICAgIGZvciAoY29uc3QgZW52IG9mIHRoaXMuZW52cykge1xuICAgICAgaWYgKGVudi50eXBlID09PSBUWVBFX0VOVl9WQVVMVF9GSUxFKSB7IC8vIGRlcHJlY2F0ZSBzb21lZGF5IC0gZm9yIGRlcHJlY2F0ZWQgLmVudi52YXVsdCBmaWxlc1xuICAgICAgICB0aGlzLl9pbmplY3RFbnZWYXVsdEZpbGUoZW52LnZhbHVlKVxuICAgICAgfSBlbHNlIGlmIChlbnYudHlwZSA9PT0gVFlQRV9FTlZfRklMRSkge1xuICAgICAgICB0aGlzLl9pbmplY3RFbnZGaWxlKGVudi52YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAoZW52LnR5cGUgPT09IFRZUEVfRU5WKSB7XG4gICAgICAgIHRoaXMuX2luamVjdEVudihlbnYudmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2Nlc3NlZEVudnM6IHRoaXMucHJvY2Vzc2VkRW52cyxcbiAgICAgIHJlYWRhYmxlU3RyaW5nczogWy4uLnRoaXMucmVhZGFibGVTdHJpbmdzXSxcbiAgICAgIHJlYWRhYmxlRmlsZXBhdGhzOiBbLi4udGhpcy5yZWFkYWJsZUZpbGVwYXRoc10sXG4gICAgICB1bmlxdWVJbmplY3RlZEtleXM6IFsuLi50aGlzLnVuaXF1ZUluamVjdGVkS2V5c10sXG4gICAgICBiZWZvcmVFbnY6IHRoaXMuYmVmb3JlRW52LFxuICAgICAgYWZ0ZXJFbnY6IHsgLi4udGhpcy5wcm9jZXNzRW52IH1cbiAgICB9XG4gIH1cblxuICBfaW5qZWN0RW52IChlbnYpIHtcbiAgICBjb25zdCByb3cgPSB7fVxuICAgIHJvdy50eXBlID0gVFlQRV9FTlZcbiAgICByb3cuc3RyaW5nID0gZW52XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwYXJzZWQsIGVycm9ycywgaW5qZWN0ZWQsIHByZUV4aXN0ZWQgfSA9IG5ldyBQYXJzZShlbnYsIG51bGwsIHRoaXMucHJvY2Vzc0VudiwgdGhpcy5vdmVybG9hZCkucnVuKClcbiAgICAgIHJvdy5wYXJzZWQgPSBwYXJzZWRcbiAgICAgIHJvdy5lcnJvcnMgPSBlcnJvcnNcbiAgICAgIHJvdy5pbmplY3RlZCA9IGluamVjdGVkXG4gICAgICByb3cucHJlRXhpc3RlZCA9IHByZUV4aXN0ZWRcblxuICAgICAgdGhpcy5pbmplY3Qocm93LnBhcnNlZCkgLy8gaW5qZWN0XG5cbiAgICAgIHRoaXMucmVhZGFibGVTdHJpbmdzLmFkZChlbnYpXG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluamVjdGVkKSkge1xuICAgICAgICB0aGlzLnVuaXF1ZUluamVjdGVkS2V5cy5hZGQoa2V5KSAvLyB0cmFjayB1bmlxdWVJbmplY3RlZEtleXMgYWNyb3NzIG11bHRpcGxlIGZpbGVzXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcm93LmVycm9ycyA9IFtlXVxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2VkRW52cy5wdXNoKHJvdylcbiAgfVxuXG4gIF9pbmplY3RFbnZGaWxlIChlbnZGaWxlcGF0aCkge1xuICAgIGNvbnN0IHJvdyA9IHt9XG4gICAgcm93LnR5cGUgPSBUWVBFX0VOVl9GSUxFXG4gICAgcm93LmZpbGVwYXRoID0gZW52RmlsZXBhdGhcblxuICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKGVudkZpbGVwYXRoKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNvZGluZyA9IGRldGVjdEVuY29kaW5nKGZpbGVwYXRoKVxuICAgICAgY29uc3Qgc3JjID0gZnN4LnJlYWRGaWxlWChmaWxlcGF0aCwgeyBlbmNvZGluZyB9KVxuICAgICAgdGhpcy5yZWFkYWJsZUZpbGVwYXRocy5hZGQoZW52RmlsZXBhdGgpXG5cbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBmaW5kUHJpdmF0ZUtleShlbnZGaWxlcGF0aCwgdGhpcy5lbnZLZXlzRmlsZXBhdGgpXG4gICAgICBjb25zdCBwcml2YXRlS2V5TmFtZSA9IGd1ZXNzUHJpdmF0ZUtleU5hbWUoZW52RmlsZXBhdGgpXG4gICAgICBjb25zdCB7IHBhcnNlZCwgZXJyb3JzLCBpbmplY3RlZCwgcHJlRXhpc3RlZCB9ID0gbmV3IFBhcnNlKHNyYywgcHJpdmF0ZUtleSwgdGhpcy5wcm9jZXNzRW52LCB0aGlzLm92ZXJsb2FkLCBwcml2YXRlS2V5TmFtZSkucnVuKClcblxuICAgICAgcm93LnByaXZhdGVLZXlOYW1lID0gcHJpdmF0ZUtleU5hbWVcbiAgICAgIHJvdy5wcml2YXRlS2V5ID0gcHJpdmF0ZUtleVxuICAgICAgcm93LnNyYyA9IHNyY1xuICAgICAgcm93LnBhcnNlZCA9IHBhcnNlZFxuICAgICAgcm93LmVycm9ycyA9IGVycm9yc1xuICAgICAgcm93LmluamVjdGVkID0gaW5qZWN0ZWRcbiAgICAgIHJvdy5wcmVFeGlzdGVkID0gcHJlRXhpc3RlZFxuXG4gICAgICB0aGlzLmluamVjdChyb3cucGFyc2VkKSAvLyBpbmplY3RcblxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaW5qZWN0ZWQpKSB7XG4gICAgICAgIHRoaXMudW5pcXVlSW5qZWN0ZWRLZXlzLmFkZChrZXkpIC8vIHRyYWNrIHVuaXF1ZUluamVjdGVkS2V5cyBhY3Jvc3MgbXVsdGlwbGUgZmlsZXNcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnRU5PRU5UJyB8fCBlLmNvZGUgPT09ICdFSVNESVInKSB7XG4gICAgICAgIHJvdy5lcnJvcnMgPSBbbmV3IEVycm9ycyh7IGVudkZpbGVwYXRoLCBmaWxlcGF0aCB9KS5taXNzaW5nRW52RmlsZSgpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93LmVycm9ycyA9IFtlXVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2VkRW52cy5wdXNoKHJvdylcbiAgfVxuXG4gIF9pbmplY3RFbnZWYXVsdEZpbGUgKGVudlZhdWx0RmlsZXBhdGgpIHtcbiAgICBjb25zdCByb3cgPSB7fVxuICAgIHJvdy50eXBlID0gVFlQRV9FTlZfVkFVTFRfRklMRVxuICAgIHJvdy5maWxlcGF0aCA9IGVudlZhdWx0RmlsZXBhdGhcblxuICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKGVudlZhdWx0RmlsZXBhdGgpXG4gICAgdGhpcy5yZWFkYWJsZUZpbGVwYXRocy5hZGQoZW52VmF1bHRGaWxlcGF0aClcblxuICAgIGlmICghZnN4LmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgICBjb25zdCBjb2RlID0gJ01JU1NJTkdfRU5WX1ZBVUxUX0ZJTEUnXG4gICAgICBjb25zdCBtZXNzYWdlID0gYHlvdSBzZXQgRE9URU5WX0tFWSBidXQgeW91ciAuZW52LnZhdWx0IGZpbGUgaXMgbWlzc2luZzogJHtmaWxlcGF0aH1gXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgZXJyb3IuY29kZSA9IGNvZGVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuRE9URU5WX0tFWS5sZW5ndGggPCAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gJ01JU1NJTkdfRE9URU5WX0tFWSdcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgeW91ciBET1RFTlZfS0VZIGFwcGVhcnMgdG8gYmUgYmxhbms6ICcke3RoaXMuRE9URU5WX0tFWX0nYFxuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgIGVycm9yLmNvZGUgPSBjb2RlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGxldCBkZWNyeXB0ZWRcbiAgICBjb25zdCBkb3RlbnZLZXlzID0gdGhpcy5fZG90ZW52S2V5cygpXG4gICAgY29uc3QgcGFyc2VkVmF1bHQgPSB0aGlzLl9wYXJzZWRWYXVsdChmaWxlcGF0aClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvdGVudktleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRvdGVudktleSA9IGRvdGVudktleXNbaV0udHJpbSgpIC8vIGRvdGVudjovL2tleV8xMjM0QC4uLj9lbnZpcm9ubWVudD1wcm9kXG5cbiAgICAgICAgZGVjcnlwdGVkID0gdGhpcy5fZGVjcnlwdGVkKGRvdGVudktleSwgcGFyc2VkVmF1bHQpXG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGxhc3Qga2V5XG4gICAgICAgIGlmIChpICsgMSA+PSBkb3RlbnZLZXlzLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IG5leHQga2V5XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIHBhcnNlIHRoaXMuIGl0J3MgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIC5lbnYgZmlsZVxuICAgICAgY29uc3QgeyBwYXJzZWQsIGVycm9ycywgaW5qZWN0ZWQsIHByZUV4aXN0ZWQgfSA9IG5ldyBQYXJzZShkZWNyeXB0ZWQsIG51bGwsIHRoaXMucHJvY2Vzc0VudiwgdGhpcy5vdmVybG9hZCkucnVuKClcbiAgICAgIHJvdy5wYXJzZWQgPSBwYXJzZWRcbiAgICAgIHJvdy5lcnJvcnMgPSBlcnJvcnNcbiAgICAgIHJvdy5pbmplY3RlZCA9IGluamVjdGVkXG4gICAgICByb3cucHJlRXhpc3RlZCA9IHByZUV4aXN0ZWRcblxuICAgICAgdGhpcy5pbmplY3Qocm93LnBhcnNlZCkgLy8gaW5qZWN0XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluamVjdGVkKSkge1xuICAgICAgICB0aGlzLnVuaXF1ZUluamVjdGVkS2V5cy5hZGQoa2V5KSAvLyB0cmFjayB1bmlxdWVJbmplY3RlZEtleXMgYWNyb3NzIG11bHRpcGxlIGZpbGVzXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcm93LmVycm9ycyA9IFtlXVxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc2VkRW52cy5wdXNoKHJvdylcbiAgfVxuXG4gIGluamVjdCAocGFyc2VkKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VkKSkge1xuICAgICAgdGhpcy5wcm9jZXNzRW52W2tleV0gPSBwYXJzZWRba2V5XSAvLyBpbmplY3QgdG8gcHJvY2Vzcy5lbnZcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgc2NlbmFyaW8gZm9yIGNvbW1hIHNlcGFyYXRlZCBrZXlzIC0gZm9yIHVzZSB3aXRoIGtleSByb3RhdGlvblxuICAvLyBleGFtcGxlOiBET1RFTlZfS0VZPVwiZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9cHJvZCxkb3RlbnY6Ly86a2V5Xzc4OTBAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kXCJcbiAgX2RvdGVudktleXMgKCkge1xuICAgIHJldHVybiB0aGlzLkRPVEVOVl9LRVkuc3BsaXQoJywnKVxuICB9XG5cbiAgLy8geyBcIkRPVEVOVl9WQVVMVF9ERVZFTE9QTUVOVFwiOiBcIjxjaXBoZXJ0ZXh0PlwiIH1cbiAgX3BhcnNlZFZhdWx0IChmaWxlcGF0aCkge1xuICAgIGNvbnN0IHNyYyA9IGZzeC5yZWFkRmlsZVgoZmlsZXBhdGgpXG4gICAgcmV0dXJuIGRvdGVudlBhcnNlKHNyYylcbiAgfVxuXG4gIF9kZWNyeXB0ZWQgKGRvdGVudktleSwgcGFyc2VkVmF1bHQpIHtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IHBhcnNlRW52aXJvbm1lbnRGcm9tRG90ZW52S2V5KGRvdGVudktleSlcblxuICAgIC8vIERPVEVOVl9LRVlfUFJPRFVDVElPTlxuICAgIGNvbnN0IGVudmlyb25tZW50S2V5ID0gYERPVEVOVl9WQVVMVF8ke2Vudmlyb25tZW50LnRvVXBwZXJDYXNlKCl9YFxuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBwYXJzZWRWYXVsdFtlbnZpcm9ubWVudEtleV1cbiAgICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UOiBjYW5ub3QgbG9jYXRlIGVudmlyb25tZW50ICR7ZW52aXJvbm1lbnRLZXl9IGluIHlvdXIgLmVudi52YXVsdCBmaWxlYClcbiAgICAgIGVycm9yLmNvZGUgPSAnTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVCdcblxuICAgICAgdGhyb3cgZXJyb3JcbiAgICB9XG5cbiAgICByZXR1cm4gZGVjcnlwdChjaXBoZXJ0ZXh0LCBkb3RlbnZLZXkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSdW5cbiIsImNvbnN0IGZzeCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9mc3gnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG5jb25zdCBUWVBFX0VOVl9GSUxFID0gJ2VudkZpbGUnXG5cbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9lcnJvcnMnKVxuY29uc3QgZ3Vlc3NQcml2YXRlS2V5TmFtZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9ndWVzc1ByaXZhdGVLZXlOYW1lJylcbmNvbnN0IGd1ZXNzUHVibGljS2V5TmFtZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9ndWVzc1B1YmxpY0tleU5hbWUnKVxuY29uc3QgZW5jcnlwdFZhbHVlID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2VuY3J5cHRWYWx1ZScpXG5jb25zdCBkZWNyeXB0S2V5VmFsdWUgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZGVjcnlwdEtleVZhbHVlJylcbmNvbnN0IHJlcGxhY2UgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcmVwbGFjZScpXG5jb25zdCBkb3RlbnZQYXJzZSA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kb3RlbnZQYXJzZScpXG5jb25zdCBkZXRlY3RFbmNvZGluZyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9kZXRlY3RFbmNvZGluZycpXG5jb25zdCBkZXRlcm1pbmVFbnZzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2RldGVybWluZUVudnMnKVxuY29uc3QgeyBmaW5kUHJpdmF0ZUtleSB9ID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2ZpbmRQcml2YXRlS2V5JylcbmNvbnN0IGZpbmRQdWJsaWNLZXkgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvZmluZFB1YmxpY0tleScpXG5jb25zdCBrZXlwYWlyID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2tleXBhaXInKVxuY29uc3QgdHJ1bmNhdGUgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvdHJ1bmNhdGUnKVxuY29uc3QgaXNFbmNyeXB0ZWQgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNFbmNyeXB0ZWQnKVxuXG5jbGFzcyBTZXRzIHtcbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUsIGVudnMgPSBbXSwgZW5jcnlwdCA9IHRydWUsIGVudktleXNGaWxlcGF0aCA9IG51bGwpIHtcbiAgICB0aGlzLmVudnMgPSBkZXRlcm1pbmVFbnZzKGVudnMsIHByb2Nlc3MuZW52KVxuICAgIHRoaXMua2V5ID0ga2V5XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5lbmNyeXB0ID0gZW5jcnlwdFxuICAgIHRoaXMuZW52S2V5c0ZpbGVwYXRoID0gZW52S2V5c0ZpbGVwYXRoXG5cbiAgICB0aGlzLnByb2Nlc3NlZEVudnMgPSBbXVxuICAgIHRoaXMuY2hhbmdlZEZpbGVwYXRocyA9IG5ldyBTZXQoKVxuICAgIHRoaXMudW5jaGFuZ2VkRmlsZXBhdGhzID0gbmV3IFNldCgpXG4gICAgdGhpcy5yZWFkYWJsZUZpbGVwYXRocyA9IG5ldyBTZXQoKVxuICB9XG5cbiAgcnVuICgpIHtcbiAgICAvLyBleGFtcGxlXG4gICAgLy8gZW52cyBbXG4gICAgLy8gICB7IHR5cGU6ICdlbnZGaWxlJywgdmFsdWU6ICcuZW52JyB9XG4gICAgLy8gXVxuXG4gICAgZm9yIChjb25zdCBlbnYgb2YgdGhpcy5lbnZzKSB7XG4gICAgICBpZiAoZW52LnR5cGUgPT09IFRZUEVfRU5WX0ZJTEUpIHtcbiAgICAgICAgdGhpcy5fc2V0RW52RmlsZShlbnYudmFsdWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByb2Nlc3NlZEVudnM6IHRoaXMucHJvY2Vzc2VkRW52cyxcbiAgICAgIGNoYW5nZWRGaWxlcGF0aHM6IFsuLi50aGlzLmNoYW5nZWRGaWxlcGF0aHNdLFxuICAgICAgdW5jaGFuZ2VkRmlsZXBhdGhzOiBbLi4udGhpcy51bmNoYW5nZWRGaWxlcGF0aHNdXG4gICAgfVxuICB9XG5cbiAgX3NldEVudkZpbGUgKGVudkZpbGVwYXRoKSB7XG4gICAgY29uc3Qgcm93ID0ge31cbiAgICByb3cua2V5ID0gdGhpcy5rZXkgfHwgbnVsbFxuICAgIHJvdy52YWx1ZSA9IHRoaXMudmFsdWUgfHwgbnVsbFxuICAgIHJvdy50eXBlID0gVFlQRV9FTlZfRklMRVxuXG4gICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGVudkZpbGVwYXRoKVxuICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5yZXNvbHZlKGVudkZpbGVwYXRoKVxuICAgIHJvdy5maWxlcGF0aCA9IGZpbGVwYXRoXG4gICAgcm93LmVudkZpbGVwYXRoID0gZW52RmlsZXBhdGhcbiAgICByb3cuY2hhbmdlZCA9IGZhbHNlXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jb2RpbmcgPSB0aGlzLl9kZXRlY3RFbmNvZGluZyhmaWxlcGF0aClcbiAgICAgIGxldCBlbnZTcmMgPSBmc3gucmVhZEZpbGVYKGZpbGVwYXRoLCB7IGVuY29kaW5nIH0pXG4gICAgICBjb25zdCBlbnZQYXJzZWQgPSBkb3RlbnZQYXJzZShlbnZTcmMpXG4gICAgICByb3cub3JpZ2luYWxWYWx1ZSA9IGVudlBhcnNlZFtyb3cua2V5XSB8fCBudWxsXG4gICAgICBjb25zdCB3YXNQbGFpblRleHQgPSAhaXNFbmNyeXB0ZWQocm93Lm9yaWdpbmFsVmFsdWUpXG4gICAgICB0aGlzLnJlYWRhYmxlRmlsZXBhdGhzLmFkZChlbnZGaWxlcGF0aClcblxuICAgICAgaWYgKHRoaXMuZW5jcnlwdCkge1xuICAgICAgICBsZXQgcHVibGljS2V5XG4gICAgICAgIGxldCBwcml2YXRlS2V5XG5cbiAgICAgICAgY29uc3QgcHVibGljS2V5TmFtZSA9IGd1ZXNzUHVibGljS2V5TmFtZShlbnZGaWxlcGF0aClcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleU5hbWUgPSBndWVzc1ByaXZhdGVLZXlOYW1lKGVudkZpbGVwYXRoKVxuICAgICAgICBjb25zdCBleGlzdGluZ1ByaXZhdGVLZXkgPSBmaW5kUHJpdmF0ZUtleShlbnZGaWxlcGF0aCwgdGhpcy5lbnZLZXlzRmlsZXBhdGgpXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUHVibGljS2V5ID0gZmluZFB1YmxpY0tleShlbnZGaWxlcGF0aClcblxuICAgICAgICBsZXQgZW52S2V5c0ZpbGVwYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShmaWxlcGF0aCksICcuZW52LmtleXMnKVxuICAgICAgICBpZiAodGhpcy5lbnZLZXlzRmlsZXBhdGgpIHtcbiAgICAgICAgICBlbnZLZXlzRmlsZXBhdGggPSBwYXRoLnJlc29sdmUodGhpcy5lbnZLZXlzRmlsZXBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVGaWxlcGF0aCA9IHBhdGgucmVsYXRpdmUocGF0aC5kaXJuYW1lKGZpbGVwYXRoKSwgZW52S2V5c0ZpbGVwYXRoKVxuXG4gICAgICAgIGlmIChleGlzdGluZ1ByaXZhdGVLZXkpIHtcbiAgICAgICAgICBjb25zdCBrcCA9IGtleXBhaXIoZXhpc3RpbmdQcml2YXRlS2V5KVxuICAgICAgICAgIHB1YmxpY0tleSA9IGtwLnB1YmxpY0tleVxuICAgICAgICAgIHByaXZhdGVLZXkgPSBrcC5wcml2YXRlS2V5XG5cbiAgICAgICAgICBpZiAocm93Lm9yaWdpbmFsVmFsdWUpIHtcbiAgICAgICAgICAgIHJvdy5vcmlnaW5hbFZhbHVlID0gZGVjcnlwdEtleVZhbHVlKHJvdy5rZXksIHJvdy5vcmlnaW5hbFZhbHVlLCBwcml2YXRlS2V5TmFtZSwgcHJpdmF0ZUtleSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiBkZXJpdmF0aW9uIGRvZXNuJ3QgbWF0Y2ggd2hhdCdzIGluIHRoZSBmaWxlIChvciBwcmVzZXQgaW4gZW52KVxuICAgICAgICAgIGlmIChleGlzdGluZ1B1YmxpY0tleSAmJiBleGlzdGluZ1B1YmxpY0tleSAhPT0gcHVibGljS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgZGVyaXZlZCBwdWJsaWMga2V5ICgke3RydW5jYXRlKHB1YmxpY0tleSl9KSBkb2VzIG5vdCBtYXRjaCB0aGUgZXhpc3RpbmcgcHVibGljIGtleSAoJHt0cnVuY2F0ZShleGlzdGluZ1B1YmxpY0tleSl9KWApXG4gICAgICAgICAgICBlcnJvci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX1BSSVZBVEVfS0VZJ1xuICAgICAgICAgICAgZXJyb3IuaGVscCA9IGBkZWJ1ZyBpbmZvOiAke3ByaXZhdGVLZXlOYW1lfT0ke3RydW5jYXRlKGV4aXN0aW5nUHJpdmF0ZUtleSl9IChkZXJpdmVkICR7cHVibGljS2V5TmFtZX09JHt0cnVuY2F0ZShwdWJsaWNLZXkpfSB2cyBleGlzdGluZyAke3B1YmxpY0tleU5hbWV9PSR7dHJ1bmNhdGUoZXhpc3RpbmdQdWJsaWNLZXkpfSlgXG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHR5cGljYWwgc2NlbmFyaW8gd2hlbiBlbmNyeXB0aW5nIGEgbW9ub3JlcG8gc2Vjb25kIC5lbnYgZmlsZSBmcm9tIGEgcHJpb3IgZ2VuZXJhdGVkIC1mayAuZW52LmtleXMgZmlsZVxuICAgICAgICAgIGlmICghZXhpc3RpbmdQdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBzID0gdGhpcy5fcHJlc2VydmVTaGViYW5nKGVudlNyYylcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZVByZXNlcnZlZCA9IHBzLmZpcnN0TGluZVByZXNlcnZlZFxuICAgICAgICAgICAgZW52U3JjID0gcHMuZW52U3JjXG5cbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmRQdWJsaWNLZXkgPSB0aGlzLl9wcmVwZW5kUHVibGljS2V5KHB1YmxpY0tleU5hbWUsIHB1YmxpY0tleSwgZmlsZW5hbWUsIHJlbGF0aXZlRmlsZXBhdGgpXG5cbiAgICAgICAgICAgIGVudlNyYyA9IGAke2ZpcnN0TGluZVByZXNlcnZlZH0ke3ByZXBlbmRQdWJsaWNLZXl9XFxuJHtlbnZTcmN9YFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ1B1YmxpY0tleSkge1xuICAgICAgICAgIHB1YmxpY0tleSA9IGV4aXN0aW5nUHVibGljS2V5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gLmVudi5rZXlzXG4gICAgICAgICAgbGV0IGtleXNTcmMgPSAnJ1xuICAgICAgICAgIGlmIChmc3guZXhpc3RzU3luYyhlbnZLZXlzRmlsZXBhdGgpKSB7XG4gICAgICAgICAgICBrZXlzU3JjID0gZnN4LnJlYWRGaWxlWChlbnZLZXlzRmlsZXBhdGgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgcHMgPSB0aGlzLl9wcmVzZXJ2ZVNoZWJhbmcoZW52U3JjKVxuICAgICAgICAgIGNvbnN0IGZpcnN0TGluZVByZXNlcnZlZCA9IHBzLmZpcnN0TGluZVByZXNlcnZlZFxuICAgICAgICAgIGVudlNyYyA9IHBzLmVudlNyY1xuXG4gICAgICAgICAgY29uc3Qga3AgPSBrZXlwYWlyKCkgLy8gZ2VuZXJhdGVzIGEgZnJlc2gga2V5cGFpciBpbiBtZW1vcnlcbiAgICAgICAgICBwdWJsaWNLZXkgPSBrcC5wdWJsaWNLZXlcbiAgICAgICAgICBwcml2YXRlS2V5ID0ga3AucHJpdmF0ZUtleVxuXG4gICAgICAgICAgY29uc3QgcHJlcGVuZFB1YmxpY0tleSA9IHRoaXMuX3ByZXBlbmRQdWJsaWNLZXkocHVibGljS2V5TmFtZSwgcHVibGljS2V5LCBmaWxlbmFtZSwgcmVsYXRpdmVGaWxlcGF0aClcblxuICAgICAgICAgIC8vIHByaXZhdGVLZXlcbiAgICAgICAgICBjb25zdCBmaXJzdFRpbWVLZXlzU3JjID0gW1xuICAgICAgICAgICAgJyMvLS0tLS0tLS0tLS0tLS0tLS0tIURPVEVOVl9QUklWQVRFX0tFWVMhLS0tLS0tLS0tLS0tLS0tLS0tLS8nLFxuICAgICAgICAgICAgJyMvIHByaXZhdGUgZGVjcnlwdGlvbiBrZXlzLiBETyBOT1QgY29tbWl0IHRvIHNvdXJjZSBjb250cm9sIC8nLFxuICAgICAgICAgICAgJyMvICAgICBbaG93IGl0IHdvcmtzXShodHRwczovL2RvdGVudnguY29tL2VuY3J5cHRpb24pICAgICAgIC8nLFxuICAgICAgICAgICAgJyMvLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8nXG4gICAgICAgICAgXS5qb2luKCdcXG4nKVxuICAgICAgICAgIGNvbnN0IGFwcGVuZFByaXZhdGVLZXkgPSBbXG4gICAgICAgICAgICBgIyAke2ZpbGVuYW1lfWAsXG4gICAgICAgICAgICBgJHtwcml2YXRlS2V5TmFtZX09JHtwcml2YXRlS2V5fWAsXG4gICAgICAgICAgICAnJ1xuICAgICAgICAgIF0uam9pbignXFxuJylcblxuICAgICAgICAgIGVudlNyYyA9IGAke2ZpcnN0TGluZVByZXNlcnZlZH0ke3ByZXBlbmRQdWJsaWNLZXl9XFxuJHtlbnZTcmN9YFxuICAgICAgICAgIGtleXNTcmMgPSBrZXlzU3JjLmxlbmd0aCA+IDEgPyBrZXlzU3JjIDogYCR7Zmlyc3RUaW1lS2V5c1NyY31cXG5gXG4gICAgICAgICAga2V5c1NyYyA9IGAke2tleXNTcmN9XFxuJHthcHBlbmRQcml2YXRlS2V5fWBcblxuICAgICAgICAgIC8vIHdyaXRlIHRvIC5lbnYua2V5c1xuICAgICAgICAgIGZzeC53cml0ZUZpbGVYKGVudktleXNGaWxlcGF0aCwga2V5c1NyYylcblxuICAgICAgICAgIHJvdy5wcml2YXRlS2V5QWRkZWQgPSB0cnVlXG4gICAgICAgICAgcm93LmVudktleXNGaWxlcGF0aCA9IHRoaXMuZW52S2V5c0ZpbGVwYXRoIHx8IHBhdGguam9pbihwYXRoLmRpcm5hbWUoZW52RmlsZXBhdGgpLCBwYXRoLmJhc2VuYW1lKGVudktleXNGaWxlcGF0aCkpXG4gICAgICAgIH1cblxuICAgICAgICByb3cucHVibGljS2V5ID0gcHVibGljS2V5XG4gICAgICAgIHJvdy5wcml2YXRlS2V5ID0gcHJpdmF0ZUtleVxuICAgICAgICByb3cuZW5jcnlwdGVkVmFsdWUgPSBlbmNyeXB0VmFsdWUodGhpcy52YWx1ZSwgcHVibGljS2V5KVxuICAgICAgICByb3cucHJpdmF0ZUtleU5hbWUgPSBwcml2YXRlS2V5TmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBnb2luZ0Zyb21QbGFpblRleHRUb0VuY3J5cHRlZCA9IHdhc1BsYWluVGV4dCAmJiB0aGlzLmVuY3J5cHRcbiAgICAgIGNvbnN0IHZhbHVlQ2hhbmdlZCA9IHRoaXMudmFsdWUgIT09IHJvdy5vcmlnaW5hbFZhbHVlXG4gICAgICBpZiAoZ29pbmdGcm9tUGxhaW5UZXh0VG9FbmNyeXB0ZWQgfHwgdmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIHJvdy5lbnZTcmMgPSByZXBsYWNlKGVudlNyYywgdGhpcy5rZXksIHJvdy5lbmNyeXB0ZWRWYWx1ZSB8fCB0aGlzLnZhbHVlKVxuICAgICAgICB0aGlzLmNoYW5nZWRGaWxlcGF0aHMuYWRkKGVudkZpbGVwYXRoKVxuICAgICAgICByb3cuY2hhbmdlZCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdy5lbnZTcmMgPSBlbnZTcmNcbiAgICAgICAgdGhpcy51bmNoYW5nZWRGaWxlcGF0aHMuYWRkKGVudkZpbGVwYXRoKVxuICAgICAgICByb3cuY2hhbmdlZCA9IGZhbHNlXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgcm93LmVycm9yID0gbmV3IEVycm9ycyh7IGVudkZpbGVwYXRoLCBmaWxlcGF0aCB9KS5taXNzaW5nRW52RmlsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3cuZXJyb3IgPSBlXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wcm9jZXNzZWRFbnZzLnB1c2gocm93KVxuICB9XG5cbiAgX2RldGVjdEVuY29kaW5nIChmaWxlcGF0aCkge1xuICAgIHJldHVybiBkZXRlY3RFbmNvZGluZyhmaWxlcGF0aClcbiAgfVxuXG4gIF9wcmVwZW5kUHVibGljS2V5IChwdWJsaWNLZXlOYW1lLCBwdWJsaWNLZXksIGZpbGVuYW1lLCByZWxhdGl2ZUZpbGVwYXRoID0gJy5lbnYua2V5cycpIHtcbiAgICBjb25zdCBjb21tZW50ID0gcmVsYXRpdmVGaWxlcGF0aCA9PT0gJy5lbnYua2V5cycgPyAnJyA6IGAgIyAtZmsgJHtyZWxhdGl2ZUZpbGVwYXRofWBcblxuICAgIHJldHVybiBbXG4gICAgICAnIy8tLS0tLS0tLS0tLS0tLS0tLS0tW0RPVEVOVl9QVUJMSUNfS0VZXS0tLS0tLS0tLS0tLS0tLS0tLS0tLycsXG4gICAgICAnIy8gICAgICAgICAgICBwdWJsaWMta2V5IGVuY3J5cHRpb24gZm9yIC5lbnYgZmlsZXMgICAgICAgICAgLycsXG4gICAgICAnIy8gICAgICAgW2hvdyBpdCB3b3Jrc10oaHR0cHM6Ly9kb3RlbnZ4LmNvbS9lbmNyeXB0aW9uKSAgICAgLycsXG4gICAgICAnIy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLycsXG4gICAgICBgJHtwdWJsaWNLZXlOYW1lfT1cIiR7cHVibGljS2V5fVwiJHtjb21tZW50fWAsXG4gICAgICAnJyxcbiAgICAgIGAjICR7ZmlsZW5hbWV9YFxuICAgIF0uam9pbignXFxuJylcbiAgfVxuXG4gIF9wcmVzZXJ2ZVNoZWJhbmcgKGVudlNyYykge1xuICAgIC8vIHByZXNlcnZlIHNoZWJhbmdcbiAgICBjb25zdCBbZmlyc3RMaW5lLCAuLi5yZW1haW5pbmdMaW5lc10gPSBlbnZTcmMuc3BsaXQoJ1xcbicpXG4gICAgbGV0IGZpcnN0TGluZVByZXNlcnZlZCA9ICcnXG5cbiAgICBpZiAoZmlyc3RMaW5lLnN0YXJ0c1dpdGgoJyMhJykpIHtcbiAgICAgIGZpcnN0TGluZVByZXNlcnZlZCA9IGZpcnN0TGluZSArICdcXG4nXG4gICAgICBlbnZTcmMgPSByZW1haW5pbmdMaW5lcy5qb2luKCdcXG4nKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdExpbmVQcmVzZXJ2ZWQsXG4gICAgICBlbnZTcmNcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXRzXG4iLCJjb25zdCBkZXB0aCA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXJzL2NvbG9yRGVwdGgnKVxuXG5jb25zdCBjb2xvcnMxNiA9IG5ldyBNYXAoW1xuICBbJ2JsdWUnLCAzNF0sXG4gIFsnZ3JheScsIDM3XSxcbiAgWydncmVlbicsIDMyXSxcbiAgWydvbGl2ZScsIDMzXSxcbiAgWydvcmFuZ2VyZWQnLCAzMV0sIC8vIG1hcHBlZCB0byByZWRcbiAgWydwbHVtJywgMzVdLCAvLyBtYXBwZWQgdG8gbWFnZW50YVxuICBbJ3JlZCcsIDMxXSxcbiAgWydlbGVjdHJpY2JsdWUnLCAzNl0sXG4gIFsnZG9kZ2VyYmx1ZScsIDM2XVxuXSlcblxuY29uc3QgY29sb3JzMjU2ID0gbmV3IE1hcChbXG4gIFsnYmx1ZScsIDIxXSxcbiAgWydncmF5JywgMjQ0XSxcbiAgWydncmVlbicsIDM0XSxcbiAgWydvbGl2ZScsIDE0Ml0sXG4gIFsnb3JhbmdlcmVkJywgMjAyXSxcbiAgWydwbHVtJywgMTgyXSxcbiAgWydyZWQnLCAxOTZdLFxuICBbJ2VsZWN0cmljYmx1ZScsIDQ1XSxcbiAgWydkb2RnZXJibHVlJywgMzNdXG5dKVxuXG5mdW5jdGlvbiBnZXRDb2xvciAoY29sb3IpIHtcbiAgY29uc3QgY29sb3JEZXB0aCA9IGRlcHRoLmdldENvbG9yRGVwdGgoKVxuICBpZiAoIWNvbG9yczI1Ni5oYXMoY29sb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNvbG9yICR7Y29sb3J9YClcbiAgfVxuICBpZiAoY29sb3JEZXB0aCA+PSA4KSB7XG4gICAgY29uc3QgY29kZSA9IGNvbG9yczI1Ni5nZXQoY29sb3IpXG4gICAgcmV0dXJuIChtZXNzYWdlKSA9PiBgXFx4MWJbMzg7NTske2NvZGV9bSR7bWVzc2FnZX1cXHgxYlszOW1gXG4gIH1cbiAgaWYgKGNvbG9yRGVwdGggPj0gNCkge1xuICAgIGNvbnN0IGNvZGUgPSBjb2xvcnMxNi5nZXQoY29sb3IpXG4gICAgcmV0dXJuIChtZXNzYWdlKSA9PiBgXFx4MWJbJHtjb2RlfW0ke21lc3NhZ2V9XFx4MWJbMzltYFxuICB9XG4gIHJldHVybiAobWVzc2FnZSkgPT4gbWVzc2FnZVxufVxuXG5mdW5jdGlvbiBib2xkIChtZXNzYWdlKSB7XG4gIGlmIChkZXB0aC5nZXRDb2xvckRlcHRoKCkgPj0gNCkge1xuICAgIHJldHVybiBgXFx4MWJbMW0ke21lc3NhZ2V9XFx4MWJbMjJtYFxuICB9XG5cbiAgcmV0dXJuIG1lc3NhZ2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbG9yLFxuICBib2xkXG59XG4iLCJjb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL2xpYi9oZWxwZXJzL3BhY2thZ2VKc29uJylcbmNvbnN0IHsgZ2V0Q29sb3IsIGJvbGQgfSA9IHJlcXVpcmUoJy4vY29sb3JzJylcblxuY29uc3QgbGV2ZWxzID0ge1xuICBlcnJvcjogMCxcbiAgd2FybjogMSxcbiAgc3VjY2VzczogMixcbiAgc3VjY2Vzc3Y6IDIsXG4gIGluZm86IDIsXG4gIGhlbHA6IDIsXG4gIHZlcmJvc2U6IDQsXG4gIGRlYnVnOiA1LFxuICBzaWxseTogNlxufVxuXG5jb25zdCBlcnJvciA9IChtKSA9PiBib2xkKGdldENvbG9yKCdyZWQnKShtKSlcbmNvbnN0IHdhcm4gPSBnZXRDb2xvcignb3JhbmdlcmVkJylcbmNvbnN0IHN1Y2Nlc3MgPSBnZXRDb2xvcignZ3JlZW4nKVxuY29uc3Qgc3VjY2Vzc3YgPSBnZXRDb2xvcignb2xpdmUnKSAvLyB5ZWxsb3ctaXNoIHRpbnQgdGhhdCAnbG9va3MnIGxpa2UgZG90ZW52XG5jb25zdCBoZWxwID0gZ2V0Q29sb3IoJ2RvZGdlcmJsdWUnKVxuY29uc3QgdmVyYm9zZSA9IGdldENvbG9yKCdwbHVtJylcbmNvbnN0IGRlYnVnID0gZ2V0Q29sb3IoJ3BsdW0nKVxuXG5sZXQgY3VycmVudExldmVsID0gbGV2ZWxzLmluZm8gLy8gZGVmYXVsdCBsb2cgbGV2ZWxcbmxldCBjdXJyZW50TmFtZSA9ICdkb3RlbnZ4JyAvLyBkZWZhdWx0IGxvZ2dlciBuYW1lXG5sZXQgY3VycmVudFZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uIC8vIGRlZmF1bHQgbG9nZ2VyIHZlcnNpb25cblxuZnVuY3Rpb24gc3RkZXJyIChsZXZlbCwgbWVzc2FnZSkge1xuICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gZm9ybWF0TWVzc2FnZShsZXZlbCwgbWVzc2FnZSlcbiAgY29uc29sZS5lcnJvcihmb3JtYXR0ZWRNZXNzYWdlKVxufVxuXG5mdW5jdGlvbiBzdGRvdXQgKGxldmVsLCBtZXNzYWdlKSB7XG4gIGlmIChsZXZlbHNbbGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1JU1NJTkdfTE9HX0xFVkVMOiAnJHtsZXZlbH0nLiBpbXBsZW1lbnQgaW4gbG9nZ2VyLmApXG4gIH1cblxuICBpZiAobGV2ZWxzW2xldmVsXSA8PSBjdXJyZW50TGV2ZWwpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRNZXNzYWdlID0gZm9ybWF0TWVzc2FnZShsZXZlbCwgbWVzc2FnZSlcbiAgICBjb25zb2xlLmxvZyhmb3JtYXR0ZWRNZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2UgKGxldmVsLCBtZXNzYWdlKSB7XG4gIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgPyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSA6IG1lc3NhZ2VcblxuICBzd2l0Y2ggKGxldmVsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAvLyBlcnJvcnNcbiAgICBjYXNlICdlcnJvcic6XG4gICAgICByZXR1cm4gZXJyb3IoZm9ybWF0dGVkTWVzc2FnZSlcbiAgICAvLyB3YXJuc1xuICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgcmV0dXJuIHdhcm4oZm9ybWF0dGVkTWVzc2FnZSlcbiAgICAvLyBzdWNjZXNzZXNcbiAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgIHJldHVybiBzdWNjZXNzKGZvcm1hdHRlZE1lc3NhZ2UpXG4gICAgY2FzZSAnc3VjY2Vzc3YnOiAvLyBzdWNjZXNzIHdpdGggJ3ZlcnNpb24nXG4gICAgICByZXR1cm4gc3VjY2Vzc3YoYFske2N1cnJlbnROYW1lfUAke2N1cnJlbnRWZXJzaW9ufV0gJHtmb3JtYXR0ZWRNZXNzYWdlfWApXG4gICAgLy8gaW5mb1xuICAgIGNhc2UgJ2luZm8nOlxuICAgICAgcmV0dXJuIGZvcm1hdHRlZE1lc3NhZ2VcbiAgICAvLyBoZWxwXG4gICAgY2FzZSAnaGVscCc6XG4gICAgICByZXR1cm4gaGVscChmb3JtYXR0ZWRNZXNzYWdlKVxuICAgIC8vIHZlcmJvc2VcbiAgICBjYXNlICd2ZXJib3NlJzpcbiAgICAgIHJldHVybiB2ZXJib3NlKGZvcm1hdHRlZE1lc3NhZ2UpXG4gICAgLy8gZGVidWdcbiAgICBjYXNlICdkZWJ1Zyc6XG4gICAgICByZXR1cm4gZGVidWcoZm9ybWF0dGVkTWVzc2FnZSlcbiAgfVxufVxuXG5jb25zdCBsb2dnZXIgPSB7XG4gIC8vIHRyYWNrIGxldmVsXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gZXJyb3JzXG4gIGVycm9yOiAobXNnKSA9PiBzdGRlcnIoJ2Vycm9yJywgbXNnKSxcbiAgLy8gd2FybnNcbiAgd2FybjogKG1zZykgPT4gc3Rkb3V0KCd3YXJuJywgbXNnKSxcbiAgLy8gc3VjY2Vzc1xuICBzdWNjZXNzOiAobXNnKSA9PiBzdGRvdXQoJ3N1Y2Nlc3MnLCBtc2cpLFxuICBzdWNjZXNzdjogKG1zZykgPT4gc3Rkb3V0KCdzdWNjZXNzdicsIG1zZyksXG4gIC8vIGluZm9cbiAgaW5mbzogKG1zZykgPT4gc3Rkb3V0KCdpbmZvJywgbXNnKSxcbiAgLy8gaGVscFxuICBoZWxwOiAobXNnKSA9PiBzdGRvdXQoJ2hlbHAnLCBtc2cpLFxuICAvLyB2ZXJib3NlXG4gIHZlcmJvc2U6IChtc2cpID0+IHN0ZG91dCgndmVyYm9zZScsIG1zZyksXG4gIC8vIGRlYnVnXG4gIGRlYnVnOiAobXNnKSA9PiBzdGRvdXQoJ2RlYnVnJywgbXNnKSxcbiAgc2V0TGV2ZWw6IChsZXZlbCkgPT4ge1xuICAgIGlmIChsZXZlbHNbbGV2ZWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsc1tsZXZlbF1cbiAgICAgIGxvZ2dlci5sZXZlbCA9IGxldmVsXG4gICAgfVxuICB9LFxuICBzZXROYW1lOiAobmFtZSkgPT4ge1xuICAgIGN1cnJlbnROYW1lID0gbmFtZVxuICAgIGxvZ2dlci5uYW1lID0gbmFtZVxuICB9LFxuICBzZXRWZXJzaW9uOiAodmVyc2lvbikgPT4ge1xuICAgIGN1cnJlbnRWZXJzaW9uID0gdmVyc2lvblxuICAgIGxvZ2dlci52ZXJzaW9uID0gdmVyc2lvblxuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvZ0xldmVsIChvcHRpb25zKSB7XG4gIGNvbnN0IGxvZ0xldmVsID0gb3B0aW9ucy5kZWJ1Z1xuICAgID8gJ2RlYnVnJ1xuICAgIDogb3B0aW9ucy52ZXJib3NlXG4gICAgICA/ICd2ZXJib3NlJ1xuICAgICAgOiBvcHRpb25zLnF1aWV0XG4gICAgICAgID8gJ2Vycm9yJ1xuICAgICAgICA6IG9wdGlvbnMubG9nTGV2ZWxcblxuICBpZiAoIWxvZ0xldmVsKSByZXR1cm5cbiAgbG9nZ2VyLnNldExldmVsKGxvZ0xldmVsKVxuICAvLyBPbmx5IGxvZyB3aGljaCBsZXZlbCBpdCdzIHNldHRpbmcgaWYgaXQncyBub3Qgc2V0IHRvIHF1aWV0IG1vZGVcbiAgaWYgKCFvcHRpb25zLnF1aWV0IHx8IChvcHRpb25zLnF1aWV0ICYmIGxvZ0xldmVsICE9PSAnZXJyb3InKSkge1xuICAgIGxvZ2dlci5kZWJ1ZyhgU2V0dGluZyBsb2cgbGV2ZWwgdG8gJHtsb2dMZXZlbH1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvZ05hbWUgKG9wdGlvbnMpIHtcbiAgY29uc3QgbG9nTmFtZSA9IG9wdGlvbnMubG9nTmFtZVxuICBpZiAoIWxvZ05hbWUpIHJldHVyblxuICBsb2dnZXIuc2V0TmFtZShsb2dOYW1lKVxufVxuXG5mdW5jdGlvbiBzZXRMb2dWZXJzaW9uIChvcHRpb25zKSB7XG4gIGNvbnN0IGxvZ1ZlcnNpb24gPSBvcHRpb25zLmxvZ1ZlcnNpb25cbiAgaWYgKCFsb2dWZXJzaW9uKSByZXR1cm5cbiAgbG9nZ2VyLnNldFZlcnNpb24obG9nVmVyc2lvbilcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZ2dlcixcbiAgZ2V0Q29sb3IsXG4gIHNldExvZ0xldmVsLFxuICBzZXRMb2dOYW1lLFxuICBzZXRMb2dWZXJzaW9uLFxuICBsZXZlbHNcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fY29tcGF0ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgbm9kZV9jcnlwdG9fMSA9IHJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKTtcbnZhciBBRUFEX1RBR19MRU5HVEggPSAxNjtcbi8vIEB0cy1pZ25vcmU6IG9ubHkgbmVjZXNzYXJ5IGZvciBkZW5vXG52YXIgSVNfREVOTyA9IGdsb2JhbFRoaXMuRGVubyAhPT0gdW5kZWZpbmVkO1xuLyoqXG4gKiBtYWtlIGBub2RlOmNyeXB0b2AncyBjaXBoZXJzIGNvbXBhdGlibGUgd2l0aCBgQG5vYmxlL2NpcGhlcnNgLlxuICpcbiAqIGBDaXBoZXJgJ3MgaW50ZXJmYWNlIGlzIHRoZSBzYW1lIGZvciBib3RoIGBhZXMtMjU2LWdjbWAgYW5kIGBjaGFjaGEyMC1wb2x5MTMwNWAsXG4gKiBhbGJlaXQgdGhlIGxhdHRlciBpcyBvbmUgb2YgYENpcGhlckNDTVR5cGVzYC5cbiAqIEludGVyZXN0aW5nbHksIHdoZXRoZXIgdG8gc2V0IGBwbGFpbnRleHRMZW5ndGhgIG9yIG5vdCwgb3Igd2hpY2ggdmFsdWUgdG8gc2V0LCBoYXMgbm8gYWN0dWFsIGVmZmVjdC5cbiAqL1xudmFyIF9jb21wYXQgPSBmdW5jdGlvbiAoYWxnb3JpdGhtLCBrZXksIG5vbmNlLCBBQUQpIHtcbiAgICB2YXIgaXNBRUFEID0gYWxnb3JpdGhtID09PSBcImFlcy0yNTYtZ2NtXCIgfHwgYWxnb3JpdGhtID09PSBcImNoYWNoYTIwLXBvbHkxMzA1XCI7XG4gICAgdmFyIGF1dGhUYWdMZW5ndGggPSBpc0FFQUQgPyBBRUFEX1RBR19MRU5HVEggOiAwO1xuICAgIC8vIGF1dGhUYWdMZW5ndGggaXMgbmVjZXNzYXJ5IGZvciBgY2hhY2hhMjAtcG9seTEzMDVgIGJlZm9yZSBOb2RlIHYxNi4xN1xuICAgIHZhciBvcHRpb25zID0gaXNBRUFEID8geyBhdXRoVGFnTGVuZ3RoOiBhdXRoVGFnTGVuZ3RoIH0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIGVuY3J5cHQgPSBmdW5jdGlvbiAocGxhaW5UZXh0KSB7XG4gICAgICAgIHZhciBjaXBoZXIgPSAoMCwgbm9kZV9jcnlwdG9fMS5jcmVhdGVDaXBoZXJpdikoYWxnb3JpdGhtLCBrZXksIG5vbmNlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzQUVBRCAmJiBBQUQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2lwaGVyLnNldEFBRChBQUQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cGRhdGVkID0gY2lwaGVyLnVwZGF0ZShwbGFpblRleHQpO1xuICAgICAgICB2YXIgZmluYWxpemVkID0gY2lwaGVyLmZpbmFsKCk7XG4gICAgICAgIHZhciB0YWcgPSBpc0FFQUQgPyBjaXBoZXIuZ2V0QXV0aFRhZygpIDogbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykodXBkYXRlZCwgZmluYWxpemVkLCB0YWcpO1xuICAgIH07XG4gICAgdmFyIGRlY3J5cHQgPSBmdW5jdGlvbiAoY2lwaGVyVGV4dCkge1xuICAgICAgICB2YXIgcmF3Q2lwaGVyVGV4dCA9IGNpcGhlclRleHQuc3ViYXJyYXkoMCwgY2lwaGVyVGV4dC5sZW5ndGggLSBhdXRoVGFnTGVuZ3RoKTtcbiAgICAgICAgdmFyIHRhZyA9IGNpcGhlclRleHQuc3ViYXJyYXkoY2lwaGVyVGV4dC5sZW5ndGggLSBhdXRoVGFnTGVuZ3RoKTtcbiAgICAgICAgdmFyIGRlY2lwaGVyID0gKDAsIG5vZGVfY3J5cHRvXzEuY3JlYXRlRGVjaXBoZXJpdikoYWxnb3JpdGhtLCBrZXksIG5vbmNlLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGlzQUVBRCkge1xuICAgICAgICAgICAgaWYgKEFBRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVjaXBoZXIuc2V0QUFEKEFBRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBdXRoVGFnKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogdjggaWdub3JlIG5leHQgMyAqL1xuICAgICAgICBpZiAoIWlzQUVBRCAmJiBJU19ERU5PKSB7XG4gICAgICAgICAgICBkZWNpcGhlci5zZXRBdXRvUGFkZGluZyhmYWxzZSk7IC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm8vaXNzdWVzLzI4MzgxXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZWQgPSBkZWNpcGhlci51cGRhdGUocmF3Q2lwaGVyVGV4dCk7XG4gICAgICAgIHZhciBmaW5hbGl6ZWQgPSBkZWNpcGhlci5maW5hbCgpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKHVwZGF0ZWQsIGZpbmFsaXplZCk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiBlbmNyeXB0LFxuICAgICAgICBkZWNyeXB0OiBkZWNyeXB0LFxuICAgIH07XG59O1xuZXhwb3J0cy5fY29tcGF0ID0gX2NvbXBhdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5faGNoYWNoYTIwID0gdm9pZCAwO1xuLyoqXG4gKiBDb3BpZWQgZnJvbSBgQG5vYmxlL2NpcGhlcnMvY2hhY2hhYFxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbnZhciBfaGNoYWNoYTIwID0gZnVuY3Rpb24gKHMsIGssIGksIG8zMikge1xuICAgIHZhciB4MDAgPSBzWzBdLCB4MDEgPSBzWzFdLCB4MDIgPSBzWzJdLCB4MDMgPSBzWzNdLCB4MDQgPSBrWzBdLCB4MDUgPSBrWzFdLCB4MDYgPSBrWzJdLCB4MDcgPSBrWzNdLCB4MDggPSBrWzRdLCB4MDkgPSBrWzVdLCB4MTAgPSBrWzZdLCB4MTEgPSBrWzddLCB4MTIgPSBpWzBdLCB4MTMgPSBpWzFdLCB4MTQgPSBpWzJdLCB4MTUgPSBpWzNdO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgMjA7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9IHJvdGwoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSByb3RsKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gcm90bCh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9IHJvdGwoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSByb3RsKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gcm90bCh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9IHJvdGwoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSByb3RsKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gcm90bCh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9IHJvdGwoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSByb3RsKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gcm90bCh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICB2YXIgb2kgPSAwO1xuICAgIG8zMltvaSsrXSA9IHgwMDtcbiAgICBvMzJbb2krK10gPSB4MDE7XG4gICAgbzMyW29pKytdID0geDAyO1xuICAgIG8zMltvaSsrXSA9IHgwMztcbiAgICBvMzJbb2krK10gPSB4MTI7XG4gICAgbzMyW29pKytdID0geDEzO1xuICAgIG8zMltvaSsrXSA9IHgxNDtcbiAgICBvMzJbb2krK10gPSB4MTU7XG59O1xuZXhwb3J0cy5faGNoYWNoYTIwID0gX2hjaGFjaGEyMDtcbnZhciByb3RsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZXMyNTZjYmMgPSBleHBvcnRzLmFlczI1NmdjbSA9IHZvaWQgMDtcbnZhciBjb21wYXRfMSA9IHJlcXVpcmUoXCIuLi9fbm9kZS9jb21wYXRcIik7XG52YXIgYWVzMjU2Z2NtID0gZnVuY3Rpb24gKGtleSwgbm9uY2UsIEFBRCkge1xuICAgIHJldHVybiAoMCwgY29tcGF0XzEuX2NvbXBhdCkoXCJhZXMtMjU2LWdjbVwiLCBrZXksIG5vbmNlLCBBQUQpO1xufTtcbmV4cG9ydHMuYWVzMjU2Z2NtID0gYWVzMjU2Z2NtO1xudmFyIGFlczI1NmNiYyA9IGZ1bmN0aW9uIChrZXksIG5vbmNlLCBBQUQpIHtcbiAgICByZXR1cm4gKDAsIGNvbXBhdF8xLl9jb21wYXQpKFwiYWVzLTI1Ni1jYmNcIiwga2V5LCBub25jZSk7XG59O1xuZXhwb3J0cy5hZXMyNTZjYmMgPSBhZXMyNTZjYmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhY2hhMjAgPSBleHBvcnRzLnhjaGFjaGEyMCA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCIpO1xudmFyIGNvbXBhdF8xID0gcmVxdWlyZShcIi4uL19ub2RlL2NvbXBhdFwiKTtcbnZhciBoY2hhY2hhXzEgPSByZXF1aXJlKFwiLi4vX25vZGUvaGNoYWNoYVwiKTtcbnZhciB4Y2hhY2hhMjAgPSBmdW5jdGlvbiAoa2V5LCBub25jZSwgQUFEKSB7XG4gICAgaWYgKG5vbmNlLmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieGNoYWNoYTIwJ3Mgbm9uY2UgbXVzdCBiZSAyNCBieXRlc1wiKTtcbiAgICB9XG4gICAgdmFyIGNvbnN0YW50cyA9IG5ldyBVaW50MzJBcnJheShbMHg2MTcwNzg2NSwgMHgzMzIwNjQ2ZSwgMHg3OTYyMmQzMiwgMHg2YjIwNjU3NF0pOyAvLyBcImV4cGFuZCAzMi1ieXRlIGtcIlxuICAgIHZhciBzdWJLZXkgPSBuZXcgVWludDMyQXJyYXkoOCk7XG4gICAgKDAsIGhjaGFjaGFfMS5faGNoYWNoYTIwKShjb25zdGFudHMsICgwLCB1dGlsc18xLnUzMikoa2V5KSwgKDAsIHV0aWxzXzEudTMyKShub25jZS5zdWJhcnJheSgwLCAxNikpLCBzdWJLZXkpO1xuICAgIHZhciBzdWJOb25jZSA9IG5ldyBVaW50OEFycmF5KDEyKTtcbiAgICBzdWJOb25jZS5zZXQoWzAsIDAsIDAsIDBdKTtcbiAgICBzdWJOb25jZS5zZXQobm9uY2Uuc3ViYXJyYXkoMTYpLCA0KTtcbiAgICByZXR1cm4gKDAsIGNvbXBhdF8xLl9jb21wYXQpKFwiY2hhY2hhMjAtcG9seTEzMDVcIiwgKDAsIHV0aWxzXzEudTgpKHN1YktleSksIHN1Yk5vbmNlLCBBQUQpO1xufTtcbmV4cG9ydHMueGNoYWNoYTIwID0geGNoYWNoYTIwO1xudmFyIGNoYWNoYTIwID0gZnVuY3Rpb24gKGtleSwgbm9uY2UsIEFBRCkge1xuICAgIGlmIChub25jZS5sZW5ndGggIT09IDEyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNoYWNoYTIwJ3Mgbm9uY2UgbXVzdCBiZSAxMiBieXRlc1wiKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBjb21wYXRfMS5fY29tcGF0KShcImNoYWNoYTIwLXBvbHkxMzA1XCIsIGtleSwgbm9uY2UsIEFBRCk7XG59O1xuZXhwb3J0cy5jaGFjaGEyMCA9IGNoYWNoYTIwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jaXBoZXJzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjMgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyYXBDaXBoZXIgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLm5leHRUaWNrID0gZXhwb3J0cy5pc0xFID0gdm9pZCAwO1xuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmV4cG9ydHMuYWJvb2wgPSBhYm9vbDtcbmV4cG9ydHMuYW51bWJlciA9IGFudW1iZXI7XG5leHBvcnRzLmFieXRlcyA9IGFieXRlcztcbmV4cG9ydHMuYWhhc2ggPSBhaGFzaDtcbmV4cG9ydHMuYWV4aXN0cyA9IGFleGlzdHM7XG5leHBvcnRzLmFvdXRwdXQgPSBhb3V0cHV0O1xuZXhwb3J0cy51OCA9IHU4O1xuZXhwb3J0cy51MzIgPSB1MzI7XG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGJ5dGVzVG9OdW1iZXJCRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZXhwb3J0cy5ieXRlc1RvVXRmOCA9IGJ5dGVzVG9VdGY4O1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMub3ZlcmxhcEJ5dGVzID0gb3ZlcmxhcEJ5dGVzO1xuZXhwb3J0cy5jb21wbGV4T3ZlcmxhcEJ5dGVzID0gY29tcGxleE92ZXJsYXBCeXRlcztcbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbmV4cG9ydHMuZ2V0T3V0cHV0ID0gZ2V0T3V0cHV0O1xuZXhwb3J0cy5zZXRCaWdVaW50NjQgPSBzZXRCaWdVaW50NjQ7XG5leHBvcnRzLnU2NExlbmd0aHMgPSB1NjRMZW5ndGhzO1xuZXhwb3J0cy5pc0FsaWduZWQzMiA9IGlzQWxpZ25lZDMyO1xuZXhwb3J0cy5jb3B5Qnl0ZXMgPSBjb3B5Qnl0ZXM7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgYm9vbGVhbi4gKi9cbmZ1bmN0aW9uIGFib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAnICsgbGVuZ3RocyArICcsIGdvdCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbn1cbi8qKlxuICogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaFxuICogVE9ETzogcmVtb3ZlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5mdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5mdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYWJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gICAgfVxufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTguICovXG5mdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqIENyZWF0ZSBEYXRhVmlldyBvZiBhbiBhcnJheSBmb3IgZWFzeSBieXRlLWxldmVsIG1hbmlwdWxhdGlvbi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0cy5pc0xFID0gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBVc2VkIGluIG1pY3JvXG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiAnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gVXNlZCBpbiBmZjFcbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbi8vIFVzZWQgaW4gbWljcm8sIGZmMVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuLy8gVE9ETzogcmVtb3ZlXG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGVsc2UgaWYgKGlzQnl0ZXMoZGF0YSkpXG4gICAgICAgIGRhdGEgPSBjb3B5Qnl0ZXMoZGF0YSk7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIFU4QSB1c2Ugc2FtZSB1bmRlcmx5aW5nIGJ1ZmZlciBhbmQgb3ZlcmxhcHMuXG4gKiBUaGlzIGlzIGludmFsaWQgYW5kIGNhbiBjb3JydXB0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIG92ZXJsYXBCeXRlcyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLmJ1ZmZlciA9PT0gYi5idWZmZXIgJiYgLy8gYmVzdCB3ZSBjYW4gZG8sIG1heSBmYWlsIHdpdGggYW4gb2JzY3VyZSBQcm94eVxuICAgICAgICBhLmJ5dGVPZmZzZXQgPCBiLmJ5dGVPZmZzZXQgKyBiLmJ5dGVMZW5ndGggJiYgLy8gYSBzdGFydHMgYmVmb3JlIGIgZW5kXG4gICAgICAgIGIuYnl0ZU9mZnNldCA8IGEuYnl0ZU9mZnNldCArIGEuYnl0ZUxlbmd0aCAvLyBiIHN0YXJ0cyBiZWZvcmUgYSBlbmRcbiAgICApO1xufVxuLyoqXG4gKiBJZiBpbnB1dCBhbmQgb3V0cHV0IG92ZXJsYXAgYW5kIGlucHV0IHN0YXJ0cyBiZWZvcmUgb3V0cHV0LCB3ZSB3aWxsIG92ZXJ3cml0ZSBlbmQgb2YgaW5wdXQgYmVmb3JlXG4gKiB3ZSBzdGFydCBwcm9jZXNzaW5nIGl0LCBzbyB0aGlzIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIG1vc3QgY2lwaGVycyAoZXhjZXB0IGNoYWNoYS9zYWxzZSwgd2hpY2ggZGVzaWduZWQgd2l0aCB0aGlzKVxuICovXG5mdW5jdGlvbiBjb21wbGV4T3ZlcmxhcEJ5dGVzKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyBUaGlzIGlzIHZlcnkgY3Vyc2VkLiBJdCB3b3JrcyBzb21laG93LCBidXQgSSdtIGNvbXBsZXRlbHkgdW5zdXJlLFxuICAgIC8vIHJlYXNvbmluZyBhYm91dCBvdmVybGFwcGluZyBhbGlnbmVkIHdpbmRvd3MgaXMgdmVyeSBoYXJkLlxuICAgIGlmIChvdmVybGFwQnl0ZXMoaW5wdXQsIG91dHB1dCkgJiYgaW5wdXQuYnl0ZU9mZnNldCA8IG91dHB1dC5ieXRlT2Zmc2V0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBsZXggb3ZlcmxhcCBvZiBpbnB1dCBhbmQgb3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT0gbnVsbCB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIENvbXBhcmVzIDIgdWludDhhcnJheS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWUuICovXG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlLiAqL1xuY2xhc3MgSGFzaCB7XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLyoqXG4gKiBXcmFwcyBhIGNpcGhlcjogdmFsaWRhdGVzIGFyZ3MsIGVuc3VyZXMgZW5jcnlwdCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICogQF9fTk9fU0lERV9FRkZFQ1RTX19cbiAqL1xuY29uc3Qgd3JhcENpcGhlciA9IChwYXJhbXMsIGNvbnN0cnVjdG9yKSA9PiB7XG4gICAgZnVuY3Rpb24gd3JhcHBlZENpcGhlcihrZXksIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUga2V5XG4gICAgICAgIGFieXRlcyhrZXkpO1xuICAgICAgICAvLyBCaWctRW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4gICAgICAgIGlmICghZXhwb3J0cy5pc0xFKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gbGl0dGxlLWVuZGlhbiBoYXJkd2FyZSBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBub25jZSBpZiBub25jZUxlbmd0aCBpcyBwcmVzZW50XG4gICAgICAgIGlmIChwYXJhbXMubm9uY2VMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhcmdzWzBdO1xuICAgICAgICAgICAgaWYgKCFub25jZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vbmNlIC8gaXYgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMudmFyU2l6ZU5vbmNlKVxuICAgICAgICAgICAgICAgIGFieXRlcyhub25jZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWJ5dGVzKG5vbmNlLCBwYXJhbXMubm9uY2VMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIEFBRCBpZiB0YWdMZW5ndGggcHJlc2VudFxuICAgICAgICBjb25zdCB0YWdsID0gcGFyYW1zLnRhZ0xlbmd0aDtcbiAgICAgICAgaWYgKHRhZ2wgJiYgYXJnc1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhYnl0ZXMoYXJnc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVyID0gY29uc3RydWN0b3Ioa2V5LCAuLi5hcmdzKTtcbiAgICAgICAgY29uc3QgY2hlY2tPdXRwdXQgPSAoZm5MZW5ndGgsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKG91dHB1dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZuTGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NpcGhlciBvdXRwdXQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGFieXRlcyhvdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgd3JhcHBlZCBjaXBoZXIgd2l0aCB2YWxpZGF0aW9uIGFuZCBzaW5nbGUtdXNlIGVuY3J5cHRpb25cbiAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB3ckNpcGhlciA9IHtcbiAgICAgICAgICAgIGVuY3J5cHQoZGF0YSwgb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxlZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZW5jcnlwdCgpIHR3aWNlIHdpdGggc2FtZSBrZXkgKyBub25jZScpO1xuICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICAgICAgICAgIGNoZWNrT3V0cHV0KGNpcGhlci5lbmNyeXB0Lmxlbmd0aCwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVyLmVuY3J5cHQoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNyeXB0KGRhdGEsIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnbCAmJiBkYXRhLmxlbmd0aCA8IHRhZ2wpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IGxlbmd0aDogc21hbGxlciB0aGFuIHRhZ0xlbmd0aD0nICsgdGFnbCk7XG4gICAgICAgICAgICAgICAgY2hlY2tPdXRwdXQoY2lwaGVyLmRlY3J5cHQubGVuZ3RoLCBvdXRwdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaXBoZXIuZGVjcnlwdChkYXRhLCBvdXRwdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdyQ2lwaGVyO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHdyYXBwZWRDaXBoZXIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHdyYXBwZWRDaXBoZXI7XG59O1xuZXhwb3J0cy53cmFwQ2lwaGVyID0gd3JhcENpcGhlcjtcbi8qKlxuICogQnkgZGVmYXVsdCwgcmV0dXJucyB1OGEgb2YgbGVuZ3RoLlxuICogV2hlbiBvdXQgaXMgYXZhaWxhYmxlLCBpdCBjaGVja3MgaXQgZm9yIHZhbGlkaXR5IGFuZCB1c2VzIGl0LlxuICovXG5mdW5jdGlvbiBnZXRPdXRwdXQoZXhwZWN0ZWRMZW5ndGgsIG91dCwgb25seUFsaWduZWQgPSB0cnVlKSB7XG4gICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZXhwZWN0ZWRMZW5ndGgpO1xuICAgIGlmIChvdXQubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCBsZW5ndGgsIGV4cGVjdGVkICcgKyBleHBlY3RlZExlbmd0aCArICcsIGdvdDogJyArIG91dC5sZW5ndGgpO1xuICAgIGlmIChvbmx5QWxpZ25lZCAmJiAhaXNBbGlnbmVkMzIob3V0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG91dHB1dCwgbXVzdCBiZSBhbGlnbmVkJyk7XG4gICAgcmV0dXJuIG91dDtcbn1cbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbmZ1bmN0aW9uIHU2NExlbmd0aHMoZGF0YUxlbmd0aCwgYWFkTGVuZ3RoLCBpc0xFKSB7XG4gICAgYWJvb2woaXNMRSk7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSBjcmVhdGVWaWV3KG51bSk7XG4gICAgc2V0QmlnVWludDY0KHZpZXcsIDAsIEJpZ0ludChhYWRMZW5ndGgpLCBpc0xFKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGRhdGFMZW5ndGgpLCBpc0xFKTtcbiAgICByZXR1cm4gbnVtO1xufVxuLy8gSXMgYnl0ZSBhcnJheSBhbGlnbmVkIHRvIDQgYnl0ZSBvZmZzZXQgKHUzMik/XG5mdW5jdGlvbiBpc0FsaWduZWQzMihieXRlcykge1xuICAgIHJldHVybiBieXRlcy5ieXRlT2Zmc2V0ICUgNCA9PT0gMDtcbn1cbi8vIGNvcHkgYnl0ZXMgdG8gbmV3IHU4YSAoYWxpZ25lZCkuIEJlY2F1c2UgQnVmZmVyLnNsaWNlIGlzIGJyb2tlbi5cbmZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdjbSA9IGV4cG9ydHMuY3RyID0gZXhwb3J0cy5jYmMgPSBleHBvcnRzLnV0aWxzID0gdm9pZCAwO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuZXhwb3J0cy5nZXRXZWJjcnlwdG9TdWJ0bGUgPSBnZXRXZWJjcnlwdG9TdWJ0bGU7XG5leHBvcnRzLm1hbmFnZWROb25jZSA9IG1hbmFnZWROb25jZTtcbi8qKlxuICogV2ViQ3J5cHRvLWJhc2VkIEFFUyBnY20vY3RyL2NiYywgYG1hbmFnZWROb25jZWAgYW5kIGByYW5kb21CeXRlc2AuXG4gKiBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbiAqIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbiAqIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzIG9uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbiAqIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4gKiBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbiAqIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIFVzZSBmdWxsIHBhdGggc28gdGhhdCBOb2RlLmpzIGNhbiByZXdyaXRlIGl0IHRvIGBjcnlwdG9Ob2RlLmpzYC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL2NyeXB0b1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKlxuICogU2VjdXJlIFBSTkcuIFVzZXMgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLCB3aGljaCBkZWZlcnMgdG8gT1MuXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvICYmIHR5cGVvZiBjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZ2V0V2ViY3J5cHRvU3VidGxlKCkge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5zdWJ0bGUgPT09ICdvYmplY3QnICYmIGNyeXB0b18xLmNyeXB0by5zdWJ0bGUgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5zdWJ0bGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uc3VidGxlIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLyoqXG4gKiBVc2VzIENTUFJHIGZvciBub25jZSwgbm9uY2UgaW5qZWN0ZWQgaW4gY2lwaGVydGV4dC5cbiAqIEBleGFtcGxlXG4gKiBjb25zdCBnY20gPSBtYW5hZ2VkTm9uY2UoYWVzLmdjbSk7XG4gKiBjb25zdCBjaXBociA9IGdjbShrZXkpLmVuY3J5cHQoZGF0YSk7XG4gKiBjb25zdCBwbGFpbiA9IGdjbShrZXkpLmRlY3J5cHQoY2lwaCk7XG4gKi9cbmZ1bmN0aW9uIG1hbmFnZWROb25jZShmbikge1xuICAgIGNvbnN0IHsgbm9uY2VMZW5ndGggfSA9IGZuO1xuICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKG5vbmNlTGVuZ3RoKTtcbiAgICByZXR1cm4gKChrZXksIC4uLmFyZ3MpID0+ICh7XG4gICAgICAgIGVuY3J5cHQocGxhaW50ZXh0LCAuLi5hcmdzRW5jKSB7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IHJhbmRvbUJ5dGVzKG5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBmbihrZXksIG5vbmNlLCAuLi5hcmdzKS5lbmNyeXB0KHBsYWludGV4dCwgLi4uYXJnc0VuYyk7XG4gICAgICAgICAgICBjb25zdCBvdXQgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykobm9uY2UsIGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgY2lwaGVydGV4dC5maWxsKDApO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0LCAuLi5hcmdzRGVjKSB7XG4gICAgICAgICAgICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgbm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkobm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKGtleSwgbm9uY2UsIC4uLmFyZ3MpLmRlY3J5cHQoZGF0YSwgLi4uYXJnc0RlYyk7XG4gICAgICAgIH0sXG4gICAgfSkpO1xufVxuLy8gT3ZlcnJpZGFibGVcbi8vIEBUT0RPXG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGFzeW5jIGVuY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBwbGFpbnRleHQpIHtcbiAgICAgICAgY29uc3QgY3IgPSBnZXRXZWJjcnlwdG9TdWJ0bGUoKTtcbiAgICAgICAgY29uc3QgaUtleSA9IGF3YWl0IGNyLmltcG9ydEtleSgncmF3Jywga2V5LCBrZXlQYXJhbXMsIHRydWUsIFsnZW5jcnlwdCddKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNyLmVuY3J5cHQoY3J5cHRQYXJhbXMsIGlLZXksIHBsYWludGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KTtcbiAgICB9LFxuICAgIGFzeW5jIGRlY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNyID0gZ2V0V2ViY3J5cHRvU3VidGxlKCk7XG4gICAgICAgIGNvbnN0IGlLZXkgPSBhd2FpdCBjci5pbXBvcnRLZXkoJ3JhdycsIGtleSwga2V5UGFyYW1zLCB0cnVlLCBbJ2RlY3J5cHQnXSk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IGF3YWl0IGNyLmRlY3J5cHQoY3J5cHRQYXJhbXMsIGlLZXksIGNpcGhlcnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICB9LFxufTtcbmNvbnN0IG1vZGUgPSB7XG4gICAgQ0JDOiAnQUVTLUNCQycsXG4gICAgQ1RSOiAnQUVTLUNUUicsXG4gICAgR0NNOiAnQUVTLUdDTScsXG59O1xuZnVuY3Rpb24gZ2V0Q3J5cHRQYXJhbXMoYWxnbywgbm9uY2UsIEFBRCkge1xuICAgIGlmIChhbGdvID09PSBtb2RlLkNCQylcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbW9kZS5DQkMsIGl2OiBub25jZSB9O1xuICAgIGlmIChhbGdvID09PSBtb2RlLkNUUilcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbW9kZS5DVFIsIGNvdW50ZXI6IG5vbmNlLCBsZW5ndGg6IDY0IH07XG4gICAgaWYgKGFsZ28gPT09IG1vZGUuR0NNKSB7XG4gICAgICAgIGlmIChBQUQpXG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBtb2RlLkdDTSwgaXY6IG5vbmNlLCBhZGRpdGlvbmFsRGF0YTogQUFEIH07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG1vZGUuR0NNLCBpdjogbm9uY2UgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFlcyBibG9jayBtb2RlJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShhbGdvKSB7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBBQUQpID0+IHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShrZXkpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKG5vbmNlKTtcbiAgICAgICAgY29uc3Qga2V5UGFyYW1zID0geyBuYW1lOiBhbGdvLCBsZW5ndGg6IGtleS5sZW5ndGggKiA4IH07XG4gICAgICAgIGNvbnN0IGNyeXB0UGFyYW1zID0gZ2V0Q3J5cHRQYXJhbXMoYWxnbywgbm9uY2UsIEFBRCk7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8ga2V5TGVuZ3RoLFxuICAgICAgICAgICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5hYnl0ZXMpKHBsYWludGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWVkKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0KCkgdHdpY2Ugd2l0aCBzYW1lIGtleSAvIG5vbmNlJyk7XG4gICAgICAgICAgICAgICAgY29uc3VtZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLnV0aWxzLmVuY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMudXRpbHMuZGVjcnlwdChrZXksIGtleVBhcmFtcywgY3J5cHRQYXJhbXMsIGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xufVxuLyoqIEFFUy1DQkMsIG5hdGl2ZSB3ZWJjcnlwdG8gdmVyc2lvbiAqL1xuZXhwb3J0cy5jYmMgPSAoKCkgPT4gZ2VuZXJhdGUobW9kZS5DQkMpKSgpO1xuLyoqIEFFUy1DVFIsIG5hdGl2ZSB3ZWJjcnlwdG8gdmVyc2lvbiAqL1xuZXhwb3J0cy5jdHIgPSAoKCkgPT4gZ2VuZXJhdGUobW9kZS5DVFIpKSgpO1xuLyoqIEFFUy1HQ00sIG5hdGl2ZSB3ZWJjcnlwdG8gdmVyc2lvbiAqL1xuZXhwb3J0cy5nY20gPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuZXJhdGUobW9kZS5HQ00pKSgpO1xuLy8gLy8gVHlwZSB0ZXN0c1xuLy8gaW1wb3J0IHsgc2l2LCBnY20sIGN0ciwgZWNiLCBjYmMgfSBmcm9tICcuLi9hZXMudHMnO1xuLy8gaW1wb3J0IHsgeHNhbHNhMjBwb2x5MTMwNSB9IGZyb20gJy4uL3NhbHNhLnRzJztcbi8vIGltcG9ydCB7IGNoYWNoYTIwcG9seTEzMDUsIHhjaGFjaGEyMHBvbHkxMzA1IH0gZnJvbSAnLi4vY2hhY2hhLnRzJztcbi8vIGNvbnN0IHdzaXYgPSBtYW5hZ2VkTm9uY2Uoc2l2KTtcbi8vIGNvbnN0IHdnY20gPSBtYW5hZ2VkTm9uY2UoZ2NtKTtcbi8vIGNvbnN0IHdjdHIgPSBtYW5hZ2VkTm9uY2UoY3RyKTtcbi8vIGNvbnN0IHdjYmMgPSBtYW5hZ2VkTm9uY2UoY2JjKTtcbi8vIGNvbnN0IHdzYWxzYXBvbHkgPSBtYW5hZ2VkTm9uY2UoeHNhbHNhMjBwb2x5MTMwNSk7XG4vLyBjb25zdCB3Y2hhY2hhID0gbWFuYWdlZE5vbmNlKGNoYWNoYTIwcG9seTEzMDUpO1xuLy8gY29uc3Qgd3hjaGFjaGEgPSBtYW5hZ2VkTm9uY2UoeGNoYWNoYTIwcG9seTEzMDUpO1xuLy8gLy8gc2hvdWxkIGZhaWxcbi8vIGNvbnN0IHdjYmMyID0gbWFuYWdlZE5vbmNlKG1hbmFnZWROb25jZShjYmMpKTtcbi8vIGNvbnN0IHdjdHIgPSBtYW5hZ2VkTm9uY2UoY3RyKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmNyeXB0by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG5leHBvcnRzLmNyZWF0ZUN1cnZlID0gY3JlYXRlQ3VydmU7XG4vKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgd2VpZXJzdHJhc3NfdHNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCIpO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7IGhhc2ggfTtcbn1cbi8qKiBAZGVwcmVjYXRlZCB1c2UgbmV3IGB3ZWllcnN0cmFzcygpYCBhbmQgYGVjZHNhKClgIG1ldGhvZHMgKi9cbmZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+ICgwLCB3ZWllcnN0cmFzc190c18xLndlaWVyc3RyYXNzKSh7IC4uLmN1cnZlRGVmLCBoYXNoOiBoYXNoIH0pO1xuICAgIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53TkFGID0gdm9pZCAwO1xuZXhwb3J0cy5uZWdhdGVDdCA9IG5lZ2F0ZUN0O1xuZXhwb3J0cy5ub3JtYWxpemVaID0gbm9ybWFsaXplWjtcbmV4cG9ydHMubXVsRW5kb1Vuc2FmZSA9IG11bEVuZG9VbnNhZmU7XG5leHBvcnRzLnBpcHBlbmdlciA9IHBpcHBlbmdlcjtcbmV4cG9ydHMucHJlY29tcHV0ZU1TTVVuc2FmZSA9IHByZWNvbXB1dGVNU01VbnNhZmU7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuZXhwb3J0cy5fY3JlYXRlQ3VydmVGaWVsZHMgPSBfY3JlYXRlQ3VydmVGaWVsZHM7XG4vKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXIuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5jb25zdCBtb2R1bGFyX3RzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gbmVnYXRlQ3QoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVaKGMsIHBvaW50cykge1xuICAgIGNvbnN0IGludmVydGVkWnMgPSAoMCwgbW9kdWxhcl90c18xLkZwSW52ZXJ0QmF0Y2gpKGMuRnAsIHBvaW50cy5tYXAoKHApID0+IHAuWikpO1xuICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBjLmZyb21BZmZpbmUocC50b0FmZmluZShpbnZlcnRlZFpzW2ldKSkpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVXKFcsIGJpdHMpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKFcpIHx8IFcgPD0gMCB8fCBXID4gYml0cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHdpbmRvdyBzaXplLCBleHBlY3RlZCBbMS4uJyArIGJpdHMgKyAnXSwgZ290IFc9JyArIFcpO1xufVxuZnVuY3Rpb24gY2FsY1dPcHRzKFcsIHNjYWxhckJpdHMpIHtcbiAgICB2YWxpZGF0ZVcoVywgc2NhbGFyQml0cyk7XG4gICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChzY2FsYXJCaXRzIC8gVykgKyAxOyAvLyBXPTggMzMuIE5vdCAzMiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyBXPTggMTI4LiBOb3QgMjU2LCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVzsgLy8gVz04IDI1NlxuICAgIGNvbnN0IG1hc2sgPSAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKShXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgLy8gVG8gZGlzYWJsZSBwcmVjb21wdXRlczpcbiAgICAvLyByZXR1cm4gMTtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbmZ1bmN0aW9uIGFzc2VydDAobikge1xuICAgIGlmIChuICE9PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3TkFGJyk7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFRhYmxlIGdlbmVyYXRpb24gdGFrZXMgKiozME1CIG9mIHJhbSBhbmQgMTBtcyBvbiBoaWdoLWVuZCBDUFUqKixcbiAqIGJ1dCBtYXkgdGFrZSBtdWNoIGxvbmdlciBvbiBzbG93IGRldmljZXMuIEFjdHVhbCBnZW5lcmF0aW9uIHdpbGwgaGFwcGVuIG9uXG4gKiBmaXJzdCBjYWxsIG9mIGBtdWx0aXBseSgpYC4gQnkgZGVmYXVsdCwgYEJBU0VgIHBvaW50IGlzIHByZWNvbXB1dGVkLlxuICpcbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuY2xhc3Mgd05BRiB7XG4gICAgLy8gUGFyYW1ldHJpemVkIHdpdGggYSBnaXZlbiBQb2ludCBjbGFzcyAobm90IGluZGl2aWR1YWwgcG9pbnQpXG4gICAgY29uc3RydWN0b3IoUG9pbnQsIGJpdHMpIHtcbiAgICAgICAgdGhpcy5CQVNFID0gUG9pbnQuQkFTRTtcbiAgICAgICAgdGhpcy5aRVJPID0gUG9pbnQuWkVSTztcbiAgICAgICAgdGhpcy5GbiA9IFBvaW50LkZuO1xuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xuICAgIH1cbiAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICBfdW5zYWZlTGFkZGVyKGVsbSwgbiwgcCA9IHRoaXMuWkVSTykge1xuICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgIGlmIChuICYgXzFuKVxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgbiA+Pj0gXzFuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgICAqIEBwYXJhbSBwb2ludCBQb2ludCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAqL1xuICAgIHByZWNvbXB1dGVXaW5kb3cocG9pbnQsIFcpIHtcbiAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGxldCBwID0gcG9pbnQ7XG4gICAgICAgIGxldCBiYXNlID0gcDtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAvLyBpPTEsIGJjIHdlIHNraXAgMFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogTW9yZSBjb21wYWN0IGltcGxlbWVudGF0aW9uOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICovXG4gICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAvLyBTY2FsYXIgc2hvdWxkIGJlIHNtYWxsZXIgdGhhbiBmaWVsZCBvcmRlclxuICAgICAgICBpZiAoIXRoaXMuRm4uaXNWYWxpZChuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXInKTtcbiAgICAgICAgLy8gQWNjdW11bGF0b3JzXG4gICAgICAgIGxldCBwID0gdGhpcy5aRVJPO1xuICAgICAgICBsZXQgZiA9IHRoaXMuQkFTRTtcbiAgICAgICAgLy8gVGhpcyBjb2RlIHdhcyBmaXJzdCB3cml0dGVuIHdpdGggYXNzdW1wdGlvbiB0aGF0ICdmJyBhbmQgJ3AnIHdpbGwgbmV2ZXIgYmUgaW5maW5pdHkgcG9pbnQ6XG4gICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgLy8gd291bGQgYmUgdGhlIHNhbWUgYXMgaGlnaCBlbGVtZW50LCB3aGljaCB3aWxsIGNyZWF0ZSBjYXJyeSBpbnRvIG5leHQgd2luZG93LlxuICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIC8vIChuID09PSBfMG4pIGlzIGhhbmRsZWQgYW5kIG5vdCBlYXJseS1leGl0ZWQuIGlzRXZlbiBhbmQgb2Zmc2V0RiBhcmUgdXNlZCBmb3Igbm9pc2VcbiAgICAgICAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAvLyBiaXRzIGFyZSAwOiBhZGQgZ2FyYmFnZSB0byBmYWtlIHBvaW50XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5OiBhZGQgcmFuZG9tIFwibm9pc2VcIiBwb2ludCB0byBmLlxuICAgICAgICAgICAgICAgIGYgPSBmLmFkZChuZWdhdGVDdChpc05lZ0YsIHByZWNvbXB1dGVzW29mZnNldEZdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBiaXRzIGFyZSAxOiBhZGQgdG8gcmVzdWx0IHBvaW50XG4gICAgICAgICAgICAgICAgcCA9IHAuYWRkKG5lZ2F0ZUN0KGlzTmVnLCBwcmVjb21wdXRlc1tvZmZzZXRdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0MChuKTtcbiAgICAgICAgLy8gUmV0dXJuIGJvdGggcmVhbCBhbmQgZmFrZSBwb2ludHM6IEpJVCB3b24ndCBlbGltaW5hdGUgZi5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICByZXR1cm4geyBwLCBmIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgZWMgdW5zYWZlIChub24gY29uc3QtdGltZSkgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgKiBAcGFyYW0gYWNjIGFjY3VtdWxhdG9yIHBvaW50IHRvIGFkZCByZXN1bHQgb2YgbXVsdGlwbGljYXRpb25cbiAgICAgKiBAcmV0dXJucyBwb2ludFxuICAgICAqL1xuICAgIHdOQUZVbnNhZmUoVywgcHJlY29tcHV0ZXMsIG4sIGFjYyA9IHRoaXMuWkVSTykge1xuICAgICAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCB0aGlzLmJpdHMpO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3by53aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gRWFybHktZXhpdCwgc2tpcCAwIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgaWYgKGlzWmVybykge1xuICAgICAgICAgICAgICAgIC8vIFdpbmRvdyBiaXRzIGFyZSAwOiBza2lwIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIGFjYyA9IGFjYy5hZGQoaXNOZWcgPyBpdGVtLm5lZ2F0ZSgpIDogaXRlbSk7IC8vIFJlLXVzaW5nIGFjYyBhbGxvd3MgdG8gc2F2ZSBhZGRzIGluIE1TTVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydDAobik7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIGdldFByZWNvbXB1dGVzKFcsIHBvaW50LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQocG9pbnQpO1xuICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3cocG9pbnQsIFcpO1xuICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2luZyB0cmFuc2Zvcm0gb3V0c2lkZSBvZiBpZiBicmluZ3MgMTUlIHBlcmYgaGl0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIGNvbXAgPSB0cmFuc2Zvcm0oY29tcCk7XG4gICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQocG9pbnQsIGNvbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wO1xuICAgIH1cbiAgICBjYWNoZWQocG9pbnQsIHNjYWxhciwgdHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IFcgPSBnZXRXKHBvaW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCB0aGlzLmdldFByZWNvbXB1dGVzKFcsIHBvaW50LCB0cmFuc2Zvcm0pLCBzY2FsYXIpO1xuICAgIH1cbiAgICB1bnNhZmUocG9pbnQsIHNjYWxhciwgdHJhbnNmb3JtLCBwcmV2KSB7XG4gICAgICAgIGNvbnN0IFcgPSBnZXRXKHBvaW50KTtcbiAgICAgICAgaWYgKFcgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zYWZlTGFkZGVyKHBvaW50LCBzY2FsYXIsIHByZXYpOyAvLyBGb3IgVz0xIGxhZGRlciBpcyB+eDIgZmFzdGVyXG4gICAgICAgIHJldHVybiB0aGlzLndOQUZVbnNhZmUoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSwgc2NhbGFyLCBwcmV2KTtcbiAgICB9XG4gICAgLy8gV2UgY2FsY3VsYXRlIHByZWNvbXB1dGVzIGZvciBlbGxpcHRpYyBjdXJ2ZSBwb2ludCBtdWx0aXBsaWNhdGlvblxuICAgIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG4gICAgY3JlYXRlQ2FjaGUoUCwgVykge1xuICAgICAgICB2YWxpZGF0ZVcoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKFApO1xuICAgIH1cbiAgICBoYXNDYWNoZShlbG0pIHtcbiAgICAgICAgcmV0dXJuIGdldFcoZWxtKSAhPT0gMTtcbiAgICB9XG59XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuLyoqXG4gKiBFbmRvbW9ycGhpc20tc3BlY2lmaWMgbXVsdGlwbGljYXRpb24gZm9yIEtvYmxpdHogY3VydmVzLlxuICogQ29zdDogMTI4IGRibCwgMC0yNTYgYWRkcy5cbiAqL1xuZnVuY3Rpb24gbXVsRW5kb1Vuc2FmZShQb2ludCwgcG9pbnQsIGsxLCBrMikge1xuICAgIGxldCBhY2MgPSBwb2ludDtcbiAgICBsZXQgcDEgPSBQb2ludC5aRVJPO1xuICAgIGxldCBwMiA9IFBvaW50LlpFUk87XG4gICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgIHAxID0gcDEuYWRkKGFjYyk7XG4gICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgIHAyID0gcDIuYWRkKGFjYyk7XG4gICAgICAgIGFjYyA9IGFjYy5kb3VibGUoKTtcbiAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgazIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHsgcDEsIHAyIH07XG59XG4vKipcbiAqIFBpcHBlbmdlciBhbGdvcml0aG0gZm9yIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgdGhhbiBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHBhcmFtIHNjYWxhcnMgYXJyYXkgb2YgTCBzY2FsYXJzIChha2Egc2VjcmV0IGtleXMgLyBiaWdpbnRzKVxuICovXG5mdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBzbGVuZ3RoID0gc2NhbGFycy5sZW5ndGg7XG4gICAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSAoMCwgdXRpbHNfdHNfMS5iaXRMZW4pKEJpZ0ludChwbGVuZ3RoKSk7XG4gICAgbGV0IHdpbmRvd1NpemUgPSAxOyAvLyBiaXRzXG4gICAgaWYgKHdiaXRzID4gMTIpXG4gICAgICAgIHdpbmRvd1NpemUgPSB3Yml0cyAtIDM7XG4gICAgZWxzZSBpZiAod2JpdHMgPiA0KVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAyO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gMClcbiAgICAgICAgd2luZG93U2l6ZSA9IDI7XG4gICAgY29uc3QgTUFTSyA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5mdW5jdGlvbiBwcmVjb21wdXRlTVNNVW5zYWZlKGMsIGZpZWxkTiwgcG9pbnRzLCB3aW5kb3dTaXplKSB7XG4gICAgLyoqXG4gICAgICogUGVyZm9ybWFuY2UgQW5hbHlzaXMgb2YgV2luZG93LWJhc2VkIFByZWNvbXB1dGF0aW9uXG4gICAgICpcbiAgICAgKiBCYXNlIENhc2UgKDI1Ni1iaXQgc2NhbGFyLCA4LWJpdCB3aW5kb3cpOlxuICAgICAqIC0gU3RhbmRhcmQgcHJlY29tcHV0YXRpb24gcmVxdWlyZXM6XG4gICAgICogICAtIDMxIGFkZGl0aW9ucyBwZXIgc2NhbGFyIMOXIDI1NiBzY2FsYXJzID0gNyw5MzYgb3BzXG4gICAgICogICAtIFBsdXMgMjU1IHN1bW1hcnkgYWRkaXRpb25zID0gOCwxOTEgdG90YWwgb3BzXG4gICAgICogICBOb3RlOiBTdW1tYXJ5IGFkZGl0aW9ucyBjYW4gYmUgb3B0aW1pemVkIHZpYSBhY2N1bXVsYXRvclxuICAgICAqXG4gICAgICogQ2h1bmtlZCBQcmVjb21wdXRhdGlvbiBBbmFseXNpczpcbiAgICAgKiAtIFVzaW5nIDMyIGNodW5rcyByZXF1aXJlczpcbiAgICAgKiAgIC0gMjU1IGFkZGl0aW9ucyBwZXIgY2h1bmtcbiAgICAgKiAgIC0gMjU2IGRvdWJsaW5nc1xuICAgICAqICAgLSBUb3RhbDogKDI1NSDDlyAzMikgKyAyNTYgPSA4LDQxNiBvcHNcbiAgICAgKlxuICAgICAqIE1lbW9yeSBVc2FnZSBDb21wYXJpc29uOlxuICAgICAqIFdpbmRvdyBTaXplIHwgU3RhbmRhcmQgUG9pbnRzIHwgQ2h1bmtlZCBQb2ludHNcbiAgICAgKiAtLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tXG4gICAgICogICAgIDQtYml0ICAgfCAgICAgNTIwICAgICAgICAgfCAgICAgIDE1XG4gICAgICogICAgIDgtYml0ICAgfCAgICA0LDIyNCAgICAgICAgfCAgICAgMjU1XG4gICAgICogICAgMTAtYml0ICAgfCAgIDEzLDgyNCAgICAgICAgfCAgIDEsMDIzXG4gICAgICogICAgMTYtYml0ICAgfCAgNTU3LDA1NiAgICAgICAgfCAgNjUsNTM1XG4gICAgICpcbiAgICAgKiBLZXkgQWR2YW50YWdlczpcbiAgICAgKiAxLiBFbmFibGVzIGxhcmdlciB3aW5kb3cgc2l6ZXMgZHVlIHRvIHJlZHVjZWQgbWVtb3J5IG92ZXJoZWFkXG4gICAgICogMi4gTW9yZSBlZmZpY2llbnQgZm9yIHNtYWxsZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgICAtIDE2IGNodW5rczogKDE2IMOXIDI1NSkgKyAyNTYgPSA0LDMzNiBvcHNcbiAgICAgKiAgICAtIH4yeCBmYXN0ZXIgdGhhbiBzdGFuZGFyZCA4LDE5MSBvcHNcbiAgICAgKlxuICAgICAqIExpbWl0YXRpb25zOlxuICAgICAqIC0gTm90IHN1aXRhYmxlIGZvciBwbGFpbiBwcmVjb21wdXRlcyAocmVxdWlyZXMgMjU2IGNvbnN0YW50IGRvdWJsaW5ncylcbiAgICAgKiAtIFBlcmZvcm1hbmNlIGRlZ3JhZGVzIHdpdGggbGFyZ2VyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAtIE9wdGltYWwgZm9yIH4yNTYgc2NhbGFyc1xuICAgICAqICAgLSBMZXNzIGVmZmljaWVudCBmb3IgNDA5Nisgc2NhbGFycyAoUGlwcGVuZ2VyIHByZWZlcnJlZClcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVcod2luZG93U2l6ZSwgZmllbGROLkJJVFMpO1xuICAgIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB0YWJsZVNpemUgPSAyICoqIHdpbmRvd1NpemUgLSAxOyAvLyB0YWJsZSBzaXplICh3aXRob3V0IHplcm8pXG4gICAgY29uc3QgY2h1bmtzID0gTWF0aC5jZWlsKGZpZWxkTi5CSVRTIC8gd2luZG93U2l6ZSk7IC8vIGNodW5rcyBvZiBpdGVtXG4gICAgY29uc3QgTUFTSyA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEBkZXByZWNhdGVkICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgKDAsIG1vZHVsYXJfdHNfMS52YWxpZGF0ZUZpZWxkKShjdXJ2ZS5GcCk7XG4gICAgKDAsIHV0aWxzX3RzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uKDAsIG1vZHVsYXJfdHNfMS5uTGVuZ3RoKShjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkKG9yZGVyLCBmaWVsZCwgaXNMRSkge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQuT1JERVIgIT09IG9yZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5PUkRFUiBtdXN0IG1hdGNoIG9yZGVyOiBGcCA9PSBwLCBGbiA9PSBuJyk7XG4gICAgICAgICgwLCBtb2R1bGFyX3RzXzEudmFsaWRhdGVGaWVsZCkoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfdHNfMS5GaWVsZCkob3JkZXIsIHsgaXNMRSB9KTtcbiAgICB9XG59XG4vKiogVmFsaWRhdGVzIENVUlZFIG9wdHMgYW5kIGNyZWF0ZXMgZmllbGRzICovXG5mdW5jdGlvbiBfY3JlYXRlQ3VydmVGaWVsZHModHlwZSwgQ1VSVkUsIGN1cnZlT3B0cyA9IHt9LCBGcEZuTEUpIHtcbiAgICBpZiAoRnBGbkxFID09PSB1bmRlZmluZWQpXG4gICAgICAgIEZwRm5MRSA9IHR5cGUgPT09ICdlZHdhcmRzJztcbiAgICBpZiAoIUNVUlZFIHx8IHR5cGVvZiBDVVJWRSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdmFsaWQgJHt0eXBlfSBDVVJWRSBvYmplY3RgKTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgWydwJywgJ24nLCAnaCddKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IENVUlZFW3BdO1xuICAgICAgICBpZiAoISh0eXBlb2YgdmFsID09PSAnYmlnaW50JyAmJiB2YWwgPiBfMG4pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgcG9zaXRpdmUgYmlnaW50YCk7XG4gICAgfVxuICAgIGNvbnN0IEZwID0gY3JlYXRlRmllbGQoQ1VSVkUucCwgY3VydmVPcHRzLkZwLCBGcEZuTEUpO1xuICAgIGNvbnN0IEZuID0gY3JlYXRlRmllbGQoQ1VSVkUubiwgY3VydmVPcHRzLkZuLCBGcEZuTEUpO1xuICAgIGNvbnN0IF9iID0gdHlwZSA9PT0gJ3dlaWVyc3RyYXNzJyA/ICdiJyA6ICdkJztcbiAgICBjb25zdCBwYXJhbXMgPSBbJ0d4JywgJ0d5JywgJ2EnLCBfYl07XG4gICAgZm9yIChjb25zdCBwIG9mIHBhcmFtcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmICghRnAuaXNWYWxpZChDVVJWRVtwXSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENVUlZFLiR7cH0gbXVzdCBiZSB2YWxpZCBmaWVsZCBlbGVtZW50IG9mIENVUlZFLkZwYCk7XG4gICAgfVxuICAgIENVUlZFID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKHt9LCBDVVJWRSkpO1xuICAgIHJldHVybiB7IENVUlZFLCBGcCwgRm4gfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmltZUVkd2FyZHNQb2ludCA9IHZvaWQgMDtcbmV4cG9ydHMuZWR3YXJkcyA9IGVkd2FyZHM7XG5leHBvcnRzLmVkZHNhID0gZWRkc2E7XG5leHBvcnRzLnR3aXN0ZWRFZHdhcmRzID0gdHdpc3RlZEVkd2FyZHM7XG4vKipcbiAqIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsi5cbiAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuICogVW50d2lzdGVkIEVkd2FyZHMgY3VydmVzIGV4aXN0LCBidXQgdGhleSBhcmVuJ3QgdXNlZCBpbiByZWFsLXdvcmxkIHByb3RvY29scy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbmNvbnN0IGN1cnZlX3RzXzEgPSByZXF1aXJlKFwiLi9jdXJ2ZS5qc1wiKTtcbmNvbnN0IG1vZHVsYXJfdHNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzhuID0gQmlnSW50KDgpO1xuZnVuY3Rpb24gaXNFZFZhbGlkWFkoRnAsIENVUlZFLCB4LCB5KSB7XG4gICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7XG4gICAgY29uc3QgeTIgPSBGcC5zcXIoeSk7XG4gICAgY29uc3QgbGVmdCA9IEZwLmFkZChGcC5tdWwoQ1VSVkUuYSwgeDIpLCB5Mik7XG4gICAgY29uc3QgcmlnaHQgPSBGcC5hZGQoRnAuT05FLCBGcC5tdWwoQ1VSVkUuZCwgRnAubXVsKHgyLCB5MikpKTtcbiAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbn1cbmZ1bmN0aW9uIGVkd2FyZHMocGFyYW1zLCBleHRyYU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHZhbGlkYXRlZCA9ICgwLCBjdXJ2ZV90c18xLl9jcmVhdGVDdXJ2ZUZpZWxkcykoJ2Vkd2FyZHMnLCBwYXJhbXMsIGV4dHJhT3B0cywgZXh0cmFPcHRzLkZwRm5MRSk7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IHZhbGlkYXRlZDtcbiAgICBsZXQgQ1VSVkUgPSB2YWxpZGF0ZWQuQ1VSVkU7XG4gICAgY29uc3QgeyBoOiBjb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgKDAsIHV0aWxzX3RzXzEuX3ZhbGlkYXRlT2JqZWN0KShleHRyYU9wdHMsIHt9LCB7IHV2UmF0aW86ICdmdW5jdGlvbicgfSk7XG4gICAgLy8gSW1wb3J0YW50OlxuICAgIC8vIFRoZXJlIGFyZSBzb21lIHBsYWNlcyB3aGVyZSBGcC5CWVRFUyBpcyB1c2VkIGluc3RlYWQgb2YgbkJ5dGVMZW5ndGguXG4gICAgLy8gU28gZmFyLCBldmVyeXRoaW5nIGhhcyBiZWVuIHRlc3RlZCB3aXRoIGN1cnZlcyBvZiBGcC5CWVRFUyA9PSBuQnl0ZUxlbmd0aC5cbiAgICAvLyBUT0RPOiB0ZXN0IGFuZCBmaW5kIGN1cnZlcyB3aGljaCBiZWhhdmUgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChGbi5CWVRFUyAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gKG4pID0+IEZwLmNyZWF0ZShuKTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IGV4dHJhT3B0cy51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydChGcC5kaXYodSwgdikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIGVxdWF0aW9uIGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNFZFZhbGlkWFkoRnAsIENVUlZFLCBDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8qKlxuICAgICAqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgTUFTSy5cbiAgICAgKiBDb29yZGluYXRlcyA+PSBGcC5PUkRFUiBhcmUgYWxsb3dlZCBmb3IgemlwMjE1LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhblplcm8gPyBfMW4gOiBfMG47XG4gICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgnY29vcmRpbmF0ZSAnICsgdGl0bGUsIG4sIG1pbiwgTUFTSyk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZXh0cG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gKDAsIHV0aWxzX3RzXzEubWVtb2l6ZWQpKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IFgsIFksIFogfSA9IHA7XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBfOG4gOiBGcC5pbnYoWik7IC8vIDggd2FzIGNob3NlbiBhcmJpdHJhcmlseVxuICAgICAgICBjb25zdCB4ID0gbW9kUChYICogaXopO1xuICAgICAgICBjb25zdCB5ID0gbW9kUChZICogaXopO1xuICAgICAgICBjb25zdCB6eiA9IEZwLm11bChaLCBpeik7XG4gICAgICAgIGlmIChpczApXG4gICAgICAgICAgICByZXR1cm4geyB4OiBfMG4sIHk6IF8xbiB9O1xuICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSk7XG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gKDAsIHV0aWxzX3RzXzEubWVtb2l6ZWQpKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChwLmlzMCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaLCBUIH0gPSBwO1xuICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgY29uc3QgWTIgPSBtb2RQKFkgKiBZKTsgLy8gWcKyXG4gICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWMKyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKFgsIFksIFosIFQpIOKIiyAoeD1YL1osIHk9WS9aLCBUPXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKFgsIFksIFosIFQpIHtcbiAgICAgICAgICAgIHRoaXMuWCA9IGFjb29yZCgneCcsIFgpO1xuICAgICAgICAgICAgdGhpcy5ZID0gYWNvb3JkKCd5JywgWSk7XG4gICAgICAgICAgICB0aGlzLlogPSBhY29vcmQoJ3onLCBaLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuVCA9IGFjb29yZCgndCcsIFQpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgQ1VSVkUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1VSVkU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBhY29vcmQoJ3gnLCB4KTtcbiAgICAgICAgICAgIGFjb29yZCgneScsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgYnl0ZXMgPSAoMCwgdXRpbHNfdHNfMS5jb3B5Qnl0ZXMpKCgwLCB1dGlsc190c18xLl9hYnl0ZXMyKShieXRlcywgbGVuLCAncG9pbnQnKSk7XG4gICAgICAgICAgICAoMCwgdXRpbHNfdHNfMS5fYWJvb2wyKSh6aXAyMTUsICd6aXAyMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1lZCA9ICgwLCB1dGlsc190c18xLmNvcHlCeXRlcykoYnl0ZXMpOyAvLyBjb3B5IGFnYWluLCB3ZSdsbCBtYW5pcHVsYXRlIGl0XG4gICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IGJ5dGVzW2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkobm9ybWVkKTtcbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzLiA9ZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01LlxuICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHppcDIxNSA/IE1BU0sgOiBGcC5PUkRFUjtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgncG9pbnQueScsIHksIF8wbiwgbWF4KTtcbiAgICAgICAgICAgIC8vIEVkMjU1MTk6IHjCsiA9ICh5wrItMSkvKGR5wrIrMSkgbW9kIHAuIEVkNDQ4OiB4wrIgPSAoecKyLTEpLyhkecKyLTEpIG1vZCBwLiBHZW5lcmljIGNhc2U6XG4gICAgICAgICAgICAvLyBheMKyK3nCsj0xK2R4wrJ5wrIgPT4gecKyLTE9ZHjCsnnCsi1heMKyID0+IHnCsi0xPXjCsihkecKyLWEpID0+IHjCsj0oecKyLTEpLyhkecKyLWEpXG4gICAgICAgICAgICBjb25zdCB5MiA9IG1vZFAoeSAqIHkpOyAvLyBkZW5vbWluYXRvciBpcyBhbHdheXMgbm9uLTAgbW9kIHAuXG4gICAgICAgICAgICBjb25zdCB1ID0gbW9kUCh5MiAtIF8xbik7IC8vIHUgPSB5wrIgLSAxXG4gICAgICAgICAgICBjb25zdCB2ID0gbW9kUChkICogeTIgLSBhKTsgLy8gdiA9IGQgecKyICsgMS5cbiAgICAgICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyDiiJoodS92KVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpbnZhbGlkIHkgY29vcmRpbmF0ZScpO1xuICAgICAgICAgICAgY29uc3QgaXNYT2RkID0gKHggJiBfMW4pID09PSBfMW47IC8vIFRoZXJlIGFyZSAyIHNxdWFyZSByb290cy4gVXNlIHhfMCBiaXQgdG8gc2VsZWN0IHByb3BlclxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChsYXN0Qnl0ZSAmIDB4ODApICE9PSAwOyAvLyB4XzAsIGxhc3QgYml0XG4gICAgICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSBfMG4gJiYgaXNMYXN0Qnl0ZU9kZClcbiAgICAgICAgICAgICAgICAvLyBpZiB4PTAgYW5kIHhfMCA9IDEsIGZhaWxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeD0wIGFuZCB4XzA9MScpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEJ5dGVPZGQgIT09IGlzWE9kZClcbiAgICAgICAgICAgICAgICB4ID0gbW9kUCgteCk7IC8vIGlmIHhfMCAhPSB4IG1vZCAyLCBzZXQgeCA9IHAteFxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LmZyb21CeXRlcygoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3BvaW50JywgYnl0ZXMpLCB6aXAyMTUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIGlzTGF6eSA9IHRydWUpIHtcbiAgICAgICAgICAgIHduYWYuY3JlYXRlQ2FjaGUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTGF6eSlcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5KF8ybik7IC8vIHJhbmRvbSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZWZ1bCBpbiBmcm9tQWZmaW5lKCkgLSBub3QgZm9yIGZyb21CeXRlcygpLCB3aGljaCBhbHdheXMgY3JlYXRlZCB2YWxpZCBwb2ludHMuXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYWV4dHBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBYMVoyID0gbW9kUChYMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFgyWjEgPSBtb2RQKFgyICogWjEpO1xuICAgICAgICAgICAgY29uc3QgWTFaMiA9IG1vZFAoWTEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBZMloxID0gbW9kUChZMiAqIFoxKTtcbiAgICAgICAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIC8vIEZsaXBzIHBvaW50IHNpZ24gdG8gYSBuZWdhdGl2ZSBvbmUgKC14LCB5IGluIGFmZmluZSBjb29yZHMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZFAoLXRoaXMuWCksIHRoaXMuWSwgdGhpcy5aLCBtb2RQKC10aGlzLlQpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGRvdWJsaW5nIEV4dGVuZGVkIFBvaW50LlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA0TSArIDRTICsgMSphICsgNmFkZCArIDEqMi5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDEpOyAvLyBBID0gWDEyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkxKTsgLy8gQiA9IFkxMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoXzJuICogbW9kUChaMSAqIFoxKSk7IC8vIEMgPSAyKloxMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoYSAqIEEpOyAvLyBEID0gYSpBXG4gICAgICAgICAgICBjb25zdCB4MXkxID0gWDEgKyBZMTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKG1vZFAoeDF5MSAqIHgxeTEpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKTItQS1CXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEI7IC8vIEcgPSBEK0JcbiAgICAgICAgICAgIGNvbnN0IEYgPSBHIC0gQzsgLy8gRiA9IEctQ1xuICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBCOyAvLyBIID0gRC1CXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhZXh0cG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSwgVDogVDEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIsIFQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDIpOyAvLyBBID0gWDEqWDJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTIpOyAvLyBCID0gWTEqWTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFQxICogZCAqIFQyKTsgLy8gQyA9IFQxKmQqVDJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFoxICogWjIpOyAvLyBEID0gWjEqWjJcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkqKFgyK1kyKS1BLUJcbiAgICAgICAgICAgIGNvbnN0IEYgPSBEIC0gQzsgLy8gRiA9IEQtQ1xuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBDOyAvLyBHID0gRCtDXG4gICAgICAgICAgICBjb25zdCBIID0gbW9kUChCIC0gYSAqIEEpOyAvLyBIID0gQi1hKkFcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIC8vIDEgPD0gc2NhbGFyIDwgTFxuICAgICAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChzY2FsYXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDEgPD0gc2MgPCBjdXJ2ZS5uJyk7XG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHduYWYuY2FjaGVkKHRoaXMsIHNjYWxhciwgKHApID0+ICgwLCBjdXJ2ZV90c18xLm5vcm1hbGl6ZVopKFBvaW50LCBwKSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGN1cnZlX3RzXzEubm9ybWFsaXplWikoUG9pbnQsIFtwLCBmXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAvLyBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAvLyBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbi5cbiAgICAgICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgICAgICAvLyBBY2NlcHRzIG9wdGlvbmFsIGFjY3VtdWxhdG9yIHRvIG1lcmdlIHdpdGggbXVsdGlwbHkgKGltcG9ydGFudCBmb3Igc3BhcnNlIHNjYWxhcnMpXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhciwgYWNjID0gUG9pbnQuWkVSTykge1xuICAgICAgICAgICAgLy8gMCA8PSBzY2FsYXIgPCBMXG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWQoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBleHBlY3RlZCAwIDw9IHNjIDwgY3VydmUubicpO1xuICAgICAgICAgICAgaWYgKHNjYWxhciA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2NhbGFyID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmUodGhpcywgc2NhbGFyLCAocCkgPT4gKDAsIGN1cnZlX3RzXzEubm9ybWFsaXplWikoUG9pbnQsIHApLCBhY2MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAgICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIENVUlZFLm4pLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgdG9BZmZpbmUoaW52ZXJ0ZWRaKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGludmVydGVkWik7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIEZwLnRvQnl0ZXMoKSBhbGxvd3Mgbm9uLWNhbm9uaWNhbCBlbmNvZGluZyBvZiB5ICg+PSBwKS5cbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gRnAudG9CeXRlcyh5KTtcbiAgICAgICAgICAgIC8vIEVhY2ggeSBoYXMgMiB2YWxpZCBwb2ludHM6ICh4LCB5KSwgKHgsLXkpLlxuICAgICAgICAgICAgLy8gV2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeSBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgICAgICAgYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gfD0geCAmIF8xbiA/IDB4ODAgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmJ5dGVzVG9IZXgpKHRoaXMudG9CeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgPFBvaW50ICR7dGhpcy5pczAoKSA/ICdaRVJPJyA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgZ2V0IGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldCBleigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlo7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfdHNfMS5ub3JtYWxpemVaKShQb2ludCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjdXJ2ZV90c18xLnBpcHBlbmdlcikoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY29tcHV0ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2RQKENVUlZFLkd4ICogQ1VSVkUuR3kpKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMW4sIF8xbiwgXzBuKTsgLy8gMCwgMSwgMSwgMFxuICAgIC8vIG1hdGggZmllbGRcbiAgICBQb2ludC5GcCA9IEZwO1xuICAgIC8vIHNjYWxhciBmaWVsZFxuICAgIFBvaW50LkZuID0gRm47XG4gICAgY29uc3Qgd25hZiA9IG5ldyBjdXJ2ZV90c18xLndOQUYoUG9pbnQsIEZuLkJJVFMpO1xuICAgIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIHJldHVybiBQb2ludDtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgcHJpbWUtb3JkZXIgcG9pbnRzIGxpa2UgUmlzdHJldHRvMjU1IGFuZCBEZWNhZjQ0OC5cbiAqIFRoZXNlIHBvaW50cyBlbGltaW5hdGUgY29mYWN0b3IgaXNzdWVzIGJ5IHJlcHJlc2VudGluZyBlcXVpdmFsZW5jZSBjbGFzc2VzXG4gKiBvZiBFZHdhcmRzIGN1cnZlIHBvaW50cy5cbiAqL1xuY2xhc3MgUHJpbWVFZHdhcmRzUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgdGhhdCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF9ieXRlcykge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5ub3RJbXBsZW1lbnRlZCkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoX2hleCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5ub3RJbXBsZW1lbnRlZCkoKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICB9XG4gICAgLy8gQ29tbW9uIGltcGxlbWVudGF0aW9uc1xuICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgIC8vIG5vLW9wIGZvciBwcmltZS1vcmRlciBncm91cHNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICB0aGlzLmVwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHRvQWZmaW5lKGludmVydGVkWikge1xuICAgICAgICByZXR1cm4gdGhpcy5lcC50b0FmZmluZShpbnZlcnRlZFopO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmJ5dGVzVG9IZXgpKHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLnN1YnRyYWN0KG90aGVyLmVwKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUsIGlzTGF6eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBpc0xhenkpKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltZUVkd2FyZHNQb2ludCA9IFByaW1lRWR3YXJkc1BvaW50O1xuLyoqXG4gKiBJbml0aWFsaXplcyBFZERTQSBzaWduYXR1cmVzIG92ZXIgZ2l2ZW4gRWR3YXJkcyBjdXJ2ZS5cbiAqL1xuZnVuY3Rpb24gZWRkc2EoUG9pbnQsIGNIYXNoLCBlZGRzYU9wdHMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgY0hhc2ggIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignXCJoYXNoXCIgZnVuY3Rpb24gcGFyYW0gaXMgcmVxdWlyZWQnKTtcbiAgICAoMCwgdXRpbHNfdHNfMS5fdmFsaWRhdGVPYmplY3QpKGVkZHNhT3B0cywge30sIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHByZWhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSBlZGRzYU9wdHM7XG4gICAgY29uc3QgeyBCQVNFLCBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzID0gZWRkc2FPcHRzLnJhbmRvbUJ5dGVzIHx8IHV0aWxzX3RzXzEucmFuZG9tQnl0ZXM7XG4gICAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBlZGRzYU9wdHMuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IGRvbWFpbiA9IGVkZHNhT3B0cy5kb21haW4gfHxcbiAgICAgICAgKChkYXRhLCBjdHgsIHBoZmxhZykgPT4ge1xuICAgICAgICAgICAgKDAsIHV0aWxzX3RzXzEuX2Fib29sMikocGhmbGFnLCAncGhmbGFnJyk7XG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCB8fCBwaGZsYWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZXh0cy9wcmUtaGFzaCBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pOyAvLyBOT09QXG4gICAgLy8gTGl0dGxlLWVuZGlhbiBTSEE1MTIgd2l0aCBtb2R1bG8gblxuICAgIGZ1bmN0aW9uIG1vZE5fTEUoaGFzaCkge1xuICAgICAgICByZXR1cm4gRm4uY3JlYXRlKCgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoaGFzaCkpOyAvLyBOb3QgRm4uZnJvbUJ5dGVzOiBpdCBoYXMgbGVuZ3RoIGxpbWl0XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGFzaGVkIHByaXZhdGUgc2NhbGFyIHBlciBSRkM4MDMyIDUuMS41XG4gICAgZnVuY3Rpb24gZ2V0UHJpdmF0ZVNjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zZWNyZXRLZXk7XG4gICAgICAgIGtleSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIGxlbik7XG4gICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgICAgIC8vIENoZWNrIGJ5dGUgbGVuZ3RoczogZW5zdXJlKDY0LCBoKGVuc3VyZSgzMiwga2V5KSkpXG4gICAgICAgIGNvbnN0IGhhc2hlZCA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnaGFzaGVkIHByaXZhdGUga2V5JywgY0hhc2goa2V5KSwgMiAqIGxlbik7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQuc2xpY2UoMCwgbGVuKSk7IC8vIGNsZWFyIGZpcnN0IGhhbGYgYml0cywgcHJvZHVjZSBGRVxuICAgICAgICBjb25zdCBwcmVmaXggPSBoYXNoZWQuc2xpY2UobGVuLCAyICogbGVuKTsgLy8gc2Vjb25kIGhhbGYgaXMgY2FsbGVkIGtleSBwcmVmaXggKDUuMS42KVxuICAgICAgICBjb25zdCBzY2FsYXIgPSBtb2ROX0xFKGhlYWQpOyAvLyBUaGUgYWN0dWFsIHByaXZhdGUgc2NhbGFyXG4gICAgICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyIH07XG4gICAgfVxuICAgIC8qKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjcmVhdGVzIHB1YmxpYyBrZXkgZnJvbSBzY2FsYXIuIFJGQzgwMzIgNS4xLjUgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICAgICAgY29uc3QgeyBoZWFkLCBwcmVmaXgsIHNjYWxhciB9ID0gZ2V0UHJpdmF0ZVNjYWxhcihzZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IEJBU0UubXVsdGlwbHkoc2NhbGFyKTsgLy8gUG9pbnQgb24gRWR3YXJkcyBjdXJ2ZSBha2EgcHVibGljIGtleVxuICAgICAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9CeXRlcygpO1xuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciwgcG9pbnQsIHBvaW50Qnl0ZXMgfTtcbiAgICB9XG4gICAgLyoqIENhbGN1bGF0ZXMgRWREU0EgcHViIGtleS4gUkZDODAzMiA1LjEuNS4gKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpLnBvaW50Qnl0ZXM7XG4gICAgfVxuICAgIC8vIGludCgnTEUnLCBTSEE1MTIoZG9tMihGLCBDKSB8fCBtc2dzKSkgbW9kIE5cbiAgICBmdW5jdGlvbiBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCA9IFVpbnQ4QXJyYXkub2YoKSwgLi4ubXNncykge1xuICAgICAgICBjb25zdCBtc2cgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnY29udGV4dCcsIGNvbnRleHQpLCAhIXByZWhhc2gpKSk7XG4gICAgfVxuICAgIC8qKiBTaWducyBtZXNzYWdlIHdpdGggcHJpdmF0ZUtleS4gUkZDODAzMiA1LjEuNiAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnLCBzZWNyZXRLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBtc2cgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCBldGMuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHNlY3JldEtleSk7XG4gICAgICAgIGNvbnN0IHIgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBwcmVmaXgsIG1zZyk7IC8vIHIgPSBkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKVxuICAgICAgICBjb25zdCBSID0gQkFTRS5tdWx0aXBseShyKS50b0J5dGVzKCk7IC8vIFIgPSByR1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgUiwgcG9pbnRCeXRlcywgbXNnKTsgLy8gUiB8fCBBIHx8IFBIKE0pXG4gICAgICAgIGNvbnN0IHMgPSBGbi5jcmVhdGUociArIGsgKiBzY2FsYXIpOyAvLyBTID0gKHIgKyBrICogcykgbW9kIExcbiAgICAgICAgaWYgKCFGbi5pc1ZhbGlkKHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogaW52YWxpZCBzJyk7IC8vIDAgPD0gcyA8IExcbiAgICAgICAgY29uc3QgcnMgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoUiwgRm4udG9CeXRlcyhzKSk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5fYWJ5dGVzMikocnMsIGxlbmd0aHMuc2lnbmF0dXJlLCAncmVzdWx0Jyk7XG4gICAgfVxuICAgIC8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSB7IHppcDIxNTogdHJ1ZSB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICogQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBzaWcgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZywgbGVuKTtcbiAgICAgICAgbXNnID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgcHVibGljS2V5ID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIGxlbmd0aHMucHVibGljS2V5KTtcbiAgICAgICAgaWYgKHppcDIxNSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgKDAsIHV0aWxzX3RzXzEuX2Fib29sMikoemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgbWlkID0gbGVuIC8gMjtcbiAgICAgICAgY29uc3QgciA9IHNpZy5zdWJhcnJheSgwLCBtaWQpO1xuICAgICAgICBjb25zdCBzID0gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKShzaWcuc3ViYXJyYXkobWlkLCBsZW4pKTtcbiAgICAgICAgbGV0IEEsIFIsIFNCO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gemlwMjE1PXRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMuID1mYWxzZSBmb2xsb3dzIFJGQzgwMzIgLyBOSVNUMTg2LTUuXG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIEEgPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5LCB6aXAyMTUpO1xuICAgICAgICAgICAgUiA9IFBvaW50LmZyb21CeXRlcyhyLCB6aXAyMTUpO1xuICAgICAgICAgICAgU0IgPSBCQVNFLm11bHRpcGx5VW5zYWZlKHMpOyAvLyAwIDw9IHMgPCBsIGlzIGRvbmUgaW5zaWRlXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gemlwMjE1IGFsbG93cyBwdWJsaWMga2V5cyBvZiBzbWFsbCBvcmRlclxuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQsIFIudG9CeXRlcygpLCBBLnRvQnl0ZXMoKSwgbXNnKTtcbiAgICAgICAgY29uc3QgUmtBID0gUi5hZGQoQS5tdWx0aXBseVVuc2FmZShrKSk7XG4gICAgICAgIC8vIEV4dGVuZGVkIGdyb3VwIGVxdWF0aW9uXG4gICAgICAgIC8vIFs4XVtTXUIgPSBbOF1SICsgWzhdW2tdQSdcbiAgICAgICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikuY2xlYXJDb2ZhY3RvcigpLmlzMCgpO1xuICAgIH1cbiAgICBjb25zdCBfc2l6ZSA9IEZwLkJZVEVTOyAvLyAzMiBmb3IgZWQyNTUxOSwgNTcgZm9yIGVkNDQ4XG4gICAgY29uc3QgbGVuZ3RocyA9IHtcbiAgICAgICAgc2VjcmV0S2V5OiBfc2l6ZSxcbiAgICAgICAgcHVibGljS2V5OiBfc2l6ZSxcbiAgICAgICAgc2lnbmF0dXJlOiAyICogX3NpemUsXG4gICAgICAgIHNlZWQ6IF9zaXplLFxuICAgIH07XG4gICAgZnVuY3Rpb24gcmFuZG9tU2VjcmV0S2V5KHNlZWQgPSByYW5kb21CeXRlcyhsZW5ndGhzLnNlZWQpKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5fYWJ5dGVzMikoc2VlZCwgbGVuZ3Rocy5zZWVkLCAnc2VlZCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSB1dGlscy5yYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkU2VjcmV0S2V5KGtleSkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuaXNCeXRlcykoa2V5KSAmJiBrZXkubGVuZ3RoID09PSBGbi5CWVRFUztcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZFB1YmxpY0tleShrZXksIHppcDIxNSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuICEhUG9pbnQuZnJvbUJ5dGVzKGtleSwgemlwMjE1KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXksXG4gICAgICAgIHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFB1YmxpY0tleSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGVkIHB1YmxpYyBrZXkgdG8geCBwdWJsaWMga2V5LiBVc2VzIGZvcm11bGE6XG4gICAgICAgICAqIC0gZWQyNTUxOTpcbiAgICAgICAgICogICAtIGAodSwgdikgPSAoKDEreSkvKDEteSksIHNxcnQoLTQ4NjY2NCkqdS94KWBcbiAgICAgICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgtNDg2NjY0KSp1L3YsICh1LTEpLyh1KzEpKWBcbiAgICAgICAgICogLSBlZDQ0ODpcbiAgICAgICAgICogICAtIGAodSwgdikgPSAoKHktMSkvKHkrMSksIHNxcnQoMTU2MzI0KSp1L3gpYFxuICAgICAgICAgKiAgIC0gYCh4LCB5KSA9IChzcXJ0KDE1NjMyNCkqdS92LCAoMSt1KS8oMS11KSlgXG4gICAgICAgICAqL1xuICAgICAgICB0b01vbnRnb21lcnkocHVibGljS2V5KSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMucHVibGljS2V5O1xuICAgICAgICAgICAgY29uc3QgaXMyNTUxOSA9IHNpemUgPT09IDMyO1xuICAgICAgICAgICAgaWYgKCFpczI1NTE5ICYmIHNpemUgIT09IDU3KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBkZWZpbmVkIGZvciAyNTUxOSBhbmQgNDQ4Jyk7XG4gICAgICAgICAgICBjb25zdCB1ID0gaXMyNTUxOSA/IEZwLmRpdihfMW4gKyB5LCBfMW4gLSB5KSA6IEZwLmRpdih5IC0gXzFuLCB5ICsgXzFuKTtcbiAgICAgICAgICAgIHJldHVybiBGcC50b0J5dGVzKHUpO1xuICAgICAgICB9LFxuICAgICAgICB0b01vbnRnb21lcnlQcml2KHNlY3JldEtleSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2VjcmV0S2V5O1xuICAgICAgICAgICAgKDAsIHV0aWxzX3RzXzEuX2FieXRlczIpKHNlY3JldEtleSwgc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSBjSGFzaChzZWNyZXRLZXkuc3ViYXJyYXkoMCwgc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5wcmVjb21wdXRlKHdpbmRvd1NpemUsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIFBvaW50LFxuICAgICAgICBsZW5ndGhzLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2VkZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyhjKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB7XG4gICAgICAgIGE6IGMuYSxcbiAgICAgICAgZDogYy5kLFxuICAgICAgICBwOiBjLkZwLk9SREVSLFxuICAgICAgICBuOiBjLm4sXG4gICAgICAgIGg6IGMuaCxcbiAgICAgICAgR3g6IGMuR3gsXG4gICAgICAgIEd5OiBjLkd5LFxuICAgIH07XG4gICAgY29uc3QgRnAgPSBjLkZwO1xuICAgIGNvbnN0IEZuID0gKDAsIG1vZHVsYXJfdHNfMS5GaWVsZCkoQ1VSVkUubiwgYy5uQml0TGVuZ3RoLCB0cnVlKTtcbiAgICBjb25zdCBjdXJ2ZU9wdHMgPSB7IEZwLCBGbiwgdXZSYXRpbzogYy51dlJhdGlvIH07XG4gICAgY29uc3QgZWRkc2FPcHRzID0ge1xuICAgICAgICByYW5kb21CeXRlczogYy5yYW5kb21CeXRlcyxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6IGMuYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgICAgIGRvbWFpbjogYy5kb21haW4sXG4gICAgICAgIHByZWhhc2g6IGMucHJlaGFzaCxcbiAgICAgICAgbWFwVG9DdXJ2ZTogYy5tYXBUb0N1cnZlLFxuICAgIH07XG4gICAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaDogYy5oYXNoLCBlZGRzYU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBlZGRzYSkge1xuICAgIGNvbnN0IFBvaW50ID0gZWRkc2EuUG9pbnQ7XG4gICAgY29uc3QgbGVnYWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgZWRkc2EsIHtcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIENVUlZFOiBjLFxuICAgICAgICBuQml0TGVuZ3RoOiBQb2ludC5Gbi5CSVRTLFxuICAgICAgICBuQnl0ZUxlbmd0aDogUG9pbnQuRm4uQllURVMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGxlZ2FjeTtcbn1cbi8vIFRPRE86IHJlbW92ZS4gVXNlIGVkZHNhXG5mdW5jdGlvbiB0d2lzdGVkRWR3YXJkcyhjKSB7XG4gICAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoLCBlZGRzYU9wdHMgfSA9IF9lZGRzYV9sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgUG9pbnQgPSBlZHdhcmRzKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IEVERFNBID0gZWRkc2EoUG9pbnQsIGhhc2gsIGVkZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBFRERTQSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZHdhcmRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5fRFNUX3NjYWxhciA9IHZvaWQgMDtcbmV4cG9ydHMuZXhwYW5kX21lc3NhZ2VfeG1kID0gZXhwYW5kX21lc3NhZ2VfeG1kO1xuZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94b2YgPSBleHBhbmRfbWVzc2FnZV94b2Y7XG5leHBvcnRzLmhhc2hfdG9fZmllbGQgPSBoYXNoX3RvX2ZpZWxkO1xuZXhwb3J0cy5pc29nZW55TWFwID0gaXNvZ2VueU1hcDtcbmV4cG9ydHMuY3JlYXRlSGFzaGVyID0gY3JlYXRlSGFzaGVyO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcbmNvbnN0IG1vZHVsYXJfdHNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgYW51bSh2YWx1ZSk7XG4gICAgYW51bShsZW5ndGgpO1xuICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPj0gMSA8PCAoOCAqIGxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBJMk9TUCBpbnB1dDogJyArIHZhbHVlKTtcbiAgICBjb25zdCByZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoIH0pLmZpbGwoMCk7XG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJlc1tpXSA9IHZhbHVlICYgMHhmZjtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocmVzKTtcbn1cbmZ1bmN0aW9uIHN0cnhvcihhLCBiKSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhW2ldIF4gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmZ1bmN0aW9uIGFudW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBub3JtRFNUKERTVCkge1xuICAgIGlmICghKDAsIHV0aWxzX3RzXzEuaXNCeXRlcykoRFNUKSAmJiB0eXBlb2YgRFNUICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xuICAgIHJldHVybiB0eXBlb2YgRFNUID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc190c18xLnV0ZjhUb0J5dGVzKShEU1QpIDogRFNUO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShtc2cpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgRFNUID0gbm9ybURTVChEU1QpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSCgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzX3RzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9ICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKCgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSCgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbiAqIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuICogMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbiAqICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuICogW1JGQyA5MzgwIDUuMy4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4yKS5cbiAqL1xuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBrLCBIKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShtc2cpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgRFNUID0gbm9ybURTVChEU1QpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKCgwLCB1dGlsc190c18xLnV0ZjhUb0J5dGVzKSgnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuX3ZhbGlkYXRlT2JqZWN0KShvcHRpb25zLCB7XG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnbnVtYmVyJyxcbiAgICAgICAgazogJ251bWJlcicsXG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVCB9ID0gb3B0aW9ucztcbiAgICBpZiAoISgwLCB1dGlsc190c18xLmlzSGFzaCkob3B0aW9ucy5oYXNoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBoYXNoJyk7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKShvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmZ1bmN0aW9uIGlzb2dlbnlNYXAoZmllbGQsIG1hcCkge1xuICAgIC8vIE1ha2Ugc2FtZSBvcmRlciBhcyBpbiBzcGVjXG4gICAgY29uc3QgY29lZmYgPSBtYXAubWFwKChpKSA9PiBBcnJheS5mcm9tKGkpLnJldmVyc2UoKSk7XG4gICAgcmV0dXJuICh4LCB5KSA9PiB7XG4gICAgICAgIGNvbnN0IFt4biwgeGQsIHluLCB5ZF0gPSBjb2VmZi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIC8vIDYuNi4zXG4gICAgICAgIC8vIEV4Y2VwdGlvbmFsIGNhc2VzIG9mIGlzb19tYXAgYXJlIGlucHV0cyB0aGF0IGNhdXNlIHRoZSBkZW5vbWluYXRvciBvZlxuICAgICAgICAvLyBlaXRoZXIgcmF0aW9uYWwgZnVuY3Rpb24gdG8gZXZhbHVhdGUgdG8gemVybzsgc3VjaCBjYXNlcyBNVVNUIHJldHVyblxuICAgICAgICAvLyB0aGUgaWRlbnRpdHkgcG9pbnQgb24gRS5cbiAgICAgICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9ICgwLCBtb2R1bGFyX3RzXzEuRnBJbnZlcnRCYXRjaCkoZmllbGQsIFt4ZCwgeWRdLCB0cnVlKTtcbiAgICAgICAgeCA9IGZpZWxkLm11bCh4biwgeGRfaW52KTsgLy8geE51bSAvIHhEZW5cbiAgICAgICAgeSA9IGZpZWxkLm11bCh5LCBmaWVsZC5tdWwoeW4sIHlkX2ludikpOyAvLyB5ICogKHlOdW0gLyB5RGV2KVxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmV4cG9ydHMuX0RTVF9zY2FsYXIgPSAoMCwgdXRpbHNfdHNfMS51dGY4VG9CeXRlcykoJ0hhc2hUb1NjYWxhci0nKTtcbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0uICovXG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoUG9pbnQsIG1hcFRvQ3VydmUsIGRlZmF1bHRzKSB7XG4gICAgaWYgKHR5cGVvZiBtYXBUb0N1cnZlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmUoKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICBmdW5jdGlvbiBtYXAobnVtKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUobnVtKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyKGluaXRpYWwpIHtcbiAgICAgICAgY29uc3QgUCA9IGluaXRpYWwuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICBpZiAoUC5lcXVhbHMoUG9pbnQuWkVSTykpXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTzsgLy8gemVybyB3aWxsIHRocm93IGluIGFzc2VydFxuICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBQO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZhdWx0cyxcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAyLCBvcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gbWFwKHVbMF0pO1xuICAgICAgICAgICAgY29uc3QgdTEgPSBtYXAodVsxXSk7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXIodTAuYWRkKHUxKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzRHN0ID0gZGVmYXVsdHMuZW5jb2RlRFNUID8geyBEU1Q6IGRlZmF1bHRzLmVuY29kZURTVCB9IDoge307XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdHNEc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgdSA9IGhhc2hfdG9fZmllbGQobXNnLCAxLCBvcHRzKTtcbiAgICAgICAgICAgIGNvbnN0IHUwID0gbWFwKHVbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKHUwKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIFNlZSB7QGxpbmsgSDJDSGFzaGVyfSAqL1xuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcChzY2FsYXJzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGhhc2hfdG9fc2NhbGFyIGNhbiBwcm9kdWNlIDA6IGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2VycmF0YS9laWQ4MzkzXG4gICAgICAgIC8vIFJGQyA5MzgwLCBkcmFmdC1pcnRmLWNmcmctYmJzLXNpZ25hdHVyZXMtMDhcbiAgICAgICAgaGFzaFRvU2NhbGFyKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgTiA9IFBvaW50LkZuLk9SREVSO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCB7IHA6IE4sIG06IDEsIERTVDogZXhwb3J0cy5fRFNUX3NjYWxhciB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgb3B0cylbMF1bMF07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzTmVnYXRpdmVMRSA9IHZvaWQgMDtcbmV4cG9ydHMubW9kID0gbW9kO1xuZXhwb3J0cy5wb3cgPSBwb3c7XG5leHBvcnRzLnBvdzIgPSBwb3cyO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLnRvbmVsbGlTaGFua3MgPSB0b25lbGxpU2hhbmtzO1xuZXhwb3J0cy5GcFNxcnQgPSBGcFNxcnQ7XG5leHBvcnRzLnZhbGlkYXRlRmllbGQgPSB2YWxpZGF0ZUZpZWxkO1xuZXhwb3J0cy5GcFBvdyA9IEZwUG93O1xuZXhwb3J0cy5GcEludmVydEJhdGNoID0gRnBJbnZlcnRCYXRjaDtcbmV4cG9ydHMuRnBEaXYgPSBGcERpdjtcbmV4cG9ydHMuRnBMZWdlbmRyZSA9IEZwTGVnZW5kcmU7XG5leHBvcnRzLkZwSXNTcXVhcmUgPSBGcElzU3F1YXJlO1xuZXhwb3J0cy5uTGVuZ3RoID0gbkxlbmd0aDtcbmV4cG9ydHMuRmllbGQgPSBGaWVsZDtcbmV4cG9ydHMuRnBTcXJ0T2RkID0gRnBTcXJ0T2RkO1xuZXhwb3J0cy5GcFNxcnRFdmVuID0gRnBTcXJ0RXZlbjtcbmV4cG9ydHMuaGFzaFRvUHJpdmF0ZVNjYWxhciA9IGhhc2hUb1ByaXZhdGVTY2FsYXI7XG5leHBvcnRzLmdldEZpZWxkQnl0ZXNMZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoO1xuZXhwb3J0cy5nZXRNaW5IYXNoTGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aDtcbmV4cG9ydHMubWFwSGFzaFRvRmllbGQgPSBtYXBIYXNoVG9GaWVsZDtcbi8qKlxuICogVXRpbHMgZm9yIG1vZHVsYXIgZGl2aXNpb24gYW5kIGZpZWxkcy5cbiAqIEZpZWxkIG92ZXIgMTEgaXMgYSBmaW5pdGUgKEdhbG9pcykgZmllbGQgaXMgaW50ZWdlciBudW1iZXIgb3BlcmF0aW9ucyBgbW9kIDExYC5cbiAqIFRoZXJlIGlzIG5vIGRpdmlzaW9uOiBpdCBpcyByZXBsYWNlZCBieSBtb2R1bGFyIG11bHRpcGxpY2F0aXZlIGludmVyc2UuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpLCBfM24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDQpLCBfNW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDUpLCBfN24gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDgpLCBfOW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDkpLCBfMTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSBfMG4gPyByZXN1bHQgOiBiICsgcmVzdWx0O1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSByYWlzZSBudW0gdG8gcG93ZXIgYW5kIGRvIG1vZHVsYXIgZGl2aXNpb24uXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKiBAZXhhbXBsZVxuICogcG93KDJuLCA2biwgMTFuKSAvLyA2NG4gJSAxMW4gPT0gOW5cbiAqL1xuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIHJldHVybiBGcFBvdyhGaWVsZChtb2R1bG8pLCBudW0sIHBvd2VyKTtcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvLlxuICogSW1wbGVtZW50ZWQgdXNpbmcgW0V1Y2xpZGVhbiBHQ0RdKGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vKS5cbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgJyArIG1vZHVsbyk7XG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbikge1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbn1cbi8vIE5vdCBhbGwgcm9vdHMgYXJlIHBvc3NpYmxlISBFeGFtcGxlIHdoaWNoIHdpbGwgdGhyb3c6XG4vLyBjb25zdCBOVU0gPVxuLy8gbiA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbi8vIEZwID0gRmllbGQoQmlnSW50KCcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYicpKTtcbmZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgIGNvbnN0IHAxZGl2NCA9IChGcC5PUkRFUiArIF8xbikgLyBfNG47XG4gICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgIGNvbnN0IHA1ZGl2OCA9IChGcC5PUkRFUiAtIF81bikgLyBfOG47XG4gICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICBjb25zdCB2ID0gRnAucG93KG4yLCBwNWRpdjgpO1xuICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xufVxuLy8gQmFzZWQgb24gUkZDOTM4MCwgS29uZyBhbGdvcml0aG1cbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gc3FydDltb2QxNihQKSB7XG4gICAgY29uc3QgRnBfID0gRmllbGQoUCk7XG4gICAgY29uc3QgdG4gPSB0b25lbGxpU2hhbmtzKFApO1xuICAgIGNvbnN0IGMxID0gdG4oRnBfLCBGcF8ubmVnKEZwXy5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICBjb25zdCBjMiA9IHRuKEZwXywgYzEpOyAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgIGNvbnN0IGMzID0gdG4oRnBfLCBGcF8ubmVnKGMxKSk7IC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47IC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICByZXR1cm4gKEZwLCBuKSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBGcC5wb3cobiwgYzQpOyAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICBsZXQgdHYyID0gRnAubXVsKHR2MSwgYzEpOyAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKHR2MSwgYzIpOyAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgY29uc3QgdHY0ID0gRnAubXVsKHR2MSwgYzMpOyAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIGNvbnN0IGUyID0gRnAuZXFsKEZwLnNxcih0djMpLCBuKTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIGNvbnN0IGUzID0gRnAuZXFsKEZwLnNxcih0djIpLCBuKTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICBjb25zdCByb290ID0gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICAjIFNlbGVjdCBzcXJ0IGZyb20gdHYxICYgdHYyXG4gICAgICAgIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbn1cbi8qKlxuICogVG9uZWxsaS1TaGFua3Mgc3F1YXJlIHJvb3Qgc2VhcmNoIGFsZ29yaXRobS5cbiAqIDEuIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbiAqIDIuIFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuICogQHBhcmFtIFAgZmllbGQgb3JkZXJcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgdGFrZXMgZmllbGQgRnAgKGNyZWF0ZWQgZnJvbSBQKSBhbmQgbnVtYmVyIG5cbiAqL1xuZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICAvLyBDYWNoaW5nIGluaXRpYWxpemF0aW9uIGNvdWxkIGJvb3N0IHBlcmYgYnkgNyUuXG4gICAgaWYgKFAgPCBfM24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGQnKTtcbiAgICAvLyBGYWN0b3IgUCAtIDEgPSBRICogMl5TLCB3aGVyZSBRIGlzIG9kZFxuICAgIGxldCBRID0gUCAtIF8xbjtcbiAgICBsZXQgUyA9IDA7XG4gICAgd2hpbGUgKFEgJSBfMm4gPT09IF8wbikge1xuICAgICAgICBRIC89IF8ybjtcbiAgICAgICAgUysrO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgWiA+PSAyXG4gICAgbGV0IFogPSBfMm47XG4gICAgY29uc3QgX0ZwID0gRmllbGQoUCk7XG4gICAgd2hpbGUgKEZwTGVnZW5kcmUoX0ZwLCBaKSA9PT0gMSkge1xuICAgICAgICAvLyBCYXNpYyBwcmltYWxpdHkgdGVzdCBmb3IgUC4gQWZ0ZXIgeCBpdGVyYXRpb25zLCBjaGFuY2Ugb2ZcbiAgICAgICAgLy8gbm90IGZpbmRpbmcgcXVhZHJhdGljIG5vbi1yZXNpZHVlIGlzIDJeeCwgc28gMl4xMDAwLlxuICAgICAgICBpZiAoWisrID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IHByb2JhYmx5IG5vbi1wcmltZSBQJyk7XG4gICAgfVxuICAgIC8vIEZhc3QtcGF0aDsgdXN1YWxseSBkb25lIGJlZm9yZSBaLCBidXQgd2UgZG8gXCJwcmltYWxpdHkgdGVzdFwiLlxuICAgIGlmIChTID09PSAxKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFNsb3ctcGF0aFxuICAgIC8vIFRPRE86IHRlc3Qgb24gRnAyIGFuZCBvdGhlcnNcbiAgICBsZXQgY2MgPSBfRnAucG93KFosIFEpOyAvLyBjID0gel5RXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICBpZiAoRnAuaXMwKG4pKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIC8vIENoZWNrIGlmIG4gaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB1c2luZyBMZWdlbmRyZSBzeW1ib2xcbiAgICAgICAgaWYgKEZwTGVnZW5kcmUoRnAsIG4pICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHZhcmlhYmxlcyBmb3IgdGhlIG1haW4gbG9vcFxuICAgICAgICBsZXQgTSA9IFM7XG4gICAgICAgIGxldCBjID0gRnAubXVsKEZwLk9ORSwgY2MpOyAvLyBjID0gel5RLCBtb3ZlIGNjIGZyb20gZmllbGQgX0ZwIGludG8gZmllbGQgRnBcbiAgICAgICAgbGV0IHQgPSBGcC5wb3cobiwgUSk7IC8vIHQgPSBuXlEsIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgbGV0IFIgPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gUiA9IG5eKChRKzEpLzIpLCBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgLy8gTWFpbiBsb29wXG4gICAgICAgIC8vIHdoaWxlIHQgIT0gMVxuICAgICAgICB3aGlsZSAoIUZwLmVxbCh0LCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuaXMwKHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBpZiB0PTAgcmV0dXJuIFI9MFxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc21hbGxlc3QgaSA+PSAxIHN1Y2ggdGhhdCB0XigyXmkpIOKJoSAxIChtb2QgUClcbiAgICAgICAgICAgIGxldCB0X3RtcCA9IEZwLnNxcih0KTsgLy8gdF4oMl4xKVxuICAgICAgICAgICAgd2hpbGUgKCFGcC5lcWwodF90bXAsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgdF90bXAgPSBGcC5zcXIodF90bXApOyAvLyB0XigyXjIpLi4uXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhwb25lbnQgZm9yIGI6IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gXzFuIDw8IEJpZ0ludChNIC0gaSAtIDEpOyAvLyBiaWdpbnQgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICBjb25zdCBiID0gRnAucG93KGMsIGV4cG9uZW50KTsgLy8gYiA9IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIE0gPSBpO1xuICAgICAgICAgICAgYyA9IEZwLnNxcihiKTsgLy8gYyA9IGJeMlxuICAgICAgICAgICAgdCA9IEZwLm11bCh0LCBjKTsgLy8gdCA9ICh0ICogYl4yKVxuICAgICAgICAgICAgUiA9IEZwLm11bChSLCBiKTsgLy8gUiA9IFIqYlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSO1xuICAgIH07XG59XG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gV2lsbCB0cnkgb3B0aW1pemVkIHZlcnNpb25zIGZpcnN0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBQIOKJoSAzIChtb2QgNCkgPT4g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbilcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBQIOKJoSA1IChtb2QgOCkgPT4gQXRraW4gYWxnb3JpdGhtLCBwYWdlIDEwIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuICAgIGlmIChQICUgXzhuID09PSBfNW4pXG4gICAgICAgIHJldHVybiBzcXJ0NW1vZDg7XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KSA9PiBLb25nIGFsZ29yaXRobSwgcGFnZSAxMSBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKGFsZ29yaXRobSA0KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKVxuICAgICAgICByZXR1cm4gc3FydDltb2QxNihQKTtcbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbmV4cG9ydHMuaXNOZWdhdGl2ZUxFID0gaXNOZWdhdGl2ZUxFO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ251bWJlcicsXG4gICAgICAgIEJJVFM6ICdudW1iZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICAoMCwgdXRpbHNfdHNfMS5fdmFsaWRhdGVPYmplY3QpKGZpZWxkLCBvcHRzKTtcbiAgICAvLyBjb25zdCBtYXggPSAxNjM4NDtcbiAgICAvLyBpZiAoZmllbGQuQllURVMgPCAxIHx8IGZpZWxkLkJZVEVTID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQnKTtcbiAgICAvLyBpZiAoZmllbGQuQklUUyA8IDEgfHwgZmllbGQuQklUUyA+IDggKiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmZ1bmN0aW9uIEZwUG93KEZwLCBudW0sIHBvd2VyKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gRnAuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gRnAuT05FO1xuICAgIGxldCBkID0gbnVtO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICBwID0gRnAubXVsKHAsIGQpO1xuICAgICAgICBkID0gRnAuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogRXhjZXB0aW9uLWZyZWUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvciAwIGVsZW1lbnRzLlxuICogQHBhcmFtIHBhc3NaZXJvIG1hcCAwIHRvIDAgKGluc3RlYWQgb2YgdW5kZWZpbmVkKVxuICovXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKEZwLCBudW1zLCBwYXNzWmVybyA9IGZhbHNlKSB7XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpLmZpbGwocGFzc1plcm8gPyBGcC5aRVJPIDogdW5kZWZpbmVkKTtcbiAgICAvLyBXYWxrIGZyb20gZmlyc3QgdG8gbGFzdCwgbXVsdGlwbHkgdGhlbSBieSBlYWNoIG90aGVyIE1PRCBwXG4gICAgY29uc3QgbXVsdGlwbGllZEFjYyA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoRnAuaXMwKG51bSkpXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBpbnZlcnRlZFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIEZwLm11bChhY2MsIG51bSk7XG4gICAgfSwgRnAuT05FKTtcbiAgICAvLyBJbnZlcnQgbGFzdCBlbGVtZW50XG4gICAgY29uc3QgaW52ZXJ0ZWRBY2MgPSBGcC5pbnYobXVsdGlwbGllZEFjYyk7XG4gICAgLy8gV2FsayBmcm9tIGxhc3QgdG8gZmlyc3QsIG11bHRpcGx5IHRoZW0gYnkgaW52ZXJ0ZWQgZWFjaCBvdGhlciBNT0QgcFxuICAgIG51bXMucmVkdWNlUmlnaHQoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gRnAubXVsKGFjYywgaW52ZXJ0ZWRbaV0pO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZEFjYyk7XG4gICAgcmV0dXJuIGludmVydGVkO1xufVxuLy8gVE9ETzogcmVtb3ZlXG5mdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmZ1bmN0aW9uIEZwTGVnZW5kcmUoRnAsIG4pIHtcbiAgICAvLyBXZSBjYW4gdXNlIDNyZCBhcmd1bWVudCBhcyBvcHRpb25hbCBjYWNoZSBvZiB0aGlzIHZhbHVlXG4gICAgLy8gYnV0IHNlZW1zIHVubmVlZGVkIGZvciBub3cuIFRoZSBvcGVyYXRpb24gaXMgdmVyeSBmYXN0LlxuICAgIGNvbnN0IHAxbW9kMiA9IChGcC5PUkRFUiAtIF8xbikgLyBfMm47XG4gICAgY29uc3QgcG93ZXJlZCA9IEZwLnBvdyhuLCBwMW1vZDIpO1xuICAgIGNvbnN0IHllcyA9IEZwLmVxbChwb3dlcmVkLCBGcC5PTkUpO1xuICAgIGNvbnN0IHplcm8gPSBGcC5lcWwocG93ZXJlZCwgRnAuWkVSTyk7XG4gICAgY29uc3Qgbm8gPSBGcC5lcWwocG93ZXJlZCwgRnAubmVnKEZwLk9ORSkpO1xuICAgIGlmICgheWVzICYmICF6ZXJvICYmICFubylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIExlZ2VuZHJlIHN5bWJvbCByZXN1bHQnKTtcbiAgICByZXR1cm4geWVzID8gMSA6IHplcm8gPyAwIDogLTE7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgVHJ1ZSB3aGVuZXZlciB0aGUgdmFsdWUgeCBpcyBhIHNxdWFyZSBpbiB0aGUgZmllbGQgRi5cbmZ1bmN0aW9uIEZwSXNTcXVhcmUoRnAsIG4pIHtcbiAgICBjb25zdCBsID0gRnBMZWdlbmRyZShGcCwgbik7XG4gICAgcmV0dXJuIGwgPT09IDE7XG59XG4vLyBDVVJWRS5uIGxlbmd0aHNcbmZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKG5CaXRMZW5ndGgpO1xuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBmaW5pdGUgZmllbGQuIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIDEuIERlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bC5cbiAqICogMi4gSWRlbnRpY2FsIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzLlxuICogKiAzLiBgT2JqZWN0LmZyZWV6ZWAuXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqXG4gKiBOb3RlIGFib3V0IGZpZWxkIHByb3BlcnRpZXM6XG4gKiAqIENIQVJBQ1RFUklTVElDIHAgPSBwcmltZSBudW1iZXIsIG51bWJlciBvZiBlbGVtZW50cyBpbiBtYWluIHN1Ymdyb3VwLlxuICogKiBPUkRFUiBxID0gc2ltaWxhciB0byBjb2ZhY3RvciBpbiBjdXJ2ZXMsIG1heSBiZSBjb21wb3NpdGUgYHEgPSBwXm1gLlxuICpcbiAqIEBwYXJhbSBPUkRFUiBmaWVsZCBvcmRlciwgcHJvYmFibHkgcHJpbWUsIG9yIGNvdWxkIGJlIGNvbXBvc2l0ZVxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZmF1bHQ6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5mdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuT3JPcHRzLCAvLyBUT0RPOiB1c2Ugb3B0cyBvbmx5IGluIHYyP1xuaXNMRSA9IGZhbHNlLCBvcHRzID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgbGV0IF9uYml0TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIGxldCBfc3FydCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbW9kRnJvbUJ5dGVzID0gZmFsc2U7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cy5zcXJ0IHx8IGlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50cycpO1xuICAgICAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICAgICAgaWYgKF9vcHRzLkJJVFMpXG4gICAgICAgICAgICBfbmJpdExlbmd0aCA9IF9vcHRzLkJJVFM7XG4gICAgICAgIGlmIChfb3B0cy5zcXJ0KVxuICAgICAgICAgICAgX3NxcnQgPSBfb3B0cy5zcXJ0O1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLmlzTEUgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLm1vZEZyb21CeXRlcyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgbW9kRnJvbUJ5dGVzID0gX29wdHMubW9kRnJvbUJ5dGVzO1xuICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRMZW5Pck9wdHMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgICAgIGlmIChvcHRzLnNxcnQpXG4gICAgICAgICAgICBfc3FydCA9IG9wdHMuc3FydDtcbiAgICB9XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiAoMCwgdXRpbHNfdHNfMS5iaXRNYXNrKShCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgYWxsb3dlZExlbmd0aHM6IGFsbG93ZWRMZW5ndGhzLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAnICsgdHlwZW9mIG51bSk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICAvLyBpcyB2YWxpZCBhbmQgaW52ZXJ0aWJsZVxuICAgICAgICBpc1ZhbGlkTm90MDogKG51bSkgPT4gIWYuaXMwKG51bSkgJiYgZi5pc1ZhbGlkKG51bSksXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogX3NxcnQgfHxcbiAgICAgICAgICAgICgobikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3FydFApXG4gICAgICAgICAgICAgICAgICAgIHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3FydFAoZiwgbik7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzTEUpKG51bSwgQllURVMpIDogKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9CeXRlc0JFKShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzLCBza2lwVmFsaWRhdGlvbiA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIGFsbG93ZWRMZW5ndGhzICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgICAgICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChieXRlcywgaXNMRSA/IDAgOiBwYWRkZWQubGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgc2NhbGFyID0gaXNMRSA/ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpIDogKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShieXRlcyk7XG4gICAgICAgICAgICBpZiAobW9kRnJvbUJ5dGVzKVxuICAgICAgICAgICAgICAgIHNjYWxhciA9IG1vZChzY2FsYXIsIE9SREVSKTtcbiAgICAgICAgICAgIGlmICghc2tpcFZhbGlkYXRpb24pXG4gICAgICAgICAgICAgICAgaWYgKCFmLmlzVmFsaWQoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IG91dHNpZGUgb2YgcmFuZ2UgMC4uT1JERVInKTtcbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIGRvbid0IHZhbGlkYXRlIHNjYWxhciBoZXJlLCBwbGVhc2UgdXNlIGlzVmFsaWQuIFRoaXMgZG9uZSBzdWNoIHdheSBiZWNhdXNlIHNvbWVcbiAgICAgICAgICAgIC8vIHByb3RvY29sIG1heSBhbGxvdyBub24tcmVkdWNlZCBzY2FsYXIgdGhhdCByZWR1Y2VkIGxhdGVyIG9yIGNoYW5nZWQgc29tZSBvdGhlciB3YXkuXG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPOiB3ZSBkb24ndCBuZWVkIGl0IGhlcmUsIG1vdmUgb3V0IHRvIHNlcGFyYXRlIGZuXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgICAgIC8vIGFuZCBpdCdzIHVuY2xlYXIgd2hhdCB0byByZXR1cm4gaW4gdGhlcmUuXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbi8vIEdlbmVyaWMgcmFuZG9tIHNjYWxhciwgd2UgY2FuIGRvIHNhbWUgZm9yIG90aGVyIGZpZWxkcyBpZiB2aWEgRnAyLm11bChGcDIuT05FLCBGcDIucmFuZG9tKT9cbi8vIFRoaXMgYWxsb3dzIHVuc2FmZSBtZXRob2RzIGxpa2UgaWdub3JlIGJpYXMgb3IgemVyby4gVGhlc2UgdW5zYWZlLCBidXQgb2Z0ZW4gdXNlZCBpbiBkaWZmZXJlbnQgcHJvdG9jb2xzIChpZiBkZXRlcm1pbmlzdGljIFJORykuXG4vLyB3aGljaCBtZWFuIHdlIGNhbm5vdCBmb3JjZSB0aGlzIHZpYSBvcHRzLlxuLy8gTm90IHN1cmUgd2hhdCB0byBkbyB3aXRoIHJhbmRvbUJ5dGVzLCB3ZSBjYW4gYWNjZXB0IGl0IGluc2lkZSBvcHRzIGlmIHdhbnRlZC5cbi8vIFByb2JhYmx5IG5lZWQgdG8gZXhwb3J0IGdldE1pbkhhc2hMZW5ndGggc29tZXdoZXJlP1xuLy8gcmFuZG9tKGJ5dGVzPzogVWludDhBcnJheSwgdW5zYWZlQWxsb3daZXJvID0gZmFsc2UsIHVuc2FmZUFsbG93QmlhcyA9IGZhbHNlKSB7XG4vLyAgIGNvbnN0IExFTiA9ICF1bnNhZmVBbGxvd0JpYXMgPyBnZXRNaW5IYXNoTGVuZ3RoKE9SREVSKSA6IEJZVEVTO1xuLy8gICBpZiAoYnl0ZXMgPT09IHVuZGVmaW5lZCkgYnl0ZXMgPSByYW5kb21CeXRlcyhMRU4pOyAvLyBfb3B0cy5yYW5kb21CeXRlcz9cbi8vICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuLy8gICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4vLyAgIGNvbnN0IHJlZHVjZWQgPSB1bnNhZmVBbGxvd1plcm8gPyBtb2QobnVtLCBPUkRFUikgOiBtb2QobnVtLCBPUkRFUiAtIF8xbikgKyBfMW47XG4vLyAgIHJldHVybiByZWR1Y2VkO1xuLy8gfSxcbmZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcEtleVRvRmllbGRgIGluc3RlYWRcbiAqL1xuZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyTEUpKGhhc2gpIDogKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKShrZXkpIDogKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFKShrZXkpO1xuICAgIC8vIGBtb2QoeCwgMTEpYCBjYW4gc29tZXRpbWVzIHByb2R1Y2UgMC4gYG1vZCh4LCAxMCkgKyAxYCBpcyB0aGUgc2FtZSwgYnV0IG5vIDBcbiAgICBjb25zdCByZWR1Y2VkID0gbW9kKG51bSwgZmllbGRPcmRlciAtIF8xbikgKyBfMW47XG4gICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzTEUpKHJlZHVjZWQsIGZpZWxkTGVuKSA6ICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNCRSkocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9udGdvbWVyeSA9IG1vbnRnb21lcnk7XG4vKipcbiAqIE1vbnRnb21lcnkgY3VydmUgbWV0aG9kcy4gSXQncyBub3QgcmVhbGx5IHdob2xlIG1vbnRnb21lcnkgY3VydmUsXG4gKiBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5IC8gWDQ0OCBmcm9tXG4gKiBbUkZDIDc3NDhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuY29uc3QgbW9kdWxhcl90c18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgICgwLCB1dGlsc190c18xLl92YWxpZGF0ZU9iamVjdCkoY3VydmUsIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbmZ1bmN0aW9uIG1vbnRnb21lcnkoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBQLCB0eXBlLCBhZGp1c3RTY2FsYXJCeXRlcywgcG93UG1pbnVzMiwgcmFuZG9tQnl0ZXM6IHJhbmQgfSA9IENVUlZFO1xuICAgIGNvbnN0IGlzMjU1MTkgPSB0eXBlID09PSAneDI1NTE5JztcbiAgICBpZiAoIWlzMjU1MTkgJiYgdHlwZSAhPT0gJ3g0NDgnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzXyA9IHJhbmQgfHwgdXRpbHNfdHNfMS5yYW5kb21CeXRlcztcbiAgICBjb25zdCBtb250Z29tZXJ5Qml0cyA9IGlzMjU1MTkgPyAyNTUgOiA0NDg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBpczI1NTE5ID8gMzIgOiA1NjtcbiAgICBjb25zdCBHdSA9IGlzMjU1MTkgPyBCaWdJbnQoOSkgOiBCaWdJbnQoNSk7XG4gICAgLy8gUkZDIDc3NDggIzU6XG4gICAgLy8gVGhlIGNvbnN0YW50IGEyNCBpcyAoNDg2NjYyIC0gMikgLyA0ID0gMTIxNjY1IGZvciBjdXJ2ZTI1NTE5L1gyNTUxOSBhbmRcbiAgICAvLyAoMTU2MzI2IC0gMikgLyA0ID0gMzkwODEgZm9yIGN1cnZlNDQ4L1g0NDhcbiAgICAvLyBjb25zdCBhID0gaXMyNTUxOSA/IDE1NjMyNm4gOiA0ODY2NjJuO1xuICAgIGNvbnN0IGEyNCA9IGlzMjU1MTkgPyBCaWdJbnQoMTIxNjY1KSA6IEJpZ0ludCgzOTA4MSk7XG4gICAgLy8gUkZDOiB4MjU1MTkgXCJ0aGUgcmVzdWx0aW5nIGludGVnZXIgaXMgb2YgdGhlIGZvcm0gMl4yNTQgcGx1c1xuICAgIC8vIGVpZ2h0IHRpbWVzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyXjI1MSAtIDEgKGluY2x1c2l2ZSlcIlxuICAgIC8vIHg0NDg6IFwiMl40NDcgcGx1cyBmb3VyIHRpbWVzIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAyXjQ0NSAtIDEgKGluY2x1c2l2ZSlcIlxuICAgIGNvbnN0IG1pblNjYWxhciA9IGlzMjU1MTkgPyBfMm4gKiogQmlnSW50KDI1NCkgOiBfMm4gKiogQmlnSW50KDQ0Nyk7XG4gICAgY29uc3QgbWF4QWRkZWQgPSBpczI1NTE5XG4gICAgICAgID8gQmlnSW50KDgpICogXzJuICoqIEJpZ0ludCgyNTEpIC0gXzFuXG4gICAgICAgIDogQmlnSW50KDQpICogXzJuICoqIEJpZ0ludCg0NDUpIC0gXzFuO1xuICAgIGNvbnN0IG1heFNjYWxhciA9IG1pblNjYWxhciArIG1heEFkZGVkICsgXzFuOyAvLyAoaW5jbHVzaXZlKVxuICAgIGNvbnN0IG1vZFAgPSAobikgPT4gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKG4sIFApO1xuICAgIGNvbnN0IEd1Qnl0ZXMgPSBlbmNvZGVVKEd1KTtcbiAgICBmdW5jdGlvbiBlbmNvZGVVKHUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLm51bWJlclRvQnl0ZXNMRSkobW9kUCh1KSwgZmllbGRMZW4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVKHUpIHtcbiAgICAgICAgY29uc3QgX3UgPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3UgY29vcmRpbmF0ZScsIHUsIGZpZWxkTGVuKTtcbiAgICAgICAgLy8gUkZDOiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIChidXQgbm90IFg0NDgpIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGlmIChpczI1NTE5KVxuICAgICAgICAgICAgX3VbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgLy8gUkZDOiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS4gIFRoZSBub24tY2Fub25pY2FsXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgMl4yNTUgLSAxOSB0aHJvdWdoIDJeMjU1IC0gMSBmb3IgWDI1NTE5IGFuZCAyXjQ0OCAtIDJeMjI0XG4gICAgICAgIC8vIC0gMSB0aHJvdWdoIDJeNDQ4IC0gMSBmb3IgWDQ0OC5cbiAgICAgICAgcmV0dXJuIG1vZFAoKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKShfdSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVTY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyTEUpKGFkanVzdFNjYWxhckJ5dGVzKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnc2NhbGFyJywgc2NhbGFyLCBmaWVsZExlbikpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdChzY2FsYXIsIHUpIHtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKGRlY29kZVUodSksIGRlY29kZVNjYWxhcihzY2FsYXIpKTtcbiAgICAgICAgLy8gU29tZSBwdWJsaWMga2V5cyBhcmUgdXNlbGVzcywgb2YgbG93LW9yZGVyLiBDdXJ2ZSBhdXRob3IgZG9lc24ndCB0aGlua1xuICAgICAgICAvLyBpdCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQsIGJ1dCB3ZSBkbyBpdCBub25ldGhlbGVzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jci55cC50by9lY2RoLmh0bWwjdmFsaWRhdGVcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHRCYXNlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuICAgIH1cbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDggXCJleGFtcGxlIGNvZGVcIlxuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIC8vIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAvLyBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgICAgLy8gYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAgICAgY29uc3QgZHVtbXkgPSBtb2RQKHN3YXAgKiAoeF8yIC0geF8zKSk7XG4gICAgICAgIHhfMiA9IG1vZFAoeF8yIC0gZHVtbXkpOyAvLyB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpOyAvLyB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgIHJldHVybiB7IHhfMiwgeF8zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vbnRnb21lcnkgeC1vbmx5IG11bHRpcGxpY2F0aW9uIGxhZGRlci5cbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIodSwgc2NhbGFyKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgndScsIHUsIF8wbiwgUCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFJblJhbmdlKSgnc2NhbGFyJywgc2NhbGFyLCBtaW5TY2FsYXIsIG1heFNjYWxhcik7XG4gICAgICAgIGNvbnN0IGsgPSBzY2FsYXI7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgKHsgeF8yLCB4XzMgfSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKSk7XG4gICAgICAgICAgICAoeyB4XzI6IHpfMiwgeF8zOiB6XzMgfSA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKSk7XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAoeyB4XzIsIHhfMyB9ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpKTtcbiAgICAgICAgKHsgeF8yOiB6XzIsIHhfMzogel8zIH0gPSBjc3dhcChzd2FwLCB6XzIsIHpfMykpO1xuICAgICAgICBjb25zdCB6MiA9IHBvd1BtaW51czIoel8yKTsgLy8gYEZwLnBvdyh4LCBQIC0gXzJuKWAgaXMgbXVjaCBzbG93ZXIgZXF1aXZhbGVudFxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7IC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aHMgPSB7XG4gICAgICAgIHNlY3JldEtleTogZmllbGRMZW4sXG4gICAgICAgIHB1YmxpY0tleTogZmllbGRMZW4sXG4gICAgICAgIHNlZWQ6IGZpZWxkTGVuLFxuICAgIH07XG4gICAgY29uc3QgcmFuZG9tU2VjcmV0S2V5ID0gKHNlZWQgPSByYW5kb21CeXRlc18oZmllbGRMZW4pKSA9PiB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoc2VlZCwgbGVuZ3Rocy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2FsYXJNdWx0QmFzZShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleWdlbixcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0OiAoc2VjcmV0S2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQoc2VjcmV0S2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChzZWNyZXRLZXkpID0+IHNjYWxhck11bHRCYXNlKHNlY3JldEtleSksXG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICB1dGlscyxcbiAgICAgICAgR3VCeXRlczogR3VCeXRlcy5zbGljZSgpLFxuICAgICAgICBsZW5ndGhzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERVIgPSBleHBvcnRzLkRFUkVyciA9IHZvaWQgMDtcbmV4cG9ydHMuX3NwbGl0RW5kb1NjYWxhciA9IF9zcGxpdEVuZG9TY2FsYXI7XG5leHBvcnRzLl9ub3JtRm5FbGVtZW50ID0gX25vcm1GbkVsZW1lbnQ7XG5leHBvcnRzLndlaWVyc3RyYXNzTiA9IHdlaWVyc3RyYXNzTjtcbmV4cG9ydHMuU1dVRnBTcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbztcbmV4cG9ydHMubWFwVG9DdXJ2ZVNpbXBsZVNXVSA9IG1hcFRvQ3VydmVTaW1wbGVTV1U7XG5leHBvcnRzLmVjZGggPSBlY2RoO1xuZXhwb3J0cy5lY2RzYSA9IGVjZHNhO1xuZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuZXhwb3J0cy5fbGVnYWN5SGVscGVyRXF1YXQgPSBfbGVnYWN5SGVscGVyRXF1YXQ7XG5leHBvcnRzLndlaWVyc3RyYXNzID0gd2VpZXJzdHJhc3M7XG4vKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuICogb2Ygbm9taW5hdGl2ZSB0eXBlcyBpbiBUeXBlU2NyaXB0IGFuZCBpbnRlcmZhY2VzIG9ubHkgY2hlY2sgZm9yIHNoYXBlLCBzbyBpdCdzIGhhcmQgdG8gY3JlYXRlXG4gKiB1bmlxdWUgdHlwZSBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBXZSBjYW4gdXNlIGdlbmVyaWMgdHlwZXMgdmlhIHNvbWUgcGFyYW0sIGxpa2UgY3VydmUgb3B0cywgYnV0IHRoYXQgd291bGQ6XG4gKiAgICAgMS4gRW5hYmxlIGludGVyYWN0aW9uIGJldHdlZW4gYGN1cnZlKHBhcmFtcylgIGFuZCBgY3VydmUocGFyYW1zKWAgKGN1cnZlcyBvZiBzYW1lIHBhcmFtcylcbiAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuICogICAgIDIuIFBhcmFtcyBjYW4gYmUgZ2VuZXJpYyBhbmQgd2UgY2FuJ3QgZW5mb3JjZSB0aGVtIHRvIGJlIGNvbnN0YW50IHZhbHVlOlxuICogICAgIGlmIHNvbWVib2R5IGNyZWF0ZXMgY3VydmUgZnJvbSBub24tY29uc3RhbnQgcGFyYW1zLFxuICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG4gKlxuICogQHRvZG8gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNy5odG1sI3VuaXF1ZS1zeW1ib2xcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgaG1hY19qc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaG1hYy5qc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5jb25zdCBjdXJ2ZV90c18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5jb25zdCBtb2R1bGFyX3RzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuLy8gV2UgY29uc3RydWN0IGJhc2lzIGluIHN1Y2ggd2F5IHRoYXQgZGVuIGlzIGFsd2F5cyBwb3NpdGl2ZSBhbmQgZXF1YWxzIG4sIGJ1dCBudW0gc2lnbiBkZXBlbmRzIG9uIGJhc2lzIChub3Qgb24gc2VjcmV0IHZhbHVlKVxuY29uc3QgZGl2TmVhcmVzdCA9IChudW0sIGRlbikgPT4gKG51bSArIChudW0gPj0gMCA/IGRlbiA6IC1kZW4pIC8gXzJuKSAvIGRlbjtcbi8qKlxuICogU3BsaXRzIHNjYWxhciBmb3IgR0xWIGVuZG9tb3JwaGlzbS5cbiAqL1xuZnVuY3Rpb24gX3NwbGl0RW5kb1NjYWxhcihrLCBiYXNpcywgbikge1xuICAgIC8vIFNwbGl0IHNjYWxhciBpbnRvIHR3byBzdWNoIHRoYXQgcGFydCBpcyB+aGFsZiBiaXRzOiBgYWJzKHBhcnQpIDwgc3FydChOKWBcbiAgICAvLyBTaW5jZSBwYXJ0IGNhbiBiZSBuZWdhdGl2ZSwgd2UgbmVlZCB0byBkbyB0aGlzIG9uIHBvaW50LlxuICAgIC8vIFRPRE86IHZlcmlmeVNjYWxhciBmdW5jdGlvbiB3aGljaCBjb25zdW1lcyBsYW1iZGFcbiAgICBjb25zdCBbW2ExLCBiMV0sIFthMiwgYjJdXSA9IGJhc2lzO1xuICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAvLyB8azF8L3xrMnwgaXMgPCBzcXJ0KE4pLCBidXQgY2FuIGJlIG5lZ2F0aXZlLlxuICAgIC8vIElmIHdlIGRvIGBrMSBtb2QgTmAsIHdlJ2xsIGdldCBiaWcgc2NhbGFyIChgPiBzcXJ0KE4pYCk6IHNvLCB3ZSBkbyBjaGVhcGVyIG5lZ2F0aW9uIGluc3RlYWQuXG4gICAgbGV0IGsxID0gayAtIGMxICogYTEgLSBjMiAqIGEyO1xuICAgIGxldCBrMiA9IC1jMSAqIGIxIC0gYzIgKiBiMjtcbiAgICBjb25zdCBrMW5lZyA9IGsxIDwgXzBuO1xuICAgIGNvbnN0IGsybmVnID0gazIgPCBfMG47XG4gICAgaWYgKGsxbmVnKVxuICAgICAgICBrMSA9IC1rMTtcbiAgICBpZiAoazJuZWcpXG4gICAgICAgIGsyID0gLWsyO1xuICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHJlc3VsdGluZyBzY2FsYXIgbGVzcyB0aGFuIGhhbGYgYml0cyBvZiBOOiBvdGhlcndpc2Ugd05BRiB3aWxsIGZhaWwuXG4gICAgLy8gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gb24gd3JvbmcgYmFzaXNlcy4gQWxzbywgbWF0aCBpbnNpZGUgaXMgdG9vIGNvbXBsZXggYW5kIEkgZG9uJ3QgdHJ1c3QgaXQuXG4gICAgY29uc3QgTUFYX05VTSA9ICgwLCB1dGlsc190c18xLmJpdE1hc2spKE1hdGguY2VpbCgoMCwgdXRpbHNfdHNfMS5iaXRMZW4pKG4pIC8gMikpICsgXzFuOyAvLyBIYWxmIGJpdHMgb2YgTlxuICAgIGlmIChrMSA8IF8wbiB8fCBrMSA+PSBNQVhfTlVNIHx8IGsyIDwgXzBuIHx8IGsyID49IE1BWF9OVU0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhciAoZW5kb21vcnBoaXNtKTogZmFpbGVkLCBrPScgKyBrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmICghWydjb21wYWN0JywgJ3JlY292ZXJlZCcsICdkZXInXS5pbmNsdWRlcyhmb3JtYXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBmb3JtYXQgbXVzdCBiZSBcImNvbXBhY3RcIiwgXCJyZWNvdmVyZWRcIiwgb3IgXCJkZXJcIicpO1xuICAgIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmKSB7XG4gICAgY29uc3Qgb3B0c24gPSB7fTtcbiAgICBmb3IgKGxldCBvcHROYW1lIG9mIE9iamVjdC5rZXlzKGRlZikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvcHRzbltvcHROYW1lXSA9IG9wdHNbb3B0TmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZltvcHROYW1lXSA6IG9wdHNbb3B0TmFtZV07XG4gICAgfVxuICAgICgwLCB1dGlsc190c18xLl9hYm9vbDIpKG9wdHNuLmxvd1MsICdsb3dTJyk7XG4gICAgKDAsIHV0aWxzX3RzXzEuX2Fib29sMikob3B0c24ucHJlaGFzaCwgJ3ByZWhhc2gnKTtcbiAgICBpZiAob3B0c24uZm9ybWF0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbGlkYXRlU2lnRm9ybWF0KG9wdHNuLmZvcm1hdCk7XG4gICAgcmV0dXJuIG9wdHNuO1xufVxuY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG5leHBvcnRzLkRFUkVyciA9IERFUkVycjtcbi8qKlxuICogQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllcy4gQVNOIGlzIHZlcnkgY29tcGxleCAmIGZyYWdpbGUuIEZvcm1hdDpcbiAqXG4gKiAgICAgWzB4MzAgKFNFUVVFTkNFKSwgYnl0ZWxlbmd0aCwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgUiwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgU11cbiAqXG4gKiBEb2NzOiBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9kb2NzL2Etd2FybS13ZWxjb21lLXRvLWFzbjEtYW5kLWRlci8sIGh0dHBzOi8vbHVjYS5udG9wLm9yZy9UZWFjaGluZy9BcHB1bnRpL2FzbjEuaHRtbFxuICovXG5leHBvcnRzLkRFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gKDAsIHV0aWxzX3RzXzEubnVtYmVyVG9IZXhVbnBhZGRlZCkoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0hleFVucGFkZGVkKSgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9ICgwLCB1dGlsc190c18xLm51bWJlclRvSGV4VW5wYWRkZWQpKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgICAgICBkZWNvZGUodGFnLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSAoMCwgdXRpbHNfdHNfMS5udW1iZXJUb0hleFVucGFkZGVkKShudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvTnVtYmVyQkUpKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnc2lnbmF0dXJlJywgaGV4KTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgY29uc3QgcnMgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc3MgPSB0bHYuZW5jb2RlKDB4MDIsIGludC5lbmNvZGUoc2lnLnMpKTtcbiAgICAgICAgY29uc3Qgc2VxID0gcnMgKyBzcztcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIF9ub3JtRm5FbGVtZW50KEZuLCBrZXkpIHtcbiAgICBjb25zdCB7IEJZVEVTOiBleHBlY3RlZCB9ID0gRm47XG4gICAgbGV0IG51bTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgbnVtID0ga2V5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwcml2YXRlIGtleScsIGtleSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPSBGbi5mcm9tQnl0ZXMoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHByaXZhdGUga2V5OiBleHBlY3RlZCB1aThhIG9mIHNpemUgJHtleHBlY3RlZH0sIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFGbi5pc1ZhbGlkTm90MChudW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXk6IG91dCBvZiByYW5nZSBbMS4uTi0xXScpO1xuICAgIHJldHVybiBudW07XG59XG4vKipcbiAqIENyZWF0ZXMgd2VpZXJzdHJhc3MgUG9pbnQgY29uc3RydWN0b3IsIGJhc2VkIG9uIHNwZWNpZmllZCBjdXJ2ZSBvcHRpb25zLlxuICpcbiAqIEBleGFtcGxlXG5gYGBqc1xuY29uc3Qgb3B0cyA9IHtcbiAgcDogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYnKSxcbiAgbjogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmYmNlNmZhYWRhNzE3OWU4NGYzYjljYWMyZmM2MzI1NTEnKSxcbiAgaDogQmlnSW50KDEpLFxuICBhOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmYycpLFxuICBiOiBCaWdJbnQoJzB4NWFjNjM1ZDhhYTNhOTNlN2IzZWJiZDU1NzY5ODg2YmM2NTFkMDZiMGNjNTNiMGY2M2JjZTNjM2UyN2QyNjA0YicpLFxuICBHeDogQmlnSW50KCcweDZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTYnKSxcbiAgR3k6IEJpZ0ludCgnMHg0ZmUzNDJlMmZlMWE3ZjliOGVlN2ViNGE3YzBmOWUxNjJiY2UzMzU3NmIzMTVlY2VjYmI2NDA2ODM3YmY1MWY1JyksXG59O1xuY29uc3QgcDI1Nl9Qb2ludCA9IHdlaWVyc3RyYXNzKG9wdHMpO1xuYGBgXG4gKi9cbmZ1bmN0aW9uIHdlaWVyc3RyYXNzTihwYXJhbXMsIGV4dHJhT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRhdGVkID0gKDAsIGN1cnZlX3RzXzEuX2NyZWF0ZUN1cnZlRmllbGRzKSgnd2VpZXJzdHJhc3MnLCBwYXJhbXMsIGV4dHJhT3B0cyk7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IHZhbGlkYXRlZDtcbiAgICBsZXQgQ1VSVkUgPSB2YWxpZGF0ZWQuQ1VSVkU7XG4gICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgICgwLCB1dGlsc190c18xLl92YWxpZGF0ZU9iamVjdCkoZXh0cmFPcHRzLCB7fSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBlbmRvOiAnb2JqZWN0JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICAvLyB2YWxpZGF0ZU9iamVjdChlbmRvLCB7IGJldGE6ICdiaWdpbnQnLCBzcGxpdFNjYWxhcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgICAgaWYgKCFGcC5pczAoQ1VSVkUuYSkgfHwgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHwgIUFycmF5LmlzQXJyYXkoZW5kby5iYXNpc2VzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwiYmFzaXNlc1wiOiBhcnJheScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aHMgPSBnZXRXTGVuZ3RocyhGcCwgRm4pO1xuICAgIGZ1bmN0aW9uIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IEZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50cyBJRUVFIFAxMzYzIHBvaW50IGVuY29kaW5nXG4gICAgZnVuY3Rpb24gcG9pbnRUb0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgY29uc3QgYnggPSBGcC50b0J5dGVzKHgpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5fYWJvb2wyKShpc0NvbXByZXNzZWQsICdpc0NvbXByZXNzZWQnKTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgaGFzRXZlblkgPSAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKHBwcmVmaXgoaGFzRXZlblkpLCBieCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKFVpbnQ4QXJyYXkub2YoMHgwNCksIGJ4LCBGcC50b0J5dGVzKHkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludEZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5fYWJ5dGVzMikoYnl0ZXMsIHVuZGVmaW5lZCwgJ1BvaW50Jyk7XG4gICAgICAgIGNvbnN0IHsgcHVibGljS2V5OiBjb21wLCBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IHVuY29tcCB9ID0gbGVuZ3RoczsgLy8gZS5nLiBmb3IgMzItYnl0ZTogMzMsIDY1XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgIC8vIE5vIGFjdHVhbCB2YWxpZGF0aW9uIGlzIGRvbmUgaGVyZTogdXNlIC5hc3NlcnRWYWxpZGl0eSgpXG4gICAgICAgIGlmIChsZW5ndGggPT09IGNvbXAgJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbCk7XG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgd3JvbmcgeCcpO1xuICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoc3FydEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlLCBzcXJ0IGVycm9yJyArIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRDb21wcmVzc2lvbklzU3VwcG9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCBpc1lPZGQgPSBGcC5pc09kZCh5KTsgLy8gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxOyAvLyBFQ0RTQS1zcGVjaWZpY1xuICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBGcC5uZWcoeSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoID09PSB1bmNvbXAgJiYgaGVhZCA9PT0gMHgwNCkge1xuICAgICAgICAgICAgLy8gVE9ETzogbW9yZSBjaGVja3NcbiAgICAgICAgICAgIGNvbnN0IEwgPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBMKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoTCwgTCAqIDIpKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIHBvaW50OiBnb3QgbGVuZ3RoICR7bGVuZ3RofSwgZXhwZWN0ZWQgY29tcHJlc3NlZD0ke2NvbXB9IG9yIHVuY29tcHJlc3NlZD0ke3VuY29tcH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmNvZGVQb2ludCA9IGV4dHJhT3B0cy50b0J5dGVzIHx8IHBvaW50VG9CeXRlcztcbiAgICBjb25zdCBkZWNvZGVQb2ludCA9IGV4dHJhT3B0cy5mcm9tQnl0ZXMgfHwgcG9pbnRGcm9tQnl0ZXM7XG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHjCsiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBDVVJWRS5hKSksIENVUlZFLmIpOyAvLyB4wrMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVE9ETzogbW92ZSB0b3AtbGV2ZWxcbiAgICAvKiogQ2hlY2tzIHdoZXRoZXIgZXF1YXRpb24gaG9sZHMgZm9yIGdpdmVuIHgsIHk6IHnCsiA9PSB4wrMgKyBheCArIGIgKi9cbiAgICBmdW5jdGlvbiBpc1ZhbGlkWFkoeCwgeSkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFRlc3QgMTogZXF1YXRpb24gecKyID0geMKzICsgYXggKyBiIHNob3VsZCB3b3JrIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgaWYgKCFpc1ZhbGlkWFkoQ1VSVkUuR3gsIENVUlZFLkd5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBnZW5lcmF0b3IgcG9pbnQnKTtcbiAgICAvLyBUZXN0IDI6IGRpc2NyaW1pbmFudCDOlCBwYXJ0IHNob3VsZCBiZSBub24temVybzogNGHCsyArIDI3YsKyICE9IDAuXG4gICAgLy8gR3VhcmFudGVlcyBjdXJ2ZSBpcyBnZW51cy0xLCBzbW9vdGggKG5vbi1zaW5ndWxhcikuXG4gICAgY29uc3QgXzRhMyA9IEZwLm11bChGcC5wb3coQ1VSVkUuYSwgXzNuKSwgXzRuKTtcbiAgICBjb25zdCBfMjdiMiA9IEZwLm11bChGcC5zcXIoQ1VSVkUuYiksIEJpZ0ludCgyNykpO1xuICAgIGlmIChGcC5pczAoRnAuYWRkKF80YTMsIF8yN2IyKSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogYSBvciBiJyk7XG4gICAgLyoqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgRnAuT1JERVIuICovXG4gICAgZnVuY3Rpb24gYWNvb3JkKHRpdGxlLCBuLCBiYW5aZXJvID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKG4pIHx8IChiYW5aZXJvICYmIEZwLmlzMChuKSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBwb2ludCBjb29yZGluYXRlICR7dGl0bGV9YCk7XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHJqcG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzcGxpdEVuZG9TY2FsYXJOKGspIHtcbiAgICAgICAgaWYgKCFlbmRvIHx8ICFlbmRvLmJhc2lzZXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGVuZG8nKTtcbiAgICAgICAgcmV0dXJuIF9zcGxpdEVuZG9TY2FsYXIoaywgZW5kby5iYXNpc2VzLCBGbi5PUkRFUik7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKFgsIFksIFopIOKIiyAoeD1YL1osIHk9WS9aKVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9ICgwLCB1dGlsc190c18xLm1lbW9pemVkKSgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoWiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoWik7XG4gICAgICAgIGNvbnN0IHggPSBGcC5tdWwoWCwgaXopO1xuICAgICAgICBjb25zdCB5ID0gRnAubXVsKFksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSAoMCwgdXRpbHNfdHNfMS5tZW1vaXplZCkoKHApID0+IHtcbiAgICAgICAgaWYgKHAuaXMwKCkpIHtcbiAgICAgICAgICAgIC8vICgwLCAxLCAwKSBha2EgWkVSTyBpcyBpbnZhbGlkIGluIG1vc3QgY29udGV4dHMuXG4gICAgICAgICAgICAvLyBJbiBCTFMsIFpFUk8gY2FuIGJlIHNlcmlhbGl6ZWQsIHNvIHdlIGFsbG93IGl0LlxuICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIGludmFsaWQgcmVwcmVzZW50YXRpb24gb2YgWkVSTy5cbiAgICAgICAgICAgIGlmIChleHRyYU9wdHMuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5ZKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwLnRvQWZmaW5lKCk7XG4gICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4IG9yIHkgbm90IGZpZWxkIGVsZW1lbnRzJyk7XG4gICAgICAgIGlmICghaXNWYWxpZFhZKHgsIHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgaWYgKCFwLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZmluaXNoRW5kbyhlbmRvQmV0YSwgazFwLCBrMnAsIGsxbmVnLCBrMm5lZykge1xuICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5YLCBlbmRvQmV0YSksIGsycC5ZLCBrMnAuWik7XG4gICAgICAgIGsxcCA9ICgwLCBjdXJ2ZV90c18xLm5lZ2F0ZUN0KShrMW5lZywgazFwKTtcbiAgICAgICAgazJwID0gKDAsIGN1cnZlX3RzXzEubmVnYXRlQ3QpKGsybmVnLCBrMnApO1xuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOihYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWikuXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpLlxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihYLCBZLCBaKSB7XG4gICAgICAgICAgICB0aGlzLlggPSBhY29vcmQoJ3gnLCBYKTtcbiAgICAgICAgICAgIHRoaXMuWSA9IGFjb29yZCgneScsIFksIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5aID0gYWNvb3JkKCd6JywgWik7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBDVVJWRSgpIHtcbiAgICAgICAgICAgIHJldHVybiBDVVJWRTtcbiAgICAgICAgfVxuICAgICAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgICAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGRlY29kZVBvaW50KCgwLCB1dGlsc190c18xLl9hYnl0ZXMyKShieXRlcywgdW5kZWZpbmVkLCAncG9pbnQnKSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncG9pbnRIZXgnLCBoZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHdpbmRvd1NpemVcbiAgICAgICAgICogQHBhcmFtIGlzTGF6eSB0cnVlIHdpbGwgZGVmZXIgdGFibGUgY29tcHV0YXRpb24gdW50aWwgdGhlIGZpcnN0IG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBpc0xhenkgPSB0cnVlKSB7XG4gICAgICAgICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgaWYgKCFpc0xhenkpXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseShfM24pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZXR1cm4gYHRoaXNgXG4gICAgICAgIC8qKiBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLiAqL1xuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLiAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLiAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuWCwgRnAubmVnKHRoaXMuWSksIHRoaXMuWik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBleHRyYU9wdHM7XG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWROb3QwKHNjYWxhcikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlJyk7IC8vIDAgaXMgaW52YWxpZFxuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBjb25zdCBtdWwgPSAobikgPT4gd25hZi5jYWNoZWQodGhpcywgbiwgKHApID0+ICgwLCBjdXJ2ZV90c18xLm5vcm1hbGl6ZVopKFBvaW50LCBwKSk7XG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdEVuZG9TY2FsYXJOKHNjYWxhcik7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwOiBrMXAsIGY6IGsxZiB9ID0gbXVsKGsxKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHA6IGsycCwgZjogazJmIH0gPSBtdWwoazIpO1xuICAgICAgICAgICAgICAgIGZha2UgPSBrMWYuYWRkKGsyZik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBmaW5pc2hFbmRvKGVuZG8uYmV0YSwgazFwLCBrMnAsIGsxbmVnLCBrMm5lZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IG11bChzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfdHNfMS5ub3JtYWxpemVaKShQb2ludCwgW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBzZWNyZXQga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gZXh0cmFPcHRzO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWQoc2MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IG91dCBvZiByYW5nZScpOyAvLyAwIGlzIHZhbGlkXG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbiB8fCBwLmlzMCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7IC8vIGZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKHduYWYuaGFzQ2FjaGUodGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoc2MpO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdEVuZG9TY2FsYXJOKHNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gKDAsIGN1cnZlX3RzXzEubXVsRW5kb1Vuc2FmZSkoUG9pbnQsIHAsIGsxLCBrMik7IC8vIDMwJSBmYXN0ZXIgdnMgd25hZi51bnNhZmVcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluaXNoRW5kbyhlbmRvLmJldGEsIHAxLCBwMiwgazFuZWcsIGsybmVnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZShwLCBzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gdGhpcy5tdWx0aXBseVVuc2FmZShhKS5hZGQoUS5tdWx0aXBseVVuc2FmZShiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSBpbnZlcnRlZFogWl4tMSAoaW52ZXJ0ZWQgemVybykgLSBvcHRpb25hbCwgcHJlY29tcHV0YXRpb24gaXMgdXNlZnVsIGZvciBpbnZlcnRCYXRjaFxuICAgICAgICAgKi9cbiAgICAgICAgdG9BZmZpbmUoaW52ZXJ0ZWRaKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGludmVydGVkWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIFBvaW50IGlzIGZyZWUgb2YgdG9yc2lvbiBlbGVtZW50cyAoaXMgaW4gcHJpbWUgc3ViZ3JvdXApLlxuICAgICAgICAgKiBBbHdheXMgdG9yc2lvbi1mcmVlIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlzVG9yc2lvbkZyZWUgfSA9IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBjbGVhckNvZmFjdG9yIH0gPSBleHRyYU9wdHM7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgICAgICAgLy8gY2FuIHdlIHVzZSB0aGlzLmNsZWFyQ29mYWN0b3IoKT9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc190c18xLl9hYm9vbDIpKGlzQ29tcHJlc3NlZCwgJ2lzQ29tcHJlc3NlZCcpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVBvaW50KFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyAnWkVSTycgOiB0aGlzLnRvSGV4KCl9PmA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGdldCBweCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgcHooKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5aO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMucHJlY29tcHV0ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfdHNfMS5ub3JtYWxpemVaKShQb2ludCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjdXJ2ZV90c18xLnBpcHBlbmdlcikoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShfbm9ybUZuRWxlbWVudChGbiwgcHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGJhc2UgLyBnZW5lcmF0b3IgcG9pbnRcbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICAvLyB6ZXJvIC8gaW5maW5pdHkgLyBpZGVudGl0eSBwb2ludFxuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTsgLy8gMCwgMSwgMFxuICAgIC8vIG1hdGggZmllbGRcbiAgICBQb2ludC5GcCA9IEZwO1xuICAgIC8vIHNjYWxhciBmaWVsZFxuICAgIFBvaW50LkZuID0gRm47XG4gICAgY29uc3QgYml0cyA9IEZuLkJJVFM7XG4gICAgY29uc3Qgd25hZiA9IG5ldyBjdXJ2ZV90c18xLndOQUYoUG9pbnQsIGV4dHJhT3B0cy5lbmRvID8gTWF0aC5jZWlsKGJpdHMgLyAyKSA6IGJpdHMpO1xuICAgIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIHJldHVybiBQb2ludDtcbn1cbi8vIFBvaW50cyBzdGFydCB3aXRoIGJ5dGUgMHgwMiB3aGVuIHkgaXMgZXZlbjsgb3RoZXJ3aXNlIDB4MDNcbmZ1bmN0aW9uIHBwcmVmaXgoaGFzRXZlblkpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5vZihoYXNFdmVuWSA/IDB4MDIgOiAweDAzKTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZnVuY3Rpb24gbWFwVG9DdXJ2ZVNpbXBsZVNXVShGcCwgb3B0cykge1xuICAgICgwLCBtb2R1bGFyX3RzXzEudmFsaWRhdGVGaWVsZCkoRnApO1xuICAgIGNvbnN0IHsgQSwgQiwgWiB9ID0gb3B0cztcbiAgICBpZiAoIUZwLmlzVmFsaWQoQSkgfHwgIUZwLmlzVmFsaWQoQikgfHwgIUZwLmlzVmFsaWQoWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIFopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgZG9lcyBub3QgaGF2ZSAuaXNPZGQoKScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBCKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihaLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIEEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NiwgQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIEIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgY29uc3QgdHY0X2ludiA9ICgwLCBtb2R1bGFyX3RzXzEuRnBJbnZlcnRCYXRjaCkoRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICAgICAgeCA9IEZwLm11bCh4LCB0djRfaW52KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRXTGVuZ3RocyhGcCwgRm4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNyZXRLZXk6IEZuLkJZVEVTLFxuICAgICAgICBwdWJsaWNLZXk6IDEgKyBGcC5CWVRFUyxcbiAgICAgICAgcHVibGljS2V5VW5jb21wcmVzc2VkOiAxICsgMiAqIEZwLkJZVEVTLFxuICAgICAgICBwdWJsaWNLZXlIYXNQcmVmaXg6IHRydWUsXG4gICAgICAgIHNpZ25hdHVyZTogMiAqIEZuLkJZVEVTLFxuICAgIH07XG59XG4vKipcbiAqIFNvbWV0aW1lcyB1c2VycyBvbmx5IG5lZWQgZ2V0UHVibGljS2V5LCBnZXRTaGFyZWRTZWNyZXQsIGFuZCBzZWNyZXQga2V5IGhhbmRsaW5nLlxuICogVGhpcyBoZWxwZXIgZW5zdXJlcyBubyBzaWduYXR1cmUgZnVuY3Rpb25hbGl0eSBpcyBwcmVzZW50LiBMZXNzIGNvZGUsIHNtYWxsZXIgYnVuZGxlIHNpemUuXG4gKi9cbmZ1bmN0aW9uIGVjZGgoUG9pbnQsIGVjZGhPcHRzID0ge30pIHtcbiAgICBjb25zdCB7IEZuIH0gPSBQb2ludDtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSBlY2RoT3B0cy5yYW5kb21CeXRlcyB8fCB1dGlsc190c18xLnJhbmRvbUJ5dGVzO1xuICAgIGNvbnN0IGxlbmd0aHMgPSBPYmplY3QuYXNzaWduKGdldFdMZW5ndGhzKFBvaW50LkZwLCBGbiksIHsgc2VlZDogKDAsIG1vZHVsYXJfdHNfMS5nZXRNaW5IYXNoTGVuZ3RoKShGbi5PUkRFUikgfSk7XG4gICAgZnVuY3Rpb24gaXNWYWxpZFNlY3JldEtleShzZWNyZXRLZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIV9ub3JtRm5FbGVtZW50KEZuLCBzZWNyZXRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkocHVibGljS2V5LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgeyBwdWJsaWNLZXk6IGNvbXAsIHB1YmxpY0tleVVuY29tcHJlc3NlZCB9ID0gbGVuZ3RocztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBwdWJsaWNLZXkubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCA9PT0gdHJ1ZSAmJiBsICE9PSBjb21wKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IGZhbHNlICYmIGwgIT09IHB1YmxpY0tleVVuY29tcHJlc3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gISFQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgc2VjcmV0IGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmFuZG9tU2VjcmV0S2V5KHNlZWQgPSByYW5kb21CeXRlc18obGVuZ3Rocy5zZWVkKSkge1xuICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfdHNfMS5tYXBIYXNoVG9GaWVsZCkoKDAsIHV0aWxzX3RzXzEuX2FieXRlczIpKHNlZWQsIGxlbmd0aHMuc2VlZCwgJ3NlZWQnKSwgRm4uT1JERVIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHNlY3JldCBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHNlY3JldCBrZXkuXG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5KSkudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXksIHB1YmxpY0tleVVuY29tcHJlc3NlZCB9ID0gbGVuZ3RocztcbiAgICAgICAgaWYgKEZuLmFsbG93ZWRMZW5ndGhzIHx8IHNlY3JldEtleSA9PT0gcHVibGljS2V5KVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbCA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgna2V5JywgaXRlbSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbCA9PT0gcHVibGljS2V5IHx8IGwgPT09IHB1YmxpY0tleVVuY29tcHJlc3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gc2VjcmV0IGtleSBBIGFuZCBwdWJsaWMga2V5IEIuXG4gICAgICogQ2hlY2tzOiAxKSBzZWNyZXQga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQoc2VjcmV0S2V5QSwgcHVibGljS2V5QiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHNlY3JldEtleUEpID09PSB0cnVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0tleUIpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgcyA9IF9ub3JtRm5FbGVtZW50KEZuLCBzZWNyZXRLZXlBKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljS2V5Qik7IC8vIGNoZWNrcyBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkocykudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFB1YmxpY0tleSxcbiAgICAgICAgcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXk6IGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleSkgPT4gX25vcm1GbkVsZW1lbnQoRm4sIGtleSksXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50LnByZWNvbXB1dGUod2luZG93U2l6ZSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwga2V5Z2VuLCBQb2ludCwgdXRpbHMsIGxlbmd0aHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgRUNEU0Egc2lnbmluZyBpbnRlcmZhY2UgZm9yIGdpdmVuIGVsbGlwdGljIGN1cnZlIGBQb2ludGAgYW5kIGBoYXNoYCBmdW5jdGlvbi5cbiAqIFdlIG5lZWQgYGhhc2hgIGZvciAyIGZlYXR1cmVzOlxuICogMS4gTWVzc2FnZSBwcmVoYXNoLWluZy4gTk9UIHVzZWQgaWYgYHNpZ25gIC8gYHZlcmlmeWAgYXJlIGNhbGxlZCB3aXRoIGBwcmVoYXNoOiBmYWxzZWBcbiAqIDIuIGsgZ2VuZXJhdGlvbiBpbiBgc2lnbmAsIHVzaW5nIEhNQUMtZHJiZyhoYXNoKVxuICpcbiAqIEVDRFNBT3B0cyBhcmUgb25seSByYXJlbHkgbmVlZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgcDI1Nl9Qb2ludCA9IHdlaWVyc3RyYXNzKC4uLik7XG4gKiBjb25zdCBwMjU2X3NoYTI1NiA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTI1Nik7XG4gKiBjb25zdCBwMjU2X3NoYTIyNCA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTIyNCk7XG4gKiBjb25zdCBwMjU2X3NoYTIyNF9yID0gZWNkc2EocDI1Nl9Qb2ludCwgc2hhMjI0LCB7IHJhbmRvbUJ5dGVzOiAobGVuZ3RoKSA9PiB7IC4uLiB9IH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGVjZHNhKFBvaW50LCBoYXNoLCBlY2RzYU9wdHMgPSB7fSkge1xuICAgICgwLCB1dGlsc18xLmFoYXNoKShoYXNoKTtcbiAgICAoMCwgdXRpbHNfdHNfMS5fdmFsaWRhdGVPYmplY3QpKGVjZHNhT3B0cywge30sIHtcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgcmFuZG9tQnl0ZXMgPSBlY2RzYU9wdHMucmFuZG9tQnl0ZXMgfHwgdXRpbHNfdHNfMS5yYW5kb21CeXRlcztcbiAgICBjb25zdCBobWFjID0gZWNkc2FPcHRzLmhtYWMgfHxcbiAgICAgICAgKChrZXksIC4uLm1zZ3MpID0+ICgwLCBobWFjX2pzXzEuaG1hYykoaGFzaCwga2V5LCAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4ubXNncykpKTtcbiAgICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgY29uc3QgeyBPUkRFUjogQ1VSVkVfT1JERVIsIEJJVFM6IGZuQml0cyB9ID0gRm47XG4gICAgY29uc3QgeyBrZXlnZW4sIGdldFB1YmxpY0tleSwgZ2V0U2hhcmVkU2VjcmV0LCB1dGlscywgbGVuZ3RocyB9ID0gZWNkaChQb2ludCwgZWNkc2FPcHRzKTtcbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHtcbiAgICAgICAgcHJlaGFzaDogZmFsc2UsXG4gICAgICAgIGxvd1M6IHR5cGVvZiBlY2RzYU9wdHMubG93UyA9PT0gJ2Jvb2xlYW4nID8gZWNkc2FPcHRzLmxvd1MgOiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiB1bmRlZmluZWQsIC8vJ2NvbXBhY3QnIGFzIEVDRFNBU2lnRm9ybWF0LFxuICAgICAgICBleHRyYUVudHJvcHk6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHNfZm9ybWF0ID0gJ2NvbXBhY3QnO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUlModGl0bGUsIG51bSkge1xuICAgICAgICBpZiAoIUZuLmlzVmFsaWROb3QwKG51bSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2lnbmF0dXJlICR7dGl0bGV9OiBvdXQgb2YgcmFuZ2UgMS4uUG9pbnQuRm4uT1JERVJgKTtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVTaWdMZW5ndGgoYnl0ZXMsIGZvcm1hdCkge1xuICAgICAgICB2YWxpZGF0ZVNpZ0Zvcm1hdChmb3JtYXQpO1xuICAgICAgICBjb25zdCBzaXplID0gbGVuZ3Rocy5zaWduYXR1cmU7XG4gICAgICAgIGNvbnN0IHNpemVyID0gZm9ybWF0ID09PSAnY29tcGFjdCcgPyBzaXplIDogZm9ybWF0ID09PSAncmVjb3ZlcmVkJyA/IHNpemUgKyAxIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuX2FieXRlczIpKGJ5dGVzLCBzaXplciwgYCR7Zm9ybWF0fSBzaWduYXR1cmVgKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBjb21wYWN0LCByZWNvdmVyZWQgJiBERVIgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuICAgIGNsYXNzIFNpZ25hdHVyZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHIsIHMsIHJlY292ZXJ5KSB7XG4gICAgICAgICAgICB0aGlzLnIgPSB2YWxpZGF0ZVJTKCdyJywgcik7IC8vIHIgaW4gWzEuLk4tMV07XG4gICAgICAgICAgICB0aGlzLnMgPSB2YWxpZGF0ZVJTKCdzJywgcyk7IC8vIHMgaW4gWzEuLk4tMV07XG4gICAgICAgICAgICBpZiAocmVjb3ZlcnkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIGZvcm1hdCA9IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCkge1xuICAgICAgICAgICAgdmFsaWRhdGVTaWdMZW5ndGgoYnl0ZXMsIGZvcm1hdCk7XG4gICAgICAgICAgICBsZXQgcmVjaWQ7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gZXhwb3J0cy5ERVIudG9TaWcoKDAsIHV0aWxzX3RzXzEuX2FieXRlczIpKGJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAncmVjb3ZlcmVkJykge1xuICAgICAgICAgICAgICAgIHJlY2lkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gJ2NvbXBhY3QnO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBMID0gRm4uQllURVM7XG4gICAgICAgICAgICBjb25zdCByID0gYnl0ZXMuc3ViYXJyYXkoMCwgTCk7XG4gICAgICAgICAgICBjb25zdCBzID0gYnl0ZXMuc3ViYXJyYXkoTCwgTCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoRm4uZnJvbUJ5dGVzKHIpLCBGbi5mcm9tQnl0ZXMocyksIHJlY2lkKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgsIGZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUJ5dGVzKCgwLCB1dGlsc190c18xLmhleFRvQnl0ZXMpKGhleCksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgRklFTERfT1JERVIgPSBGcC5PUkRFUjtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICAvLyBFQ0RTQSByZWNvdmVyeSBpcyBoYXJkIGZvciBjb2ZhY3RvciA+IDEgY3VydmVzLlxuICAgICAgICAgICAgLy8gSW4gc2lnbiwgYHIgPSBxLnggbW9kIG5gLCBhbmQgaGVyZSB3ZSByZWNvdmVyIHEueCBmcm9tIHIuXG4gICAgICAgICAgICAvLyBXaGlsZSByZWNvdmVyaW5nIHEueCA+PSBuLCB3ZSBuZWVkIHRvIGFkZCByK24gZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgZm9yIGNvZmFjdG9yPjEsIHIrbiBtYXkgbm90IGdldCBxLng6XG4gICAgICAgICAgICAvLyByK24qaSB3b3VsZCBuZWVkIHRvIGJlIGRvbmUgaW5zdGVhZCB3aGVyZSBpIGlzIHVua25vd24uXG4gICAgICAgICAgICAvLyBUbyBlYXNpbHkgZ2V0IGksIHdlIGVpdGhlciBuZWVkIHRvOlxuICAgICAgICAgICAgLy8gYS4gaW5jcmVhc2UgYW1vdW50IG9mIHZhbGlkIHJlY2lkIHZhbHVlcyAoNCwgNS4uLik7IE9SXG4gICAgICAgICAgICAvLyBiLiBwcm9oaWJpdCBub24tcHJpbWUtb3JkZXIgc2lnbmF0dXJlcyAocmVjaWQgPiAxKS5cbiAgICAgICAgICAgIGNvbnN0IGhhc0NvZmFjdG9yID0gQ1VSVkVfT1JERVIgKiBfMm4gPCBGSUVMRF9PUkRFUjtcbiAgICAgICAgICAgIGlmIChoYXNDb2ZhY3RvciAmJiByZWMgPiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaXMgYW1iaWd1b3VzIGZvciBoPjEgY3VydmUnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFX09SREVSIDogcjtcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZChyYWRqKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAudG9CeXRlcyhyYWRqKTtcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tQnl0ZXMoKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKHBwcmVmaXgoKHJlYyAmIDEpID09PSAwKSwgeCkpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBGbi5pbnYocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1lc3NhZ2VIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGNvbnN0IHUxID0gRm4uY3JlYXRlKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gRm4uY3JlYXRlKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSkuIHVuc2FmZSBpcyBmaW5lOiB0aGVyZSBpcyBubyBwcml2YXRlIGRhdGEuXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseVVuc2FmZSh1MSkuYWRkKFIubXVsdGlwbHlVbnNhZmUodTIpKTtcbiAgICAgICAgICAgIGlmIChRLmlzMCgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTtcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9CeXRlcyhmb3JtYXQgPSBkZWZhdWx0U2lnT3B0c19mb3JtYXQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGVyJylcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuaGV4VG9CeXRlcykoZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCByID0gRm4udG9CeXRlcyh0aGlzLnIpO1xuICAgICAgICAgICAgY29uc3QgcyA9IEZuLnRvQnl0ZXModGhpcy5zKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdyZWNvdmVyZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnkgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBiaXQgbXVzdCBiZSBwcmVzZW50Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc190c18xLmNvbmNhdEJ5dGVzKShVaW50OEFycmF5Lm9mKHRoaXMucmVjb3ZlcnkpLCByLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb0hleCkodGhpcy50b0J5dGVzKGZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHsgfVxuICAgICAgICBzdGF0aWMgZnJvbUNvbXBhY3QoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CeXRlcygoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3NpZycsIGhleCksICdjb21wYWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CeXRlcygoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3NpZycsIGhleCksICdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBGbi5uZWcodGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfdHNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvQnl0ZXMoJ2RlcicpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoJ2NvbXBhY3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb0hleCkodGhpcy50b0J5dGVzKCdjb21wYWN0JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBlY2RzYU9wdHMuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gYml0czJpbnRfZGVmKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBPdXIgY3VzdG9tIGNoZWNrIFwianVzdCBpbiBjYXNlXCIsIGZvciBwcm90ZWN0aW9uIGFnYWluc3QgRG9TXG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gODE5MilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IGlzIHRvbyBsYXJnZScpO1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRSkoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBmbkJpdHM7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBlY2RzYU9wdHMuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiBiaXRzMmludF9tb2ROX2RlZihieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBQYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gKDAsIHV0aWxzX3RzXzEuYml0TWFzaykoZm5CaXRzKTtcbiAgICAvKiogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC4gKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IHRoZSBjaGVjayBlbnN1cmVzIHdvcmtpbmcgZm9yIGNhc2UgYEZuLkJZVEVTICE9IEZuLkJJVFMgKiA4YFxuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hSW5SYW5nZSkoJ251bSA8IDJeJyArIGZuQml0cywgbnVtLCBfMG4sIE9SREVSX01BU0spO1xuICAgICAgICByZXR1cm4gRm4udG9CeXRlcyhudW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU1zZ0FuZEhhc2gobWVzc2FnZSwgcHJlaGFzaCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5fYWJ5dGVzMikobWVzc2FnZSwgdW5kZWZpbmVkLCAnbWVzc2FnZScpO1xuICAgICAgICByZXR1cm4gcHJlaGFzaCA/ICgwLCB1dGlsc190c18xLl9hYnl0ZXMyKShoYXNoKG1lc3NhZ2UpLCB1bmRlZmluZWQsICdwcmVoYXNoZWQgbWVzc2FnZScpIDogbWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgKiBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAgKiBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1lc3NhZ2UgaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgICAqIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTYuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weSB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChtZXNzYWdlLCBwcmVoYXNoKTsgLy8gUkZDNjk3OSAzLjIgQTogaDEgPSBIKG0pXG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIGZuQml0cyAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtZXNzYWdlKTtcbiAgICAgICAgY29uc3QgZCA9IF9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgc2VjcmV0IGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChleHRyYUVudHJvcHkgIT0gbnVsbCAmJiBleHRyYUVudHJvcHkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIC8vIGdlbiByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgY29uc3QgZSA9IGV4dHJhRW50cm9weSA9PT0gdHJ1ZSA/IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VjcmV0S2V5KSA6IGV4dHJhRW50cm9weTtcbiAgICAgICAgICAgIHNlZWRBcmdzLnB1c2goKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSAoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgLy8gVG8gdHJhbnNmb3JtIGsgPT4gU2lnbmF0dXJlOlxuICAgICAgICAvLyBxID0ga+KLhUdcbiAgICAgICAgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAvLyBzID0ga14tMShtICsgcmQpIG1vZCBuXG4gICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIG1vZCBuLCBub3QgbW9kIHBcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBWYWxpZCBzY2FsYXJzIChpbmNsdWRpbmcgaykgbXVzdCBiZSBpbiAxLi5OLTFcbiAgICAgICAgICAgIGNvbnN0IGlrID0gRm4uaW52KGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0ga+KLhUdcbiAgICAgICAgICAgIGNvbnN0IHIgPSBGbi5jcmVhdGUocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBzID0gRm4uY3JlYXRlKGlrICogRm4uY3JlYXRlKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZSwgc2VlIGNvbW1lbnQgYWJvdmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gRm4ubmVnKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBzZWNyZXQga2V5LlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkKSB3aGVyZVxuICAgICAqICAgayA9IHJmYzY5NzlfaG1hY19kcmJnKG0sIGQpXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikgLyBrIG1vZCBuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtZXNzYWdlLCBzZWNyZXRLZXksIG9wdHMgPSB7fSkge1xuICAgICAgICBtZXNzYWdlID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobWVzc2FnZSwgc2VjcmV0S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgZHJiZyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhtYWNEcmJnKShoYXNoLm91dHB1dExlbiwgRm4uQllURVMsIGhtYWMpO1xuICAgICAgICBjb25zdCBzaWcgPSBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cnlQYXJzaW5nU2lnKHNnKSB7XG4gICAgICAgIC8vIFRyeSB0byBkZWR1Y2UgZm9ybWF0XG4gICAgICAgIGxldCBzaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCAoMCwgdXRpbHNfdHNfMS5pc0J5dGVzKShzZyk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gIWlzSGV4ICYmXG4gICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIGlmICghaXNIZXggJiYgIWlzT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgVWludDhBcnJheSwgaGV4IHN0cmluZyBvciBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICBzaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tQnl0ZXMoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdzaWcnLCBzZyksICdkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgZXhwb3J0cy5ERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNpZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZyA9IFNpZ25hdHVyZS5mcm9tQnl0ZXMoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdzaWcnLCBzZyksICdjb21wYWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2lnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogc2VlIHtAbGluayBFQ0RTQVZlcmlmeU9wdHN9LlxuICAgICAqIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICogICB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5LCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IHZhbGlkYXRlU2lnT3B0cyhvcHRzLCBkZWZhdWx0U2lnT3B0cyk7XG4gICAgICAgIHB1YmxpY0tleSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaCgoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKSwgcHJlaGFzaCk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHNpZyA9IGZvcm1hdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHRyeVBhcnNpbmdTaWcoc2lnbmF0dXJlKVxuICAgICAgICAgICAgOiBTaWduYXR1cmUuZnJvbUJ5dGVzKCgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnc2lnJywgc2lnbmF0dXJlKSwgZm9ybWF0KTtcbiAgICAgICAgaWYgKHNpZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBzaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1lc3NhZ2UpOyAvLyBtb2Qgbiwgbm90IG1vZCBwXG4gICAgICAgICAgICBjb25zdCBpcyA9IEZuLmludihzKTsgLy8gc14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlVbnNhZmUodTEpLmFkZChQLm11bHRpcGx5VW5zYWZlKHUyKSk7IC8vIHUx4ouFRyArIHUy4ouFUFxuICAgICAgICAgICAgaWYgKFIuaXMwKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZuLmNyZWF0ZShSLngpOyAvLyB2ID0gci54IG1vZCBuXG4gICAgICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoc2lnbmF0dXJlLCBtZXNzYWdlLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBwcmVoYXNoIH0gPSB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmYXVsdFNpZ09wdHMpO1xuICAgICAgICBtZXNzYWdlID0gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpO1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21CeXRlcyhzaWduYXR1cmUsICdyZWNvdmVyZWQnKS5yZWNvdmVyUHVibGljS2V5KG1lc3NhZ2UpLnRvQnl0ZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICBrZXlnZW4sXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICB1dGlscyxcbiAgICAgICAgbGVuZ3RocyxcbiAgICAgICAgUG9pbnQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleSxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICBoYXNoLFxuICAgIH0pO1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBgd2VpZXJzdHJhc3NgIGluIG5ld2VyIHJlbGVhc2VzICovXG5mdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhjKSB7XG4gICAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzIH0gPSBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIHJldHVybiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpO1xufVxuZnVuY3Rpb24gX3dlaWVyc3RyYXNzX2xlZ2FjeV9vcHRzX3RvX25ldyhjKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB7XG4gICAgICAgIGE6IGMuYSxcbiAgICAgICAgYjogYy5iLFxuICAgICAgICBwOiBjLkZwLk9SREVSLFxuICAgICAgICBuOiBjLm4sXG4gICAgICAgIGg6IGMuaCxcbiAgICAgICAgR3g6IGMuR3gsXG4gICAgICAgIEd5OiBjLkd5LFxuICAgIH07XG4gICAgY29uc3QgRnAgPSBjLkZwO1xuICAgIGxldCBhbGxvd2VkTGVuZ3RocyA9IGMuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzXG4gICAgICAgID8gQXJyYXkuZnJvbShuZXcgU2V0KGMuYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzLm1hcCgobCkgPT4gTWF0aC5jZWlsKGwgLyAyKSkpKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBGbiA9ICgwLCBtb2R1bGFyX3RzXzEuRmllbGQpKENVUlZFLm4sIHtcbiAgICAgICAgQklUUzogYy5uQml0TGVuZ3RoLFxuICAgICAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgICAgIG1vZEZyb21CeXRlczogYy53cmFwUHJpdmF0ZUtleSxcbiAgICB9KTtcbiAgICBjb25zdCBjdXJ2ZU9wdHMgPSB7XG4gICAgICAgIEZwLFxuICAgICAgICBGbixcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiBjLmFsbG93SW5maW5pdHlQb2ludCxcbiAgICAgICAgZW5kbzogYy5lbmRvLFxuICAgICAgICBpc1RvcnNpb25GcmVlOiBjLmlzVG9yc2lvbkZyZWUsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6IGMuY2xlYXJDb2ZhY3RvcixcbiAgICAgICAgZnJvbUJ5dGVzOiBjLmZyb21CeXRlcyxcbiAgICAgICAgdG9CeXRlczogYy50b0J5dGVzLFxuICAgIH07XG4gICAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cyB9O1xufVxuZnVuY3Rpb24gX2VjZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyhjKSB7XG4gICAgY29uc3QgeyBDVVJWRSwgY3VydmVPcHRzIH0gPSBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IGVjZHNhT3B0cyA9IHtcbiAgICAgICAgaG1hYzogYy5obWFjLFxuICAgICAgICByYW5kb21CeXRlczogYy5yYW5kb21CeXRlcyxcbiAgICAgICAgbG93UzogYy5sb3dTLFxuICAgICAgICBiaXRzMmludDogYy5iaXRzMmludCxcbiAgICAgICAgYml0czJpbnRfbW9kTjogYy5iaXRzMmludF9tb2ROLFxuICAgIH07XG4gICAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaDogYy5oYXNoLCBlY2RzYU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9sZWdhY3lIZWxwZXJFcXVhdChGcCwgYSwgYikge1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYS4gVGFrZXMgeCwgcmV0dXJucyB5wrIuXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHjCsiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4wrMgKyBhICogeCArIGJcbiAgICB9XG4gICAgcmV0dXJuIHdlaWVyc3RyYXNzRXF1YXRpb247XG59XG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpIHtcbiAgICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX3RzXzEuaW5SYW5nZSkobnVtLCBfMW4sIEZuLk9SREVSKTtcbiAgICB9XG4gICAgY29uc3Qgd2VpZXJzdHJhc3NFcXVhdGlvbiA9IF9sZWdhY3lIZWxwZXJFcXVhdChGcCwgYy5hLCBjLmIpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgIENVUlZFOiBjLFxuICAgICAgICBQb2ludDogUG9pbnQsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IChrZXkpID0+IF9ub3JtRm5FbGVtZW50KEZuLCBrZXkpLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZWNkc2FfbmV3X291dHB1dF90b19sZWdhY3koYywgX2VjZHNhKSB7XG4gICAgY29uc3QgUG9pbnQgPSBfZWNkc2EuUG9pbnQ7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIF9lY2RzYSwge1xuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBDVVJWRTogT2JqZWN0LmFzc2lnbih7fSwgYywgKDAsIG1vZHVsYXJfdHNfMS5uTGVuZ3RoKShQb2ludC5Gbi5PUkRFUiwgUG9pbnQuRm4uQklUUykpLFxuICAgIH0pO1xufVxuLy8gX2VjZHNhX2xlZ2FjeVxuZnVuY3Rpb24gd2VpZXJzdHJhc3MoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWNkc2FPcHRzIH0gPSBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IHNpZ25zID0gZWNkc2EoUG9pbnQsIGhhc2gsIGVjZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBzaWducyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaF90b19yaXN0cmV0dG8yNTUgPSBleHBvcnRzLmhhc2hUb1Jpc3RyZXR0bzI1NSA9IGV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9IGV4cG9ydHMuaGFzaFRvQ3VydmUgPSBleHBvcnRzLlJpc3RyZXR0b1BvaW50ID0gZXhwb3J0cy5lZHdhcmRzVG9Nb250Z29tZXJ5ID0gZXhwb3J0cy5FRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBleHBvcnRzLnJpc3RyZXR0bzI1NV9oYXNoZXIgPSBleHBvcnRzLnJpc3RyZXR0bzI1NSA9IGV4cG9ydHMuZWQyNTUxOV9oYXNoZXIgPSBleHBvcnRzLngyNTUxOSA9IGV4cG9ydHMuZWQyNTUxOXBoID0gZXhwb3J0cy5lZDI1NTE5Y3R4ID0gZXhwb3J0cy5lZDI1NTE5ID0gdm9pZCAwO1xuZXhwb3J0cy5lZHdhcmRzVG9Nb250Z29tZXJ5UHViID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1YjtcbmV4cG9ydHMuZWR3YXJkc1RvTW9udGdvbWVyeVByaXYgPSBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdjtcbi8qKlxuICogZWQyNTUxOSBUd2lzdGVkIEVkd2FyZHMgY3VydmUgd2l0aCBmb2xsb3dpbmcgYWRkb25zOlxuICogLSBYMjU1MTkgRUNESFxuICogLSBSaXN0cmV0dG8gY29mYWN0b3IgZWxpbWluYXRpb25cbiAqIC0gRWxsaWdhdG9yIGhhc2gtdG8tZ3JvdXAgLyBwb2ludCBpbmRpc3Rpbmd1aXNoYWJpbGl0eVxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBzaGEyX2pzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCIpO1xuY29uc3QgY3VydmVfdHNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2N1cnZlLmpzXCIpO1xuY29uc3QgZWR3YXJkc190c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvZWR3YXJkcy5qc1wiKTtcbmNvbnN0IGhhc2hfdG9fY3VydmVfdHNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIik7XG5jb25zdCBtb2R1bGFyX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCIpO1xuY29uc3QgbW9udGdvbWVyeV90c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9udGdvbWVyeS5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBQID0gMm4qKjI1NW4tMTluXG5jb25zdCBlZDI1NTE5X0NVUlZFX3AgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCcpO1xuLy8gTiA9IDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuXG4vLyBhID0gRnAuY3JlYXRlKEJpZ0ludCgtMSkpXG4vLyBkID0gLTEyMTY2NS8xMjE2NjYgYS5rLmEuIEZwLm5lZygxMjE2NjUgKiBGcC5pbnYoMTIxNjY2KSlcbmNvbnN0IGVkMjU1MTlfQ1VSVkUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgcDogZWQyNTUxOV9DVVJWRV9wLFxuICAgIG46IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkJyksXG4gICAgaDogXzhuLFxuICAgIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gICAgZDogQmlnSW50KCcweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTMnKSxcbiAgICBHeDogQmlnSW50KCcweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnKSxcbiAgICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn0pKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuLy8gRnAuc3FydChGcC5uZWcoMSkpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IHYzID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9ICgwLCBtb2R1bGFyX3RzXzEubW9kKSh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09ICgwLCBtb2R1bGFyX3RzXzEubW9kKSgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoKDAsIG1vZHVsYXJfdHNfMS5pc05lZ2F0aXZlTEUpKHgsIFApKVxuICAgICAgICB4ID0gKDAsIG1vZHVsYXJfdHNfMS5tb2QpKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmNvbnN0IEZwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgbW9kdWxhcl90c18xLkZpZWxkKShlZDI1NTE5X0NVUlZFLnAsIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IEZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgbW9kdWxhcl90c18xLkZpZWxkKShlZDI1NTE5X0NVUlZFLm4sIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICAuLi5lZDI1NTE5X0NVUlZFLFxuICAgIEZwLFxuICAgIGhhc2g6IHNoYTJfanNfMS5zaGE1MTIsXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgLy8gZG9tMlxuICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAvLyBDb25zdGFudC10aW1lLCB1L+KImnZcbiAgICB1dlJhdGlvLFxufSkpKCk7XG4vKipcbiAqIGVkMjU1MTkgY3VydmUgd2l0aCBFZERTQSBzaWduYXR1cmVzLlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGVkMjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuICogY29uc3QgeyBzZWNyZXRLZXksIHB1YmxpY0tleSB9ID0gZWQyNTUxOS5rZXlnZW4oKTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnaGVsbG8nKTtcbiAqIGNvbnN0IHNpZyA9IGVkMjU1MTkuc2lnbihtc2csIHByaXYpO1xuICogZWQyNTUxOS52ZXJpZnkoc2lnLCBtc2csIHB1Yik7IC8vIERlZmF1bHQgbW9kZTogZm9sbG93cyBaSVAyMTVcbiAqIGVkMjU1MTkudmVyaWZ5KHNpZywgbXNnLCBwdWIsIHsgemlwMjE1OiBmYWxzZSB9KTsgLy8gUkZDODAzMiAvIEZJUFMgMTg2LTVcbiAqL1xuZXhwb3J0cy5lZDI1NTE5ID0gKCgpID0+ICgwLCBlZHdhcmRzX3RzXzEudHdpc3RlZEVkd2FyZHMpKGVkMjU1MTlEZWZhdWx0cykpKCk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLCBuZXcgVWludDhBcnJheShbcGhmbGFnID8gMSA6IDAsIGN0eC5sZW5ndGhdKSwgY3R4LCBkYXRhKTtcbn1cbi8qKiBDb250ZXh0IG9mIGVkMjU1MTkuIFVzZXMgY29udGV4dCBmb3IgZG9tYWluIHNlcGFyYXRpb24uICovXG5leHBvcnRzLmVkMjU1MTljdHggPSAoKCkgPT4gKDAsIGVkd2FyZHNfdHNfMS50d2lzdGVkRWR3YXJkcykoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxufSkpKCk7XG4vKiogUHJlaGFzaGVkIHZlcnNpb24gb2YgZWQyNTUxOS4gQWNjZXB0cyBhbHJlYWR5LWhhc2hlZCBtZXNzYWdlcyBpbiBzaWduKCkgYW5kIHZlcmlmeSgpLiAqL1xuZXhwb3J0cy5lZDI1NTE5cGggPSAoKCkgPT4gKDAsIGVkd2FyZHNfdHNfMS50d2lzdGVkRWR3YXJkcykoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGEyX2pzXzEuc2hhNTEyLFxufSkpKSgpO1xuLyoqXG4gKiBFQ0RIIHVzaW5nIGN1cnZlMjU1MTkgYWthIHgyNTUxOS5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB4MjU1MTkgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTknO1xuICogY29uc3QgcHJpdiA9ICdhNTQ2ZTM2YmYwNTI3YzlkM2IxNjE1NGI4MjQ2NWVkZDYyMTQ0YzBhYzFmYzVhMTg1MDZhMjI0NGJhNDQ5YWM0JztcbiAqIGNvbnN0IHB1YiA9ICdlNmRiNjg2NzU4MzAzMGRiMzU5NGMxYTQyNGIxNWY3YzcyNjYyNGVjMjZiMzM1M2IxMGE5MDNhNmQwYWIxYzRjJztcbiAqIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQocHJpdiwgcHViKSA9PT0geDI1NTE5LnNjYWxhck11bHQocHJpdiwgcHViKTsgLy8gYWxpYXNlc1xuICogeDI1NTE5LmdldFB1YmxpY0tleShwcml2KSA9PT0geDI1NTE5LnNjYWxhck11bHRCYXNlKHByaXYpO1xuICogeDI1NTE5LmdldFB1YmxpY0tleSh4MjU1MTkudXRpbHMucmFuZG9tU2VjcmV0S2V5KCkpO1xuICovXG5leHBvcnRzLngyNTUxOSA9ICgoKSA9PiB7XG4gICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgIHJldHVybiAoMCwgbW9udGdvbWVyeV90c18xLm1vbnRnb21lcnkpKHtcbiAgICAgICAgUCxcbiAgICAgICAgdHlwZTogJ3gyNTUxOScsXG4gICAgICAgIHBvd1BtaW51czI6ICh4KSA9PiB7XG4gICAgICAgICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcbiAgICAgICAgICAgIGNvbnN0IHsgcG93X3BfNV84LCBiMiB9ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl90c18xLm1vZCkoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShwb3dfcF81XzgsIF8zbiwgUCkgKiBiMiwgUCk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuICAgIH0pO1xufSkoKTtcbi8vIEhhc2ggVG8gQ3VydmUgRWxsaWdhdG9yMiBNYXAgKE5PVEU6IGRpZmZlcmVudCBmcm9tIHJpc3RyZXR0bzI1NSBlbGxpZ2F0b3IpXG4vLyBOT1RFOiB2ZXJ5IGltcG9ydGFudCBwYXJ0IGlzIHVzYWdlIG9mIEZwU3FydEV2ZW4gZm9yIEVMTDJfQzFfRURXQVJEUywgc2luY2Vcbi8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcbmNvbnN0IEVMTDJfQzEgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IChlZDI1NTE5X0NVUlZFX3AgKyBfM24pIC8gXzhuKSgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5wb3coXzJuLCBFTEwyX0MxKSkoKTsgLy8gMi4gYzIgPSAyXmMxXG5jb25zdCBFTEwyX0MzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcC5zcXJ0KEZwLm5lZyhGcC5PTkUpKSkoKTsgLy8gMy4gYzMgPSBzcXJ0KC0xKVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpIHtcbiAgICBjb25zdCBFTEwyX0M0ID0gKGVkMjU1MTlfQ1VSVkVfcCAtIF81bikgLyBfOG47IC8vIDQuIGM0ID0gKHEgLSA1KSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICBjb25zdCBFTEwyX0ogPSBCaWdJbnQoNDg2NjYyKTtcbiAgICBsZXQgdHYxID0gRnAuc3FyKHUpOyAvLyAgMS4gIHR2MSA9IHVeMlxuICAgIHR2MSA9IEZwLm11bCh0djEsIF8ybik7IC8vICAyLiAgdHYxID0gMiAqIHR2MVxuICAgIGxldCB4ZCA9IEZwLmFkZCh0djEsIEZwLk9ORSk7IC8vICAzLiAgIHhkID0gdHYxICsgMSAgICAgICAgICMgTm9uemVybzogLTEgaXMgc3F1YXJlIChtb2QgcCksIHR2MSBpcyBub3RcbiAgICBsZXQgeDFuID0gRnAubmVnKEVMTDJfSik7IC8vICA0LiAgeDFuID0gLUogICAgICAgICAgICAgICMgeDEgPSB4MW4gLyB4ZCA9IC1KIC8gKDEgKyAyICogdV4yKVxuICAgIGxldCB0djIgPSBGcC5zcXIoeGQpOyAvLyAgNS4gIHR2MiA9IHhkXjJcbiAgICBsZXQgZ3hkID0gRnAubXVsKHR2MiwgeGQpOyAvLyAgNi4gIGd4ZCA9IHR2MiAqIHhkICAgICAgICAjIGd4ZCA9IHhkXjNcbiAgICBsZXQgZ3gxID0gRnAubXVsKHR2MSwgRUxMMl9KKTsgLy8gIDcuICBneDEgPSBKICogdHYxICAgICAgICAgIyB4MW4gKyBKICogeGRcbiAgICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAvLyAgOC4gIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkXG4gICAgZ3gxID0gRnAuYWRkKGd4MSwgdHYyKTsgLy8gIDkuICBneDEgPSBneDEgKyB0djIgICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZCArIHhkXjJcbiAgICBneDEgPSBGcC5tdWwoZ3gxLCB4MW4pOyAvLyAgMTAuIGd4MSA9IGd4MSAqIHgxbiAgICAgICAjIHgxbl4zICsgSiAqIHgxbl4yICogeGQgKyB4MW4gKiB4ZF4yXG4gICAgbGV0IHR2MyA9IEZwLnNxcihneGQpOyAvLyAgMTEuIHR2MyA9IGd4ZF4yXG4gICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vICAxMi4gdHYyID0gdHYzXjIgICAgICAgICAgICMgZ3hkXjRcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneGQpOyAvLyAgMTMuIHR2MyA9IHR2MyAqIGd4ZCAgICAgICAjIGd4ZF4zXG4gICAgdHYzID0gRnAubXVsKHR2MywgZ3gxKTsgLy8gIDE0LiB0djMgPSB0djMgKiBneDEgICAgICAgIyBneDEgKiBneGReM1xuICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vICAxNS4gdHYyID0gdHYyICogdHYzICAgICAgICMgZ3gxICogZ3hkXjdcbiAgICBsZXQgeTExID0gRnAucG93KHR2MiwgRUxMMl9DNCk7IC8vICAxNi4geTExID0gdHYyXmM0ICAgICAgICAjIChneDEgKiBneGReNyleKChwIC0gNSkgLyA4KVxuICAgIHkxMSA9IEZwLm11bCh5MTEsIHR2Myk7IC8vICAxNy4geTExID0geTExICogdHYzICAgICAgICMgZ3gxKmd4ZF4zKihneDEqZ3hkXjcpXigocC01KS84KVxuICAgIGxldCB5MTIgPSBGcC5tdWwoeTExLCBFTEwyX0MzKTsgLy8gIDE4LiB5MTIgPSB5MTEgKiBjM1xuICAgIHR2MiA9IEZwLnNxcih5MTEpOyAvLyAgMTkuIHR2MiA9IHkxMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDIwLiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTEgPSBGcC5lcWwodHYyLCBneDEpOyAvLyAgMjEuICBlMSA9IHR2MiA9PSBneDFcbiAgICBsZXQgeTEgPSBGcC5jbW92KHkxMiwgeTExLCBlMSk7IC8vICAyMi4gIHkxID0gQ01PVih5MTIsIHkxMSwgZTEpICAjIElmIGcoeDEpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIGxldCB4Mm4gPSBGcC5tdWwoeDFuLCB0djEpOyAvLyAgMjMuIHgybiA9IHgxbiAqIHR2MSAgICAgICAjIHgyID0geDJuIC8geGQgPSAyICogdV4yICogeDFuIC8geGRcbiAgICBsZXQgeTIxID0gRnAubXVsKHkxMSwgdSk7IC8vICAyNC4geTIxID0geTExICogdVxuICAgIHkyMSA9IEZwLm11bCh5MjEsIEVMTDJfQzIpOyAvLyAgMjUuIHkyMSA9IHkyMSAqIGMyXG4gICAgbGV0IHkyMiA9IEZwLm11bCh5MjEsIEVMTDJfQzMpOyAvLyAgMjYuIHkyMiA9IHkyMSAqIGMzXG4gICAgbGV0IGd4MiA9IEZwLm11bChneDEsIHR2MSk7IC8vICAyNy4gZ3gyID0gZ3gxICogdHYxICAgICAgICMgZyh4MikgPSBneDIgLyBneGQgPSAyICogdV4yICogZyh4MSlcbiAgICB0djIgPSBGcC5zcXIoeTIxKTsgLy8gIDI4LiB0djIgPSB5MjFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyOS4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUyID0gRnAuZXFsKHR2MiwgZ3gyKTsgLy8gIDMwLiAgZTIgPSB0djIgPT0gZ3gyXG4gICAgbGV0IHkyID0gRnAuY21vdih5MjIsIHkyMSwgZTIpOyAvLyAgMzEuICB5MiA9IENNT1YoeTIyLCB5MjEsIGUyKSAgIyBJZiBnKHgyKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcbiAgICB0djIgPSBGcC5zcXIoeTEpOyAvLyAgMzIuIHR2MiA9IHkxXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMzMuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMyA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAzNC4gIGUzID0gdHYyID09IGd4MVxuICAgIGxldCB4biA9IEZwLmNtb3YoeDJuLCB4MW4sIGUzKTsgLy8gIDM1LiAgeG4gPSBDTU9WKHgybiwgeDFuLCBlMykgICMgSWYgZTMsIHggPSB4MSwgZWxzZSB4ID0geDJcbiAgICBsZXQgeSA9IEZwLmNtb3YoeTIsIHkxLCBlMyk7IC8vICAzNi4gICB5ID0gQ01PVih5MiwgeTEsIGUzKSAgICAjIElmIGUzLCB5ID0geTEsIGVsc2UgeSA9IHkyXG4gICAgbGV0IGU0ID0gRnAuaXNPZGQoeSk7IC8vICAzNy4gIGU0ID0gc2duMCh5KSA9PSAxICAgICAgICAjIEZpeCBzaWduIG9mIHlcbiAgICB5ID0gRnAuY21vdih5LCBGcC5uZWcoeSksIGUzICE9PSBlNCk7IC8vICAzOC4gICB5ID0gQ01PVih5LCAteSwgZTMgWE9SIGU0KVxuICAgIHJldHVybiB7IHhNbjogeG4sIHhNZDogeGQsIHlNbjogeSwgeU1kOiBfMW4gfTsgLy8gIDM5LiByZXR1cm4gKHhuLCB4ZCwgeSwgMSlcbn1cbmNvbnN0IEVMTDJfQzFfRURXQVJEUyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIG1vZHVsYXJfdHNfMS5GcFNxcnRFdmVuKShGcCwgRnAubmVnKEJpZ0ludCg0ODY2NjQpKSkpKCk7IC8vIHNnbjAoYzEpIE1VU1QgZXF1YWwgMFxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5KHUpIHtcbiAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG4gICAgLy8gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KVxuICAgIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcbiAgICBsZXQgeGQgPSBGcC5tdWwoeE1kLCB5TW4pOyAvLyAgNC4gIHhkID0geE1kICogeU1uICAgICMgeG4gLyB4ZCA9IGMxICogeE0gLyB5TVxuICAgIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG4gICAgbGV0IHR2MSA9IEZwLm11bCh4ZCwgeWQpOyAvLyAgNy4gdHYxID0geGQgKiB5ZFxuICAgIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuICAgIHhkID0gRnAuY21vdih4ZCwgRnAuT05FLCBlKTsgLy8gIDEwLiB4ZCA9IENNT1YoeGQsIDEsIGUpXG4gICAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuICAgIGNvbnN0IFt4ZF9pbnYsIHlkX2ludl0gPSAoMCwgbW9kdWxhcl90c18xLkZwSW52ZXJ0QmF0Y2gpKEZwLCBbeGQsIHlkXSwgdHJ1ZSk7IC8vIGJhdGNoIGRpdmlzaW9uXG4gICAgcmV0dXJuIHsgeDogRnAubXVsKHhuLCB4ZF9pbnYpLCB5OiBGcC5tdWwoeW4sIHlkX2ludikgfTsgLy8gIDEzLiByZXR1cm4gKHhuLCB4ZCwgeW4sIHlkKVxufVxuLyoqIEhhc2hpbmcgdG8gZWQyNTUxOSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydHMuZWQyNTUxOV9oYXNoZXIgPSAoKCkgPT4gKDAsIGhhc2hfdG9fY3VydmVfdHNfMS5jcmVhdGVIYXNoZXIpKGV4cG9ydHMuZWQyNTUxOS5Qb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBlZDI1NTE5X0NVUlZFX3AsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyX2pzXzEuc2hhNTEyLFxufSkpKCk7XG4vLyDiiJooLTEpIGFrYSDiiJooYSkgYWthIDJeKChwLTEpLzQpXG5jb25zdCBTUVJUX00xID0gRUQyNTUxOV9TUVJUX00xO1xuLy8g4oiaKGFkIC0gMSlcbmNvbnN0IFNRUlRfQURfTUlOVVNfT05FID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMjUwNjMwNjg5NTMzODQ2MjM0NzQxMTE0MTQxNTg3MDIxNTI3MDEyNDQ1MzE1MDI0OTI2NTY0NjAwNzkyMTA0ODI2MTA0MzA3NTAyMzUnKTtcbi8vIDEgLyDiiJooYS1kKVxuY29uc3QgSU5WU1FSVF9BX01JTlVTX0QgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCc1NDQ2OTMwNzAwODkwOTMxNjkyMDk5NTgxMzg2ODc0NTE0MTYwNTM5MzU5NzI5MjkyNzQ1NjkyMTIwNTMxMjg5NjMxMTcyMTAxNzU3OCcpO1xuLy8gMS1kwrJcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMTE1OTg0MzAyMTY2ODc3OTg3OTE5Mzc3NTUyMTg1NTU4NjY0NzkzNzM1Nzc1OTcxNTQxNzY1NDQzOTg3OTcyMDg3NjExMTgwNjgzOCcpO1xuLy8gKGQtMSnCslxuY29uc3QgRF9NSU5VU19PTkVfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCc0MDQ0MDgzNDM0NjMwODUzNjg1ODEwMTA0MjQ2OTMyMzE5MDgyNjI0ODM5OTE0NjIzODcwODM1MjI0MDEzMzIyMDg2NTEzNzI2NTk1MicpO1xuLy8gQ2FsY3VsYXRlcyAxL+KImihudW1iZXIpXG5jb25zdCBpbnZlcnRTcXJ0ID0gKG51bWJlcikgPT4gdXZSYXRpbyhfMW4sIG51bWJlcik7XG5jb25zdCBNQVhfMjU1QiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuY29uc3QgYnl0ZXMyNTVUb051bWJlckxFID0gKGJ5dGVzKSA9PiBleHBvcnRzLmVkMjU1MTkuUG9pbnQuRnAuY3JlYXRlKCgwLCB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJMRSkoYnl0ZXMpICYgTUFYXzI1NUIpO1xuLyoqXG4gKiBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG8yNTUuXG4gKiBEZXNjcmliZWQgaW4gW1JGQzkzODBdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI2FwcGVuZGl4LUIpIGFuZCBvblxuICogdGhlIFt3ZWJzaXRlXShodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbCkuXG4gKi9cbmZ1bmN0aW9uIGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjApIHtcbiAgICBjb25zdCB7IGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCBtb2QgPSAobikgPT4gRnAuY3JlYXRlKG4pO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoISgwLCBtb2R1bGFyX3RzXzEuaXNOZWdhdGl2ZUxFKShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5lZDI1NTE5LlBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG5mdW5jdGlvbiByaXN0cmV0dG8yNTVfbWFwKGJ5dGVzKSB7XG4gICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShieXRlcywgNjQpO1xuICAgIGNvbnN0IHIxID0gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShieXRlcy5zdWJhcnJheSgzMiwgNjQpKTtcbiAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KFIxLmFkZChSMikpO1xufVxuLyoqXG4gKiBXcmFwcGVyIG92ZXIgRWR3YXJkcyBQb2ludCBmb3IgcmlzdHJldHRvMjU1LlxuICpcbiAqIEVhY2ggZWQyNTUxOS9FeHRlbmRlZFBvaW50IGhhcyA4IGRpZmZlcmVudCBlcXVpdmFsZW50IHBvaW50cy4gVGhpcyBjYW4gYmVcbiAqIGEgc291cmNlIG9mIGJ1Z3MgZm9yIHByb3RvY29scyBsaWtlIHJpbmcgc2lnbmF0dXJlcy4gUmlzdHJldHRvIHdhcyBjcmVhdGVkIHRvIHNvbHZlIHRoaXMuXG4gKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG4gKiBidXQgaXQgc2hvdWxkIHdvcmsgaW4gaXRzIG93biBuYW1lc3BhY2U6IGRvIG5vdCBjb21iaW5lIHRob3NlIHR3by5cbiAqIFNlZSBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYpLlxuICovXG5jbGFzcyBfUmlzdHJldHRvUG9pbnQgZXh0ZW5kcyBlZHdhcmRzX3RzXzEuUHJpbWVFZHdhcmRzUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHN1cGVyKGVwKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUoYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoZXhwb3J0cy5lZDI1NTE5LlBvaW50LmZyb21BZmZpbmUoYXApKTtcbiAgICB9XG4gICAgYXNzZXJ0U2FtZShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIF9SaXN0cmV0dG9Qb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jpc3RyZXR0b1BvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIGluaXQoZXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoZXApO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyByaXN0cmV0dG8yNTVfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcCgoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3Jpc3RyZXR0b0hhc2gnLCBoZXgsIDY0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShieXRlcywgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfdHNfMS5lcXVhbEJ5dGVzKShGcC50b0J5dGVzKHMpLCBieXRlcykgfHwgKDAsIG1vZHVsYXJfdHNfMS5pc05lZ2F0aXZlTEUpKHMsIFApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJpc3RyZXR0bzI1NSBlbmNvZGluZyAxJyk7XG4gICAgICAgIGNvbnN0IHMyID0gbW9kKHMgKiBzKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoXzFuIC0gYSAqIHMyKTsgLy8gNVxuICAgICAgICBjb25zdCB1MV8yID0gbW9kKHUxICogdTEpO1xuICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGEgKiBkICogdTFfMiAtIHUyXzIpOyAvLyA2XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWU6IEkgfSA9IGludmVydFNxcnQobW9kKHYgKiB1Ml8yKSk7IC8vIDdcbiAgICAgICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuICAgICAgICBjb25zdCBEeSA9IG1vZChJICogRHggKiB2KTsgLy8gOVxuICAgICAgICBsZXQgeCA9IG1vZCgocyArIHMpICogRHgpOyAvLyAxMFxuICAgICAgICBpZiAoKDAsIG1vZHVsYXJfdHNfMS5pc05lZ2F0aXZlTEUpKHgsIFApKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7IC8vIDEwXG4gICAgICAgIGNvbnN0IHkgPSBtb2QodTEgKiBEeSk7IC8vIDExXG4gICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuICAgICAgICBpZiAoIWlzVmFsaWQgfHwgKDAsIG1vZHVsYXJfdHNfMS5pc05lZ2F0aXZlTEUpKHQsIFApIHx8IHkgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByaXN0cmV0dG8yNTUgZW5jb2RpbmcgMicpO1xuICAgICAgICByZXR1cm4gbmV3IF9SaXN0cmV0dG9Qb2ludChuZXcgZXhwb3J0cy5lZDI1NTE5LlBvaW50KHgsIHksIF8xbiwgdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1kZWNvZGUpLlxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIF9SaXN0cmV0dG9Qb2ludC5mcm9tQnl0ZXMoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdyaXN0cmV0dG9IZXgnLCBoZXgsIDMyKSk7XG4gICAgfVxuICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgICAgIHJldHVybiAoMCwgY3VydmVfdHNfMS5waXBwZW5nZXIpKF9SaXN0cmV0dG9Qb2ludCwgZXhwb3J0cy5lZDI1NTE5LlBvaW50LkZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIHJpc3RyZXR0byBwb2ludCB0byBVaW50OEFycmF5LlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1lbmNvZGUpLlxuICAgICAqL1xuICAgIHRvQnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IFgsIFksIFosIFQgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZChaICsgWSkgKiBtb2QoWiAtIFkpKTsgLy8gMVxuICAgICAgICBjb25zdCB1MiA9IG1vZChYICogWSk7IC8vIDJcbiAgICAgICAgLy8gU3F1YXJlIHJvb3QgYWx3YXlzIGV4aXN0c1xuICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBpbnZzcXJ0IH0gPSBpbnZlcnRTcXJ0KG1vZCh1MSAqIHUyc3EpKTsgLy8gM1xuICAgICAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpOyAvLyA0XG4gICAgICAgIGNvbnN0IEQyID0gbW9kKGludnNxcnQgKiB1Mik7IC8vIDVcbiAgICAgICAgY29uc3QgekludiA9IG1vZChEMSAqIEQyICogVCk7IC8vIDZcbiAgICAgICAgbGV0IEQ7IC8vIDdcbiAgICAgICAgaWYgKCgwLCBtb2R1bGFyX3RzXzEuaXNOZWdhdGl2ZUxFKShUICogekludiwgUCkpIHtcbiAgICAgICAgICAgIGxldCBfeCA9IG1vZChZICogU1FSVF9NMSk7XG4gICAgICAgICAgICBsZXQgX3kgPSBtb2QoWCAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgWCA9IF94O1xuICAgICAgICAgICAgWSA9IF95O1xuICAgICAgICAgICAgRCA9IG1vZChEMSAqIElOVlNRUlRfQV9NSU5VU19EKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEQgPSBEMjsgLy8gOFxuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgbW9kdWxhcl90c18xLmlzTmVnYXRpdmVMRSkoWCAqIHpJbnYsIFApKVxuICAgICAgICAgICAgWSA9IG1vZCgtWSk7IC8vIDlcbiAgICAgICAgbGV0IHMgPSBtb2QoKFogLSBZKSAqIEQpOyAvLyAxMCAoY2hlY2sgZm9vdGVyJ3Mgbm90ZSwgbm8gc3FydCgtYSkpXG4gICAgICAgIGlmICgoMCwgbW9kdWxhcl90c18xLmlzTmVnYXRpdmVMRSkocywgUCkpXG4gICAgICAgICAgICBzID0gbW9kKC1zKTtcbiAgICAgICAgcmV0dXJuIEZwLnRvQnl0ZXMocyk7IC8vIDExXG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBSaXN0cmV0dG8gcG9pbnRzLlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1lcXVhbHMpLlxuICAgICAqL1xuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICB0aGlzLmFzc2VydFNhbWUob3RoZXIpO1xuICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIgfSA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBtb2QgPSAobikgPT4gRnAuY3JlYXRlKG4pO1xuICAgICAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChYMSAqIFkyKSA9PT0gbW9kKFkxICogWDIpO1xuICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGlzMCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKF9SaXN0cmV0dG9Qb2ludC5aRVJPKTtcbiAgICB9XG59XG4vLyBEbyBOT1QgY2hhbmdlIHN5bnRheDogdGhlIGZvbGxvd2luZyBneW1uYXN0aWNzIGlzIGRvbmUsXG4vLyBiZWNhdXNlIHR5cGVzY3JpcHQgc3RyaXBzIGNvbW1lbnRzLCB3aGljaCBtYWtlcyBidW5kbGVycyBkaXNhYmxlIHRyZWUtc2hha2luZy5cbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LkJBU0UgPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbmV3IF9SaXN0cmV0dG9Qb2ludChleHBvcnRzLmVkMjU1MTkuUG9pbnQuQkFTRSkpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5aRVJPID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZXhwb3J0cy5lZDI1NTE5LlBvaW50LlpFUk8pKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuRnAgPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRnApKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5GbiA9IFxuLyogQF9fUFVSRV9fICovICgoKSA9PiBGbikoKTtcbmV4cG9ydHMucmlzdHJldHRvMjU1ID0geyBQb2ludDogX1Jpc3RyZXR0b1BvaW50IH07XG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnRzLnJpc3RyZXR0bzI1NV9oYXNoZXIgPSB7XG4gICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IERTVCA9IG9wdGlvbnM/LkRTVCB8fCAncmlzdHJldHRvMjU1X1hNRDpTSEEtNTEyX1IyNTVNQVBfUk9fJztcbiAgICAgICAgY29uc3QgeG1kID0gKDAsIGhhc2hfdG9fY3VydmVfdHNfMS5leHBhbmRfbWVzc2FnZV94bWQpKG1zZywgRFNULCA2NCwgc2hhMl9qc18xLnNoYTUxMik7XG4gICAgICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKHhtZCk7XG4gICAgfSxcbiAgICBoYXNoVG9TY2FsYXIobXNnLCBvcHRpb25zID0geyBEU1Q6IGhhc2hfdG9fY3VydmVfdHNfMS5fRFNUX3NjYWxhciB9KSB7XG4gICAgICAgIGNvbnN0IHhtZCA9ICgwLCBoYXNoX3RvX2N1cnZlX3RzXzEuZXhwYW5kX21lc3NhZ2VfeG1kKShtc2csIG9wdGlvbnMuRFNULCA2NCwgc2hhMl9qc18xLnNoYTUxMik7XG4gICAgICAgIHJldHVybiBGbi5jcmVhdGUoKDAsIHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckxFKSh4bWQpKTtcbiAgICB9LFxufTtcbi8vIGV4cG9ydCBjb25zdCByaXN0cmV0dG8yNTVfb3ByZjogT1BSRiA9IGNyZWF0ZU9SUEYoe1xuLy8gICBuYW1lOiAncmlzdHJldHRvMjU1LVNIQTUxMicsXG4vLyAgIFBvaW50OiBSaXN0cmV0dG9Qb2ludCxcbi8vICAgaGFzaDogc2hhNTEyLFxuLy8gICBoYXNoVG9Hcm91cDogcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSxcbi8vICAgaGFzaFRvU2NhbGFyOiByaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb1NjYWxhcixcbi8vIH0pO1xuLyoqXG4gKiBXZWlyZCAvIGJvZ3VzIHBvaW50cywgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gKiBBbGwgOCBlZDI1NTE5IHBvaW50cyBvZiA4LXRvcnNpb24gc3ViZ3JvdXAgY2FuIGJlIGdlbmVyYXRlZCBmcm9tIHRoZSBwb2ludFxuICogVCA9IGAyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1YC5cbiAqIOKfqFTin6kgPSB7IE8sIFQsIDJULCAzVCwgNFQsIDVULCA2VCwgN1QgfVxuICovXG5leHBvcnRzLkVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5YCAqL1xuZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVB1YihlZHdhcmRzUHViKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZWQyNTUxOS51dGlscy50b01vbnRnb21lcnkoKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwdWInLCBlZHdhcmRzUHViKSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeWAgKi9cbmV4cG9ydHMuZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVByaXZgICovXG5mdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIHJldHVybiBleHBvcnRzLmVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5UHJpdigoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ3B1YicsIGVkd2FyZHNQcml2KSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGByaXN0cmV0dG8yNTUuUG9pbnRgICovXG5leHBvcnRzLlJpc3RyZXR0b1BvaW50ID0gX1Jpc3RyZXR0b1BvaW50O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gZXhwb3J0cy5lZDI1NTE5X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IGVkMjU1MTlfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSAoKCkgPT4gZXhwb3J0cy5lZDI1NTE5X2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0cy5oYXNoVG9SaXN0cmV0dG8yNTUgPSAoKCkgPT4gZXhwb3J0cy5yaXN0cmV0dG8yNTVfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0cy5oYXNoX3RvX3Jpc3RyZXR0bzI1NSA9ICgoKSA9PiBleHBvcnRzLnJpc3RyZXR0bzI1NV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZDI1NTE5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IGV4cG9ydHMuc2VjcDI1NmsxX2hhc2hlciA9IGV4cG9ydHMuc2Nobm9yciA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuLyoqXG4gKiBTRUNHIHNlY3AyNTZrMS4gU2VlIFtwZGZdKGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzItdjIucGRmKS5cbiAqXG4gKiBCZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHktY29tcHV0YWJsZSBHTFYgZW5kb21vcnBoaXNtIM+ILFxuICogY2hlY2sgb3V0IHtAbGluayBFbmRvbW9ycGhpc21PcHRzfS4gU2VlbXMgdG8gYmUgcmlnaWQgKG5vdCBiYWNrZG9vcmVkKS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgc2hhMl9qc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMi5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlscy5qc1wiKTtcbmNvbnN0IF9zaG9ydHdfdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL19zaG9ydHdfdXRpbHMuanNcIik7XG5jb25zdCBoYXNoX3RvX2N1cnZlX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCIpO1xuY29uc3QgbW9kdWxhcl90c18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IHdlaWVyc3RyYXNzX3RzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFNlZW1zIGxpa2UgZ2VuZXJhdG9yIHdhcyBwcm9kdWNlZCBmcm9tIHNvbWUgc2VlZDpcbi8vIGBQb2ludC5CQVNFLm11bHRpcGx5KFBvaW50LkZuLmludigybiwgTikpLnRvQWZmaW5lKCkueGBcbi8vIC8vIGdpdmVzIHNob3J0IHggMHgzYjc4Y2U1NjNmODlhMGVkOTQxNGY1YWEyOGFkMGQ5NmQ2Nzk1ZjljNjNuXG5jb25zdCBzZWNwMjU2azFfQ1VSVkUgPSB7XG4gICAgcDogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKSxcbiAgICBuOiBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEd4OiBCaWdJbnQoJzB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OCcpLFxuICAgIEd5OiBCaWdJbnQoJzB4NDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcpLFxufTtcbmNvbnN0IHNlY3AyNTZrMV9FTkRPID0ge1xuICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgYmFzaXNlczogW1xuICAgICAgICBbQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1JyksIC1CaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKV0sXG4gICAgICAgIFtCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyksIEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpXSxcbiAgICBdLFxufTtcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKTtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMV9DVVJWRS5wO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKCgwLCBtb2R1bGFyX3RzXzEucG93MikoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKShiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9ICgoMCwgbW9kdWxhcl90c18xLnBvdzIpKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAoKDAsIG1vZHVsYXJfdHNfMS5wb3cyKSh0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9ICgwLCBtb2R1bGFyX3RzXzEucG93MikodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSAoMCwgbW9kdWxhcl90c18xLkZpZWxkKShzZWNwMjU2azFfQ1VSVkUucCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKlxuICogRmllbGQ6IGAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxbmBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNlY3AyNTZrMS5rZXlnZW4oKTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSgnaGVsbG8nKTtcbiAqIGNvbnN0IHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzZWNwMjU2azEudmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXkpID09PSB0cnVlO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gKDAsIF9zaG9ydHdfdXRpbHNfdHNfMS5jcmVhdGVDdXJ2ZSkoeyAuLi5zZWNwMjU2azFfQ1VSVkUsIEZwOiBGcGsxLCBsb3dTOiB0cnVlLCBlbmRvOiBzZWNwMjU2azFfRU5ETyB9LCBzaGEyX2pzXzEuc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSAoMCwgc2hhMl9qc18xLnNoYTI1NikoKDAsIHV0aWxzX3RzXzEudXRmOFRvQnl0ZXMpKHRhZykpO1xuICAgICAgICB0YWdQID0gKDAsIHV0aWxzX3RzXzEuY29uY2F0Qnl0ZXMpKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBzaGEyX2pzXzEuc2hhMjU2KSgoMCwgdXRpbHNfdHNfMS5jb25jYXRCeXRlcykodGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgUG9pbnRrMSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZXhwb3J0cy5zZWNwMjU2azEuUG9pbnQpKCk7XG5jb25zdCBoYXNFdmVuID0gKHkpID0+IHkgJSBfMm4gPT09IF8wbjtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgY29uc3QgeyBGbiwgQkFTRSB9ID0gUG9pbnRrMTtcbiAgICBjb25zdCBkXyA9ICgwLCB3ZWllcnN0cmFzc190c18xLl9ub3JtRm5FbGVtZW50KShGbiwgcHJpdik7XG4gICAgY29uc3QgcCA9IEJBU0UubXVsdGlwbHkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gaGFzRXZlbihwLnkpID8gZF8gOiBGbi5uZWcoZF8pO1xuICAgIHJldHVybiB7IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgIGNvbnN0IEZwID0gRnBrMTtcbiAgICBpZiAoIUZwLmlzVmFsaWROb3QwKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgeDogRmFpbCBpZiB4IOKJpSBwJyk7XG4gICAgY29uc3QgeHggPSBGcC5jcmVhdGUoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBGcC5jcmVhdGUoeHggKiB4ICsgQmlnSW50KDcpKTsgLy8gTGV0IGMgPSB4wrMgKyA3IG1vZCBwLlxuICAgIGxldCB5ID0gRnAuc3FydChjKTsgLy8gTGV0IHkgPSBjXihwKzEpLzQgbW9kIHAuIFNhbWUgYXMgc3FydCgpLlxuICAgIC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIC8vIHkoUCkgPSB5IGlmIHkgbW9kIDIgPSAwIG9yIHkoUCkgPSBwLXkgb3RoZXJ3aXNlLlxuICAgIGlmICghaGFzRXZlbih5KSlcbiAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICBjb25zdCBwID0gUG9pbnRrMS5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG5jb25zdCBudW0gPSB1dGlsc190c18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBQb2ludGsxLkZuLmNyZWF0ZShudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHNlY3JldEtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgYXV4UmFuZCA9ICgwLCB1dGlsc19qc18xLnJhbmRvbUJ5dGVzKSgzMikpIHtcbiAgICBjb25zdCB7IEZuIH0gPSBQb2ludGsxO1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfdHNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHNlY3JldEtleSk7IC8vIGNoZWNrcyBmb3IgaXNXaXRoaW5DdXJ2ZU9yZGVyXG4gICAgY29uc3QgYSA9ICgwLCB1dGlsc190c18xLmVuc3VyZUJ5dGVzKSgnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBGbi50b0J5dGVzKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG4uIEZhaWwgaWYgaycgPSAwLiBMZXQgUiA9IGsn4ouFR1xuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocmFuZCk7XG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQoRm4udG9CeXRlcyhGbi5jcmVhdGUoayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHsgRm4sIEJBU0UgfSA9IFBvaW50azE7XG4gICAgY29uc3Qgc2lnID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgcHViID0gKDAsIHV0aWxzX3RzXzEuZW5zdXJlQnl0ZXMpKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfdHNfMS5pblJhbmdlKShyLCBfMW4sIHNlY3AyNTZrMV9DVVJWRS5wKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcyA9IG51bShzaWcuc3ViYXJyYXkoMzIsIDY0KSk7IC8vIExldCBzID0gaW50KHNpZ1szMjo2NF0pOyBmYWlsIGlmIHMg4omlIG4uXG4gICAgICAgIGlmICghKDAsIHV0aWxzX3RzXzEuaW5SYW5nZSkocywgXzFuLCBzZWNwMjU2azFfQ1VSVkUubikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKEZuLnRvQnl0ZXMociksIHBvaW50VG9CeXRlcyhQKSwgbSk7XG4gICAgICAgIC8vIFIgPSBz4ouFRyAtIGXii4VQLCB3aGVyZSAtZVAgPT0gKG4tZSlQXG4gICAgICAgIGNvbnN0IFIgPSBCQVNFLm11bHRpcGx5VW5zYWZlKHMpLmFkZChQLm11bHRpcGx5VW5zYWZlKEZuLm5lZyhlKSkpO1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IFIudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICAgICAgaWYgKFIuaXMwKCkgfHwgIWhhc0V2ZW4oeSkgfHwgeCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBTY2hub3JyIHNpZ25hdHVyZXMgb3ZlciBzZWNwMjU2azEuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzY2hub3JyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICogY29uc3QgeyBzZWNyZXRLZXksIHB1YmxpY0tleSB9ID0gc2Nobm9yci5rZXlnZW4oKTtcbiAqIC8vIGNvbnN0IHB1YmxpY0tleSA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzY2hub3JyLnNpZ24obXNnLCBzZWNyZXRLZXkpO1xuICogY29uc3QgaXNWYWxpZCA9IHNjaG5vcnIudmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXkpO1xuICogYGBgXG4gKi9cbmV4cG9ydHMuc2Nobm9yciA9ICgoKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IDMyO1xuICAgIGNvbnN0IHNlZWRMZW5ndGggPSA0ODtcbiAgICBjb25zdCByYW5kb21TZWNyZXRLZXkgPSAoc2VlZCA9ICgwLCB1dGlsc19qc18xLnJhbmRvbUJ5dGVzKShzZWVkTGVuZ3RoKSkgPT4ge1xuICAgICAgICByZXR1cm4gKDAsIG1vZHVsYXJfdHNfMS5tYXBIYXNoVG9GaWVsZCkoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICAgIH07XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgZXhwb3J0cy5zZWNwMjU2azEudXRpbHMucmFuZG9tU2VjcmV0S2V5O1xuICAgIGZ1bmN0aW9uIGtleWdlbihzZWVkKSB7XG4gICAgICAgIGNvbnN0IHNlY3JldEtleSA9IHJhbmRvbVNlY3JldEtleShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHsgc2VjcmV0S2V5LCBwdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlnZW4sXG4gICAgICAgIGdldFB1YmxpY0tleTogc2Nobm9yckdldFB1YmxpY0tleSxcbiAgICAgICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICAgICAgUG9pbnQ6IFBvaW50azEsXG4gICAgICAgIHV0aWxzOiB7XG4gICAgICAgICAgICByYW5kb21TZWNyZXRLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgICAgIGxpZnRfeCxcbiAgICAgICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgICAgIG51bWJlclRvQnl0ZXNCRTogdXRpbHNfdHNfMS5udW1iZXJUb0J5dGVzQkUsXG4gICAgICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX3RzXzEuYnl0ZXNUb051bWJlckJFLFxuICAgICAgICAgICAgbW9kOiBtb2R1bGFyX3RzXzEubW9kLFxuICAgICAgICB9LFxuICAgICAgICBsZW5ndGhzOiB7XG4gICAgICAgICAgICBzZWNyZXRLZXk6IHNpemUsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHNpemUsXG4gICAgICAgICAgICBwdWJsaWNLZXlIYXNQcmVmaXg6IGZhbHNlLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBzaXplICogMixcbiAgICAgICAgICAgIHNlZWQ6IHNlZWRMZW5ndGgsXG4gICAgICAgIH0sXG4gICAgfTtcbn0pKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX3RzXzEuaXNvZ2VueU1hcCkoRnBrMSwgW1xuICAgIC8vIHhOdW1cbiAgICBbXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4YzcnLFxuICAgICAgICAnMHg3ZDNkNGM4MGJjMzIxZDViOWYzMTVjZWE3ZmQ0NGM1ZDU5NWQyZmMwYmY2M2I5MmRmZmYxMDQ0ZjE3YzY1ODEnLFxuICAgICAgICAnMHg1MzRjMzI4ZDIzZjIzNGU2ZTJhNDEzZGVjYTI1Y2FlY2U0NTA2MTQ0MDM3YzQwMzE0ZWNiZDBiNTNkOWRkMjYyJyxcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYTg4YycsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHhkMzU3NzExOTNkOTQ5MThhOWNhMzRjY2JiN2I2NDBkZDg2Y2Q0MDk1NDJmODQ4N2Q5ZmU2Yjc0NTc4MWViNDliJyxcbiAgICAgICAgJzB4ZWRhZGM2ZjY0MzgzZGMxZGY3YzRiMmQ1MWI1NDIyNTQwNmQzNmI2NDFmNWU0MWJiYzUyYTU2NjEyYThjNmQxNCcsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuICAgIC8vIHlOdW1cbiAgICBbXG4gICAgICAgICcweDRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiOGUzOGUyM2MnLFxuICAgICAgICAnMHhjNzVlMGMzMmQ1Y2I3YzBmYTlkMGE1NGIxMmEwYTZkNTY0N2FiMDQ2ZDY4NmRhNmZkZmZjOTBmYzIwMWQ3MWEzJyxcbiAgICAgICAgJzB4MjlhNjE5NDY5MWY5MWE3MzcxNTIwOWVmNjUxMmU1NzY3MjI4MzBhMjAxYmUyMDE4YTc2NWU4NWE5ZWNlZTkzMScsXG4gICAgICAgICcweDJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmMzhlMzhkODQnLFxuICAgIF0sXG4gICAgLy8geURlblxuICAgIFtcbiAgICAgICAgJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZjkzYicsXG4gICAgICAgICcweDdhMDY1MzRiYjhiZGI0OWZkNWU5ZTY2MzI3MjJjMjk4OTQ2N2MxYmZjOGU4ZDk3OGRmYjQyNWQyNjg1YzI1NzMnLFxuICAgICAgICAnMHg2NDg0YWE3MTY1NDVjYTJjZjNhNzBjM2ZhOGZlMzM3ZTBhM2QyMTE2MmYwZDYyOTlhN2JmODE5MmJmZDJhNzZmJyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG5dLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IEJpZ0ludChqKSkpKSkoKTtcbmNvbnN0IG1hcFNXVSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKDAsIHdlaWVyc3RyYXNzX3RzXzEubWFwVG9DdXJ2ZVNpbXBsZVNXVSkoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0cy5zZWNwMjU2azFfaGFzaGVyID0gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX3RzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcGsxLmNyZWF0ZShzY2FsYXJzWzBdKSk7XG4gICAgcmV0dXJuIGlzb01hcCh4LCB5KTtcbn0sIHtcbiAgICBEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9ST18nLFxuICAgIGVuY29kZURTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX05VXycsXG4gICAgcDogRnBrMS5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTJfanNfMS5zaGEyNTYsXG59KSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHNlY3AyNTZrMV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyc7YCAqL1xuZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9ICgoKSA9PiBleHBvcnRzLnNlY3AyNTZrMV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBzZWNwMjU2azFfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMnO2AgKi9cbmV4cG9ydHMuZW5jb2RlVG9DdXJ2ZSA9ICgoKSA9PiBleHBvcnRzLnNlY3AyNTZrMV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm90SW1wbGVtZW50ZWQgPSBleHBvcnRzLmJpdE1hc2sgPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMuaXNCeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9VdGY4ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hbnVtYmVyID0gZXhwb3J0cy5hYnl0ZXMgPSB2b2lkIDA7XG5leHBvcnRzLmFib29sID0gYWJvb2w7XG5leHBvcnRzLl9hYm9vbDIgPSBfYWJvb2wyO1xuZXhwb3J0cy5fYWJ5dGVzMiA9IF9hYnl0ZXMyO1xuZXhwb3J0cy5udW1iZXJUb0hleFVucGFkZGVkID0gbnVtYmVyVG9IZXhVbnBhZGRlZDtcbmV4cG9ydHMuaGV4VG9OdW1iZXIgPSBoZXhUb051bWJlcjtcbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0xFID0gbnVtYmVyVG9CeXRlc0xFO1xuZXhwb3J0cy5udW1iZXJUb1ZhckJ5dGVzQkUgPSBudW1iZXJUb1ZhckJ5dGVzQkU7XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuZXhwb3J0cy5jb3B5Qnl0ZXMgPSBjb3B5Qnl0ZXM7XG5leHBvcnRzLmFzY2lpVG9CeXRlcyA9IGFzY2lpVG9CeXRlcztcbmV4cG9ydHMuaW5SYW5nZSA9IGluUmFuZ2U7XG5leHBvcnRzLmFJblJhbmdlID0gYUluUmFuZ2U7XG5leHBvcnRzLmJpdExlbiA9IGJpdExlbjtcbmV4cG9ydHMuYml0R2V0ID0gYml0R2V0O1xuZXhwb3J0cy5iaXRTZXQgPSBiaXRTZXQ7XG5leHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gY3JlYXRlSG1hY0RyYmc7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG5leHBvcnRzLmlzSGFzaCA9IGlzSGFzaDtcbmV4cG9ydHMuX3ZhbGlkYXRlT2JqZWN0ID0gX3ZhbGlkYXRlT2JqZWN0O1xuZXhwb3J0cy5tZW1vaXplZCA9IG1lbW9pemVkO1xuLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIik7XG52YXIgdXRpbHNfanNfMiA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmFieXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFudW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuYW51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9VdGY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmJ5dGVzVG9VdGY4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmhleFRvQnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmlzQnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfanNfMi5yYW5kb21CeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5mdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyB0bXAgbmFtZSB1bnRpbCB2MlxuZnVuY3Rpb24gX2Fib29sMih2YWx1ZSwgdGl0bGUgPSAnJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBib29sZWFuLCBnb3QgdHlwZT0nICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gdG1wIG5hbWUgdW50aWwgdjJcbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZnVuY3Rpb24gX2FieXRlczIodmFsdWUsIGxlbmd0aCwgdGl0bGUgPSAnJykge1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzX2pzXzEuaXNCeXRlcykodmFsdWUpO1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlPy5sZW5ndGg7XG4gICAgY29uc3QgbmVlZHNMZW4gPSBsZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoIWJ5dGVzIHx8IChuZWVkc0xlbiAmJiBsZW4gIT09IGxlbmd0aCkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGl0bGUgJiYgYFwiJHt0aXRsZX1cIiBgO1xuICAgICAgICBjb25zdCBvZkxlbiA9IG5lZWRzTGVuID8gYCBvZiBsZW5ndGggJHtsZW5ndGh9YCA6ICcnO1xuICAgICAgICBjb25zdCBnb3QgPSBieXRlcyA/IGBsZW5ndGg9JHtsZW59YCA6IGB0eXBlPSR7dHlwZW9mIHZhbHVlfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXggKyAnZXhwZWN0ZWQgVWludDhBcnJheScgKyBvZkxlbiArICcsIGdvdCAnICsgZ290KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gVXNlZCBpbiB3ZWllcnN0cmFzcywgZGVyXG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKCgwLCB1dGlsc19qc18xLmJ5dGVzVG9IZXgpKGJ5dGVzKSk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIHtcbiAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb0hleCkoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuaGV4VG9CeXRlcykobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZnVuY3Rpb24gbnVtYmVyVG9WYXJCeXRlc0JFKG4pIHtcbiAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuaGV4VG9CeXRlcykobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3NlY3JldCBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSAoMCwgdXRpbHNfanNfMS5oZXhUb0J5dGVzKShoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc19qc18xLmlzQnl0ZXMpKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQ29waWVzIFVpbnQ4QXJyYXkuIFdlIGNhbid0IHVzZSB1OGEuc2xpY2UoKSwgYmVjYXVzZSB1OGEgY2FuIGJlIEJ1ZmZlcixcbiAqIGFuZCBCdWZmZXIjc2xpY2UgY3JlYXRlcyBtdXRhYmxlIGNvcHkuIE5ldmVyIHVzZSBCdWZmZXJzIVxuICovXG5mdW5jdGlvbiBjb3B5Qnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ5dGVzKTtcbn1cbi8qKlxuICogRGVjb2RlcyA3LWJpdCBBU0NJSSBzdHJpbmcgdG8gVWludDhBcnJheSwgdGhyb3dzIG9uIG5vbi1hc2NpaSBzeW1ib2xzXG4gKiBTaG91bGQgYmUgc2FmZSB0byB1c2UgZm9yIHRoaW5ncyBleHBlY3RlZCB0byBiZSBBU0NJSS5cbiAqIFJldHVybnMgZXhhY3Qgc2FtZSByZXN1bHQgYXMgdXRmOFRvQnl0ZXMgZm9yIEFTQ0lJIG9yIHRocm93cy5cbiAqL1xuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGFzY2lpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhc2NpaSwgKGMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gMSB8fCBjaGFyQ29kZSA+IDEyNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlciBcIiR7YXNjaWlbaV19XCIgd2l0aCBjb2RlICR7Y2hhckNvZGV9IGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgfSk7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbi8vIGV4cG9ydCBjb25zdCB1dGY4VG9CeXRlczogdHlwZW9mIHV0ZjhUb0J5dGVzXyA9IHV0ZjhUb0J5dGVzXztcbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGJ5dGVzVG9VdGY4OiB0eXBlb2YgYnl0ZXNUb1V0ZjhfID0gYnl0ZXNUb1V0ZjhfO1xuLy8gSXMgcG9zaXRpdmUgYmlnaW50XG5jb25zdCBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5mdW5jdGlvbiBpblJhbmdlKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIGlzUG9zQmlnKG4pICYmIGlzUG9zQmlnKG1pbikgJiYgaXNQb3NCaWcobWF4KSAmJiBtaW4gPD0gbiAmJiBuIDwgbWF4O1xufVxuLyoqXG4gKiBBc3NlcnRzIG1pbiA8PSBuIDwgbWF4LiBOT1RFOiBJdCdzIDwgbWF4IGFuZCBub3QgPD0gbWF4LlxuICogQGV4YW1wbGVcbiAqIGFJblJhbmdlKCd4JywgeCwgMW4sIDI1Nm4pOyAvLyB3b3VsZCBhc3N1bWUgeCBpcyBpbiAoMW4uLjI1NW4pXG4gKi9cbmZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5mdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5jb25zdCBiaXRNYXNrID0gKG4pID0+IChfMW4gPDwgQmlnSW50KG4pKSAtIF8xbjtcbmV4cG9ydHMuYml0TWFzayA9IGJpdE1hc2s7XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gICAgY29uc3QgdThvZiA9IChieXRlKSA9PiBVaW50OEFycmF5Lm9mKGJ5dGUpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThvZigweDAwKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8ICgwLCB1dGlsc19qc18xLmlzQnl0ZXMpKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdmFsaWRhdG9yIGZ1bmN0aW9uJyk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGFyYW0gJyArIFN0cmluZyhmaWVsZE5hbWUpICsgJyBpcyBpbnZhbGlkLiBFeHBlY3RlZCAnICsgdHlwZSArICcsIGdvdCAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyh2YWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIGZhbHNlKTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKG9wdFZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbi8vIHZhbGlkYXRlIHR5cGUgdGVzdHNcbi8vIGNvbnN0IG86IHsgYTogbnVtYmVyOyBiOiBudW1iZXI7IGM6IG51bWJlciB9ID0geyBhOiAxLCBiOiA1LCBjOiA2IH07XG4vLyBjb25zdCB6MCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ2JpZ2ludCcgfSk7IC8vIE9rIVxuLy8gLy8gU2hvdWxkIGZhaWwgdHlwZS1jaGVja1xuLy8gY29uc3QgejEgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICd0bXAnIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHoyID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejMgPSB2YWxpZGF0ZU9iamVjdChvLCB7IHRlc3Q6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyBjb25zdCB6NCA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbmZ1bmN0aW9uIGlzSGFzaCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKTtcbn1cbmZ1bmN0aW9uIF92YWxpZGF0ZU9iamVjdChvYmplY3QsIGZpZWxkcywgb3B0RmllbGRzID0ge30pIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBvcHRpb25zIG9iamVjdCcpO1xuICAgIGZ1bmN0aW9uIGNoZWNrRmllbGQoZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIGlzT3B0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHQgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gZXhwZWN0ZWRUeXBlIHx8IHZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke2ZpZWxkTmFtZX1cIiBpcyBpbnZhbGlkOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke2N1cnJlbnR9YCk7XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIGZhbHNlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0RmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgdHJ1ZSkpO1xufVxuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmNvbnN0IG5vdEltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZXhwb3J0cy5ub3RJbXBsZW1lbnRlZCA9IG5vdEltcGxlbWVudGVkO1xuLyoqXG4gKiBNZW1vaXplcyAoY2FjaGVzKSBjb21wdXRhdGlvbiByZXN1bHQuXG4gKiBVc2VzIFdlYWtNYXA6IHRoZSB2YWx1ZSBpcyBnb2luZyBhdXRvLWNsZWFuZWQgYnkgR0MgYWZ0ZXIgbGFzdCByZWZlcmVuY2UgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBleHBvcnRzLlNIQTM4NF9JViA9IGV4cG9ydHMuU0hBMjI0X0lWID0gZXhwb3J0cy5TSEEyNTZfSVYgPSBleHBvcnRzLkhhc2hNRCA9IHZvaWQgMDtcbmV4cG9ydHMuc2V0QmlnVWludDY0ID0gc2V0QmlnVWludDY0O1xuZXhwb3J0cy5DaGkgPSBDaGk7XG5leHBvcnRzLk1haiA9IE1hajtcbi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqIFBvbHlmaWxsIGZvciBTYWZhcmkgMTQuIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfZGF0YXZpZXdfc2V0YmlndWludDY0ICovXG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5mdW5jdGlvbiBDaGkoYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKH5hICYgYyk7XG59XG4vKiogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZS4gKi9cbmZ1bmN0aW9uIE1haihhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbn1cbi8qKlxuICogTWVya2xlLURhbWdhcmQgaGFzaCBjb25zdHJ1Y3Rpb24gYmFzZSBjbGFzcy5cbiAqIENvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIE1ENSwgUklQRU1ELCBTSEExLCBTSEEyLlxuICovXG5jbGFzcyBIYXNoTUQgZXh0ZW5kcyB1dGlsc190c18xLkhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykoZGF0YSk7XG4gICAgICAgICAgICAgICAgZm9yICg7IGJsb2NrTGVuIDw9IGxlbiAtIHBvczsgcG9zICs9IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoZGF0YVZpZXcsIHBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXIuc2V0KGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyB0YWtlKSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGggKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMucm91bmRDbGVhbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFvdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykpO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KShvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaE1EID0gSGFzaE1EO1xuLyoqXG4gKiBJbml0aWFsIFNIQS0yIHN0YXRlOiBmcmFjdGlvbmFsIHBhcnRzIG9mIHNxdWFyZSByb290cyBvZiBmaXJzdCAxNiBwcmltZXMgMi4uNTMuXG4gKiBDaGVjayBvdXQgYHRlc3QvbWlzYy9zaGEyLWdlbi1pdi5qc2AgZm9yIHJlY29tcHV0YXRpb24gZ3VpZGUuXG4gKi9cbi8qKiBJbml0aWFsIFNIQTI1NiBzdGF0ZS4gQml0cyAwLi4zMiBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBMjU2X0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOSxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMjI0IHN0YXRlLiBCaXRzIDMyLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTIyNF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksIDB4ZmZjMDBiMzEsIDB4Njg1ODE1MTEsIDB4NjRmOThmYTcsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTM4NCBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMjMuLjUzICovXG5leHBvcnRzLlNIQTM4NF9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgsIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsIDB4OTE1OTAxNWEsIDB4MzA3MGRkMTcsIDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzksXG4gICAgMHg2NzMzMjY2NywgMHhmZmMwMGIzMSwgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSwgMHhkYjBjMmUwZCwgMHg2NGY5OGZhNywgMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBNTEyIHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0cy5TSEE1MTJfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LCAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLCAweDNjNmVmMzcyLCAweGZlOTRmODJiLCAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuICAgIDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEsIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsIDB4MWY4M2Q5YWIsIDB4ZmI0MWJkNmIsIDB4NWJlMGNkMTksIDB4MTM3ZTIxNzksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudG9CaWcgPSBleHBvcnRzLnNoclNMID0gZXhwb3J0cy5zaHJTSCA9IGV4cG9ydHMucm90clNMID0gZXhwb3J0cy5yb3RyU0ggPSBleHBvcnRzLnJvdHJCTCA9IGV4cG9ydHMucm90ckJIID0gZXhwb3J0cy5yb3RyMzJMID0gZXhwb3J0cy5yb3RyMzJIID0gZXhwb3J0cy5yb3RsU0wgPSBleHBvcnRzLnJvdGxTSCA9IGV4cG9ydHMucm90bEJMID0gZXhwb3J0cy5yb3RsQkggPSBleHBvcnRzLmFkZDVMID0gZXhwb3J0cy5hZGQ1SCA9IGV4cG9ydHMuYWRkNEwgPSBleHBvcnRzLmFkZDRIID0gZXhwb3J0cy5hZGQzTCA9IGV4cG9ydHMuYWRkM0ggPSB2b2lkIDA7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5leHBvcnRzLnNwbGl0ID0gc3BsaXQ7XG4vKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGxzdC5sZW5ndGg7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDNMID0gYWRkM0w7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkM0ggPSBhZGQzSDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuZXhwb3J0cy5hZGQ0TCA9IGFkZDRMO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDRIID0gYWRkNEg7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuZXhwb3J0cy5hZGQ1TCA9IGFkZDVMO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDVIID0gYWRkNUg7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuLyoqXG4gKiBJbnRlcm5hbCB3ZWJjcnlwdG8gYWxpYXMuXG4gKiBXZSBwcmVmZXIgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIG5vZGUuanMgMTYrLlxuICogRmFsbHMgYmFjayB0byBOb2RlLmpzIGJ1aWx0LWluIGNyeXB0byBmb3IgTm9kZS5qcyA8PXYxNC5cbiAqIFNlZSB1dGlscy50cyBmb3IgZGV0YWlscy5cbiAqIEBtb2R1bGVcbiAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgbmMgPSByZXF1aXJlKFwibm9kZTpjcnlwdG9cIik7XG5leHBvcnRzLmNyeXB0byA9IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3dlYmNyeXB0bycgaW4gbmNcbiAgICA/IG5jLndlYmNyeXB0b1xuICAgIDogbmMgJiYgdHlwZW9mIG5jID09PSAnb2JqZWN0JyAmJiAncmFuZG9tQnl0ZXMnIGluIG5jXG4gICAgICAgID8gbmNcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG9Ob2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oa2RmID0gdm9pZCAwO1xuZXhwb3J0cy5leHRyYWN0ID0gZXh0cmFjdDtcbmV4cG9ydHMuZXhwYW5kID0gZXhwYW5kO1xuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBTZWUgaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi8uXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IGhtYWNfdHNfMSA9IHJlcXVpcmUoXCIuL2htYWMuanNcIik7XG5jb25zdCB1dGlsc190c18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKipcbiAqIEhLREYtZXh0cmFjdCBmcm9tIHNwZWMuIExlc3MgaW1wb3J0YW50IHBhcnQuIGBIS0RGLUV4dHJhY3QoSUtNLCBzYWx0KSAtPiBQUktgXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoIC0gaGFzaCBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgKGUuZy4gc2hhMjU2KVxuICogQHBhcmFtIGlrbSAtIGlucHV0IGtleWluZyBtYXRlcmlhbCwgdGhlIGluaXRpYWwga2V5XG4gKiBAcGFyYW0gc2FsdCAtIG9wdGlvbmFsIHNhbHQgdmFsdWUgKGEgbm9uLXNlY3JldCByYW5kb20gdmFsdWUpXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSB7XG4gICAgKDAsIHV0aWxzX3RzXzEuYWhhc2gpKGhhc2gpO1xuICAgIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gICAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTtcbiAgICByZXR1cm4gKDAsIGhtYWNfdHNfMS5obWFjKShoYXNoLCAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShzYWx0KSwgKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoaWttKSk7XG59XG5jb25zdCBIS0RGX0NPVU5URVIgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKFswXSk7XG5jb25zdCBFTVBUWV9CVUZGRVIgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5vZigpO1xuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLiBUaGUgbW9zdCBpbXBvcnRhbnQgcGFydC4gYEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNYFxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gcHJrIC0gYSBwc2V1ZG9yYW5kb20ga2V5IG9mIGF0IGxlYXN0IEhhc2hMZW4gb2N0ZXRzICh1c3VhbGx5LCB0aGUgb3V0cHV0IGZyb20gdGhlIGV4dHJhY3Qgc3RlcClcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuICovXG5mdW5jdGlvbiBleHBhbmQoaGFzaCwgcHJrLCBpbmZvLCBsZW5ndGggPSAzMikge1xuICAgICgwLCB1dGlsc190c18xLmFoYXNoKShoYXNoKTtcbiAgICAoMCwgdXRpbHNfdHNfMS5hbnVtYmVyKShsZW5ndGgpO1xuICAgIGNvbnN0IG9sZW4gPSBoYXNoLm91dHB1dExlbjtcbiAgICBpZiAobGVuZ3RoID4gMjU1ICogb2xlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZW5ndGggc2hvdWxkIGJlIDw9IDI1NSpIYXNoTGVuJyk7XG4gICAgY29uc3QgYmxvY2tzID0gTWF0aC5jZWlsKGxlbmd0aCAvIG9sZW4pO1xuICAgIGlmIChpbmZvID09PSB1bmRlZmluZWQpXG4gICAgICAgIGluZm8gPSBFTVBUWV9CVUZGRVI7XG4gICAgLy8gZmlyc3QgTChlbmd0aCkgb2N0ZXRzIG9mIFRcbiAgICBjb25zdCBva20gPSBuZXcgVWludDhBcnJheShibG9ja3MgKiBvbGVuKTtcbiAgICAvLyBSZS11c2UgSE1BQyBpbnN0YW5jZSBiZXR3ZWVuIGJsb2Nrc1xuICAgIGNvbnN0IEhNQUMgPSBobWFjX3RzXzEuaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgb2xlbiAqIGNvdW50ZXIpO1xuICAgICAgICBITUFDLl9jbG9uZUludG8oSE1BQ1RtcCk7XG4gICAgfVxuICAgIEhNQUMuZGVzdHJveSgpO1xuICAgIEhNQUNUbXAuZGVzdHJveSgpO1xuICAgICgwLCB1dGlsc190c18xLmNsZWFuKShULCBIS0RGX0NPVU5URVIpO1xuICAgIHJldHVybiBva20uc2xpY2UoMCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogSEtERiAoUkZDIDU4NjkpOiBkZXJpdmUga2V5cyBmcm9tIGFuIGluaXRpYWwgaW5wdXQuXG4gKiBDb21iaW5lcyBoa2RmX2V4dHJhY3QgKyBoa2RmX2V4cGFuZCBpbiBvbmUgc3RlcFxuICogQHBhcmFtIGhhc2ggLSBoYXNoIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCAoZS5nLiBzaGEyNTYpXG4gKiBAcGFyYW0gaWttIC0gaW5wdXQga2V5aW5nIG1hdGVyaWFsLCB0aGUgaW5pdGlhbCBrZXlcbiAqIEBwYXJhbSBzYWx0IC0gb3B0aW9uYWwgc2FsdCB2YWx1ZSAoYSBub24tc2VjcmV0IHJhbmRvbSB2YWx1ZSlcbiAqIEBwYXJhbSBpbmZvIC0gb3B0aW9uYWwgY29udGV4dCBhbmQgYXBwbGljYXRpb24gc3BlY2lmaWMgaW5mb3JtYXRpb24gKGNhbiBiZSBhIHplcm8tbGVuZ3RoIHN0cmluZylcbiAqIEBwYXJhbSBsZW5ndGggLSBsZW5ndGggb2Ygb3V0cHV0IGtleWluZyBtYXRlcmlhbCBpbiBieXRlc1xuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhrZGYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2hrZGYnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG4gKiBjb25zdCBpbnB1dEtleSA9IHJhbmRvbUJ5dGVzKDMyKTtcbiAqIGNvbnN0IHNhbHQgPSByYW5kb21CeXRlcygzMik7XG4gKiBjb25zdCBpbmZvID0gJ2FwcGxpY2F0aW9uLWtleSc7XG4gKiBjb25zdCBoazEgPSBoa2RmKHNoYTI1NiwgaW5wdXRLZXksIHNhbHQsIGluZm8sIDMyKTtcbiAqL1xuY29uc3QgaGtkZiA9IChoYXNoLCBpa20sIHNhbHQsIGluZm8sIGxlbmd0aCkgPT4gZXhwYW5kKGhhc2gsIGV4dHJhY3QoaGFzaCwgaWttLCBzYWx0KSwgaW5mbywgbGVuZ3RoKTtcbmV4cG9ydHMuaGtkZiA9IGhrZGY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oa2RmLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gZXhwb3J0cy5ITUFDID0gdm9pZCAwO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX3RzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFoYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHBhZCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhNTEyXzIyNCA9IGV4cG9ydHMuc2hhNTEyXzI1NiA9IGV4cG9ydHMuc2hhMzg0ID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLnNoYTIyNCA9IGV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5TSEE1MTJfMjU2ID0gZXhwb3J0cy5TSEE1MTJfMjI0ID0gZXhwb3J0cy5TSEEzODQgPSBleHBvcnRzLlNIQTUxMiA9IGV4cG9ydHMuU0hBMjI0ID0gZXhwb3J0cy5TSEEyNTYgPSB2b2lkIDA7XG4vKipcbiAqIFNIQTIgaGFzaCBmdW5jdGlvbi4gQS5rLmEuIHNoYTI1Niwgc2hhMzg0LCBzaGE1MTIsIHNoYTUxMl8yMjQsIHNoYTUxMl8yNTYuXG4gKiBTSEEyNTYgaXMgdGhlIGZhc3Rlc3QgaGFzaCBpbXBsZW1lbnRhYmxlIGluIEpTLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIENoZWNrIG91dCBbUkZDIDQ2MzRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNDYzNCkgYW5kXG4gKiBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IF9tZF90c18xID0gcmVxdWlyZShcIi4vX21kLmpzXCIpO1xuY29uc3QgdTY0ID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKlxuICogUm91bmQgY29uc3RhbnRzOlxuICogRmlyc3QgMzIgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gMzIpIHtcbiAgICAgICAgc3VwZXIoNjQsIG91dHB1dExlbiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gX21kX3RzXzEuU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gX21kX3RzXzEuU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gX21kX3RzXzEuU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gX21kX3RzXzEuU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gX21kX3RzXzEuU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gX21kX3RzXzEuU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gX21kX3RzXzEuU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gX21kX3RzXzEuU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9ICgwLCB1dGlsc190c18xLnJvdHIpKFcxNSwgNykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMiwgMTcpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9ICgwLCB1dGlsc190c18xLnJvdHIpKEUsIDYpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgMTEpIF4gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArICgwLCBfbWRfdHNfMS5DaGkpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gKDAsIHV0aWxzX3RzXzEucm90cikoQSwgMikgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAxMykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyAoMCwgX21kX3RzXzEuTWFqKShBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShTSEEyNTZfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMjU2ID0gU0hBMjU2O1xuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkEgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBfbWRfdHNfMS5TSEEyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBfbWRfdHNfMS5TSEEyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBfbWRfdHNfMS5TSEEyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBfbWRfdHNfMS5TSEEyMjRfSVZbN10gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMjI0ID0gU0hBMjI0O1xuLy8gU0hBMi01MTIgaXMgc2xvd2VyIHRoYW4gc2hhMjU2IGluIGpzIGJlY2F1c2UgdTY0IG9wZXJhdGlvbnMgYXJlIHNsb3cuXG4vLyBSb3VuZCBjb250YW50c1xuLy8gRmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBLNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuY29uc3QgU0hBNTEyX0toID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzBdKSgpO1xuY29uc3QgU0hBNTEyX0tsID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzFdKSgpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlcnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIFNIQTUxMiBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3Iob3V0cHV0TGVuID0gNjQpIHtcbiAgICAgICAgc3VwZXIoMTI4LCBvdXRwdXRMZW4sIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gX21kX3RzXzEuU0hBNTEyX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gX21kX3RzXzEuU0hBNTEyX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IF9tZF90c18xLlNIQTUxMl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBfbWRfdHNfMS5TSEE1MTJfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gX21kX3RzXzEuU0hBNTEyX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IF9tZF90c18xLlNIQTUxMl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBfbWRfdHNfMS5TSEE1MTJfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gX21kX3RzXzEuU0hBNTEyX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gX21kX3RzXzEuU0hBNTEyX0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gX21kX3RzXzEuU0hBNTEyX0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTVdIHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTIgPSBTSEE1MTI7XG5jbGFzcyBTSEEzODQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig0OCk7XG4gICAgICAgIHRoaXMuQWggPSBfbWRfdHNfMS5TSEEzODRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gX21kX3RzXzEuU0hBMzg0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IF9tZF90c18xLlNIQTM4NF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBfbWRfdHNfMS5TSEEzODRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gX21kX3RzXzEuU0hBMzg0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IF9tZF90c18xLlNIQTM4NF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBfbWRfdHNfMS5TSEEzODRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gX21kX3RzXzEuU0hBMzg0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IF9tZF90c18xLlNIQTM4NF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBfbWRfdHNfMS5TSEEzODRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gX21kX3RzXzEuU0hBMzg0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gX21kX3RzXzEuU0hBMzg0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMzg0ID0gU0hBMzg0O1xuLyoqXG4gKiBUcnVuY2F0ZWQgU0hBNTEyLzI1NiBhbmQgU0hBNTEyLzIyNC5cbiAqIFNIQTUxMl9JViBpcyBYT1JlZCB3aXRoIDB4YTVhNWE1YTVhNWE1YTVhNSwgdGhlbiB1c2VkIGFzIFwiaW50ZXJtZWRpYXJ5XCIgSVYgb2YgU0hBNTEyL3QuXG4gKiBUaGVuIHQgaGFzaGVzIHN0cmluZyB0byBwcm9kdWNlIHJlc3VsdCBJVi5cbiAqIFNlZSBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYC5cbiAqL1xuLyoqIFNIQTUxMi8yMjQgSVYgKi9cbmNvbnN0IFQyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg4YzNkMzdjOCwgMHgxOTU0NGRhMiwgMHg3M2UxOTk2NiwgMHg4OWRjZDRkNiwgMHgxZGZhYjdhZSwgMHgzMmZmOWM4MiwgMHg2NzlkZDUxNCwgMHg1ODJmOWZjZixcbiAgICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG4vKiogU0hBNTEyLzI1NiBJViAqL1xuY29uc3QgVDI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAgIDB4OTYyODNlZTIsIDB4YTg4ZWZmZTMsIDB4YmU1ZTFlMjUsIDB4NTM4NjM5OTIsIDB4MmIwMTk5ZmMsIDB4MmM4NWI4YWEsIDB4MGViNzJkZGMsIDB4ODFjNTJjYTIsXG5dKTtcbmNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQWggPSBUMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyMjRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDIyNF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjI0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyMjRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyMjRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyMjRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yMjQgPSBTSEE1MTJfMjI0O1xuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICAgICAgdGhpcy5BaCA9IFQyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDI1Nl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjU2X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyNTZfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDI1Nl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDI1Nl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDI1Nl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDI1Nl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDI1Nl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDI1Nl9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzI1NiA9IFNIQTUxMl8yNTY7XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC5cbiAqXG4gKiBJdCBpcyB0aGUgZmFzdGVzdCBKUyBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICovXG5leHBvcnRzLnNoYTI1NiA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTI1NigpKTtcbi8qKiBTSEEyLTIyNCBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQgKi9cbmV4cG9ydHMuc2hhMjI0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLyoqIFNIQTItNTEyIGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydHMuc2hhNTEyID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyKCkpO1xuLyoqIFNIQTItMzg0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydHMuc2hhMzg0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yNTYgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0cy5zaGE1MTJfMjU2ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbi8qKlxuICogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydHMuc2hhNTEyXzIyNCA9ICgwLCB1dGlsc190c18xLmNyZWF0ZUhhc2hlcikoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGhleCwgYnl0ZXMsIENTUFJORy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLnN3YXAzMklmQkUgPSBleHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuc3dhcDhJZkJFID0gZXhwb3J0cy5pc0xFID0gdm9pZCAwO1xuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmV4cG9ydHMuYW51bWJlciA9IGFudW1iZXI7XG5leHBvcnRzLmFieXRlcyA9IGFieXRlcztcbmV4cG9ydHMuYWhhc2ggPSBhaGFzaDtcbmV4cG9ydHMuYWV4aXN0cyA9IGFleGlzdHM7XG5leHBvcnRzLmFvdXRwdXQgPSBhb3V0cHV0O1xuZXhwb3J0cy51OCA9IHU4O1xuZXhwb3J0cy51MzIgPSB1MzI7XG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbmV4cG9ydHMucm90bCA9IHJvdGw7XG5leHBvcnRzLmJ5dGVTd2FwID0gYnl0ZVN3YXA7XG5leHBvcnRzLmJ5dGVTd2FwMzIgPSBieXRlU3dhcDMyO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG5leHBvcnRzLmtkZklucHV0VG9CeXRlcyA9IGtkZklucHV0VG9CeXRlcztcbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG5leHBvcnRzLmNyZWF0ZU9wdEhhc2hlciA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydHMuY3JlYXRlWE9GZXIgPSBjcmVhdGVYT0ZlcjtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuLyoqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gQmUgY2FyZWZ1bDogbm9kZWpzIEJ1ZmZlciB3aWxsIHJldHVybiB0cnVlLiAqL1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAnICsgbGVuZ3RocyArICcsIGdvdCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBoYXNoICovXG5mdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5mdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYWJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gICAgfVxufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTguICovXG5mdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqIENyZWF0ZSBEYXRhVmlldyBvZiBhbiBhcnJheSBmb3IgZWFzeSBieXRlLWxldmVsIG1hbmlwdWxhdGlvbi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiByb3RsKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG59XG4vKiogSXMgY3VycmVudCBwbGF0Zm9ybSBsaXR0bGUtZW5kaWFuPyBNb3N0IGFyZS4gQmlnLUVuZGlhbiBwbGF0Zm9ybTogSUJNICovXG5leHBvcnRzLmlzTEUgPSAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NCkoKTtcbi8qKiBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0cy5zd2FwOElmQkUgPSBleHBvcnRzLmlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5zd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5zd2FwMzJJZkJFID0gZXhwb3J0cy5pc0xFXG4gICAgPyAodSkgPT4gdVxuICAgIDogYnl0ZVN3YXAzMjtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIEtERnM6IGNvbnN1bWVzIHVpbnQ4YXJyYXkgb3Igc3RyaW5nLlxuICogV2hlbiBzdHJpbmcgaXMgcGFzc2VkLCBkb2VzIHV0ZjggZGVjb2RpbmcsIHVzaW5nIFRleHREZWNvZGVyLlxuICovXG5mdW5jdGlvbiBrZGZJbnB1dFRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKiogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmNsYXNzIEhhc2gge1xufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZnVuY3Rpb24gY3JlYXRlWE9GZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBjcmVhdGVPcHRIYXNoZXI7XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlWE9GZXI7XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgLy8gTGVnYWN5IE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBsYXVuY2hlciB9IGZyb20gXCIuL2xhdW5jaGVyXCI7XHJcbmltcG9ydCB7IHN0b3JlIH0gZnJvbSBcIi4vc3RvcmVcIjtcclxuaW1wb3J0IHsgdGVzdCB9IGZyb20gXCIuL3Rlc3RcIjtcclxuXHJcbmV4cG9ydCB7IGxhdW5jaGVyLCBzdG9yZSwgdGVzdCB9O1xyXG4iLCJpbXBvcnQgeyBwcmlzbWFTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL3ByaXNtYVwiO1xyXG5cclxuLy8gTGF1bmNoZXIgZGF0YSBDb250cm9sbGVyXHJcbmV4cG9ydCBjb25zdCBsYXVuY2hlciA9IHtcclxuICBHRVQ6IGFzeW5jICh7IGZuLCBhcmdzIH0pID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcmlzbWFTZXJ2aWNlKHtcclxuICAgICAgdGFibGU6IFwibGF1bmNoZXJcIixcclxuICAgICAgZm46IGZuLFxyXG4gICAgICBhcmdzOiB7IC4uLmFyZ3MgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKGRhdGEuc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzIHx8IDUwMCxcclxuICAgICAgICBkYXRhOiBgTWV0aG9kIGxhdW5jaGVyLkdFVCBmYWlsZWQ6ICR7ZGF0YS5kYXRhfWAsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxuICB9LFxyXG59O1xyXG4iLCJpbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWxzXCI7XHJcblxyXG4vLyBTdG9yZSBkYXRhIENvbnRyb2xsZXJcclxuZXhwb3J0IGNvbnN0IHN0b3JlID0ge1xyXG4gIEdFVDogYXN5bmMgKGFyZ3MpID0+IHtcclxuICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlKCk7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgc3RvcmUuZ2V0KGFyZ3MpO1xyXG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKGRhdGEpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiAyMDAsXHJcbiAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgfTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiA1MDAsXHJcbiAgICAgICAgZGF0YTogYE1ldGhvZCBzdG9yZS5HRVQgZmFpbGVkOiAke2RhdGF9YCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9LFxyXG4gIFBPU1Q6IGFzeW5jIChhcmdzKSA9PiB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJncyk7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc3RhdHVzOiA0MTQsXHJcbiAgICAgICAgZGF0YTogYE1ldGhvZCBzdG9yZS5QT1NUIGZhaWxlZDogT25seSAxIGtleSBpcyBhbGxvd2VkLiBGb3VuZCBrZXlzOiAke2tleXMuam9pbihcIiwgXCIpfWAsXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZSgpO1xyXG4gICAgc3RvcmUuc2V0KGFyZ3MpO1xyXG4gICAgY29uc3QgaGFzS2V5ID0gc3RvcmUuaGFzKGtleXNbMF0pO1xyXG4gICAgaWYgKGhhc0tleSkge1xyXG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgc3RvcmUuZ2V0KGtleXNbMF0pO1xyXG4gICAgICBpZiAoXy5pc0VxdWFsKGFyZ3Nba2V5c1swXV0sIGRhdGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdGF0dXM6IDUwMCxcclxuICAgICAgZGF0YTogYE1ldGhvZCBzdG9yZS5QT1NUIGZhaWxlZDogQ2Fubm90IHdyaXRlIFN0b3JlYCxcclxuICAgIH07XHJcbiAgfSxcclxuICBERUxFVEU6IGFzeW5jIChhcmdzKSA9PiB7XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZSgpO1xyXG4gICAgc3RvcmUuZGVsZXRlKGFyZ3MpO1xyXG4gICAgY29uc3QgaGFzS2V5ID0gc3RvcmUuaGFzKGFyZ3MpO1xyXG4gICAgaWYgKCFoYXNLZXkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IDIwMCxcclxuICAgICAgICBkYXRhOiAhaGFzS2V5LFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiA1MDAsXHJcbiAgICAgIGRhdGE6IGBNZXRob2Qgc3RvcmUuREVMRVRFIGZhaWxlZGAsXHJcbiAgICB9O1xyXG4gIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IHByaXNtYVNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvcHJpc21hXCI7XHJcblxyXG4vLyBUZXN0IENvbnRyb2xsZXJcclxuZXhwb3J0IGNvbnN0IHRlc3QgPSB7XHJcbiAgR0VUOiBhc3luYyAoeyB1c2VyIH0pID0+IHtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBwcmlzbWFTZXJ2aWNlKHtcclxuICAgICAgdGFibGU6IFwidXNlclwiLFxyXG4gICAgICBmbjogXCJmaW5kTWFueVwiLFxyXG4gICAgICBhcmdzOiB7XHJcbiAgICAgICAgd2hlcmU6IHtcclxuICAgICAgICAgIG5hbWU6IHVzZXIsXHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKGRhdGEuc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBzdGF0dXM6IGRhdGEuc3RhdHVzIHx8IDUwMCxcclxuICAgICAgICBkYXRhOiBgTWV0aG9kIHRlc3QuR0VUIGZhaWxlZDogJHtkYXRhLmRhdGF9YCxcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IGFwcCB9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG5cclxuLy8gQWxsICdhcHAub24nIGV2ZW50c1xyXG5leHBvcnQgY29uc3QgYXBwRXZlbnRzID0gKCkgPT4ge1xyXG4gIGNvbnN0IGlzUHJvZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxuXHJcbiAgLy8gQ2xvc2UgYWxsIHdpbmRvd3NcclxuICBhcHAub24oXCJ3aW5kb3ctYWxsLWNsb3NlZFwiLCAoKSA9PiB7XHJcbiAgICBsb2dnZXIoYEFwcGxpY2F0aW9uIENsb3NlZGApO1xyXG4gICAgYXBwLnF1aXQoKTtcclxuICB9KTtcclxuXHJcbiAgLy8gS2V5Ym9hcmQgY29tbWFuZHMgcmVnaXN0ZXJpbmdcclxuICBhcHAub24oXCJicm93c2VyLXdpbmRvdy1mb2N1c1wiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaXNQcm9kKSB7XHJcbiAgICAgIGdsb2JhbFNob3J0Y3V0LnJlZ2lzdGVyKFwiQ29tbWFuZE9yQ29udHJvbCtSXCIsICgpID0+IHtcclxuICAgICAgICBsb2dnZXIoXCJDb21tYW5kT3JDb250cm9sK1IgaXMgcHJlc3NlZDogU2hvcnRjdXQgRGlzYWJsZWRcIik7XHJcbiAgICAgIH0pO1xyXG4gICAgICBnbG9iYWxTaG9ydGN1dC5yZWdpc3RlcihcIkY1XCIsICgpID0+IHtcclxuICAgICAgICBsb2dnZXIoXCJGNSBpcyBwcmVzc2VkOiBTaG9ydGN1dCBEaXNhYmxlZFwiKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGdsb2JhbFNob3J0Y3V0LnJlZ2lzdGVyKFwiQ29tbWFuZE9yQ29udHJvbCtTaGlmdCtSXCIsICgpID0+IHtcclxuICAgICAgICBsb2dnZXIoXCJDb21tYW5kT3JDb250cm9sK1NoaWZ0K1IgaXMgcHJlc3NlZDogU2hvcnRjdXQgRGlzYWJsZWRcIik7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvLyBEaXNhYmxpbmcga2V5Ym9hcmQgY29tbWFuZHMgb24gcHJvZHVjdGlvblxyXG4gIGFwcC5vbihcInJlYWR5XCIsICgpID0+IHtcclxuICAgIGlmIChpc1Byb2QpIHtcclxuICAgICAgbG9nZ2VyKGBSZW1vdmluZyBLZXlib2FyZCBDb21tYW5kcy4uLmApO1xyXG4gICAgICBnbG9iYWxTaG9ydGN1dC51bnJlZ2lzdGVyKFwiQ29tbWFuZE9yQ29udHJvbCtSXCIpO1xyXG4gICAgICBnbG9iYWxTaG9ydGN1dC51bnJlZ2lzdGVyKFwiRjVcIik7XHJcbiAgICAgIGdsb2JhbFNob3J0Y3V0LnVucmVnaXN0ZXIoXCJDb21tYW5kT3JDb250cm9sK1NoaWZ0K1JcIik7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcbiIsImltcG9ydCB7IEJyb3dzZXJXaW5kb3csIHNjcmVlbiB9IGZyb20gXCJlbGVjdHJvblwiO1xuaW1wb3J0IFN0b3JlIGZyb20gXCJlbGVjdHJvbi1zdG9yZVwiO1xuXG5leHBvcnQgY29uc3QgY3JlYXRlV2luZG93ID0gKHdpbmRvd05hbWUsIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qga2V5ID0gXCJ3aW5kb3ctc3RhdGVcIjtcbiAgY29uc3QgbmFtZSA9IGB3aW5kb3ctc3RhdGUtJHt3aW5kb3dOYW1lfWA7XG4gIGNvbnN0IHN0b3JlID0gbmV3IFN0b3JlKHsgbmFtZSB9KTtcbiAgY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgd2lkdGg6IG9wdGlvbnMud2lkdGgsXG4gICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcbiAgfTtcbiAgbGV0IHN0YXRlID0ge307XG5cbiAgY29uc3QgcmVzdG9yZSA9ICgpID0+IHN0b3JlLmdldChrZXksIGRlZmF1bHRTaXplKTtcblxuICBjb25zdCBnZXRDdXJyZW50UG9zaXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB3aW4uZ2V0UG9zaXRpb24oKTtcbiAgICBjb25zdCBzaXplID0gd2luLmdldFNpemUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcG9zaXRpb25bMF0sXG4gICAgICB5OiBwb3NpdGlvblsxXSxcbiAgICAgIHdpZHRoOiBzaXplWzBdLFxuICAgICAgaGVpZ2h0OiBzaXplWzFdLFxuICAgIH07XG4gIH07XG5cbiAgY29uc3Qgd2luZG93V2l0aGluQm91bmRzID0gKHdpbmRvd1N0YXRlLCBib3VuZHMpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgd2luZG93U3RhdGUueCA+PSBib3VuZHMueCAmJlxuICAgICAgd2luZG93U3RhdGUueSA+PSBib3VuZHMueSAmJlxuICAgICAgd2luZG93U3RhdGUueCArIHdpbmRvd1N0YXRlLndpZHRoIDw9IGJvdW5kcy54ICsgYm91bmRzLndpZHRoICYmXG4gICAgICB3aW5kb3dTdGF0ZS55ICsgd2luZG93U3RhdGUuaGVpZ2h0IDw9IGJvdW5kcy55ICsgYm91bmRzLmhlaWdodFxuICAgICk7XG4gIH07XG5cbiAgY29uc3QgcmVzZXRUb0RlZmF1bHRzID0gKCkgPT4ge1xuICAgIGNvbnN0IGJvdW5kcyA9IHNjcmVlbi5nZXRQcmltYXJ5RGlzcGxheSgpLmJvdW5kcztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFNpemUsIHtcbiAgICAgIHg6IChib3VuZHMud2lkdGggLSBkZWZhdWx0U2l6ZS53aWR0aCkgLyAyLFxuICAgICAgeTogKGJvdW5kcy5oZWlnaHQgLSBkZWZhdWx0U2l6ZS5oZWlnaHQpIC8gMixcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBlbnN1cmVWaXNpYmxlT25Tb21lRGlzcGxheSA9ICh3aW5kb3dTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHZpc2libGUgPSBzY3JlZW4uZ2V0QWxsRGlzcGxheXMoKS5zb21lKChkaXNwbGF5KSA9PiB7XG4gICAgICByZXR1cm4gd2luZG93V2l0aGluQm91bmRzKHdpbmRvd1N0YXRlLCBkaXNwbGF5LmJvdW5kcyk7XG4gICAgfSk7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICByZXR1cm4gcmVzZXRUb0RlZmF1bHRzKCk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3dTdGF0ZTtcbiAgfTtcblxuICBjb25zdCBzYXZlU3RhdGUgPSAoKSA9PiB7XG4gICAgaWYgKCF3aW4uaXNNaW5pbWl6ZWQoKSAmJiAhd2luLmlzTWF4aW1pemVkKCkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIGdldEN1cnJlbnRQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgc3RvcmUuc2V0KGtleSwgc3RhdGUpO1xuICB9O1xuXG4gIHN0YXRlID0gZW5zdXJlVmlzaWJsZU9uU29tZURpc3BsYXkocmVzdG9yZSgpKTtcblxuICBjb25zdCB3aW4gPSBuZXcgQnJvd3NlcldpbmRvdyh7XG4gICAgLi4uc3RhdGUsXG4gICAgLi4ub3B0aW9ucyxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgbm9kZUludGVncmF0aW9uOiBmYWxzZSxcbiAgICAgIGNvbnRleHRJc29sYXRpb246IHRydWUsXG4gICAgICAuLi5vcHRpb25zLndlYlByZWZlcmVuY2VzLFxuICAgIH0sXG4gIH0pO1xuXG4gIHdpbi5vbihcImNsb3NlXCIsIHNhdmVTdGF0ZSk7XG5cbiAgcmV0dXJuIHdpbjtcbn07XG4iLCJpbXBvcnQgeyBhcHAgfSBmcm9tIFwiZWxlY3Ryb25cIjtcclxuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xyXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVsZWN0cm9uQnVpbGRlckJvb3RzdHJhcCgpIHtcclxuICBjb25zdCBpc1Byb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XHJcblxyXG4gIGNvbnN0IGNvbmZpZyA9IHtcclxuICAgIHByb3ZpZGVyOiBcImdpdGh1YlwiLFxyXG4gICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9EZXhEZXZMYWIvbmV4dHJvbi1hdXRvdXBkYXRlLWFwcFwiLFxyXG4gICAgdXNlTXVsdGlwbGVSYW5nZVJlcXVlc3Q6IGZhbHNlLFxyXG4gICAgY2hhbm5lbDogXCJsYXRlc3RcIixcclxuICAgIHVwZGF0ZXJDYWNoZURpck5hbWU6IGFwcC5nZXROYW1lKCksXHJcbiAgICByZXNvdXJjZVBhdGg6IGlzUHJvZCA/IHByb2Nlc3MucmVzb3VyY2VzUGF0aCA6IHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9yZXNvdXJjZXMnKVxyXG4gIH07XHJcblxyXG4gIGxldCB5YW1sID0gXCJcIjtcclxuXHJcbiAgeWFtbCArPSBgcHJvdmlkZXI6ICR7Y29uZmlnLnByb3ZpZGVyfVxcbmA7XHJcbiAgeWFtbCArPSBgdXJsOiAke2NvbmZpZy51cmx9XFxuYDtcclxuICB5YW1sICs9IGB1c2VNdWx0aXBsZVJhbmdlUmVxdWVzdDogJHtjb25maWcudXNlTXVsdGlwbGVSYW5nZVJlcXVlc3R9XFxuYDtcclxuICB5YW1sICs9IGBjaGFubmVsOiAke2NvbmZpZy5jaGFubmVsfVxcbmA7XHJcbiAgeWFtbCArPSBgdXBkYXRlckNhY2hlRGlyTmFtZTogJHtjb25maWcudXBkYXRlckNhY2hlRGlyTmFtZX1gO1xyXG5cclxuICBsZXQgdXBkYXRlX2ZpbGUgPSBbcGF0aC5qb2luKGNvbmZpZy5yZXNvdXJjZVBhdGgsIFwiYXBwLXVwZGF0ZS55bWxcIiksIHlhbWxdO1xyXG4gIGxldCBkZXZfdXBkYXRlX2ZpbGUgPSBbXHJcbiAgICBwYXRoLmpvaW4oY29uZmlnLnJlc291cmNlUGF0aCwgXCJkZXYtYXBwLXVwZGF0ZS55bWxcIiksXHJcbiAgICB5YW1sLFxyXG4gIF07XHJcbiAgbGV0IGNoZWNrRmlsZXMgPSBbdXBkYXRlX2ZpbGUsIGRldl91cGRhdGVfZmlsZV07XHJcblxyXG4gIGZvciAobGV0IGZpbGUgb2YgY2hlY2tGaWxlcykge1xyXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVbMF0pKSB7XHJcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVswXSwgZmlsZVsxXSwgKCkgPT4ge30pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBhcHAsIEJyb3dzZXJXaW5kb3csIGlwY01haW4gfSBmcm9tIFwiZWxlY3Ryb25cIjtcclxuaW1wb3J0IHsgZG93bmxvYWQgfSBmcm9tIFwiZWxlY3Ryb24tZGxcIjtcclxuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xyXG5pbXBvcnQgeyBwcmlzbWFTZXJ2aWNlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL3ByaXNtYVwiO1xyXG5pbXBvcnQgeyBnZXRBbGxXaW5kb3dzLCBpbnN0YW50aWF0ZUVsZWN0cm9uU3RvcmUsIGxvZ2dlciB9IGZyb20gXCIuL3V0aWxzXCI7XHJcbmltcG9ydCB7IGluc3RhbnRpYXRlV2luZG93IH0gZnJvbSBcIi4vd2luZG93c1wiO1xyXG5cclxuLy8gQWxsICdpcGNNYWluLm9uIC8gaXBjTWFpbi5oYW5kbGUnIGV2ZW50cyBhbmQgZnVuY3Rpb25zXHJcbmV4cG9ydCBjb25zdCBpcGNFdmVudHMgPSAoKSA9PiB7XHJcbiAgLy8gRGVmYXVsdCBtZXNzYWdlIGZ1bmN0aW9uXHJcbiAgaXBjTWFpbi5vbihcIm1lc3NhZ2VcIiwgYXN5bmMgKGV2ZW50LCBhcmcpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHVzZXJzID0gYXBwLmdldEFwcFBhdGgoKTtcclxuICAgICAgZXZlbnQucmVwbHkoXCJtZXNzYWdlXCIsIHVzZXJzKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGxvZ2dlcihlcnJvcik7XHJcbiAgICAgIGV2ZW50LnJlcGx5KFwibWVzc2FnZVwiLCBlcnJvcik7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIE1vY2sgRG93bmxvYWQgZnVuY3Rpb25cclxuICBpcGNNYWluLm9uKFwiZG93bmxvYWRcIiwgYXN5bmMgKGV2ZW50LCBhcmcpID0+IHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IEJyb3dzZXJXaW5kb3cuZ2V0Rm9jdXNlZFdpbmRvdygpO1xyXG4gICAgY29uc29sZS5sb2coNDEsIFwiZG93bmxvYWQgYXJnczogXCIsIGFyZyk7XHJcblxyXG4gICAgZG93bmxvYWQod2luZG93LCBhcmcudXJsLCB7XHJcbiAgICAgIG9uUHJvZ3Jlc3M6IChzdGF0dXMpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyg0NywgXCJkb3dubG9hZCBwcm9ncmVzczogXCIsIHN0YXR1cyk7XHJcblxyXG4gICAgICAgIC8vUFJPR1JFU1MgU0VORElOR1xyXG4gICAgICAgIGNvbnN0IG1haW5XaW5kb3dJZCA9IGdldEFsbFdpbmRvd3MoXCJEZXhDcmFmdCBMYXVuY2hlclwiKS5pZDtcclxuICAgICAgICBCcm93c2VyV2luZG93LmZyb21JZChtYWluV2luZG93SWQpLndlYkNvbnRlbnRzLnNlbmQoXHJcbiAgICAgICAgICBcImRvd25sb2FkIHByb2dyZXNzXCIsXHJcbiAgICAgICAgICBzdGF0dXNcclxuICAgICAgICApO1xyXG4gICAgICAgIC8vbWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKFwiZG93bmxvYWQgcHJvZ3Jlc3NcIiwgc3RhdHVzKTtcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gIH0pO1xyXG5cclxuICAvLyBNb2NrIGluc2VydCBkYXRhIHRvIGRiIGZ1bmN0aW9uXHJcbiAgaXBjTWFpbi5vbihcImNhZGFzdHJhclwiLCBhc3luYyAoZXZlbnQsIHsgbmFtZSwgZW1haWwsIHBhc3N3b3JkIH0pID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBwYXNzd29yZCxcclxuICAgICAgICBuZXh0U2Vhc29uVGFnczogXCJcIixcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIGNvbnN0IGNyZWF0ZVVzZXIgPSBhd2FpdCBwcmlzbWEudXNlci5jcmVhdGUoe1xyXG4gICAgICAvLyAgIGRhdGEsXHJcbiAgICAgIC8vIH0pO1xyXG4gICAgICBjb25zdCBjcmVhdGVVc2VyID0gYXdhaXQgcHJpc21hU2VydmljZSh7XHJcbiAgICAgICAgdGFibGU6IFwidXNlclwiLFxyXG4gICAgICAgIGZuOiBcImNyZWF0ZVwiLFxyXG4gICAgICAgIGFyZ3M6IGRhdGEsXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgZXZlbnQucmVwbHkoXCJjYWRhc3RyYXJcIiwgY3JlYXRlVXNlcik7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBldmVudC5yZXBseShcImNhZGFzdHJhclwiLCBlcnJvcik7XHJcbiAgICB9XHJcblxyXG4gICAge1xyXG4gICAgICAvKiBkYXRhOiB7XHJcbiAgICAgICAgICBuYW1lOiAnQ0FSQUxITycsXHJcbiAgICAgICAgICBlbWFpbDogJ21ldWN1QHRldWN1LmNvbScsXHJcbiAgICAgICAgICBwYXNzd29yZDogJ1NlbmhAMTIzJ1xyXG4gICAgICAgICAgbmV4dFNlYXNvblRhZ3M6ICcnLFxyXG4gICAgICAgICAgY3JlYXRlZEF0OiAnMjAyNS0wNC0xMC0tMTM6NDcnXHJcbiAgICAgICAgfSwgKi9cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLy8gT3BlbnMgYSB3aW5kb3cgZnJvbSBSZW5kZXJcclxuICBpcGNNYWluLm9uKFxyXG4gICAgXCJ3aW5kb3ctb3BlblwiLFxyXG4gICAgYXN5bmMgKGV2ZW50LCB7IHdpbmRvd05hbWUsIGNsb3NlUGFyZW50ID0gZmFsc2UgfSkgPT4ge1xyXG4gICAgICBpZiAoY2xvc2VQYXJlbnQpIHtcclxuICAgICAgICBldmVudC5zZW5kZXIuY2xvc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB3aW5kb3dJZCA9IGdldEFsbFdpbmRvd3MoeyBuYW1lOiB3aW5kb3dOYW1lIH0pLmlkO1xyXG4gICAgICBpZiAod2luZG93SWQgPT09IDApIHtcclxuICAgICAgICBpbnN0YW50aWF0ZVdpbmRvd1t3aW5kb3dOYW1lXSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEJyb3dzZXJXaW5kb3cuZnJvbUlkKHdpbmRvd0lkKS5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApO1xyXG5cclxuICAvLyBDbG9zZXMgb3duIHdpbmRvdyBmcm9tIFJlbmRlci4gTWF5IGNsb3NlIHRoZSBlbnRpcmUgYXBwIGlmIG5lZWRlZFxyXG4gIGlwY01haW4ub24oXCJ3aW5kb3ctY2xvc2VcIiwgYXN5bmMgKGV2ZW50LCBleGl0QXBwID0gZmFsc2UpID0+IHtcclxuICAgIGV2ZW50LnNlbmRlci5jbG9zZSgpO1xyXG4gICAgaWYgKGV4aXRBcHApIHtcclxuICAgICAgYXBwLmV4aXQoMCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbn07XHJcblxyXG5pcGNNYWluLm9uKCd1cGRhdGUtbXNnJywgYXN5bmMoZXZlbnQsIGFyZ3MpID0+e1xyXG4gIGNvbnNvbGUubG9nKDEwMiwgYXJncyk7XHJcbiAgQnJvd3NlcldpbmRvdy5nZXRGb2N1c2VkV2luZG93KCkud2ViQ29udGVudHMuc2VuZCgndXBkYXRlLW1zZycsIGFyZ3MpXHJcbiAgLy9ldmVudC5yZXBseSgndXBkYXRlLW1zZycsIGFyZ3MpO1xyXG59KVxyXG5cclxuXHJcbi8vIEdldHMgZGF0YSBmcm9tIEVsZWN0cm9uIFN0b3JlLiBNYXkgdXNlIHNwZWNpZmljIGtleSB0byBnZXQgcmVmaW5lZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgKHJlY29tbWVuZGVkIGZvciBwZXJmb3JtYW5jZSlcclxuLy8gaXBjTWFpbi5vbihcInN0b3JlLWdldFwiLCBhc3luYyAoZXZlbnQsIGtleSkgPT4ge1xyXG4vLyAgIGNvbnN0IHN0b3JlRGF0YSA9IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZSgpLmdldChrZXkpO1xyXG4vLyAgIGV2ZW50LnJlcGx5KFwic3RvcmUtZ2V0XCIsIHN0b3JlRGF0YSk7XHJcbi8vIH0pO1xyXG5cclxuXHJcblxyXG5cclxuLy8gU3RvcmVzIGRhdGEgdG8gRWxlY3Ryb24gU3RvcmUsIGluIE9iamVjdCBmb3JtYXQuIFVzZXMgd2F0Y2hlcnMgKG9wdGlvbmFsKSB0byBjcmVhdGUgaWRlbnRpZmllciBmb3IgYSBzcGVjaWZpYyBsaXN0ZW5lciBmb3IgdGhlIG9iamVjdCB3YXMgc2V0LiBJZiB0aGUgb2JqZWN0IGNoYW5nZXMsIGl0IHRyaWdnZ2VycyB0aGUgZXZlbnQgdXNpbmcgYSBjaGFubmVsIG1hZGUgd2l0aCB0aGUgd2F0Y2hlclxyXG4vLyBpcGNNYWluLm9uKFwic3RvcmUtc2V0XCIsIGFzeW5jIChldmVudCwgeyBvYmosIHdhdGNoZXJzIH0pID0+IHtcclxuLy8gICBpbnN0YW50aWF0ZUVsZWN0cm9uU3RvcmUoKS5zZXQoeyAuLi5vYmogfSk7XHJcbi8vICAgY29uc3Qgc3RvcmVEYXRhID0gaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlKCkuZ2V0KE9iamVjdC5rZXlzKHsgLi4ub2JqIH0pWzBdKTtcclxuLy8gICBpZiAoXy5pc0FycmF5KHdhdGNoZXJzKSkge1xyXG4vLyAgICAgd2F0Y2hlcnMuZm9yRWFjaCgoaWQpID0+IHtcclxuLy8gICAgICAgZXZlbnQucmVwbHkoYHN0b3JlLXdhdGNoLSR7T2JqZWN0LmtleXMoeyAuLi5vYmogfSlbMF19LSR7aWR9YCwgc3RvcmVEYXRhKTtcclxuLy8gICAgIH0pO1xyXG4vLyAgIH0gZWxzZSB7XHJcbi8vICAgICBldmVudC5yZXBseShcclxuLy8gICAgICAgYHN0b3JlLXdhdGNoLSR7T2JqZWN0LmtleXMoeyAuLi5vYmogfSlbMF19LSR7d2F0Y2hlcnN9YCxcclxuLy8gICAgICAgc3RvcmVEYXRhXHJcbi8vICAgICApO1xyXG4vLyAgIH1cclxuLy8gfSk7XHJcblxyXG4vLyBEZWxldGVzIGEgdmFsdWUgZnJvbSB0aGUgRWxlY3Ryb24gU3RvcmUuIERlbGV0ZXMgZW50aXJlIHN0b3JlIGlmIG5vIGtleSBpcyBwcm92aWRlZFxyXG4vLyBpcGNNYWluLm9uKFwic3RvcmUtZGVsZXRlXCIsIGFzeW5jIChldmVudCwga2V5KSA9PiB7XHJcbi8vICAgaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlKCkuZGVsZXRlKGtleSk7XHJcbi8vIH0pO1xyXG5cclxuLy8gLy8gSW5zdGFudGlhdGUgdGhlIEVsZWN0cm9uIFN0b3JlIGxvZ2dlclxyXG4vLyBpcGNNYWluLmhhbmRsZShcImxvZ2dlci1zdGFydFwiLCBhc3luYyAoZXZlbnQsIG1zZykgPT4ge1xyXG4vLyAgIGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZShmYWxzZSwgeyBuYW1lOiBcImxvZ1wiIH0pLmNsZWFyKCk7XHJcbi8vIH0pO1xyXG5cclxuLy8gLy8gU2V0IGluZm9ybWF0aW9uIHRvIHRoZSBFbGVjdHJvbiBTdG9yZSBMb2dnZXJcclxuLy8gaXBjTWFpbi5vbihcImxvZ2dlci1zZXRcIiwgYXN5bmMgKGV2ZW50LCBtc2cpID0+IHtcclxuLy8gICBpbnN0YW50aWF0ZUVsZWN0cm9uU3RvcmUoZmFsc2UsIHsgbmFtZTogXCJsb2dcIiB9KS5zZXQobXNnKTtcclxuLy8gfSk7XHJcblxyXG5cclxuIiwiaW1wb3J0IHsgaXBjTWFpbiB9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5pbXBvcnQgXyBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7IGxhdW5jaGVyLCBzdG9yZSwgdGVzdCB9IGZyb20gXCIuLi9jb250cm9sbGVyc1wiO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi91dGlsc1wiO1xyXG5cclxuLy8gQWxsIElQQyBDb250cm9sbGVycyB0byBleHRlcm5hbCBBUElzXHJcbmV4cG9ydCBjb25zdCBpcGNIYW5kbGVycyA9ICgpID0+IHtcclxuICAvLyBQcmlzbWEgKGRhdGFiYXNlKSBUZXN0IChUZXN0IGNvbnRyb2xsZXIpIEdFVCAoTWV0aG9kKVxyXG4gIGlwY01haW4uaGFuZGxlKFwicHJpc21hLXRlc3QtZ2V0XCIsIGFzeW5jIChldmVudCwgeyBmbiwgdXNlciB9KSA9PiB7XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGVzdC5HRVQoeyB1c2VyOiB1c2VyIH0pO1xyXG4gICAgcmV0dXJuIGRhdGE7XHJcbiAgfSk7XHJcbn07XHJcblxyXG4vLyBQcmlzbWEgKGRhdGFiYXNlKSBMYXVuY2hlciAoTGF1bmNoZXIgY29udHJvbGxlcikgR0VUIChNZXRob2QpXHJcbmlwY01haW4uaGFuZGxlKFwicHJpc21hLWxhdW5jaGVyLWdldFwiLCBhc3luYyAoZXZlbnQsIHsgZm4sIGFyZ3MgfSkgPT4ge1xyXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBsYXVuY2hlci5HRVQoeyBmbjogZm4sIGFyZ3M6IGFyZ3MgfSk7XHJcbiAgcmV0dXJuIGRhdGE7XHJcbn0pO1xyXG5cclxuaXBjTWFpbi5oYW5kbGUoXCJsb2dnZXJcIiwgYXN5bmMgKGV2ZW50LCBhcmdzKSA9PiB7XHJcbiAgYXdhaXQgbG9nZ2VyKGFyZ3MpO1xyXG59KTtcclxuXHJcbi8vIFN0b3JlIChFbGVjdHJvbiBTdG9yZSkgR0VUIChNZXRob2QpLiBNYXkgdXNlIHNwZWNpZmljIGtleSB0byBnZXQgcmVmaW5lZCBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgKHJlY29tbWVuZGVkIGZvciBwZXJmb3JtYW5jZSlcclxuaXBjTWFpbi5oYW5kbGUoXCJzdG9yZS1nZXRcIiwgYXN5bmMgKGV2ZW50LCBhcmdzKSA9PiB7XHJcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHN0b3JlLkdFVChhcmdzKTtcclxuICByZXR1cm4gZGF0YTtcclxufSk7XHJcblxyXG4vLyBTdG9yZSAoRWxlY3Ryb24gU3RvcmUpIFBPU1QgKE1ldGhvZCkuIFVzZXMgd2F0Y2hlcnMgKG9wdGlvbmFsKSB0byBjcmVhdGUgaWRlbnRpZmllciBmb3IgYSBzcGVjaWZpYyBsaXN0ZW5lciBmb3IgdGhlIG9iamVjdCB3YXMgc2V0LiBJZiB0aGUgb2JqZWN0IGNoYW5nZXMsIGl0IHRyaWdnZ2VycyB0aGUgZXZlbnQgdXNpbmcgYSBjaGFubmVsIG1hZGUgd2l0aCB0aGUgd2F0Y2hlclxyXG5pcGNNYWluLm9uKFwic3RvcmUtcG9zdFwiLCBhc3luYyAoZXZlbnQsIHsga2V5LCB2YWx1ZSwgd2F0Y2hlcnMgfSkgPT4ge1xyXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yZS5QT1NUKHsgW2tleV06IHZhbHVlIH0pO1xyXG4gIGlmICh3YXRjaGVycykge1xyXG4gICAgaWYgKF8uaXNBcnJheSh3YXRjaGVycykpIHtcclxuICAgICAgd2F0Y2hlcnMuZm9yRWFjaCgoaWQpID0+IHtcclxuICAgICAgICBldmVudC5yZXBseShgc3RvcmUtd2F0Y2gtJHtrZXl9LSR7aWR9YCwgZGF0YSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZXZlbnQucmVwbHkoYHN0b3JlLXdhdGNoLSR7a2V5fS0ke3dhdGNoZXJzfWAsIGRhdGEpO1xyXG4gICAgfVxyXG4gIH1cclxufSk7XHJcblxyXG4vLyBTdG9yZSAoRWxlY3Ryb24gU3RvcmUpIERFTEVURSAoTWV0aG9kKS4gRGVsZXRlcyBhIHZhbHVlIGZyb20gdGhlIEVsZWN0cm9uIFN0b3JlLiBEZWxldGVzIGVudGlyZSBzdG9yZSBpZiBubyBrZXkgaXMgcHJvdmlkZWRcclxuaXBjTWFpbi5oYW5kbGUoXCJzdG9yZS1kZWxldGVcIiwgYXN5bmMgKGV2ZW50LCBhcmdzKSA9PiB7XHJcbiAgY29uc3QgZGF0YSA9IGF3YWl0IHN0b3JlLkRFTEVURShhcmdzKTtcclxuICByZXR1cm4gZGF0YTtcclxufSk7XHJcbiIsImltcG9ydCB7IGFwcCwgQnJvd3NlcldpbmRvdyB9IGZyb20gXCJlbGVjdHJvblwiO1xyXG5pbXBvcnQgU3RvcmUgZnJvbSBcImVsZWN0cm9uLXN0b3JlXCI7XHJcbmltcG9ydCBfIGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHsgd2luZG93VGl0bGVzIH0gZnJvbSBcIi4vd2luZG93c1wiO1xyXG5cclxuLy8gVHJhbnNsYXRlIHBhZ2UgcGF0aCB0byBXaW5kb3cgTG9hZGVyIGRlcGVuZGluZyBvZiB0aGUgYXBwbGljYXRpb24gZW52aXJvbm1lbnRcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJhY2tlbmRQYXRoKHBhZ2VQYXRoKSB7XHJcbiAgY29uc3QgaXNQcm9kID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG4gIGlmIChpc1Byb2QpIHtcclxuICAgIHJldHVybiBgYXBwOi8vLi8ke3BhZ2VQYXRofWA7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnN0IHBvcnQgPSBwcm9jZXNzLmFyZ3ZbMl07XHJcbiAgICByZXR1cm4gYGh0dHA6Ly9sb2NhbGhvc3Q6JHtwb3J0fS8ke3BhZ2VQYXRofWA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBJTlRFUk5BTCBGTiBUTyBGT1JNQVQgQ1VSUkVOVCBEQVRFIFRPIEEgU0FOSVRJWkVEIEZPUk1BVFxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVGb3JtYXR0ZWREYXRlKGRhdGUpIHtcclxuICBsZXQgdG9kYXkgPSBudWxsO1xyXG4gIGlmIChkYXRlID09IG51bGwpIHtcclxuICAgIHRvZGF5ID0gbmV3IERhdGUoKTtcclxuICB9IGVsc2Uge1xyXG4gICAgdG9kYXkgPSBuZXcgRGF0ZShkYXRlKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IFlZWVkgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xyXG4gIGNvbnN0IE1NID0gU3RyaW5nKHRvZGF5LmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCBcIjBcIik7XHJcbiAgY29uc3QgREQgPSBTdHJpbmcodG9kYXkuZ2V0RGF0ZSgpKS5wYWRTdGFydCgyLCBcIjBcIik7XHJcbiAgY29uc3QgaGggPSBTdHJpbmcodG9kYXkuZ2V0SG91cnMoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gIGNvbnN0IG1tID0gU3RyaW5nKHRvZGF5LmdldE1pbnV0ZXMoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gIGNvbnN0IHNzID0gU3RyaW5nKHRvZGF5LmdldFNlY29uZHMoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xyXG4gIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBgJHtZWVlZfS0ke01NfS0ke0REfS0tJHtoaH06JHttbX06JHtzc31gO1xyXG5cclxuICByZXR1cm4gZm9ybWF0dGVkRGF0ZTtcclxufVxyXG5cclxuLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBFbGVjdHJvbiBTdG9yZVxyXG5leHBvcnQgY29uc3QgaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlID0gYXN5bmMgKGluaXQgPSBmYWxzZSwgb3B0aW9ucyA9IHt9KSA9PiB7XHJcbiAgY29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUob3B0aW9ucyk7XHJcbiAgaWYgKGluaXQpIHtcclxuICAgIHN3aXRjaCAob3B0aW9ucz8ubmFtZSkge1xyXG4gICAgICBjYXNlIFwibG9nXCI6XHJcbiAgICAgICAgc3RvcmUuY2xlYXIoKTtcclxuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBnZW5lcmF0ZUZvcm1hdHRlZERhdGUoKTtcclxuICAgICAgICBzdG9yZS5zZXQoe1xyXG4gICAgICAgICAgW3RpbWVzdGFtcF06IFwiTG9nZ2VyIFN0YXJ0ZWRcIixcclxuICAgICAgICB9KTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICBzdG9yZS5zZXQoe1xyXG4gICAgICAgICAgdmVyc2lvbjogYXBwLmdldFZlcnNpb24oKSxcclxuICAgICAgICB9KTtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0b3JlO1xyXG59O1xyXG5cclxuLy8gU3RvcmVzIGRhdGEgdG8gRWxlY3Ryb24gU3RvcmUsIGluIE9iamVjdCBmb3JtYXQuIFVzZXMgd2F0Y2hlcnMgKG9wdGlvbmFsKSB0byBjcmVhdGUgaWRlbnRpZmllciBmb3IgYSBzcGVjaWZpYyBsaXN0ZW5lciBmb3IgdGhlIG9iamVjdCB3YXMgc2V0LiBJZiB0aGUgb2JqZWN0IGNoYW5nZXMsIGl0IHRyaWdnZ2VycyB0aGUgZXZlbnQgdXNpbmcgYSBjaGFubmVsIG1hZGUgd2l0aCB0aGUgd2F0Y2hlci4gVGhpcyBGdW5jdGlvbiBpcyBtZWFudCB0byBiZSB1c2VkIGJ5IHRoZSBFbGVjdHJvbiBiYWNrZW5kXHJcbmV4cG9ydCBjb25zdCBzZXRFbGVjdHJvblN0b3JlID0gYXN5bmMgKGFyZ3MsIG9wdGlvbnMgPSB7fSkgPT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoYXJncyk7XHJcbiAgICBpZiAoa2V5cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yOiBPbmx5IDEga2V5IGlzIGFsbG93ZWRcIik7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdG9yZSA9IGF3YWl0IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZShmYWxzZSwgb3B0aW9ucyk7XHJcbiAgICBzdG9yZS5zZXQoYXJncyk7XHJcbiAgICBjb25zdCBoYXNLZXkgPSBzdG9yZS5oYXMoa2V5c1swXSk7XHJcbiAgICBpZiAoIWhhc0tleSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBzdG9yZS5nZXQoa2V5c1swXSk7XHJcbiAgICAgIGlmIChfLmlzRXF1YWwoYXJnc1trZXlzWzBdXSwgZGF0YSkpIHtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGUpO1xyXG4gICAgZXJyb3IubWVzc2FnZSA9IFwiRXJyb3I6IFN0b3JlIGNhbm5vdCBiZSB3cml0YWJsZVwiO1xyXG4gICAgY29uc3QgdGltZXN0YW1wID0gZ2VuZXJhdGVGb3JtYXR0ZWREYXRlKCk7XHJcbiAgICBhd2FpdCBzZXRFbGVjdHJvblN0b3JlKHsgW3RpbWVzdGFtcF06IGVycm9yLm1lc3NhZ2UgfSwgeyBuYW1lOiBcImxvZ1wiIH0pO1xyXG4gICAgY29uc3QgaXNQcm9kID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiO1xyXG4gICAgaWYgKGlzUHJvZCkge1xyXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBhcHAuZXhpdCgxKTtcclxuICAgICAgfSwgNTAwMCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gU2VuZCBtZXNzYWdlIGZyb20gbWFpbiB0byBsb2dnZXJcclxuZXhwb3J0IGNvbnN0IGxvZ2dlciA9IGFzeW5jIChtZXNzYWdlKSA9PiB7XHJcbiAgbGV0IG1zZyA9IFwiXCI7XHJcbiAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBnZW5lcmF0ZUZvcm1hdHRlZERhdGUoKTtcclxuICAgIG1zZyA9IHtcclxuICAgICAgW3RpbWVzdGFtcF06IG1lc3NhZ2UsXHJcbiAgICB9O1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtc2cgPSBtZXNzYWdlO1xyXG4gIH1cclxuICBhd2FpdCBzZXRFbGVjdHJvblN0b3JlKG1zZywgeyBuYW1lOiBcImxvZ1wiIH0pO1xyXG59O1xyXG5cclxuLy8gR2V0IGFsbCBjdXJyZW50IEVsZWN0cm9uIHdpbmRvd3MsIG9yIGdldCBieSB0aXRsZSBvciBuYW1lXHJcbmV4cG9ydCBjb25zdCBnZXRBbGxXaW5kb3dzID0gKHsgdGl0bGUsIG5hbWUgfSkgPT4ge1xyXG4gIGNvbnN0IGJyb3dzZXJXaW5kb3dBcnIgPSBCcm93c2VyV2luZG93LmdldEFsbFdpbmRvd3MoKTtcclxuICBsZXQgd2luZG93TGlzdCA9IFtdO1xyXG4gIGJyb3dzZXJXaW5kb3dBcnIuZm9yRWFjaCgod2luZG93KSA9PiB7XHJcbiAgICB3aW5kb3dMaXN0LnB1c2goe1xyXG4gICAgICBpZDogd2luZG93LmlkLFxyXG4gICAgICB0aXRsZTogd2luZG93LmdldFRpdGxlKCksXHJcbiAgICB9KTtcclxuICB9KTtcclxuICB3aW5kb3dMaXN0ID0gd2luZG93TGlzdC5yZXZlcnNlKCk7XHJcblxyXG4gIHRpdGxlID0gdGl0bGUgfHwgd2luZG93VGl0bGVzW25hbWVdIHx8IG5hbWU7XHJcblxyXG4gIGlmICh0aXRsZSkge1xyXG4gICAgd2luZG93TGlzdCA9IHdpbmRvd0xpc3QuZmlsdGVyKCh3aW5kb3cpID0+IHdpbmRvdy50aXRsZSA9PT0gdGl0bGUpO1xyXG4gICAgaWYgKHdpbmRvd0xpc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IDAsXHJcbiAgICAgICAgdGl0bGU6IFwibm9uZVwiLFxyXG4gICAgICB9O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHdpbmRvd0xpc3Rbd2luZG93TGlzdC5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHdpbmRvd0xpc3Q7XHJcbiAgfVxyXG59O1xyXG4iLCJpbXBvcnQgeyBhcHAgfSBmcm9tIFwiZWxlY3Ryb25cIjtcclxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgY3JlYXRlV2luZG93IH0gZnJvbSBcIi4vY3JlYXRlV2luZG93XCI7XHJcbmltcG9ydCB7IGdldEJhY2tlbmRQYXRoIH0gZnJvbSBcIi4vdXRpbHNcIjtcclxuXHJcbmNvbnN0IGlzUHJvZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcclxuXHJcbi8vIExpc3QgYWxsIHdpbmRvdyB0aXRsZXMgZm9yIGJldHRlciByZWZlcmVuY2VcclxuZXhwb3J0IGNvbnN0IHdpbmRvd1RpdGxlcyA9IHtcclxuICBzcGxhc2g6IFwiU3BsYXNoIFNjcmVlblwiLFxyXG4gIGxvZ2luOiBcIkVudHJlIG5vIERleENyYWZ0IExhdW5jaGVyXCIsXHJcbiAgbWFpbjogXCJEZXhDcmFmdCBMYXVuY2hlclwiLFxyXG59O1xyXG5cclxuLy8gU2V0IGFuZCBpbnN0YW50aWF0ZSBhbGwgYXBwbGljYXRpb24gd2luZG93c1xyXG5leHBvcnQgY29uc3QgaW5zdGFudGlhdGVXaW5kb3cgPSB7XHJcbiAgc3BsYXNoOiBhc3luYyAoKSA9PiB7XHJcbiAgICAvLyBTZXR0aW5nIHdpbmRvd1xyXG4gICAgY29uc3Qgd2luZG93ID0gY3JlYXRlV2luZG93KFwic3BsYXNoXCIsIHtcclxuICAgICAgdGl0bGU6IHdpbmRvd1RpdGxlcy5zcGxhc2gsXHJcbiAgICAgIHdpZHRoOiAzMDAsXHJcbiAgICAgIGhlaWdodDogMzAwLFxyXG4gICAgICBtaW5IZWlnaHQ6IDMwMCxcclxuICAgICAgbWluV2lkdGg6IDMwMCxcclxuICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgIGF1dG9IaWRlTWVudUJhcjogdHJ1ZSxcclxuICAgICAgd2ViUHJlZmVyZW5jZXM6IHtcclxuICAgICAgICBwcmVsb2FkOiBwYXRoLmpvaW4oX19kaXJuYW1lLCBcInByZWxvYWQuanNcIiksXHJcbiAgICAgICAgd2ViU2VjdXJpdHk6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgICBhbHdheXNPblRvcDogdHJ1ZSxcclxuICAgICAgZm9jdXNhYmxlOiB0cnVlLFxyXG4gICAgICBmcmFtZTogZmFsc2UsXHJcbiAgICAgIHNraXBUYXNrYmFyOiB0cnVlLFxyXG4gICAgICBtb3ZhYmxlOiB0cnVlLFxyXG4gICAgICByZXNpemFibGU6IGZhbHNlLFxyXG4gICAgICBtYXhpbWl6YWJsZTogZmFsc2UsXHJcbiAgICAgIG1pbmltaXphYmxlOiBmYWxzZSxcclxuICAgIH0pO1xyXG4gICAgLy8gTG9hZGluZyBQYWdlIGNvbXBvbmVudFxyXG4gICAgYXdhaXQgd2luZG93LmxvYWRVUkwoZ2V0QmFja2VuZFBhdGgoXCJzcGxhc2hcIikpO1xyXG5cclxuICAgIHdpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoKTtcclxuICAgIGlmICghaXNQcm9kKSB7XHJcbiAgICAgIC8vIE9wZW4gRGV2IFRvb2xzXHJcbiAgICAgIC8vd2luZG93LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpO1xyXG4gICAgfVxyXG4gICAgLy8gU3BlY2lmaWMgY29tbWFuZHMgd2hlbiBjbG9zaW5nIHdpbmRvd1xyXG4gICAgd2luZG93Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xyXG4gICAgICBhcHAuZXhpdCgwKTtcclxuICAgIH0pO1xyXG4gICAgLy8gVXNpbmcgJ2NlbnRlcicgYmVmb3JlICdzaG93JyBpcyBuZWVkZWQgdG8gY2VudGVyIHRoZSB3aW5kb3cgcHJvcGVybHkgb24gdGhlIHNjcmVlblxyXG4gICAgd2luZG93LmNlbnRlcigpO1xyXG4gICAgd2luZG93LnNob3coKTtcclxuICAgIHJldHVybiB3aW5kb3c7XHJcbiAgfSxcclxuICBsb2dpbjogYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3Qgd2luZG93ID0gY3JlYXRlV2luZG93KFwibG9naW5cIiwge1xyXG4gICAgICB0aXRsZTogd2luZG93VGl0bGVzLmxvZ2luLFxyXG4gICAgICB3aWR0aDogMTkyMCxcclxuICAgICAgaGVpZ2h0OiAxMDgwLFxyXG4gICAgICBtaW5IZWlnaHQ6IDc2OCxcclxuICAgICAgbWluV2lkdGg6IDEzNjYsXHJcbiAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICBhdXRvSGlkZU1lbnVCYXI6IHRydWUsXHJcbiAgICAgIHdlYlByZWZlcmVuY2VzOiB7XHJcbiAgICAgICAgcHJlbG9hZDogcGF0aC5qb2luKF9fZGlybmFtZSwgXCJwcmVsb2FkLmpzXCIpLFxyXG4gICAgICAgIHdlYlNlY3VyaXR5OiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgaWYgKCFpc1Byb2QpIHtcclxuICAgICAgd2luZG93LndlYkNvbnRlbnRzLm9wZW5EZXZUb29scygpO1xyXG4gICAgfVxyXG4gICAgd2luZG93LnNldEJhY2tncm91bmRDb2xvcihcIiMxQTIwMkNcIik7XHJcbiAgICBhd2FpdCB3aW5kb3cubG9hZFVSTChnZXRCYWNrZW5kUGF0aChcImxvZ2luXCIpKTtcclxuICAgIHdpbmRvdy5jZW50ZXIoKTtcclxuICAgIHdpbmRvdy5tYXhpbWl6ZSgpO1xyXG4gICAgd2luZG93Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xyXG4gICAgICBhcHAuZXhpdCgwKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHdpbmRvdztcclxuICB9LFxyXG4gIG1haW46IGFzeW5jICgpID0+IHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IGNyZWF0ZVdpbmRvdyhcIm1haW5cIiwge1xyXG4gICAgICB0aXRsZTogd2luZG93VGl0bGVzLm1haW4sXHJcbiAgICAgIHdpZHRoOiAxOTIwLFxyXG4gICAgICBoZWlnaHQ6IDEwODAsXHJcbiAgICAgIG1pbkhlaWdodDogNzY4LFxyXG4gICAgICBtaW5XaWR0aDogMTM2NixcclxuICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgIGF1dG9IaWRlTWVudUJhcjogdHJ1ZSxcclxuICAgICAgd2ViUHJlZmVyZW5jZXM6IHtcclxuICAgICAgICBwcmVsb2FkOiBwYXRoLmpvaW4oX19kaXJuYW1lLCBcInByZWxvYWQuanNcIiksXHJcbiAgICAgICAgd2ViU2VjdXJpdHk6IGZhbHNlLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgICBpZiAoIWlzUHJvZCkge1xyXG4gICAgICB3aW5kb3cud2ViQ29udGVudHMub3BlbkRldlRvb2xzKCk7XHJcbiAgICB9XHJcbiAgICB3aW5kb3cuc2V0QmFja2dyb3VuZENvbG9yKFwiIzFBMjAyQ1wiKTtcclxuICAgIGF3YWl0IHdpbmRvdy5sb2FkVVJMKGdldEJhY2tlbmRQYXRoKFwibWFpblwiKSk7XHJcbiAgICB3aW5kb3cuY2VudGVyKCk7XHJcbiAgICB3aW5kb3cubWF4aW1pemUoKTtcclxuICAgIHdpbmRvdy5vbihcImNsb3NlXCIsICgpID0+IHtcclxuICAgICAgYXBwLmV4aXQoMCk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB3aW5kb3c7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgUHJpc21hQ2xpZW50IH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlcy9nZW5lcmF0ZWQvcHJpc21hL2NsaWVudFwiO1xyXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsc1wiO1xyXG5cclxuLy8gR2V0dGluZyBEYXRhYmFzZSBVcmxcclxuY29uc3QgZGF0YWJhc2VVcmwgPSBwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkw7XHJcblxyXG4vLyBDYWxsIE9STSBjbGllbnQgb25jZVxyXG5jb25zdCBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KHtcclxuICBkYXRhc291cmNlczoge1xyXG4gICAgZGI6IHtcclxuICAgICAgdXJsOiBkYXRhYmFzZVVybCxcclxuICAgIH0sXHJcbiAgfSxcclxufSk7XHJcblxyXG4vLyBQcmlzbWEgT1JNIGNvcmUgZnVuY3Rpb24uIENhbGxzIGRhdGFiYXNlIGFuZCByZXR1cm4gcXVlcnkuXHJcbmV4cG9ydCBjb25zdCBwcmlzbWFTZXJ2aWNlID0gYXN5bmMgKHsgdGFibGUsIGZuLCBhcmdzIH0pID0+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcXVlcnkgPSBhd2FpdCBwcmlzbWFbdGFibGVdW2ZuXShhcmdzKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHN0YXR1czogMjAwLFxyXG4gICAgICBkYXRhOiBxdWVyeSxcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGF3YWl0IGxvZ2dlcihgRXJyb3I6IFByaXNtYSBTZXJ2aWNlIC0gJHtlcnJvcn1gKTtcclxuICAgIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3RhdHVzOiBlcnJvci5jb2RlIHx8IGVycm9yLmVycm9yQ29kZSB8fCA1MDAsXHJcbiAgICAgIGRhdGE6IGBFcnJvcjogUHJpc21hIEVycm9yICR7ZXJyb3J9YCxcclxuICAgIH07XHJcbiAgfSBmaW5hbGx5IHtcclxuICAgIGF3YWl0IHByaXNtYS4kZGlzY29ubmVjdCgpO1xyXG4gIH1cclxufTtcclxuIiwiXG4vKiAhISEgVGhpcyBpcyBjb2RlIGdlbmVyYXRlZCBieSBQcmlzbWEuIERvIG5vdCBlZGl0IGRpcmVjdGx5LiAhISEgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVjayBcbi8qKlxuICogVGhpcyBmaWxlIHNob3VsZCBiZSB5b3VyIG1haW4gaW1wb3J0IHRvIHVzZSBQcmlzbWEuIFRocm91Z2ggaXQgeW91IGdldCBhY2Nlc3MgdG8gYWxsIHRoZSBtb2RlbHMsIGVudW1zLCBhbmQgaW5wdXQgdHlwZXMuXG4gKlxuICog8J+foiBZb3UgY2FuIGltcG9ydCB0aGlzIGZpbGUgZGlyZWN0bHkuXG4gKi9cblxuaW1wb3J0ICogYXMgcHJvY2VzcyBmcm9tICdub2RlOnByb2Nlc3MnXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tICdub2RlOnVybCdcbmNvbnN0IF9fZGlybmFtZSA9IHBhdGguZGlybmFtZShmaWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCkpXG5cbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSBcIkBwcmlzbWEvY2xpZW50L3J1bnRpbWUvbGlicmFyeVwiXG5pbXBvcnQgKiBhcyAkRW51bXMgZnJvbSBcIi4vZW51bXMudHNcIlxuaW1wb3J0ICogYXMgJENsYXNzIGZyb20gXCIuL2ludGVybmFsL2NsYXNzLnRzXCJcbmltcG9ydCAqIGFzIFByaXNtYSBmcm9tIFwiLi9pbnRlcm5hbC9wcmlzbWFOYW1lc3BhY2UudHNcIlxuXG5leHBvcnQgKiBhcyAkRW51bXMgZnJvbSAnLi9lbnVtcy50cydcbi8qKlxuICogIyMgUHJpc21hIENsaWVudFxuICogXG4gKiBUeXBlLXNhZmUgZGF0YWJhc2UgY2xpZW50IGZvciBUeXBlU2NyaXB0XG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBwcmlzbWEgPSBuZXcgUHJpc21hQ2xpZW50KClcbiAqIC8vIEZldGNoIHplcm8gb3IgbW9yZSBVc2Vyc1xuICogY29uc3QgdXNlcnMgPSBhd2FpdCBwcmlzbWEudXNlci5maW5kTWFueSgpXG4gKiBgYGBcbiAqIFxuICogUmVhZCBtb3JlIGluIG91ciBbZG9jc10oaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvcmVmZXJlbmNlL3Rvb2xzLWFuZC1pbnRlcmZhY2VzL3ByaXNtYS1jbGllbnQpLlxuICovXG5leHBvcnQgY29uc3QgUHJpc21hQ2xpZW50ID0gJENsYXNzLmdldFByaXNtYUNsaWVudENsYXNzKF9fZGlybmFtZSlcbmV4cG9ydCB0eXBlIFByaXNtYUNsaWVudDxDbGllbnRPcHRpb25zIGV4dGVuZHMgUHJpc21hLlByaXNtYUNsaWVudE9wdGlvbnMgPSBQcmlzbWEuUHJpc21hQ2xpZW50T3B0aW9ucywgTG9nID0gJENsYXNzLkxvZ09wdGlvbnM8Q2xpZW50T3B0aW9ucz4sIEV4dEFyZ3MgZXh0ZW5kcyBydW50aW1lLlR5cGVzLkV4dGVuc2lvbnMuSW50ZXJuYWxBcmdzID0gcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLkRlZmF1bHRBcmdzPiA9ICRDbGFzcy5QcmlzbWFDbGllbnQ8Q2xpZW50T3B0aW9ucywgTG9nLCBFeHRBcmdzPlxuZXhwb3J0IHsgUHJpc21hIH1cblxuXG4vLyBmaWxlIGFubm90YXRpb25zIGZvciBidW5kbGluZyB0b29scyB0byBpbmNsdWRlIHRoZXNlIGZpbGVzXG5wYXRoLmpvaW4oX19kaXJuYW1lLCBcInF1ZXJ5X2VuZ2luZS13aW5kb3dzLmRsbC5ub2RlXCIpXG5wYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgXCJnZW5lcmF0ZWQvcHJpc21hL3F1ZXJ5X2VuZ2luZS13aW5kb3dzLmRsbC5ub2RlXCIpXG5cbi8qKlxuICogTW9kZWwgVXNlclxuICogXG4gKi9cbmV4cG9ydCB0eXBlIFVzZXIgPSBQcmlzbWEuVXNlck1vZGVsXG4vKipcbiAqIE1vZGVsIExhdW5jaGVyXG4gKiBcbiAqL1xuZXhwb3J0IHR5cGUgTGF1bmNoZXIgPSBQcmlzbWEuTGF1bmNoZXJNb2RlbFxuLyoqXG4gKiBNb2RlbCBNb3RkXG4gKiBcbiAqL1xuZXhwb3J0IHR5cGUgTW90ZCA9IFByaXNtYS5Nb3RkTW9kZWxcbi8qKlxuICogTW9kZWwgU2VydmVyXG4gKiBcbiAqL1xuZXhwb3J0IHR5cGUgU2VydmVyID0gUHJpc21hLlNlcnZlck1vZGVsXG4vKipcbiAqIE1vZGVsIFNlcnZlclRhZ1xuICogXG4gKi9cbmV4cG9ydCB0eXBlIFNlcnZlclRhZyA9IFByaXNtYS5TZXJ2ZXJUYWdNb2RlbFxuLyoqXG4gKiBNb2RlbCBBcnRpY2xlc1xuICogXG4gKi9cbmV4cG9ydCB0eXBlIEFydGljbGVzID0gUHJpc21hLkFydGljbGVzTW9kZWxcblxuXG4iLCJcbi8qICEhISBUaGlzIGlzIGNvZGUgZ2VuZXJhdGVkIGJ5IFByaXNtYS4gRG8gbm90IGVkaXQgZGlyZWN0bHkuICEhISAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrIFxuLyoqXG4qIFRoaXMgZmlsZSBleHBvcnRzIGFsbCBlbnVtIHJlbGF0ZWQgdHlwZXMgZnJvbSB0aGUgc2NoZW1hLlxuKlxuKiDwn5+iIFlvdSBjYW4gaW1wb3J0IHRoaXMgZmlsZSBkaXJlY3RseS5cbiovXG5cblxuLy8gVGhpcyBmaWxlIGlzIGVtcHR5IGJlY2F1c2UgdGhlcmUgYXJlIG5vIGVudW1zIGluIHRoZSBzY2hlbWEuXG5leHBvcnQge31cbiIsIlxuLyogISEhIFRoaXMgaXMgY29kZSBnZW5lcmF0ZWQgYnkgUHJpc21hLiBEbyBub3QgZWRpdCBkaXJlY3RseS4gISEhICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2sgXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgaXMgYW4gaW50ZXJuYWwgZmlsZSB0aGF0IGlzIHN1YmplY3QgdG8gY2hhbmdlIVxuICpcbiAqIPCfm5EgVW5kZXIgbm8gY2lyY3Vtc3RhbmNlcyBzaG91bGQgeW91IGltcG9ydCB0aGlzIGZpbGUgZGlyZWN0bHkhIPCfm5FcbiAqXG4gKiBQbGVhc2UgaW1wb3J0IHRoZSBgUHJpc21hQ2xpZW50YCBjbGFzcyBmcm9tIHRoZSBgY2xpZW50LnRzYCBmaWxlIGluc3RlYWQuXG4gKi9cblxuaW1wb3J0ICogYXMgcnVudGltZSBmcm9tIFwiQHByaXNtYS9jbGllbnQvcnVudGltZS9saWJyYXJ5XCJcbmltcG9ydCB0eXBlICogYXMgUHJpc21hIGZyb20gXCIuL3ByaXNtYU5hbWVzcGFjZS50c1wiXG5cblxuY29uc3QgY29uZmlnOiBydW50aW1lLkdldFByaXNtYUNsaWVudENvbmZpZyA9IHtcbiAgXCJnZW5lcmF0b3JcIjoge1xuICAgIFwibmFtZVwiOiBcImNsaWVudFwiLFxuICAgIFwicHJvdmlkZXJcIjoge1xuICAgICAgXCJmcm9tRW52VmFyXCI6IG51bGwsXG4gICAgICBcInZhbHVlXCI6IFwicHJpc21hLWNsaWVudFwiXG4gICAgfSxcbiAgICBcIm91dHB1dFwiOiB7XG4gICAgICBcInZhbHVlXCI6IFwiRDpcXFxcR2l0XFxcXG5leHRyb24tYXV0b3VwZGF0ZS1hcHBcXFxcZ2VuZXJhdGVkXFxcXHByaXNtYVwiLFxuICAgICAgXCJmcm9tRW52VmFyXCI6IG51bGxcbiAgICB9LFxuICAgIFwiY29uZmlnXCI6IHtcbiAgICAgIFwibW9kdWxlRm9ybWF0XCI6IFwiZXNtXCIsXG4gICAgICBcImVuZ2luZVR5cGVcIjogXCJsaWJyYXJ5XCJcbiAgICB9LFxuICAgIFwiYmluYXJ5VGFyZ2V0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiZnJvbUVudlZhclwiOiBudWxsLFxuICAgICAgICBcInZhbHVlXCI6IFwid2luZG93c1wiLFxuICAgICAgICBcIm5hdGl2ZVwiOiB0cnVlXG4gICAgICB9XG4gICAgXSxcbiAgICBcInByZXZpZXdGZWF0dXJlc1wiOiBbXSxcbiAgICBcInNvdXJjZUZpbGVQYXRoXCI6IFwiRDpcXFxcR2l0XFxcXG5leHRyb24tYXV0b3VwZGF0ZS1hcHBcXFxccHJpc21hXFxcXHNjaGVtYS5wcmlzbWFcIixcbiAgICBcImlzQ3VzdG9tT3V0cHV0XCI6IHRydWVcbiAgfSxcbiAgXCJyZWxhdGl2ZVBhdGhcIjogXCIuLi8uLi9wcmlzbWFcIixcbiAgXCJjbGllbnRWZXJzaW9uXCI6IFwiNi4xMi4wXCIsXG4gIFwiZW5naW5lVmVyc2lvblwiOiBcIjgwNDdjOTZiYmQ5MmRiOThhMmFiYzdjOTMyM2NlNzdjMDJjODlkYmNcIixcbiAgXCJkYXRhc291cmNlTmFtZXNcIjogW1xuICAgIFwiZGJcIlxuICBdLFxuICBcImFjdGl2ZVByb3ZpZGVyXCI6IFwibXlzcWxcIixcbiAgXCJwb3N0aW5zdGFsbFwiOiBmYWxzZSxcbiAgXCJpbmxpbmVEYXRhc291cmNlc1wiOiB7XG4gICAgXCJkYlwiOiB7XG4gICAgICBcInVybFwiOiB7XG4gICAgICAgIFwiZnJvbUVudlZhclwiOiBcIkRBVEFCQVNFX1VSTFwiLFxuICAgICAgICBcInZhbHVlXCI6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiaW5saW5lU2NoZW1hXCI6IFwiLy8gVGhpcyBpcyB5b3VyIFByaXNtYSBzY2hlbWEgZmlsZSxcXG4vLyBsZWFybiBtb3JlIGFib3V0IGl0IGluIHRoZSBkb2NzOiBodHRwczovL3ByaXMubHkvZC9wcmlzbWEtc2NoZW1hXFxuXFxuLy8gTG9va2luZyBmb3Igd2F5cyB0byBzcGVlZCB1cCB5b3VyIHF1ZXJpZXMsIG9yIHNjYWxlIGVhc2lseSB3aXRoIHlvdXIgc2VydmVybGVzcyBvciBlZGdlIGZ1bmN0aW9ucz9cXG4vLyBUcnkgUHJpc21hIEFjY2VsZXJhdGU6IGh0dHBzOi8vcHJpcy5seS9jbGkvYWNjZWxlcmF0ZS1pbml0XFxuXFxuZ2VuZXJhdG9yIGNsaWVudCB7XFxuICBwcm92aWRlciAgICAgID0gXFxcInByaXNtYS1jbGllbnRcXFwiXFxuICBvdXRwdXQgICAgICAgID0gXFxcIi4uL2dlbmVyYXRlZC9wcmlzbWFcXFwiXFxuICBtb2R1bGVGb3JtYXQgID0gXFxcImVzbVxcXCJcXG4gIC8vIGJpbmFyeVRhcmdldHMgPSBbXFxcImRlYmlhbi1vcGVuc3NsLTMuMC54XFxcIiwgXFxcImRhcndpblxcXCIsIFxcXCJkYXJ3aW4tYXJtNjRcXFwiLCBcXFwid2luZG93c1xcXCIsIFxcXCJuYXRpdmVcXFwiXVxcbiAgYmluYXJ5VGFyZ2V0cyA9IFtcXFwibmF0aXZlXFxcIl1cXG59XFxuXFxuZGF0YXNvdXJjZSBkYiB7XFxuICBwcm92aWRlciA9IFxcXCJteXNxbFxcXCJcXG4gIHVybCAgICAgID0gZW52KFxcXCJEQVRBQkFTRV9VUkxcXFwiKVxcbn1cXG5cXG5tb2RlbCBVc2VyIHtcXG4gIGlkICAgICAgICBTdHJpbmcgICBAaWQgQHVuaXF1ZSBAZGVmYXVsdChjdWlkKCkpXFxuICBlbWFpbCAgICAgU3RyaW5nICAgQHVuaXF1ZVxcbiAgbmFtZSAgICAgIFN0cmluZyAgIEB1bmlxdWVcXG4gIHBhc3N3b3JkICBTdHJpbmcgICBAZGVmYXVsdChcXFwiXFxcIilcXG4gIHBvbGxUYWdzICBTdHJpbmdcXG4gIGNyZWF0ZWRBdCBEYXRlVGltZSBAZGVmYXVsdChub3coKSlcXG4gIHVwZGF0ZWRBdCBEYXRlVGltZSBAdXBkYXRlZEF0XFxufVxcblxcbm1vZGVsIExhdW5jaGVyIHtcXG4gIGlkICAgICAgICBTdHJpbmcgICBAaWQgQHVuaXF1ZSBAZGVmYXVsdChjdWlkKCkpXFxuICBkYXRhVHlwZSAgU3RyaW5nICAgQHVuaXF1ZVxcbiAgZGF0YVZhbHVlIFN0cmluZyAgIEBkYi5Mb25nVGV4dFxcbiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKVxcbiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXRcXG59XFxuXFxubW9kZWwgTW90ZCB7XFxuICBpZCAgICAgICAgU3RyaW5nICAgQGlkIEB1bmlxdWUgQGRlZmF1bHQoY3VpZCgpKVxcbiAgbW90ZCAgICAgIFN0cmluZyAgIEBkYi5Mb25nVGV4dFxcbiAgY3JlYXRlZEF0IERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKVxcbiAgdXBkYXRlZEF0IERhdGVUaW1lIEB1cGRhdGVkQXRcXG59XFxuXFxubW9kZWwgU2VydmVyIHtcXG4gIGlkICAgICAgICAgU3RyaW5nICAgICAgQGlkIEB1bmlxdWUgQGRlZmF1bHQoY3VpZCgpKVxcbiAgc2VydmVySWQgICBJbnQgICAgICAgICBAdW5pcXVlXFxuICBuYW1lICAgICAgIFN0cmluZ1xcbiAgZGVzYyAgICAgICBTdHJpbmcgICAgICBAZGVmYXVsdChcXFwiXFxcIilcXG4gIG1jVmVyc2lvbiAgU3RyaW5nICAgICAgQGRlZmF1bHQoXFxcIjEuNy4xMFxcXCIpXFxuICBkaWZmaWN1bHR5IEludCAgICAgICAgIEBkZWZhdWx0KDIpXFxuICBhc3NldHMgICAgIFN0cmluZyAgICAgIEBkZWZhdWx0KFxcXCJcXFwiKVxcbiAgY29yZSAgICAgICBTdHJpbmcgICAgICBAZGVmYXVsdChcXFwiXFxcIilcXG4gIG1vZHBhY2sgICAgU3RyaW5nICAgICAgQGRlZmF1bHQoXFxcIlxcXCIpXFxuICBhdmFpbGFibGUgIEJvb2xlYW4gICAgIEBkZWZhdWx0KGZhbHNlKVxcbiAgbW9kZGVkICAgICBCb29sZWFuICAgICBAZGVmYXVsdChmYWxzZSlcXG4gIGZlYXR1cmVkICAgU3RyaW5nICAgICAgQGRlZmF1bHQoXFxcIlxcXCIpXFxuICBwZXJpb2RpYyAgIEJvb2xlYW4gICAgIEBkZWZhdWx0KGZhbHNlKVxcbiAgdGFncyAgICAgICBTZXJ2ZXJUYWdbXVxcbiAgY3JlYXRlZEF0ICBEYXRlVGltZSAgICBAZGVmYXVsdChub3coKSlcXG4gIHVwZGF0ZWRBdCAgRGF0ZVRpbWUgICAgQHVwZGF0ZWRBdFxcbn1cXG5cXG5tb2RlbCBTZXJ2ZXJUYWcge1xcbiAgaWQgICAgICAgIFN0cmluZyAgIEBpZCBAdW5pcXVlIEBkZWZhdWx0KGN1aWQoKSlcXG4gIHRhZ0lkICAgICBJbnQgICAgICBAdW5pcXVlXFxuICBuYW1lICAgICAgU3RyaW5nICAgQHVuaXF1ZVxcbiAgZGVzYyAgICAgIFN0cmluZ1xcbiAgc2VydmVycyAgIFNlcnZlcltdXFxuICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpXFxuICB1cGRhdGVkQXQgRGF0ZVRpbWUgQHVwZGF0ZWRBdFxcbn1cXG5cXG5tb2RlbCBBcnRpY2xlcyB7XFxuICBpZCAgICAgICAgU3RyaW5nICAgQGlkIEB1bmlxdWUgQGRlZmF1bHQoY3VpZCgpKVxcbiAgYXJ0aWNsZUlkIEludCAgICAgIEB1bmlxdWVcXG4gIHNlcnZlcklkICBJbnQgICAgICBAZGVmYXVsdCgtMSlcXG4gIHRhYk5hbWUgICBTdHJpbmdcXG4gIHBhZ2VPcmRlciBJbnQgICAgICBAZGVmYXVsdCgwKVxcbiAgdGl0bGUgICAgIFN0cmluZyAgIEBkZWZhdWx0KFxcXCJcXFwiKVxcbiAgc3VidGl0bGUgIFN0cmluZyAgIEBkZWZhdWx0KFxcXCJcXFwiKVxcbiAgdGV4dCAgICAgIFN0cmluZyAgIEBkYi5Mb25nVGV4dFxcbiAgYXZhaWxhYmxlIEJvb2xlYW4gIEBkZWZhdWx0KHRydWUpXFxuICBjcmVhdGVkQXQgRGF0ZVRpbWUgQGRlZmF1bHQobm93KCkpXFxuICB1cGRhdGVkQXQgRGF0ZVRpbWUgQHVwZGF0ZWRBdFxcbn1cXG5cIixcbiAgXCJpbmxpbmVTY2hlbWFIYXNoXCI6IFwiNjM0OTgxMzQ2YTNhY2IzYzg2Mjg0NTE2MmQ5ZGU1MGZhYmNmYWMzMTZjYjY0NjgxNWU0MGFhNjNjYTAwYWU0MlwiLFxuICBcImNvcHlFbmdpbmVcIjogdHJ1ZSxcbiAgXCJydW50aW1lRGF0YU1vZGVsXCI6IHtcbiAgICBcIm1vZGVsc1wiOiB7fSxcbiAgICBcImVudW1zXCI6IHt9LFxuICAgIFwidHlwZXNcIjoge31cbiAgfSxcbiAgXCJkaXJuYW1lXCI6IFwiXCJcbn1cblxuY29uZmlnLnJ1bnRpbWVEYXRhTW9kZWwgPSBKU09OLnBhcnNlKFwie1xcXCJtb2RlbHNcXFwiOntcXFwiVXNlclxcXCI6e1xcXCJkYk5hbWVcXFwiOm51bGwsXFxcInNjaGVtYVxcXCI6bnVsbCxcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOlsxXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJlbWFpbFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6dHJ1ZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcIm5hbWVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOnRydWUsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJwYXNzd29yZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6XFxcIlxcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJwb2xsVGFnc1xcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJjcmVhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIkRhdGVUaW1lXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwibm93XFxcIixcXFwiYXJnc1xcXCI6W119LFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwidXBkYXRlZEF0XFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjp0cnVlfV0sXFxcInByaW1hcnlLZXlcXFwiOm51bGwsXFxcInVuaXF1ZUZpZWxkc1xcXCI6W10sXFxcInVuaXF1ZUluZGV4ZXNcXFwiOltdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2V9LFxcXCJMYXVuY2hlclxcXCI6e1xcXCJkYk5hbWVcXFwiOm51bGwsXFxcInNjaGVtYVxcXCI6bnVsbCxcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOlsxXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJkYXRhVHlwZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6dHJ1ZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImRhdGFWYWx1ZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOltcXFwiTG9uZ1RleHRcXFwiLFtdXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImNyZWF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJub3dcXFwiLFxcXCJhcmdzXFxcIjpbXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJ1cGRhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOnRydWV9XSxcXFwicHJpbWFyeUtleVxcXCI6bnVsbCxcXFwidW5pcXVlRmllbGRzXFxcIjpbXSxcXFwidW5pcXVlSW5kZXhlc1xcXCI6W10sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZX0sXFxcIk1vdGRcXFwiOntcXFwiZGJOYW1lXFxcIjpudWxsLFxcXCJzY2hlbWFcXFwiOm51bGwsXFxcImZpZWxkc1xcXCI6W3tcXFwibmFtZVxcXCI6XFxcImlkXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6dHJ1ZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOntcXFwibmFtZVxcXCI6XFxcImN1aWRcXFwiLFxcXCJhcmdzXFxcIjpbMV19LFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwibW90ZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOltcXFwiTG9uZ1RleHRcXFwiLFtdXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImNyZWF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJub3dcXFwiLFxcXCJhcmdzXFxcIjpbXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJ1cGRhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOnRydWV9XSxcXFwicHJpbWFyeUtleVxcXCI6bnVsbCxcXFwidW5pcXVlRmllbGRzXFxcIjpbXSxcXFwidW5pcXVlSW5kZXhlc1xcXCI6W10sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZX0sXFxcIlNlcnZlclxcXCI6e1xcXCJkYk5hbWVcXFwiOm51bGwsXFxcInNjaGVtYVxcXCI6bnVsbCxcXFwiZmllbGRzXFxcIjpbe1xcXCJuYW1lXFxcIjpcXFwiaWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjp0cnVlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwiY3VpZFxcXCIsXFxcImFyZ3NcXFwiOlsxXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJzZXJ2ZXJJZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6dHJ1ZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiSW50XFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcIm5hbWVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwiZGVzY1xcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6XFxcIlxcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJtY1ZlcnNpb25cXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOlxcXCIxLjcuMTBcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwiZGlmZmljdWx0eVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiSW50XFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6MixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImFzc2V0c1xcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6XFxcIlxcXCIsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJjb3JlXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjpcXFwiXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcIm1vZHBhY2tcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOlxcXCJcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwiYXZhaWxhYmxlXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJCb29sZWFuXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6ZmFsc2UsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJtb2RkZWRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIkJvb2xlYW5cXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjpmYWxzZSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImZlYXR1cmVkXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjpcXFwiXFxcIixcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInBlcmlvZGljXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJCb29sZWFuXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6ZmFsc2UsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJ0YWdzXFxcIixcXFwia2luZFxcXCI6XFxcIm9iamVjdFxcXCIsXFxcImlzTGlzdFxcXCI6dHJ1ZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTZXJ2ZXJUYWdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJyZWxhdGlvbk5hbWVcXFwiOlxcXCJTZXJ2ZXJUb1NlcnZlclRhZ1xcXCIsXFxcInJlbGF0aW9uRnJvbUZpZWxkc1xcXCI6W10sXFxcInJlbGF0aW9uVG9GaWVsZHNcXFwiOltdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwiY3JlYXRlZEF0XFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOntcXFwibmFtZVxcXCI6XFxcIm5vd1xcXCIsXFxcImFyZ3NcXFwiOltdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInVwZGF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIkRhdGVUaW1lXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6dHJ1ZX1dLFxcXCJwcmltYXJ5S2V5XFxcIjpudWxsLFxcXCJ1bmlxdWVGaWVsZHNcXFwiOltdLFxcXCJ1bmlxdWVJbmRleGVzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlfSxcXFwiU2VydmVyVGFnXFxcIjp7XFxcImRiTmFtZVxcXCI6bnVsbCxcXFwic2NoZW1hXFxcIjpudWxsLFxcXCJmaWVsZHNcXFwiOlt7XFxcIm5hbWVcXFwiOlxcXCJpZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOnRydWUsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJjdWlkXFxcIixcXFwiYXJnc1xcXCI6WzFdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInRhZ0lkXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjp0cnVlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJJbnRcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwibmFtZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6dHJ1ZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU3RyaW5nXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImRlc2NcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwic2VydmVyc1xcXCIsXFxcImtpbmRcXFwiOlxcXCJvYmplY3RcXFwiLFxcXCJpc0xpc3RcXFwiOnRydWUsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiU2VydmVyXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwicmVsYXRpb25OYW1lXFxcIjpcXFwiU2VydmVyVG9TZXJ2ZXJUYWdcXFwiLFxcXCJyZWxhdGlvbkZyb21GaWVsZHNcXFwiOltdLFxcXCJyZWxhdGlvblRvRmllbGRzXFxcIjpbXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImNyZWF0ZWRBdFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJub3dcXFwiLFxcXCJhcmdzXFxcIjpbXX0sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJ1cGRhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJEYXRlVGltZVxcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOnRydWV9XSxcXFwicHJpbWFyeUtleVxcXCI6bnVsbCxcXFwidW5pcXVlRmllbGRzXFxcIjpbXSxcXFwidW5pcXVlSW5kZXhlc1xcXCI6W10sXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZX0sXFxcIkFydGljbGVzXFxcIjp7XFxcImRiTmFtZVxcXCI6bnVsbCxcXFwic2NoZW1hXFxcIjpudWxsLFxcXCJmaWVsZHNcXFwiOlt7XFxcIm5hbWVcXFwiOlxcXCJpZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOnRydWUsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjp7XFxcIm5hbWVcXFwiOlxcXCJjdWlkXFxcIixcXFwiYXJnc1xcXCI6WzFdfSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImFydGljbGVJZFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6dHJ1ZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiSW50XFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInNlcnZlcklkXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJJbnRcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjotMSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcInRhYk5hbWVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6ZmFsc2UsXFxcInR5cGVcXFwiOlxcXCJTdHJpbmdcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwicGFnZU9yZGVyXFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOnRydWUsXFxcInR5cGVcXFwiOlxcXCJJbnRcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJkZWZhdWx0XFxcIjowLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwidGl0bGVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOlxcXCJcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwic3VidGl0bGVcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOlxcXCJcXFwiLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwidGV4dFxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjpmYWxzZSxcXFwidHlwZVxcXCI6XFxcIlN0cmluZ1xcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOltcXFwiTG9uZ1RleHRcXFwiLFtdXSxcXFwiaXNHZW5lcmF0ZWRcXFwiOmZhbHNlLFxcXCJpc1VwZGF0ZWRBdFxcXCI6ZmFsc2V9LHtcXFwibmFtZVxcXCI6XFxcImF2YWlsYWJsZVxcXCIsXFxcImtpbmRcXFwiOlxcXCJzY2FsYXJcXFwiLFxcXCJpc0xpc3RcXFwiOmZhbHNlLFxcXCJpc1JlcXVpcmVkXFxcIjp0cnVlLFxcXCJpc1VuaXF1ZVxcXCI6ZmFsc2UsXFxcImlzSWRcXFwiOmZhbHNlLFxcXCJpc1JlYWRPbmx5XFxcIjpmYWxzZSxcXFwiaGFzRGVmYXVsdFZhbHVlXFxcIjp0cnVlLFxcXCJ0eXBlXFxcIjpcXFwiQm9vbGVhblxcXCIsXFxcIm5hdGl2ZVR5cGVcXFwiOm51bGwsXFxcImRlZmF1bHRcXFwiOnRydWUsXFxcImlzR2VuZXJhdGVkXFxcIjpmYWxzZSxcXFwiaXNVcGRhdGVkQXRcXFwiOmZhbHNlfSx7XFxcIm5hbWVcXFwiOlxcXCJjcmVhdGVkQXRcXFwiLFxcXCJraW5kXFxcIjpcXFwic2NhbGFyXFxcIixcXFwiaXNMaXN0XFxcIjpmYWxzZSxcXFwiaXNSZXF1aXJlZFxcXCI6dHJ1ZSxcXFwiaXNVbmlxdWVcXFwiOmZhbHNlLFxcXCJpc0lkXFxcIjpmYWxzZSxcXFwiaXNSZWFkT25seVxcXCI6ZmFsc2UsXFxcImhhc0RlZmF1bHRWYWx1ZVxcXCI6dHJ1ZSxcXFwidHlwZVxcXCI6XFxcIkRhdGVUaW1lXFxcIixcXFwibmF0aXZlVHlwZVxcXCI6bnVsbCxcXFwiZGVmYXVsdFxcXCI6e1xcXCJuYW1lXFxcIjpcXFwibm93XFxcIixcXFwiYXJnc1xcXCI6W119LFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjpmYWxzZX0se1xcXCJuYW1lXFxcIjpcXFwidXBkYXRlZEF0XFxcIixcXFwia2luZFxcXCI6XFxcInNjYWxhclxcXCIsXFxcImlzTGlzdFxcXCI6ZmFsc2UsXFxcImlzUmVxdWlyZWRcXFwiOnRydWUsXFxcImlzVW5pcXVlXFxcIjpmYWxzZSxcXFwiaXNJZFxcXCI6ZmFsc2UsXFxcImlzUmVhZE9ubHlcXFwiOmZhbHNlLFxcXCJoYXNEZWZhdWx0VmFsdWVcXFwiOmZhbHNlLFxcXCJ0eXBlXFxcIjpcXFwiRGF0ZVRpbWVcXFwiLFxcXCJuYXRpdmVUeXBlXFxcIjpudWxsLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2UsXFxcImlzVXBkYXRlZEF0XFxcIjp0cnVlfV0sXFxcInByaW1hcnlLZXlcXFwiOm51bGwsXFxcInVuaXF1ZUZpZWxkc1xcXCI6W10sXFxcInVuaXF1ZUluZGV4ZXNcXFwiOltdLFxcXCJpc0dlbmVyYXRlZFxcXCI6ZmFsc2V9fSxcXFwiZW51bXNcXFwiOnt9LFxcXCJ0eXBlc1xcXCI6e319XCIpXG5jb25maWcuZW5naW5lV2FzbSA9IHVuZGVmaW5lZFxuY29uZmlnLmNvbXBpbGVyV2FzbSA9IHVuZGVmaW5lZFxuXG5cblxuXG5leHBvcnQgdHlwZSBMb2dPcHRpb25zPENsaWVudE9wdGlvbnMgZXh0ZW5kcyBQcmlzbWEuUHJpc21hQ2xpZW50T3B0aW9ucz4gPVxuICAnbG9nJyBleHRlbmRzIGtleW9mIENsaWVudE9wdGlvbnMgPyBDbGllbnRPcHRpb25zWydsb2cnXSBleHRlbmRzIEFycmF5PFByaXNtYS5Mb2dMZXZlbCB8IFByaXNtYS5Mb2dEZWZpbml0aW9uPiA/IFByaXNtYS5HZXRFdmVudHM8Q2xpZW50T3B0aW9uc1snbG9nJ10+IDogbmV2ZXIgOiBuZXZlclxuXG5leHBvcnQgaW50ZXJmYWNlIFByaXNtYUNsaWVudENvbnN0cnVjdG9yIHtcbiAgICAvKipcbiAgICogIyMgUHJpc21hIENsaWVudFxuICAgKiBcbiAgICogVHlwZS1zYWZlIGRhdGFiYXNlIGNsaWVudCBmb3IgVHlwZVNjcmlwdFxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgcHJpc21hID0gbmV3IFByaXNtYUNsaWVudCgpXG4gICAqIC8vIEZldGNoIHplcm8gb3IgbW9yZSBVc2Vyc1xuICAgKiBjb25zdCB1c2VycyA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRNYW55KClcbiAgICogYGBgXG4gICAqIFxuICAgKiBSZWFkIG1vcmUgaW4gb3VyIFtkb2NzXShodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9yZWZlcmVuY2UvdG9vbHMtYW5kLWludGVyZmFjZXMvcHJpc21hLWNsaWVudCkuXG4gICAqL1xuXG4gIG5ldyA8XG4gICAgQ2xpZW50T3B0aW9ucyBleHRlbmRzIFByaXNtYS5QcmlzbWFDbGllbnRPcHRpb25zID0gUHJpc21hLlByaXNtYUNsaWVudE9wdGlvbnMsXG4gICAgVSA9IExvZ09wdGlvbnM8Q2xpZW50T3B0aW9ucz4sXG4gICAgRXh0QXJncyBleHRlbmRzIHJ1bnRpbWUuVHlwZXMuRXh0ZW5zaW9ucy5JbnRlcm5hbEFyZ3MgPSBydW50aW1lLlR5cGVzLkV4dGVuc2lvbnMuRGVmYXVsdEFyZ3NcbiAgPihvcHRpb25zPzogUHJpc21hLlN1YnNldDxDbGllbnRPcHRpb25zLCBQcmlzbWEuUHJpc21hQ2xpZW50T3B0aW9ucz4pOiBQcmlzbWFDbGllbnQ8Q2xpZW50T3B0aW9ucywgVSwgRXh0QXJncz5cbn1cblxuLyoqXG4gKiAjIyBQcmlzbWEgQ2xpZW50XG4gKiBcbiAqIFR5cGUtc2FmZSBkYXRhYmFzZSBjbGllbnQgZm9yIFR5cGVTY3JpcHRcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IHByaXNtYSA9IG5ldyBQcmlzbWFDbGllbnQoKVxuICogLy8gRmV0Y2ggemVybyBvciBtb3JlIFVzZXJzXG4gKiBjb25zdCB1c2VycyA9IGF3YWl0IHByaXNtYS51c2VyLmZpbmRNYW55KClcbiAqIGBgYFxuICogXG4gKiBSZWFkIG1vcmUgaW4gb3VyIFtkb2NzXShodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9yZWZlcmVuY2UvdG9vbHMtYW5kLWludGVyZmFjZXMvcHJpc21hLWNsaWVudCkuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBQcmlzbWFDbGllbnQ8XG4gIENsaWVudE9wdGlvbnMgZXh0ZW5kcyBQcmlzbWEuUHJpc21hQ2xpZW50T3B0aW9ucyA9IFByaXNtYS5QcmlzbWFDbGllbnRPcHRpb25zLFxuICBVID0gTG9nT3B0aW9uczxDbGllbnRPcHRpb25zPixcbiAgRXh0QXJncyBleHRlbmRzIHJ1bnRpbWUuVHlwZXMuRXh0ZW5zaW9ucy5JbnRlcm5hbEFyZ3MgPSBydW50aW1lLlR5cGVzLkV4dGVuc2lvbnMuRGVmYXVsdEFyZ3Ncbj4ge1xuICBbSzogc3ltYm9sXTogeyB0eXBlczogUHJpc21hLlR5cGVNYXA8RXh0QXJncz5bJ290aGVyJ10gfVxuXG4gICRvbjxWIGV4dGVuZHMgVT4oZXZlbnRUeXBlOiBWLCBjYWxsYmFjazogKGV2ZW50OiBWIGV4dGVuZHMgJ3F1ZXJ5JyA/IFByaXNtYS5RdWVyeUV2ZW50IDogUHJpc21hLkxvZ0V2ZW50KSA9PiB2b2lkKTogUHJpc21hQ2xpZW50O1xuXG4gIC8qKlxuICAgKiBDb25uZWN0IHdpdGggdGhlIGRhdGFiYXNlXG4gICAqL1xuICAkY29ubmVjdCgpOiBydW50aW1lLlR5cGVzLlV0aWxzLkpzUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBkYXRhYmFzZVxuICAgKi9cbiAgJGRpc2Nvbm5lY3QoKTogcnVudGltZS5UeXBlcy5VdGlscy5Kc1Byb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIEFkZCBhIG1pZGRsZXdhcmVcbiAgICogQGRlcHJlY2F0ZWQgc2luY2UgNC4xNi4wLiBGb3IgbmV3IGNvZGUsIHByZWZlciBjbGllbnQgZXh0ZW5zaW9ucyBpbnN0ZWFkLlxuICAgKiBAc2VlIGh0dHBzOi8vcHJpcy5seS9kL2V4dGVuc2lvbnNcbiAgICovXG4gICR1c2UoY2I6IFByaXNtYS5NaWRkbGV3YXJlKTogdm9pZFxuXG4vKipcbiAgICogRXhlY3V0ZXMgYSBwcmVwYXJlZCByYXcgcXVlcnkgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBhZmZlY3RlZCByb3dzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRleGVjdXRlUmF3YFVQREFURSBVc2VyIFNFVCBjb29sID0gJHt0cnVlfSBXSEVSRSBlbWFpbCA9ICR7J3VzZXJAZW1haWwuY29tJ307YFxuICAgKiBgYGBcbiAgICpcbiAgICogUmVhZCBtb3JlIGluIG91ciBbZG9jc10oaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvcmVmZXJlbmNlL3Rvb2xzLWFuZC1pbnRlcmZhY2VzL3ByaXNtYS1jbGllbnQvcmF3LWRhdGFiYXNlLWFjY2VzcykuXG4gICAqL1xuICAkZXhlY3V0ZVJhdzxUID0gdW5rbm93bj4ocXVlcnk6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHwgUHJpc21hLlNxbCwgLi4udmFsdWVzOiBhbnlbXSk6IFByaXNtYS5QcmlzbWFQcm9taXNlPG51bWJlcj47XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcmF3IHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2YgYWZmZWN0ZWQgcm93cy5cbiAgICogU3VzY2VwdGlibGUgdG8gU1FMIGluamVjdGlvbnMsIHNlZSBkb2N1bWVudGF0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJpc21hLiRleGVjdXRlUmF3VW5zYWZlKCdVUERBVEUgVXNlciBTRVQgY29vbCA9ICQxIFdIRVJFIGVtYWlsID0gJDIgOycsIHRydWUsICd1c2VyQGVtYWlsLmNvbScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZWFkIG1vcmUgaW4gb3VyIFtkb2NzXShodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9yZWZlcmVuY2UvdG9vbHMtYW5kLWludGVyZmFjZXMvcHJpc21hLWNsaWVudC9yYXctZGF0YWJhc2UtYWNjZXNzKS5cbiAgICovXG4gICRleGVjdXRlUmF3VW5zYWZlPFQgPSB1bmtub3duPihxdWVyeTogc3RyaW5nLCAuLi52YWx1ZXM6IGFueVtdKTogUHJpc21hLlByaXNtYVByb21pc2U8bnVtYmVyPjtcblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBwcmVwYXJlZCByYXcgcXVlcnkgYW5kIHJldHVybnMgdGhlIGBTRUxFQ1RgIGRhdGEuXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJHF1ZXJ5UmF3YFNFTEVDVCAqIEZST00gVXNlciBXSEVSRSBpZCA9ICR7MX0gT1IgZW1haWwgPSAkeyd1c2VyQGVtYWlsLmNvbSd9O2BcbiAgICogYGBgXG4gICAqXG4gICAqIFJlYWQgbW9yZSBpbiBvdXIgW2RvY3NdKGh0dHBzOi8vd3d3LnByaXNtYS5pby9kb2NzL3JlZmVyZW5jZS90b29scy1hbmQtaW50ZXJmYWNlcy9wcmlzbWEtY2xpZW50L3Jhdy1kYXRhYmFzZS1hY2Nlc3MpLlxuICAgKi9cbiAgJHF1ZXJ5UmF3PFQgPSB1bmtub3duPihxdWVyeTogVGVtcGxhdGVTdHJpbmdzQXJyYXkgfCBQcmlzbWEuU3FsLCAuLi52YWx1ZXM6IGFueVtdKTogUHJpc21hLlByaXNtYVByb21pc2U8VD47XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgcmF3IHF1ZXJ5IGFuZCByZXR1cm5zIHRoZSBgU0VMRUNUYCBkYXRhLlxuICAgKiBTdXNjZXB0aWJsZSB0byBTUUwgaW5qZWN0aW9ucywgc2VlIGRvY3VtZW50YXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJHF1ZXJ5UmF3VW5zYWZlKCdTRUxFQ1QgKiBGUk9NIFVzZXIgV0hFUkUgaWQgPSAkMSBPUiBlbWFpbCA9ICQyOycsIDEsICd1c2VyQGVtYWlsLmNvbScpXG4gICAqIGBgYFxuICAgKlxuICAgKiBSZWFkIG1vcmUgaW4gb3VyIFtkb2NzXShodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9yZWZlcmVuY2UvdG9vbHMtYW5kLWludGVyZmFjZXMvcHJpc21hLWNsaWVudC9yYXctZGF0YWJhc2UtYWNjZXNzKS5cbiAgICovXG4gICRxdWVyeVJhd1Vuc2FmZTxUID0gdW5rbm93bj4ocXVlcnk6IHN0cmluZywgLi4udmFsdWVzOiBhbnlbXSk6IFByaXNtYS5QcmlzbWFQcm9taXNlPFQ+O1xuXG5cbiAgLyoqXG4gICAqIEFsbG93cyB0aGUgcnVubmluZyBvZiBhIHNlcXVlbmNlIG9mIHJlYWQvd3JpdGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBndWFyYW50ZWVkIHRvIGVpdGhlciBzdWNjZWVkIG9yIGZhaWwgYXMgYSB3aG9sZS5cbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IFtnZW9yZ2UsIGJvYiwgYWxpY2VdID0gYXdhaXQgcHJpc21hLiR0cmFuc2FjdGlvbihbXG4gICAqICAgcHJpc21hLnVzZXIuY3JlYXRlKHsgZGF0YTogeyBuYW1lOiAnR2VvcmdlJyB9IH0pLFxuICAgKiAgIHByaXNtYS51c2VyLmNyZWF0ZSh7IGRhdGE6IHsgbmFtZTogJ0JvYicgfSB9KSxcbiAgICogICBwcmlzbWEudXNlci5jcmVhdGUoeyBkYXRhOiB7IG5hbWU6ICdBbGljZScgfSB9KSxcbiAgICogXSlcbiAgICogYGBgXG4gICAqIFxuICAgKiBSZWFkIG1vcmUgaW4gb3VyIFtkb2NzXShodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9jb25jZXB0cy9jb21wb25lbnRzL3ByaXNtYS1jbGllbnQvdHJhbnNhY3Rpb25zKS5cbiAgICovXG4gICR0cmFuc2FjdGlvbjxQIGV4dGVuZHMgUHJpc21hLlByaXNtYVByb21pc2U8YW55PltdPihhcmc6IFsuLi5QXSwgb3B0aW9ucz86IHsgaXNvbGF0aW9uTGV2ZWw/OiBQcmlzbWEuVHJhbnNhY3Rpb25Jc29sYXRpb25MZXZlbCB9KTogcnVudGltZS5UeXBlcy5VdGlscy5Kc1Byb21pc2U8cnVudGltZS5UeXBlcy5VdGlscy5VbndyYXBUdXBsZTxQPj5cblxuICAkdHJhbnNhY3Rpb248Uj4oZm46IChwcmlzbWE6IE9taXQ8UHJpc21hQ2xpZW50LCBydW50aW1lLklUWENsaWVudERlbnlMaXN0PikgPT4gcnVudGltZS5UeXBlcy5VdGlscy5Kc1Byb21pc2U8Uj4sIG9wdGlvbnM/OiB7IG1heFdhaXQ/OiBudW1iZXIsIHRpbWVvdXQ/OiBudW1iZXIsIGlzb2xhdGlvbkxldmVsPzogUHJpc21hLlRyYW5zYWN0aW9uSXNvbGF0aW9uTGV2ZWwgfSk6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuSnNQcm9taXNlPFI+XG5cblxuICAkZXh0ZW5kczogcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLkV4dGVuZHNIb29rPFwiZXh0ZW5kc1wiLCBQcmlzbWEuVHlwZU1hcENiPENsaWVudE9wdGlvbnM+LCBFeHRBcmdzLCBydW50aW1lLlR5cGVzLlV0aWxzLkNhbGw8UHJpc21hLlR5cGVNYXBDYjxDbGllbnRPcHRpb25zPiwge1xuICAgIGV4dEFyZ3M6IEV4dEFyZ3NcbiAgfT4+XG5cbiAgICAgIC8qKlxuICAgKiBgcHJpc21hLnVzZXJgOiBFeHBvc2VzIENSVUQgb3BlcmF0aW9ucyBmb3IgdGhlICoqVXNlcioqIG1vZGVsLlxuICAgICogRXhhbXBsZSB1c2FnZTpcbiAgICAqIGBgYHRzXG4gICAgKiAvLyBGZXRjaCB6ZXJvIG9yIG1vcmUgVXNlcnNcbiAgICAqIGNvbnN0IHVzZXJzID0gYXdhaXQgcHJpc21hLnVzZXIuZmluZE1hbnkoKVxuICAgICogYGBgXG4gICAgKi9cbiAgZ2V0IHVzZXIoKTogUHJpc21hLlVzZXJEZWxlZ2F0ZTxFeHRBcmdzLCBDbGllbnRPcHRpb25zPjtcblxuICAvKipcbiAgICogYHByaXNtYS5sYXVuY2hlcmA6IEV4cG9zZXMgQ1JVRCBvcGVyYXRpb25zIGZvciB0aGUgKipMYXVuY2hlcioqIG1vZGVsLlxuICAgICogRXhhbXBsZSB1c2FnZTpcbiAgICAqIGBgYHRzXG4gICAgKiAvLyBGZXRjaCB6ZXJvIG9yIG1vcmUgTGF1bmNoZXJzXG4gICAgKiBjb25zdCBsYXVuY2hlcnMgPSBhd2FpdCBwcmlzbWEubGF1bmNoZXIuZmluZE1hbnkoKVxuICAgICogYGBgXG4gICAgKi9cbiAgZ2V0IGxhdW5jaGVyKCk6IFByaXNtYS5MYXVuY2hlckRlbGVnYXRlPEV4dEFyZ3MsIENsaWVudE9wdGlvbnM+O1xuXG4gIC8qKlxuICAgKiBgcHJpc21hLm1vdGRgOiBFeHBvc2VzIENSVUQgb3BlcmF0aW9ucyBmb3IgdGhlICoqTW90ZCoqIG1vZGVsLlxuICAgICogRXhhbXBsZSB1c2FnZTpcbiAgICAqIGBgYHRzXG4gICAgKiAvLyBGZXRjaCB6ZXJvIG9yIG1vcmUgTW90ZHNcbiAgICAqIGNvbnN0IG1vdGRzID0gYXdhaXQgcHJpc21hLm1vdGQuZmluZE1hbnkoKVxuICAgICogYGBgXG4gICAgKi9cbiAgZ2V0IG1vdGQoKTogUHJpc21hLk1vdGREZWxlZ2F0ZTxFeHRBcmdzLCBDbGllbnRPcHRpb25zPjtcblxuICAvKipcbiAgICogYHByaXNtYS5zZXJ2ZXJgOiBFeHBvc2VzIENSVUQgb3BlcmF0aW9ucyBmb3IgdGhlICoqU2VydmVyKiogbW9kZWwuXG4gICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgICogYGBgdHNcbiAgICAqIC8vIEZldGNoIHplcm8gb3IgbW9yZSBTZXJ2ZXJzXG4gICAgKiBjb25zdCBzZXJ2ZXJzID0gYXdhaXQgcHJpc21hLnNlcnZlci5maW5kTWFueSgpXG4gICAgKiBgYGBcbiAgICAqL1xuICBnZXQgc2VydmVyKCk6IFByaXNtYS5TZXJ2ZXJEZWxlZ2F0ZTxFeHRBcmdzLCBDbGllbnRPcHRpb25zPjtcblxuICAvKipcbiAgICogYHByaXNtYS5zZXJ2ZXJUYWdgOiBFeHBvc2VzIENSVUQgb3BlcmF0aW9ucyBmb3IgdGhlICoqU2VydmVyVGFnKiogbW9kZWwuXG4gICAgKiBFeGFtcGxlIHVzYWdlOlxuICAgICogYGBgdHNcbiAgICAqIC8vIEZldGNoIHplcm8gb3IgbW9yZSBTZXJ2ZXJUYWdzXG4gICAgKiBjb25zdCBzZXJ2ZXJUYWdzID0gYXdhaXQgcHJpc21hLnNlcnZlclRhZy5maW5kTWFueSgpXG4gICAgKiBgYGBcbiAgICAqL1xuICBnZXQgc2VydmVyVGFnKCk6IFByaXNtYS5TZXJ2ZXJUYWdEZWxlZ2F0ZTxFeHRBcmdzLCBDbGllbnRPcHRpb25zPjtcblxuICAvKipcbiAgICogYHByaXNtYS5hcnRpY2xlc2A6IEV4cG9zZXMgQ1JVRCBvcGVyYXRpb25zIGZvciB0aGUgKipBcnRpY2xlcyoqIG1vZGVsLlxuICAgICogRXhhbXBsZSB1c2FnZTpcbiAgICAqIGBgYHRzXG4gICAgKiAvLyBGZXRjaCB6ZXJvIG9yIG1vcmUgQXJ0aWNsZXNcbiAgICAqIGNvbnN0IGFydGljbGVzID0gYXdhaXQgcHJpc21hLmFydGljbGVzLmZpbmRNYW55KClcbiAgICAqIGBgYFxuICAgICovXG4gIGdldCBhcnRpY2xlcygpOiBQcmlzbWEuQXJ0aWNsZXNEZWxlZ2F0ZTxFeHRBcmdzLCBDbGllbnRPcHRpb25zPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByaXNtYUNsaWVudENsYXNzKGRpcm5hbWU6IHN0cmluZyk6IFByaXNtYUNsaWVudENvbnN0cnVjdG9yIHtcbiAgY29uZmlnLmRpcm5hbWUgPSBkaXJuYW1lXG4gIHJldHVybiBydW50aW1lLmdldFByaXNtYUNsaWVudChjb25maWcpIGFzIHVua25vd24gYXMgUHJpc21hQ2xpZW50Q29uc3RydWN0b3Jcbn1cbiIsIlxuLyogISEhIFRoaXMgaXMgY29kZSBnZW5lcmF0ZWQgYnkgUHJpc21hLiBEbyBub3QgZWRpdCBkaXJlY3RseS4gISEhICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2sgXG4vKipcbiAqIFdBUk5JTkc6IFRoaXMgaXMgYW4gaW50ZXJuYWwgZmlsZSB0aGF0IGlzIHN1YmplY3QgdG8gY2hhbmdlIVxuICogXG4gKiDwn5uRIFVuZGVyIG5vIGNpcmN1bXN0YW5jZXMgc2hvdWxkIHlvdSBpbXBvcnQgdGhpcyBmaWxlIGRpcmVjdGx5ISDwn5uRXG4gKiBcbiAqIEFsbCBleHBvcnRzIGZyb20gdGhpcyBmaWxlIGFyZSB3cmFwcGVkIHVuZGVyIGEgYFByaXNtYWAgbmFtZXNwYWNlIG9iamVjdCBpbiB0aGUgY2xpZW50LnRzIGZpbGUuXG4gKiBXaGlsZSB0aGlzIGVuYWJsZXMgcGFydGlhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCBpdCBpcyBub3QgcGFydCBvZiB0aGUgc3RhYmxlIHB1YmxpYyBBUEkuXG4gKiBcbiAqIElmIHlvdSBhcmUgbG9va2luZyBmb3IgeW91ciBNb2RlbHMsIEVudW1zLCBhbmQgSW5wdXQgVHlwZXMsIHBsZWFzZSBpbXBvcnQgdGhlbSBmcm9tIHRoZSByZXNwZWN0aXZlIFxuICogbW9kZWwgZmlsZXMgaW4gdGhlIGBtb2RlbGAgZGlyZWN0b3J5IVxuICovXG5cbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSBcIkBwcmlzbWEvY2xpZW50L3J1bnRpbWUvbGlicmFyeVwiXG5pbXBvcnQgdHlwZSAqIGFzIFByaXNtYSBmcm9tIFwiLi4vbW9kZWxzLnRzXCJcbmltcG9ydCB7IHR5cGUgUHJpc21hQ2xpZW50IH0gZnJvbSBcIi4vY2xhc3MudHNcIlxuXG5leHBvcnQgdHlwZSAqIGZyb20gJy4uL21vZGVscy50cydcblxuZXhwb3J0IHR5cGUgRE1NRiA9IHR5cGVvZiBydW50aW1lLkRNTUZcblxuZXhwb3J0IHR5cGUgUHJpc21hUHJvbWlzZTxUPiA9IHJ1bnRpbWUuVHlwZXMuUHVibGljLlByaXNtYVByb21pc2U8VD5cblxuLyoqXG4gKiBWYWxpZGF0b3JcbiAqL1xuZXhwb3J0IGNvbnN0IHZhbGlkYXRvciA9IHJ1bnRpbWUuUHVibGljLnZhbGlkYXRvclxuXG4vKipcbiAqIFByaXNtYSBFcnJvcnNcbiAqL1xuXG5leHBvcnQgY29uc3QgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IgPSBydW50aW1lLlByaXNtYUNsaWVudEtub3duUmVxdWVzdEVycm9yXG5leHBvcnQgdHlwZSBQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciA9IHJ1bnRpbWUuUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcblxuZXhwb3J0IGNvbnN0IFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgPSBydW50aW1lLlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcbmV4cG9ydCB0eXBlIFByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IgPSBydW50aW1lLlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcblxuZXhwb3J0IGNvbnN0IFByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yID0gcnVudGltZS5QcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvclxuZXhwb3J0IHR5cGUgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IgPSBydW50aW1lLlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXG5cbmV4cG9ydCBjb25zdCBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yID0gcnVudGltZS5QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yXG5leHBvcnQgdHlwZSBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yID0gcnVudGltZS5QcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yXG5cbmV4cG9ydCBjb25zdCBQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IgPSBydW50aW1lLlByaXNtYUNsaWVudFZhbGlkYXRpb25FcnJvclxuZXhwb3J0IHR5cGUgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yID0gcnVudGltZS5QcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3JcblxuLyoqXG4gKiBSZS1leHBvcnQgb2Ygc3FsLXRlbXBsYXRlLXRhZ1xuICovXG5leHBvcnQgY29uc3Qgc3FsID0gcnVudGltZS5zcWx0YWdcbmV4cG9ydCBjb25zdCBlbXB0eSA9IHJ1bnRpbWUuZW1wdHlcbmV4cG9ydCBjb25zdCBqb2luID0gcnVudGltZS5qb2luXG5leHBvcnQgY29uc3QgcmF3ID0gcnVudGltZS5yYXdcbmV4cG9ydCBjb25zdCBTcWwgPSBydW50aW1lLlNxbFxuZXhwb3J0IHR5cGUgU3FsID0gcnVudGltZS5TcWxcblxuXG5cbi8qKlxuICogRGVjaW1hbC5qc1xuICovXG5leHBvcnQgY29uc3QgRGVjaW1hbCA9IHJ1bnRpbWUuRGVjaW1hbFxuZXhwb3J0IHR5cGUgRGVjaW1hbCA9IHJ1bnRpbWUuRGVjaW1hbFxuXG5leHBvcnQgdHlwZSBEZWNpbWFsSnNMaWtlID0gcnVudGltZS5EZWNpbWFsSnNMaWtlXG5cbi8qKlxuICogTWV0cmljc1xuICovXG5leHBvcnQgdHlwZSBNZXRyaWNzID0gcnVudGltZS5NZXRyaWNzXG5leHBvcnQgdHlwZSBNZXRyaWM8VD4gPSBydW50aW1lLk1ldHJpYzxUPlxuZXhwb3J0IHR5cGUgTWV0cmljSGlzdG9ncmFtID0gcnVudGltZS5NZXRyaWNIaXN0b2dyYW1cbmV4cG9ydCB0eXBlIE1ldHJpY0hpc3RvZ3JhbUJ1Y2tldCA9IHJ1bnRpbWUuTWV0cmljSGlzdG9ncmFtQnVja2V0XG5cbi8qKlxuKiBFeHRlbnNpb25zXG4qL1xuZXhwb3J0IHR5cGUgRXh0ZW5zaW9uID0gcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLlVzZXJBcmdzXG5leHBvcnQgY29uc3QgZ2V0RXh0ZW5zaW9uQ29udGV4dCA9IHJ1bnRpbWUuRXh0ZW5zaW9ucy5nZXRFeHRlbnNpb25Db250ZXh0XG5leHBvcnQgdHlwZSBBcmdzPFQsIEYgZXh0ZW5kcyBydW50aW1lLk9wZXJhdGlvbj4gPSBydW50aW1lLlR5cGVzLlB1YmxpYy5BcmdzPFQsIEY+XG5leHBvcnQgdHlwZSBQYXlsb2FkPFQsIEYgZXh0ZW5kcyBydW50aW1lLk9wZXJhdGlvbiA9IG5ldmVyPiA9IHJ1bnRpbWUuVHlwZXMuUHVibGljLlBheWxvYWQ8VCwgRj5cbmV4cG9ydCB0eXBlIFJlc3VsdDxULCBBLCBGIGV4dGVuZHMgcnVudGltZS5PcGVyYXRpb24+ID0gcnVudGltZS5UeXBlcy5QdWJsaWMuUmVzdWx0PFQsIEEsIEY+XG5leHBvcnQgdHlwZSBFeGFjdDxBLCBXPiA9IHJ1bnRpbWUuVHlwZXMuUHVibGljLkV4YWN0PEEsIFc+XG5cbmV4cG9ydCB0eXBlIFByaXNtYVZlcnNpb24gPSB7XG4gIGNsaWVudDogc3RyaW5nXG4gIGVuZ2luZTogc3RyaW5nXG59XG5cbi8qKlxuICogUHJpc21hIENsaWVudCBKUyB2ZXJzaW9uOiA2LjEyLjBcbiAqIFF1ZXJ5IEVuZ2luZSB2ZXJzaW9uOiA4MDQ3Yzk2YmJkOTJkYjk4YTJhYmM3YzkzMjNjZTc3YzAyYzg5ZGJjXG4gKi9cbmV4cG9ydCBjb25zdCBwcmlzbWFWZXJzaW9uOiBQcmlzbWFWZXJzaW9uID0ge1xuICBjbGllbnQ6IFwiNi4xMi4wXCIsXG4gIGVuZ2luZTogXCI4MDQ3Yzk2YmJkOTJkYjk4YTJhYmM3YzkzMjNjZTc3YzAyYzg5ZGJjXCJcbn1cblxuLyoqXG4gKiBVdGlsaXR5IFR5cGVzXG4gKi9cblxuZXhwb3J0IHR5cGUgSnNvbk9iamVjdCA9IHJ1bnRpbWUuSnNvbk9iamVjdFxuZXhwb3J0IHR5cGUgSnNvbkFycmF5ID0gcnVudGltZS5Kc29uQXJyYXlcbmV4cG9ydCB0eXBlIEpzb25WYWx1ZSA9IHJ1bnRpbWUuSnNvblZhbHVlXG5leHBvcnQgdHlwZSBJbnB1dEpzb25PYmplY3QgPSBydW50aW1lLklucHV0SnNvbk9iamVjdFxuZXhwb3J0IHR5cGUgSW5wdXRKc29uQXJyYXkgPSBydW50aW1lLklucHV0SnNvbkFycmF5XG5leHBvcnQgdHlwZSBJbnB1dEpzb25WYWx1ZSA9IHJ1bnRpbWUuSW5wdXRKc29uVmFsdWVcblxuZXhwb3J0IGNvbnN0IE51bGxUeXBlcyA9IHtcbiAgRGJOdWxsOiBydW50aW1lLm9iamVjdEVudW1WYWx1ZXMuY2xhc3Nlcy5EYk51bGwgYXMgKG5ldyAoc2VjcmV0OiBuZXZlcikgPT4gdHlwZW9mIHJ1bnRpbWUub2JqZWN0RW51bVZhbHVlcy5pbnN0YW5jZXMuRGJOdWxsKSxcbiAgSnNvbk51bGw6IHJ1bnRpbWUub2JqZWN0RW51bVZhbHVlcy5jbGFzc2VzLkpzb25OdWxsIGFzIChuZXcgKHNlY3JldDogbmV2ZXIpID0+IHR5cGVvZiBydW50aW1lLm9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzLkpzb25OdWxsKSxcbiAgQW55TnVsbDogcnVudGltZS5vYmplY3RFbnVtVmFsdWVzLmNsYXNzZXMuQW55TnVsbCBhcyAobmV3IChzZWNyZXQ6IG5ldmVyKSA9PiB0eXBlb2YgcnVudGltZS5vYmplY3RFbnVtVmFsdWVzLmluc3RhbmNlcy5BbnlOdWxsKSxcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGZpbHRlcmluZyBKU09OIGVudHJpZXMgdGhhdCBoYXZlIGBudWxsYCBvbiB0aGUgZGF0YWJhc2UgKGVtcHR5IG9uIHRoZSBkYilcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnByaXNtYS5pby9kb2NzL2NvbmNlcHRzL2NvbXBvbmVudHMvcHJpc21hLWNsaWVudC93b3JraW5nLXdpdGgtZmllbGRzL3dvcmtpbmctd2l0aC1qc29uLWZpZWxkcyNmaWx0ZXJpbmctb24tYS1qc29uLWZpZWxkXG4gKi9cbmV4cG9ydCBjb25zdCBEYk51bGwgPSBydW50aW1lLm9iamVjdEVudW1WYWx1ZXMuaW5zdGFuY2VzLkRiTnVsbFxuXG4vKipcbiAqIEhlbHBlciBmb3IgZmlsdGVyaW5nIEpTT04gZW50cmllcyB0aGF0IGhhdmUgSlNPTiBgbnVsbGAgdmFsdWVzIChub3QgZW1wdHkgb24gdGhlIGRiKVxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvY29uY2VwdHMvY29tcG9uZW50cy9wcmlzbWEtY2xpZW50L3dvcmtpbmctd2l0aC1maWVsZHMvd29ya2luZy13aXRoLWpzb24tZmllbGRzI2ZpbHRlcmluZy1vbi1hLWpzb24tZmllbGRcbiAqL1xuZXhwb3J0IGNvbnN0IEpzb25OdWxsID0gcnVudGltZS5vYmplY3RFbnVtVmFsdWVzLmluc3RhbmNlcy5Kc29uTnVsbFxuXG4vKipcbiAqIEhlbHBlciBmb3IgZmlsdGVyaW5nIEpTT04gZW50cmllcyB0aGF0IGFyZSBgUHJpc21hLkRiTnVsbGAgb3IgYFByaXNtYS5Kc29uTnVsbGBcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnByaXNtYS5pby9kb2NzL2NvbmNlcHRzL2NvbXBvbmVudHMvcHJpc21hLWNsaWVudC93b3JraW5nLXdpdGgtZmllbGRzL3dvcmtpbmctd2l0aC1qc29uLWZpZWxkcyNmaWx0ZXJpbmctb24tYS1qc29uLWZpZWxkXG4gKi9cbmV4cG9ydCBjb25zdCBBbnlOdWxsID0gcnVudGltZS5vYmplY3RFbnVtVmFsdWVzLmluc3RhbmNlcy5BbnlOdWxsXG5cbnR5cGUgU2VsZWN0QW5kSW5jbHVkZSA9IHtcbiAgc2VsZWN0OiBhbnlcbiAgaW5jbHVkZTogYW55XG59XG5cbnR5cGUgU2VsZWN0QW5kT21pdCA9IHtcbiAgc2VsZWN0OiBhbnlcbiAgb21pdDogYW55XG59XG5cbi8qKlxuICogRnJvbSBULCBwaWNrIGEgc2V0IG9mIHByb3BlcnRpZXMgd2hvc2Uga2V5cyBhcmUgaW4gdGhlIHVuaW9uIEtcbiAqL1xudHlwZSBQcmlzbWFfX1BpY2s8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0ge1xuICAgIFtQIGluIEtdOiBUW1BdO1xufTtcblxuZXhwb3J0IHR5cGUgRW51bWVyYWJsZTxUPiA9IFQgfCBBcnJheTxUPjtcblxuLyoqXG4gKiBTdWJzZXRcbiAqIEBkZXNjIEZyb20gYFRgIHBpY2sgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGBVYC4gU2ltcGxlIHZlcnNpb24gb2YgSW50ZXJzZWN0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIFN1YnNldDxULCBVPiA9IHtcbiAgW2tleSBpbiBrZXlvZiBUXToga2V5IGV4dGVuZHMga2V5b2YgVSA/IFRba2V5XSA6IG5ldmVyO1xufTtcblxuLyoqXG4gKiBTZWxlY3RTdWJzZXRcbiAqIEBkZXNjIEZyb20gYFRgIHBpY2sgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGBVYC4gU2ltcGxlIHZlcnNpb24gb2YgSW50ZXJzZWN0aW9uLlxuICogQWRkaXRpb25hbGx5LCBpdCB2YWxpZGF0ZXMsIGlmIGJvdGggc2VsZWN0IGFuZCBpbmNsdWRlIGFyZSBwcmVzZW50LiBJZiB0aGUgY2FzZSwgaXQgZXJyb3JzLlxuICovXG5leHBvcnQgdHlwZSBTZWxlY3RTdWJzZXQ8VCwgVT4gPSB7XG4gIFtrZXkgaW4ga2V5b2YgVF06IGtleSBleHRlbmRzIGtleW9mIFUgPyBUW2tleV0gOiBuZXZlclxufSAmXG4gIChUIGV4dGVuZHMgU2VsZWN0QW5kSW5jbHVkZVxuICAgID8gJ1BsZWFzZSBlaXRoZXIgY2hvb3NlIGBzZWxlY3RgIG9yIGBpbmNsdWRlYC4nXG4gICAgOiBUIGV4dGVuZHMgU2VsZWN0QW5kT21pdFxuICAgICAgPyAnUGxlYXNlIGVpdGhlciBjaG9vc2UgYHNlbGVjdGAgb3IgYG9taXRgLidcbiAgICAgIDoge30pXG5cbi8qKlxuICogU3Vic2V0ICsgSW50ZXJzZWN0aW9uXG4gKiBAZGVzYyBGcm9tIGBUYCBwaWNrIHByb3BlcnRpZXMgdGhhdCBleGlzdCBpbiBgVWAgYW5kIGludGVyc2VjdCBgS2BcbiAqL1xuZXhwb3J0IHR5cGUgU3Vic2V0SW50ZXJzZWN0aW9uPFQsIFUsIEs+ID0ge1xuICBba2V5IGluIGtleW9mIFRdOiBrZXkgZXh0ZW5kcyBrZXlvZiBVID8gVFtrZXldIDogbmV2ZXJcbn0gJlxuICBLXG5cbnR5cGUgV2l0aG91dDxULCBVPiA9IHsgW1AgaW4gRXhjbHVkZTxrZXlvZiBULCBrZXlvZiBVPl0/OiBuZXZlciB9O1xuXG4vKipcbiAqIFhPUiBpcyBuZWVkZWQgdG8gaGF2ZSBhIHJlYWwgbXV0dWFsbHkgZXhjbHVzaXZlIHVuaW9uIHR5cGVcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQyMTIzNDA3L2RvZXMtdHlwZXNjcmlwdC1zdXBwb3J0LW11dHVhbGx5LWV4Y2x1c2l2ZS10eXBlc1xuICovXG5leHBvcnQgdHlwZSBYT1I8VCwgVT4gPVxuICBUIGV4dGVuZHMgb2JqZWN0ID9cbiAgVSBleHRlbmRzIG9iamVjdCA/XG4gICAgKFdpdGhvdXQ8VCwgVT4gJiBVKSB8IChXaXRob3V0PFUsIFQ+ICYgVClcbiAgOiBVIDogVFxuXG5cbi8qKlxuICogSXMgVCBhIFJlY29yZD9cbiAqL1xudHlwZSBJc09iamVjdDxUIGV4dGVuZHMgYW55PiA9IFQgZXh0ZW5kcyBBcnJheTxhbnk+XG4/IEZhbHNlXG46IFQgZXh0ZW5kcyBEYXRlXG4/IEZhbHNlXG46IFQgZXh0ZW5kcyBVaW50OEFycmF5XG4/IEZhbHNlXG46IFQgZXh0ZW5kcyBCaWdJbnRcbj8gRmFsc2VcbjogVCBleHRlbmRzIG9iamVjdFxuPyBUcnVlXG46IEZhbHNlXG5cblxuLyoqXG4gKiBJZiBpdCdzIFRbXSwgcmV0dXJuIFRcbiAqL1xuZXhwb3J0IHR5cGUgVW5FbnVtZXJhdGU8VCBleHRlbmRzIHVua25vd24+ID0gVCBleHRlbmRzIEFycmF5PGluZmVyIFU+ID8gVSA6IFRcblxuLyoqXG4gKiBGcm9tIHRzLXRvb2xiZWx0XG4gKi9cblxudHlwZSBfX0VpdGhlcjxPIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMgS2V5PiA9IE9taXQ8TywgSz4gJlxuICB7XG4gICAgLy8gTWVyZ2UgYWxsIGJ1dCBLXG4gICAgW1AgaW4gS106IFByaXNtYV9fUGljazxPLCBQICYga2V5b2YgTz4gLy8gV2l0aCBLIHBvc3NpYmlsaXRpZXNcbiAgfVtLXVxuXG50eXBlIEVpdGhlclN0cmljdDxPIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMgS2V5PiA9IFN0cmljdDxfX0VpdGhlcjxPLCBLPj5cblxudHlwZSBFaXRoZXJMb29zZTxPIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMgS2V5PiA9IENvbXB1dGVSYXc8X19FaXRoZXI8TywgSz4+XG5cbnR5cGUgX0VpdGhlcjxcbiAgTyBleHRlbmRzIG9iamVjdCxcbiAgSyBleHRlbmRzIEtleSxcbiAgc3RyaWN0IGV4dGVuZHMgQm9vbGVhblxuPiA9IHtcbiAgMTogRWl0aGVyU3RyaWN0PE8sIEs+XG4gIDA6IEVpdGhlckxvb3NlPE8sIEs+XG59W3N0cmljdF1cblxuZXhwb3J0IHR5cGUgRWl0aGVyPFxuICBPIGV4dGVuZHMgb2JqZWN0LFxuICBLIGV4dGVuZHMgS2V5LFxuICBzdHJpY3QgZXh0ZW5kcyBCb29sZWFuID0gMVxuPiA9IE8gZXh0ZW5kcyB1bmtub3duID8gX0VpdGhlcjxPLCBLLCBzdHJpY3Q+IDogbmV2ZXJcblxuZXhwb3J0IHR5cGUgVW5pb24gPSBhbnlcblxuZXhwb3J0IHR5cGUgUGF0Y2hVbmRlZmluZWQ8TyBleHRlbmRzIG9iamVjdCwgTzEgZXh0ZW5kcyBvYmplY3Q+ID0ge1xuICBbSyBpbiBrZXlvZiBPXTogT1tLXSBleHRlbmRzIHVuZGVmaW5lZCA/IEF0PE8xLCBLPiA6IE9bS11cbn0gJiB7fVxuXG4vKiogSGVscGVyIFR5cGVzIGZvciBcIk1lcmdlXCIgKiovXG5leHBvcnQgdHlwZSBJbnRlcnNlY3RPZjxVIGV4dGVuZHMgVW5pb24+ID0gKFxuICBVIGV4dGVuZHMgdW5rbm93biA/IChrOiBVKSA9PiB2b2lkIDogbmV2ZXJcbikgZXh0ZW5kcyAoazogaW5mZXIgSSkgPT4gdm9pZFxuICA/IElcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBPdmVyd3JpdGU8TyBleHRlbmRzIG9iamVjdCwgTzEgZXh0ZW5kcyBvYmplY3Q+ID0ge1xuICAgIFtLIGluIGtleW9mIE9dOiBLIGV4dGVuZHMga2V5b2YgTzEgPyBPMVtLXSA6IE9bS107XG59ICYge307XG5cbnR5cGUgX01lcmdlPFUgZXh0ZW5kcyBvYmplY3Q+ID0gSW50ZXJzZWN0T2Y8T3ZlcndyaXRlPFUsIHtcbiAgICBbSyBpbiBrZXlvZiBVXS0/OiBBdDxVLCBLPjtcbn0+PjtcblxudHlwZSBLZXkgPSBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2w7XG50eXBlIEF0U3RyaWN0PE8gZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBLZXk+ID0gT1tLICYga2V5b2YgT107XG50eXBlIEF0TG9vc2U8TyBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIEtleT4gPSBPIGV4dGVuZHMgdW5rbm93biA/IEF0U3RyaWN0PE8sIEs+IDogbmV2ZXI7XG5leHBvcnQgdHlwZSBBdDxPIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMgS2V5LCBzdHJpY3QgZXh0ZW5kcyBCb29sZWFuID0gMT4gPSB7XG4gICAgMTogQXRTdHJpY3Q8TywgSz47XG4gICAgMDogQXRMb29zZTxPLCBLPjtcbn1bc3RyaWN0XTtcblxuZXhwb3J0IHR5cGUgQ29tcHV0ZVJhdzxBIGV4dGVuZHMgYW55PiA9IEEgZXh0ZW5kcyBGdW5jdGlvbiA/IEEgOiB7XG4gIFtLIGluIGtleW9mIEFdOiBBW0tdO1xufSAmIHt9O1xuXG5leHBvcnQgdHlwZSBPcHRpb25hbEZsYXQ8Tz4gPSB7XG4gIFtLIGluIGtleW9mIE9dPzogT1tLXTtcbn0gJiB7fTtcblxudHlwZSBfUmVjb3JkPEsgZXh0ZW5kcyBrZXlvZiBhbnksIFQ+ID0ge1xuICBbUCBpbiBLXTogVDtcbn07XG5cbi8vIGNhdXNlIHR5cGVzY3JpcHQgbm90IHRvIGV4cGFuZCB0eXBlcyBhbmQgcHJlc2VydmUgbmFtZXNcbnR5cGUgTm9FeHBhbmQ8VD4gPSBUIGV4dGVuZHMgdW5rbm93biA/IFQgOiBuZXZlcjtcblxuLy8gdGhpcyB0eXBlIGFzc3VtZXMgdGhlIHBhc3NlZCBvYmplY3QgaXMgZW50aXJlbHkgb3B0aW9uYWxcbmV4cG9ydCB0eXBlIEF0TGVhc3Q8TyBleHRlbmRzIG9iamVjdCwgSyBleHRlbmRzIHN0cmluZz4gPSBOb0V4cGFuZDxcbiAgTyBleHRlbmRzIHVua25vd25cbiAgPyB8IChLIGV4dGVuZHMga2V5b2YgTyA/IHsgW1AgaW4gS106IE9bUF0gfSAmIE8gOiBPKVxuICAgIHwge1tQIGluIGtleW9mIE8gYXMgUCBleHRlbmRzIEsgPyBQIDogbmV2ZXJdLT86IE9bUF19ICYgT1xuICA6IG5ldmVyPjtcblxudHlwZSBfU3RyaWN0PFUsIF9VID0gVT4gPSBVIGV4dGVuZHMgdW5rbm93biA/IFUgJiBPcHRpb25hbEZsYXQ8X1JlY29yZDxFeGNsdWRlPEtleXM8X1U+LCBrZXlvZiBVPiwgbmV2ZXI+PiA6IG5ldmVyO1xuXG5leHBvcnQgdHlwZSBTdHJpY3Q8VSBleHRlbmRzIG9iamVjdD4gPSBDb21wdXRlUmF3PF9TdHJpY3Q8VT4+O1xuLyoqIEVuZCBIZWxwZXIgVHlwZXMgZm9yIFwiTWVyZ2VcIiAqKi9cblxuZXhwb3J0IHR5cGUgTWVyZ2U8VSBleHRlbmRzIG9iamVjdD4gPSBDb21wdXRlUmF3PF9NZXJnZTxTdHJpY3Q8VT4+PjtcblxuZXhwb3J0IHR5cGUgQm9vbGVhbiA9IFRydWUgfCBGYWxzZVxuXG5leHBvcnQgdHlwZSBUcnVlID0gMVxuXG5leHBvcnQgdHlwZSBGYWxzZSA9IDBcblxuZXhwb3J0IHR5cGUgTm90PEIgZXh0ZW5kcyBCb29sZWFuPiA9IHtcbiAgMDogMVxuICAxOiAwXG59W0JdXG5cbmV4cG9ydCB0eXBlIEV4dGVuZHM8QTEgZXh0ZW5kcyBhbnksIEEyIGV4dGVuZHMgYW55PiA9IFtBMV0gZXh0ZW5kcyBbbmV2ZXJdXG4gID8gMCAvLyBhbnl0aGluZyBgbmV2ZXJgIGlzIGZhbHNlXG4gIDogQTEgZXh0ZW5kcyBBMlxuICA/IDFcbiAgOiAwXG5cbmV4cG9ydCB0eXBlIEhhczxVIGV4dGVuZHMgVW5pb24sIFUxIGV4dGVuZHMgVW5pb24+ID0gTm90PFxuICBFeHRlbmRzPEV4Y2x1ZGU8VTEsIFU+LCBVMT5cbj5cblxuZXhwb3J0IHR5cGUgT3I8QjEgZXh0ZW5kcyBCb29sZWFuLCBCMiBleHRlbmRzIEJvb2xlYW4+ID0ge1xuICAwOiB7XG4gICAgMDogMFxuICAgIDE6IDFcbiAgfVxuICAxOiB7XG4gICAgMDogMVxuICAgIDE6IDFcbiAgfVxufVtCMV1bQjJdXG5cbmV4cG9ydCB0eXBlIEtleXM8VSBleHRlbmRzIFVuaW9uPiA9IFUgZXh0ZW5kcyB1bmtub3duID8ga2V5b2YgVSA6IG5ldmVyXG5cbmV4cG9ydCB0eXBlIEdldFNjYWxhclR5cGU8VCwgTz4gPSBPIGV4dGVuZHMgb2JqZWN0ID8ge1xuICBbUCBpbiBrZXlvZiBUXTogUCBleHRlbmRzIGtleW9mIE9cbiAgICA/IE9bUF1cbiAgICA6IG5ldmVyXG59IDogbmV2ZXJcblxudHlwZSBGaWVsZFBhdGhzPFxuICBULFxuICBVID0gT21pdDxULCAnX2F2ZycgfCAnX3N1bScgfCAnX2NvdW50JyB8ICdfbWluJyB8ICdfbWF4Jz5cbj4gPSBJc09iamVjdDxUPiBleHRlbmRzIFRydWUgPyBVIDogVFxuXG5leHBvcnQgdHlwZSBHZXRIYXZpbmdGaWVsZHM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBPcjxcbiAgICBPcjxFeHRlbmRzPCdPUicsIEs+LCBFeHRlbmRzPCdBTkQnLCBLPj4sXG4gICAgRXh0ZW5kczwnTk9UJywgSz5cbiAgPiBleHRlbmRzIFRydWVcbiAgICA/IC8vIGluZmVyIGlzIG9ubHkgbmVlZGVkIHRvIG5vdCBoaXQgVFMgbGltaXRcbiAgICAgIC8vIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgaWRlYSBvZiBQaWVycmUtQW50b2luZSBNaWxsc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMDE4OCNpc3N1ZWNvbW1lbnQtNDc4OTM4NDM3XG4gICAgICBUW0tdIGV4dGVuZHMgaW5mZXIgVEtcbiAgICAgID8gR2V0SGF2aW5nRmllbGRzPFVuRW51bWVyYXRlPFRLPiBleHRlbmRzIG9iamVjdCA/IE1lcmdlPFVuRW51bWVyYXRlPFRLPj4gOiBuZXZlcj5cbiAgICAgIDogbmV2ZXJcbiAgICA6IHt9IGV4dGVuZHMgRmllbGRQYXRoczxUW0tdPlxuICAgID8gbmV2ZXJcbiAgICA6IEtcbn1ba2V5b2YgVF1cblxuLyoqXG4gKiBDb252ZXJ0IHR1cGxlIHRvIHVuaW9uXG4gKi9cbnR5cGUgX1R1cGxlVG9VbmlvbjxUPiA9IFQgZXh0ZW5kcyAoaW5mZXIgRSlbXSA/IEUgOiBuZXZlclxudHlwZSBUdXBsZVRvVW5pb248SyBleHRlbmRzIHJlYWRvbmx5IGFueVtdPiA9IF9UdXBsZVRvVW5pb248Sz5cbmV4cG9ydCB0eXBlIE1heWJlVHVwbGVUb1VuaW9uPFQ+ID0gVCBleHRlbmRzIGFueVtdID8gVHVwbGVUb1VuaW9uPFQ+IDogVFxuXG4vKipcbiAqIExpa2UgYFBpY2tgLCBidXQgYWRkaXRpb25hbGx5IGNhbiBhbHNvIGFjY2VwdCBhbiBhcnJheSBvZiBrZXlzXG4gKi9cbmV4cG9ydCB0eXBlIFBpY2tFbnVtZXJhYmxlPFQsIEsgZXh0ZW5kcyBFbnVtZXJhYmxlPGtleW9mIFQ+IHwga2V5b2YgVD4gPSBQcmlzbWFfX1BpY2s8VCwgTWF5YmVUdXBsZVRvVW5pb248Sz4+XG5cbi8qKlxuICogRXhjbHVkZSBhbGwga2V5cyB3aXRoIHVuZGVyc2NvcmVzXG4gKi9cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVVbmRlcnNjb3JlS2V5czxUIGV4dGVuZHMgc3RyaW5nPiA9IFQgZXh0ZW5kcyBgXyR7c3RyaW5nfWAgPyBuZXZlciA6IFRcblxuXG5leHBvcnQgdHlwZSBGaWVsZFJlZjxNb2RlbCwgRmllbGRUeXBlPiA9IHJ1bnRpbWUuRmllbGRSZWY8TW9kZWwsIEZpZWxkVHlwZT5cblxudHlwZSBGaWVsZFJlZklucHV0VHlwZTxNb2RlbCwgRmllbGRUeXBlPiA9IE1vZGVsIGV4dGVuZHMgbmV2ZXIgPyBuZXZlciA6IEZpZWxkUmVmPE1vZGVsLCBGaWVsZFR5cGU+XG5cblxuZXhwb3J0IGNvbnN0IE1vZGVsTmFtZSA9IHtcbiAgVXNlcjogJ1VzZXInLFxuICBMYXVuY2hlcjogJ0xhdW5jaGVyJyxcbiAgTW90ZDogJ01vdGQnLFxuICBTZXJ2ZXI6ICdTZXJ2ZXInLFxuICBTZXJ2ZXJUYWc6ICdTZXJ2ZXJUYWcnLFxuICBBcnRpY2xlczogJ0FydGljbGVzJ1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBNb2RlbE5hbWUgPSAodHlwZW9mIE1vZGVsTmFtZSlba2V5b2YgdHlwZW9mIE1vZGVsTmFtZV1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVHlwZU1hcENiPENsaWVudE9wdGlvbnMgPSB7fT4gZXh0ZW5kcyBydW50aW1lLlR5cGVzLlV0aWxzLkZuPHtleHRBcmdzOiBydW50aW1lLlR5cGVzLkV4dGVuc2lvbnMuSW50ZXJuYWxBcmdzIH0sIHJ1bnRpbWUuVHlwZXMuVXRpbHMuUmVjb3JkPHN0cmluZywgYW55Pj4ge1xuICByZXR1cm5zOiBUeXBlTWFwPHRoaXNbJ3BhcmFtcyddWydleHRBcmdzJ10sIENsaWVudE9wdGlvbnMgZXh0ZW5kcyB7IG9taXQ6IGluZmVyIE9taXRPcHRpb25zIH0gPyBPbWl0T3B0aW9ucyA6IHt9PlxufVxuXG5leHBvcnQgdHlwZSBUeXBlTWFwPEV4dEFyZ3MgZXh0ZW5kcyBydW50aW1lLlR5cGVzLkV4dGVuc2lvbnMuSW50ZXJuYWxBcmdzID0gcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLkRlZmF1bHRBcmdzLCBHbG9iYWxPbWl0T3B0aW9ucyA9IHt9PiA9IHtcbiAgZ2xvYmFsT21pdE9wdGlvbnM6IHtcbiAgICBvbWl0OiBHbG9iYWxPbWl0T3B0aW9uc1xuICB9XG4gIG1ldGE6IHtcbiAgICBtb2RlbFByb3BzOiBcInVzZXJcIiB8IFwibGF1bmNoZXJcIiB8IFwibW90ZFwiIHwgXCJzZXJ2ZXJcIiB8IFwic2VydmVyVGFnXCIgfCBcImFydGljbGVzXCJcbiAgICB0eElzb2xhdGlvbkxldmVsOiBUcmFuc2FjdGlvbklzb2xhdGlvbkxldmVsXG4gIH1cbiAgbW9kZWw6IHtcbiAgICBVc2VyOiB7XG4gICAgICBwYXlsb2FkOiBQcmlzbWEuJFVzZXJQYXlsb2FkPEV4dEFyZ3M+XG4gICAgICBmaWVsZHM6IFByaXNtYS5Vc2VyRmllbGRSZWZzXG4gICAgICBvcGVyYXRpb25zOiB7XG4gICAgICAgIGZpbmRVbmlxdWU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuVXNlckZpbmRVbmlxdWVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFVzZXJQYXlsb2FkPiB8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBmaW5kVW5pcXVlT3JUaHJvdzoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyRmluZFVuaXF1ZU9yVGhyb3dBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFVzZXJQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaXJzdDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyRmluZEZpcnN0QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRVc2VyUGF5bG9hZD4gfCBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpcnN0T3JUaHJvdzoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyRmluZEZpcnN0T3JUaHJvd0FyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kVXNlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZmluZE1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuVXNlckZpbmRNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRVc2VyUGF5bG9hZD5bXVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyQ3JlYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRVc2VyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlVzZXJDcmVhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlVzZXJEZWxldGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFVzZXJQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyVXBkYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRVc2VyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBkZWxldGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlVzZXJEZWxldGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyVXBkYXRlTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IEJhdGNoUGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIHVwc2VydDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyVXBzZXJ0QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRVc2VyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBhZ2dyZWdhdGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuVXNlckFnZ3JlZ2F0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLkFnZ3JlZ2F0ZVVzZXI+XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBCeToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Vc2VyR3JvdXBCeUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLlVzZXJHcm91cEJ5T3V0cHV0VHlwZT5bXVxuICAgICAgICB9XG4gICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlVzZXJDb3VudEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLlVzZXJDb3VudEFnZ3JlZ2F0ZU91dHB1dFR5cGU+IHwgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgTGF1bmNoZXI6IHtcbiAgICAgIHBheWxvYWQ6IFByaXNtYS4kTGF1bmNoZXJQYXlsb2FkPEV4dEFyZ3M+XG4gICAgICBmaWVsZHM6IFByaXNtYS5MYXVuY2hlckZpZWxkUmVmc1xuICAgICAgb3BlcmF0aW9uczoge1xuICAgICAgICBmaW5kVW5pcXVlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyRmluZFVuaXF1ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kTGF1bmNoZXJQYXlsb2FkPiB8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBmaW5kVW5pcXVlT3JUaHJvdzoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5MYXVuY2hlckZpbmRVbmlxdWVPclRocm93QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRMYXVuY2hlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpcnN0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyRmluZEZpcnN0QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRMYXVuY2hlclBheWxvYWQ+IHwgbnVsbFxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaXJzdE9yVGhyb3c6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJGaW5kRmlyc3RPclRocm93QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRMYXVuY2hlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZmluZE1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJGaW5kTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kTGF1bmNoZXJQYXlsb2FkPltdXG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyQ3JlYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRMYXVuY2hlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5MYXVuY2hlckNyZWF0ZU1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBCYXRjaFBheWxvYWRcbiAgICAgICAgfVxuICAgICAgICBkZWxldGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJEZWxldGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJExhdW5jaGVyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJVcGRhdGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJExhdW5jaGVyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBkZWxldGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyRGVsZXRlTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IEJhdGNoUGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJVcGRhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdXBzZXJ0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyVXBzZXJ0QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRMYXVuY2hlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgYWdncmVnYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkxhdW5jaGVyQWdncmVnYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuQWdncmVnYXRlTGF1bmNoZXI+XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBCeToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5MYXVuY2hlckdyb3VwQnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLk9wdGlvbmFsPFByaXNtYS5MYXVuY2hlckdyb3VwQnlPdXRwdXRUeXBlPltdXG4gICAgICAgIH1cbiAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTGF1bmNoZXJDb3VudEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLkxhdW5jaGVyQ291bnRBZ2dyZWdhdGVPdXRwdXRUeXBlPiB8IG51bWJlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIE1vdGQ6IHtcbiAgICAgIHBheWxvYWQ6IFByaXNtYS4kTW90ZFBheWxvYWQ8RXh0QXJncz5cbiAgICAgIGZpZWxkczogUHJpc21hLk1vdGRGaWVsZFJlZnNcbiAgICAgIG9wZXJhdGlvbnM6IHtcbiAgICAgICAgZmluZFVuaXF1ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Nb3RkRmluZFVuaXF1ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kTW90ZFBheWxvYWQ+IHwgbnVsbFxuICAgICAgICB9XG4gICAgICAgIGZpbmRVbmlxdWVPclRocm93OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRGaW5kVW5pcXVlT3JUaHJvd0FyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kTW90ZFBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpcnN0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRGaW5kRmlyc3RBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJE1vdGRQYXlsb2FkPiB8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBmaW5kRmlyc3RPclRocm93OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRGaW5kRmlyc3RPclRocm93QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRNb3RkUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBmaW5kTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Nb3RkRmluZE1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJE1vdGRQYXlsb2FkPltdXG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRDcmVhdGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJE1vdGRQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTW90ZENyZWF0ZU1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBCYXRjaFBheWxvYWRcbiAgICAgICAgfVxuICAgICAgICBkZWxldGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTW90ZERlbGV0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kTW90ZFBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRVcGRhdGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJE1vdGRQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTW90ZERlbGV0ZU1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBCYXRjaFBheWxvYWRcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRVcGRhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdXBzZXJ0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRVcHNlcnRBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJE1vdGRQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGFnZ3JlZ2F0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5Nb3RkQWdncmVnYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuQWdncmVnYXRlTW90ZD5cbiAgICAgICAgfVxuICAgICAgICBncm91cEJ5OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLk1vdGRHcm91cEJ5QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuTW90ZEdyb3VwQnlPdXRwdXRUeXBlPltdXG4gICAgICAgIH1cbiAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuTW90ZENvdW50QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuTW90ZENvdW50QWdncmVnYXRlT3V0cHV0VHlwZT4gfCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBTZXJ2ZXI6IHtcbiAgICAgIHBheWxvYWQ6IFByaXNtYS4kU2VydmVyUGF5bG9hZDxFeHRBcmdzPlxuICAgICAgZmllbGRzOiBQcmlzbWEuU2VydmVyRmllbGRSZWZzXG4gICAgICBvcGVyYXRpb25zOiB7XG4gICAgICAgIGZpbmRVbmlxdWU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyRmluZFVuaXF1ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyUGF5bG9hZD4gfCBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZmluZFVuaXF1ZU9yVGhyb3c6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyRmluZFVuaXF1ZU9yVGhyb3dBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpcnN0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlckZpbmRGaXJzdEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyUGF5bG9hZD4gfCBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZmluZEZpcnN0T3JUaHJvdzoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJGaW5kRmlyc3RPclRocm93QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRTZXJ2ZXJQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGZpbmRNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlckZpbmRNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRTZXJ2ZXJQYXlsb2FkPltdXG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlckNyZWF0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBjcmVhdGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlckNyZWF0ZU1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBCYXRjaFBheWxvYWRcbiAgICAgICAgfVxuICAgICAgICBkZWxldGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyRGVsZXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRTZXJ2ZXJQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJVcGRhdGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclBheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJEZWxldGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJVcGRhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgdXBzZXJ0OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclVwc2VydEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBhZ2dyZWdhdGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyQWdncmVnYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuQWdncmVnYXRlU2VydmVyPlxuICAgICAgICB9XG4gICAgICAgIGdyb3VwQnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyR3JvdXBCeUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLlNlcnZlckdyb3VwQnlPdXRwdXRUeXBlPltdXG4gICAgICAgIH1cbiAgICAgICAgY291bnQ6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyQ291bnRBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLk9wdGlvbmFsPFByaXNtYS5TZXJ2ZXJDb3VudEFnZ3JlZ2F0ZU91dHB1dFR5cGU+IHwgbnVtYmVyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgU2VydmVyVGFnOiB7XG4gICAgICBwYXlsb2FkOiBQcmlzbWEuJFNlcnZlclRhZ1BheWxvYWQ8RXh0QXJncz5cbiAgICAgIGZpZWxkczogUHJpc21hLlNlcnZlclRhZ0ZpZWxkUmVmc1xuICAgICAgb3BlcmF0aW9uczoge1xuICAgICAgICBmaW5kVW5pcXVlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0ZpbmRVbmlxdWVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclRhZ1BheWxvYWQ+IHwgbnVsbFxuICAgICAgICB9XG4gICAgICAgIGZpbmRVbmlxdWVPclRocm93OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0ZpbmRVbmlxdWVPclRocm93QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRTZXJ2ZXJUYWdQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaXJzdDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJUYWdGaW5kRmlyc3RBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclRhZ1BheWxvYWQ+IHwgbnVsbFxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaXJzdE9yVGhyb3c6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyVGFnRmluZEZpcnN0T3JUaHJvd0FyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyVGFnUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICBmaW5kTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJUYWdGaW5kTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyVGFnUGF5bG9hZD5bXVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJUYWdDcmVhdGVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclRhZ1BheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJUYWdDcmVhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0RlbGV0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kU2VydmVyVGFnUGF5bG9hZD5cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyVGFnVXBkYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRTZXJ2ZXJUYWdQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyVGFnRGVsZXRlTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IEJhdGNoUGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuU2VydmVyVGFnVXBkYXRlTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IEJhdGNoUGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIHVwc2VydDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5TZXJ2ZXJUYWdVcHNlcnRBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJFNlcnZlclRhZ1BheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgYWdncmVnYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0FnZ3JlZ2F0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLkFnZ3JlZ2F0ZVNlcnZlclRhZz5cbiAgICAgICAgfVxuICAgICAgICBncm91cEJ5OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0dyb3VwQnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLk9wdGlvbmFsPFByaXNtYS5TZXJ2ZXJUYWdHcm91cEJ5T3V0cHV0VHlwZT5bXVxuICAgICAgICB9XG4gICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLlNlcnZlclRhZ0NvdW50QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuU2VydmVyVGFnQ291bnRBZ2dyZWdhdGVPdXRwdXRUeXBlPiB8IG51bWJlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIEFydGljbGVzOiB7XG4gICAgICBwYXlsb2FkOiBQcmlzbWEuJEFydGljbGVzUGF5bG9hZDxFeHRBcmdzPlxuICAgICAgZmllbGRzOiBQcmlzbWEuQXJ0aWNsZXNGaWVsZFJlZnNcbiAgICAgIG9wZXJhdGlvbnM6IHtcbiAgICAgICAgZmluZFVuaXF1ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc0ZpbmRVbmlxdWVBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJEFydGljbGVzUGF5bG9hZD4gfCBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZmluZFVuaXF1ZU9yVGhyb3c6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuQXJ0aWNsZXNGaW5kVW5pcXVlT3JUaHJvd0FyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kQXJ0aWNsZXNQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGZpbmRGaXJzdDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc0ZpbmRGaXJzdEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kQXJ0aWNsZXNQYXlsb2FkPiB8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBmaW5kRmlyc3RPclRocm93OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzRmluZEZpcnN0T3JUaHJvd0FyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kQXJ0aWNsZXNQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGZpbmRNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzRmluZE1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLlBheWxvYWRUb1Jlc3VsdDxQcmlzbWEuJEFydGljbGVzUGF5bG9hZD5bXVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc0NyZWF0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kQXJ0aWNsZXNQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZU1hbnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuQXJ0aWNsZXNDcmVhdGVNYW55QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogQmF0Y2hQYXlsb2FkXG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzRGVsZXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRBcnRpY2xlc1BheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzVXBkYXRlQXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5QYXlsb2FkVG9SZXN1bHQ8UHJpc21hLiRBcnRpY2xlc1BheWxvYWQ+XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlTWFueToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc0RlbGV0ZU1hbnlBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBCYXRjaFBheWxvYWRcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVNYW55OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzVXBkYXRlTWFueUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IEJhdGNoUGF5bG9hZFxuICAgICAgICB9XG4gICAgICAgIHVwc2VydDoge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc1Vwc2VydEFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuUGF5bG9hZFRvUmVzdWx0PFByaXNtYS4kQXJ0aWNsZXNQYXlsb2FkPlxuICAgICAgICB9XG4gICAgICAgIGFnZ3JlZ2F0ZToge1xuICAgICAgICAgIGFyZ3M6IFByaXNtYS5BcnRpY2xlc0FnZ3JlZ2F0ZUFyZ3M8RXh0QXJncz5cbiAgICAgICAgICByZXN1bHQ6IHJ1bnRpbWUuVHlwZXMuVXRpbHMuT3B0aW9uYWw8UHJpc21hLkFnZ3JlZ2F0ZUFydGljbGVzPlxuICAgICAgICB9XG4gICAgICAgIGdyb3VwQnk6IHtcbiAgICAgICAgICBhcmdzOiBQcmlzbWEuQXJ0aWNsZXNHcm91cEJ5QXJnczxFeHRBcmdzPlxuICAgICAgICAgIHJlc3VsdDogcnVudGltZS5UeXBlcy5VdGlscy5PcHRpb25hbDxQcmlzbWEuQXJ0aWNsZXNHcm91cEJ5T3V0cHV0VHlwZT5bXVxuICAgICAgICB9XG4gICAgICAgIGNvdW50OiB7XG4gICAgICAgICAgYXJnczogUHJpc21hLkFydGljbGVzQ291bnRBcmdzPEV4dEFyZ3M+XG4gICAgICAgICAgcmVzdWx0OiBydW50aW1lLlR5cGVzLlV0aWxzLk9wdGlvbmFsPFByaXNtYS5BcnRpY2xlc0NvdW50QWdncmVnYXRlT3V0cHV0VHlwZT4gfCBudW1iZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAmIHtcbiAgb3RoZXI6IHtcbiAgICBwYXlsb2FkOiBhbnlcbiAgICBvcGVyYXRpb25zOiB7XG4gICAgICAkZXhlY3V0ZVJhdzoge1xuICAgICAgICBhcmdzOiBbcXVlcnk6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHwgU3FsLCAuLi52YWx1ZXM6IGFueVtdXSxcbiAgICAgICAgcmVzdWx0OiBhbnlcbiAgICAgIH1cbiAgICAgICRleGVjdXRlUmF3VW5zYWZlOiB7XG4gICAgICAgIGFyZ3M6IFtxdWVyeTogc3RyaW5nLCAuLi52YWx1ZXM6IGFueVtdXSxcbiAgICAgICAgcmVzdWx0OiBhbnlcbiAgICAgIH1cbiAgICAgICRxdWVyeVJhdzoge1xuICAgICAgICBhcmdzOiBbcXVlcnk6IFRlbXBsYXRlU3RyaW5nc0FycmF5IHwgU3FsLCAuLi52YWx1ZXM6IGFueVtdXSxcbiAgICAgICAgcmVzdWx0OiBhbnlcbiAgICAgIH1cbiAgICAgICRxdWVyeVJhd1Vuc2FmZToge1xuICAgICAgICBhcmdzOiBbcXVlcnk6IHN0cmluZywgLi4udmFsdWVzOiBhbnlbXV0sXG4gICAgICAgIHJlc3VsdDogYW55XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW51bXNcbiAqL1xuXG5leHBvcnQgY29uc3QgVHJhbnNhY3Rpb25Jc29sYXRpb25MZXZlbCA9IHJ1bnRpbWUubWFrZVN0cmljdEVudW0oe1xuICBSZWFkVW5jb21taXR0ZWQ6ICdSZWFkVW5jb21taXR0ZWQnLFxuICBSZWFkQ29tbWl0dGVkOiAnUmVhZENvbW1pdHRlZCcsXG4gIFJlcGVhdGFibGVSZWFkOiAnUmVwZWF0YWJsZVJlYWQnLFxuICBTZXJpYWxpemFibGU6ICdTZXJpYWxpemFibGUnXG59IGFzIGNvbnN0KVxuXG5leHBvcnQgdHlwZSBUcmFuc2FjdGlvbklzb2xhdGlvbkxldmVsID0gKHR5cGVvZiBUcmFuc2FjdGlvbklzb2xhdGlvbkxldmVsKVtrZXlvZiB0eXBlb2YgVHJhbnNhY3Rpb25Jc29sYXRpb25MZXZlbF1cblxuXG5leHBvcnQgY29uc3QgVXNlclNjYWxhckZpZWxkRW51bSA9IHtcbiAgaWQ6ICdpZCcsXG4gIGVtYWlsOiAnZW1haWwnLFxuICBuYW1lOiAnbmFtZScsXG4gIHBhc3N3b3JkOiAncGFzc3dvcmQnLFxuICBwb2xsVGFnczogJ3BvbGxUYWdzJyxcbiAgY3JlYXRlZEF0OiAnY3JlYXRlZEF0JyxcbiAgdXBkYXRlZEF0OiAndXBkYXRlZEF0J1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBVc2VyU2NhbGFyRmllbGRFbnVtID0gKHR5cGVvZiBVc2VyU2NhbGFyRmllbGRFbnVtKVtrZXlvZiB0eXBlb2YgVXNlclNjYWxhckZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgTGF1bmNoZXJTY2FsYXJGaWVsZEVudW0gPSB7XG4gIGlkOiAnaWQnLFxuICBkYXRhVHlwZTogJ2RhdGFUeXBlJyxcbiAgZGF0YVZhbHVlOiAnZGF0YVZhbHVlJyxcbiAgY3JlYXRlZEF0OiAnY3JlYXRlZEF0JyxcbiAgdXBkYXRlZEF0OiAndXBkYXRlZEF0J1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBMYXVuY2hlclNjYWxhckZpZWxkRW51bSA9ICh0eXBlb2YgTGF1bmNoZXJTY2FsYXJGaWVsZEVudW0pW2tleW9mIHR5cGVvZiBMYXVuY2hlclNjYWxhckZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgTW90ZFNjYWxhckZpZWxkRW51bSA9IHtcbiAgaWQ6ICdpZCcsXG4gIG1vdGQ6ICdtb3RkJyxcbiAgY3JlYXRlZEF0OiAnY3JlYXRlZEF0JyxcbiAgdXBkYXRlZEF0OiAndXBkYXRlZEF0J1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBNb3RkU2NhbGFyRmllbGRFbnVtID0gKHR5cGVvZiBNb3RkU2NhbGFyRmllbGRFbnVtKVtrZXlvZiB0eXBlb2YgTW90ZFNjYWxhckZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgU2VydmVyU2NhbGFyRmllbGRFbnVtID0ge1xuICBpZDogJ2lkJyxcbiAgc2VydmVySWQ6ICdzZXJ2ZXJJZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgZGVzYzogJ2Rlc2MnLFxuICBtY1ZlcnNpb246ICdtY1ZlcnNpb24nLFxuICBkaWZmaWN1bHR5OiAnZGlmZmljdWx0eScsXG4gIGFzc2V0czogJ2Fzc2V0cycsXG4gIGNvcmU6ICdjb3JlJyxcbiAgbW9kcGFjazogJ21vZHBhY2snLFxuICBhdmFpbGFibGU6ICdhdmFpbGFibGUnLFxuICBtb2RkZWQ6ICdtb2RkZWQnLFxuICBmZWF0dXJlZDogJ2ZlYXR1cmVkJyxcbiAgcGVyaW9kaWM6ICdwZXJpb2RpYycsXG4gIGNyZWF0ZWRBdDogJ2NyZWF0ZWRBdCcsXG4gIHVwZGF0ZWRBdDogJ3VwZGF0ZWRBdCdcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU2VydmVyU2NhbGFyRmllbGRFbnVtID0gKHR5cGVvZiBTZXJ2ZXJTY2FsYXJGaWVsZEVudW0pW2tleW9mIHR5cGVvZiBTZXJ2ZXJTY2FsYXJGaWVsZEVudW1dXG5cblxuZXhwb3J0IGNvbnN0IFNlcnZlclRhZ1NjYWxhckZpZWxkRW51bSA9IHtcbiAgaWQ6ICdpZCcsXG4gIHRhZ0lkOiAndGFnSWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIGRlc2M6ICdkZXNjJyxcbiAgY3JlYXRlZEF0OiAnY3JlYXRlZEF0JyxcbiAgdXBkYXRlZEF0OiAndXBkYXRlZEF0J1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBTZXJ2ZXJUYWdTY2FsYXJGaWVsZEVudW0gPSAodHlwZW9mIFNlcnZlclRhZ1NjYWxhckZpZWxkRW51bSlba2V5b2YgdHlwZW9mIFNlcnZlclRhZ1NjYWxhckZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgQXJ0aWNsZXNTY2FsYXJGaWVsZEVudW0gPSB7XG4gIGlkOiAnaWQnLFxuICBhcnRpY2xlSWQ6ICdhcnRpY2xlSWQnLFxuICBzZXJ2ZXJJZDogJ3NlcnZlcklkJyxcbiAgdGFiTmFtZTogJ3RhYk5hbWUnLFxuICBwYWdlT3JkZXI6ICdwYWdlT3JkZXInLFxuICB0aXRsZTogJ3RpdGxlJyxcbiAgc3VidGl0bGU6ICdzdWJ0aXRsZScsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgYXZhaWxhYmxlOiAnYXZhaWxhYmxlJyxcbiAgY3JlYXRlZEF0OiAnY3JlYXRlZEF0JyxcbiAgdXBkYXRlZEF0OiAndXBkYXRlZEF0J1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBBcnRpY2xlc1NjYWxhckZpZWxkRW51bSA9ICh0eXBlb2YgQXJ0aWNsZXNTY2FsYXJGaWVsZEVudW0pW2tleW9mIHR5cGVvZiBBcnRpY2xlc1NjYWxhckZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgU29ydE9yZGVyID0ge1xuICBhc2M6ICdhc2MnLFxuICBkZXNjOiAnZGVzYydcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU29ydE9yZGVyID0gKHR5cGVvZiBTb3J0T3JkZXIpW2tleW9mIHR5cGVvZiBTb3J0T3JkZXJdXG5cblxuZXhwb3J0IGNvbnN0IFVzZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtID0ge1xuICBpZDogJ2lkJyxcbiAgZW1haWw6ICdlbWFpbCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgcGFzc3dvcmQ6ICdwYXNzd29yZCcsXG4gIHBvbGxUYWdzOiAncG9sbFRhZ3MnXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFVzZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtID0gKHR5cGVvZiBVc2VyT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSlba2V5b2YgdHlwZW9mIFVzZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtXVxuXG5cbmV4cG9ydCBjb25zdCBMYXVuY2hlck9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSB7XG4gIGlkOiAnaWQnLFxuICBkYXRhVHlwZTogJ2RhdGFUeXBlJyxcbiAgZGF0YVZhbHVlOiAnZGF0YVZhbHVlJ1xufSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBMYXVuY2hlck9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSAodHlwZW9mIExhdW5jaGVyT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSlba2V5b2YgdHlwZW9mIExhdW5jaGVyT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bV1cblxuXG5leHBvcnQgY29uc3QgTW90ZE9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSB7XG4gIGlkOiAnaWQnLFxuICBtb3RkOiAnbW90ZCdcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgTW90ZE9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSAodHlwZW9mIE1vdGRPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtKVtrZXlvZiB0eXBlb2YgTW90ZE9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW1dXG5cblxuZXhwb3J0IGNvbnN0IFNlcnZlck9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSB7XG4gIGlkOiAnaWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIGRlc2M6ICdkZXNjJyxcbiAgbWNWZXJzaW9uOiAnbWNWZXJzaW9uJyxcbiAgYXNzZXRzOiAnYXNzZXRzJyxcbiAgY29yZTogJ2NvcmUnLFxuICBtb2RwYWNrOiAnbW9kcGFjaycsXG4gIGZlYXR1cmVkOiAnZmVhdHVyZWQnXG59IGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIFNlcnZlck9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0gPSAodHlwZW9mIFNlcnZlck9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0pW2tleW9mIHR5cGVvZiBTZXJ2ZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtXVxuXG5cbmV4cG9ydCBjb25zdCBTZXJ2ZXJUYWdPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtID0ge1xuICBpZDogJ2lkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBkZXNjOiAnZGVzYydcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgU2VydmVyVGFnT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSA9ICh0eXBlb2YgU2VydmVyVGFnT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSlba2V5b2YgdHlwZW9mIFNlcnZlclRhZ09yZGVyQnlSZWxldmFuY2VGaWVsZEVudW1dXG5cblxuZXhwb3J0IGNvbnN0IEFydGljbGVzT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSA9IHtcbiAgaWQ6ICdpZCcsXG4gIHRhYk5hbWU6ICd0YWJOYW1lJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHN1YnRpdGxlOiAnc3VidGl0bGUnLFxuICB0ZXh0OiAndGV4dCdcbn0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgQXJ0aWNsZXNPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtID0gKHR5cGVvZiBBcnRpY2xlc09yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0pW2tleW9mIHR5cGVvZiBBcnRpY2xlc09yZGVyQnlSZWxldmFuY2VGaWVsZEVudW1dXG5cblxuXG4vKipcbiAqIEZpZWxkIHJlZmVyZW5jZXMgXG4gKi9cblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZpZWxkIG9mIHR5cGUgJ1N0cmluZydcbiAqL1xuZXhwb3J0IHR5cGUgU3RyaW5nRmllbGRSZWZJbnB1dDwkUHJpc21hTW9kZWw+ID0gRmllbGRSZWZJbnB1dFR5cGU8JFByaXNtYU1vZGVsLCAnU3RyaW5nJz5cbiAgICBcblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZpZWxkIG9mIHR5cGUgJ0RhdGVUaW1lJ1xuICovXG5leHBvcnQgdHlwZSBEYXRlVGltZUZpZWxkUmVmSW5wdXQ8JFByaXNtYU1vZGVsPiA9IEZpZWxkUmVmSW5wdXRUeXBlPCRQcmlzbWFNb2RlbCwgJ0RhdGVUaW1lJz5cbiAgICBcblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZpZWxkIG9mIHR5cGUgJ0ludCdcbiAqL1xuZXhwb3J0IHR5cGUgSW50RmllbGRSZWZJbnB1dDwkUHJpc21hTW9kZWw+ID0gRmllbGRSZWZJbnB1dFR5cGU8JFByaXNtYU1vZGVsLCAnSW50Jz5cbiAgICBcblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZpZWxkIG9mIHR5cGUgJ0Jvb2xlYW4nXG4gKi9cbmV4cG9ydCB0eXBlIEJvb2xlYW5GaWVsZFJlZklucHV0PCRQcmlzbWFNb2RlbD4gPSBGaWVsZFJlZklucHV0VHlwZTwkUHJpc21hTW9kZWwsICdCb29sZWFuJz5cbiAgICBcblxuXG4vKipcbiAqIFJlZmVyZW5jZSB0byBhIGZpZWxkIG9mIHR5cGUgJ0Zsb2F0J1xuICovXG5leHBvcnQgdHlwZSBGbG9hdEZpZWxkUmVmSW5wdXQ8JFByaXNtYU1vZGVsPiA9IEZpZWxkUmVmSW5wdXRUeXBlPCRQcmlzbWFNb2RlbCwgJ0Zsb2F0Jz5cbiAgICBcblxuLyoqXG4gKiBCYXRjaCBQYXlsb2FkIGZvciB1cGRhdGVNYW55ICYgZGVsZXRlTWFueSAmIGNyZWF0ZU1hbnlcbiAqL1xuZXhwb3J0IHR5cGUgQmF0Y2hQYXlsb2FkID0ge1xuICBjb3VudDogbnVtYmVyXG59XG5cblxuZXhwb3J0IHR5cGUgRGF0YXNvdXJjZSA9IHtcbiAgdXJsPzogc3RyaW5nXG59XG5leHBvcnQgdHlwZSBEYXRhc291cmNlcyA9IHtcbiAgZGI/OiBEYXRhc291cmNlXG59XG5cbmV4cG9ydCBjb25zdCBkZWZpbmVFeHRlbnNpb24gPSBydW50aW1lLkV4dGVuc2lvbnMuZGVmaW5lRXh0ZW5zaW9uIGFzIHVua25vd24gYXMgcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLkV4dGVuZHNIb29rPFwiZGVmaW5lXCIsIFR5cGVNYXBDYiwgcnVudGltZS5UeXBlcy5FeHRlbnNpb25zLkRlZmF1bHRBcmdzPlxuZXhwb3J0IHR5cGUgRGVmYXVsdFByaXNtYUNsaWVudCA9IFByaXNtYUNsaWVudFxuZXhwb3J0IHR5cGUgRXJyb3JGb3JtYXQgPSAncHJldHR5JyB8ICdjb2xvcmxlc3MnIHwgJ21pbmltYWwnXG5leHBvcnQgaW50ZXJmYWNlIFByaXNtYUNsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogT3ZlcndyaXRlcyB0aGUgZGF0YXNvdXJjZSB1cmwgZnJvbSB5b3VyIHNjaGVtYS5wcmlzbWEgZmlsZVxuICAgKi9cbiAgZGF0YXNvdXJjZXM/OiBEYXRhc291cmNlc1xuICAvKipcbiAgICogT3ZlcndyaXRlcyB0aGUgZGF0YXNvdXJjZSB1cmwgZnJvbSB5b3VyIHNjaGVtYS5wcmlzbWEgZmlsZVxuICAgKi9cbiAgZGF0YXNvdXJjZVVybD86IHN0cmluZ1xuICAvKipcbiAgICogQGRlZmF1bHQgXCJjb2xvcmxlc3NcIlxuICAgKi9cbiAgZXJyb3JGb3JtYXQ/OiBFcnJvckZvcm1hdFxuICAvKipcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIC8vIERlZmF1bHRzIHRvIHN0ZG91dFxuICAgKiBsb2c6IFsncXVlcnknLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ11cbiAgICogXG4gICAqIC8vIEVtaXQgYXMgZXZlbnRzXG4gICAqIGxvZzogW1xuICAgKiAgIHsgZW1pdDogJ3N0ZG91dCcsIGxldmVsOiAncXVlcnknIH0sXG4gICAqICAgeyBlbWl0OiAnc3Rkb3V0JywgbGV2ZWw6ICdpbmZvJyB9LFxuICAgKiAgIHsgZW1pdDogJ3N0ZG91dCcsIGxldmVsOiAnd2FybicgfVxuICAgKiAgIHsgZW1pdDogJ3N0ZG91dCcsIGxldmVsOiAnZXJyb3InIH1cbiAgICogXVxuICAgKiBgYGBcbiAgICogUmVhZCBtb3JlIGluIG91ciBbZG9jc10oaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvcmVmZXJlbmNlL3Rvb2xzLWFuZC1pbnRlcmZhY2VzL3ByaXNtYS1jbGllbnQvbG9nZ2luZyN0aGUtbG9nLW9wdGlvbikuXG4gICAqL1xuICBsb2c/OiAoTG9nTGV2ZWwgfCBMb2dEZWZpbml0aW9uKVtdXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHRyYW5zYWN0aW9uT3B0aW9uc1xuICAgKiBtYXhXYWl0ID89IDIwMDBcbiAgICogdGltZW91dCA/PSA1MDAwXG4gICAqL1xuICB0cmFuc2FjdGlvbk9wdGlvbnM/OiB7XG4gICAgbWF4V2FpdD86IG51bWJlclxuICAgIHRpbWVvdXQ/OiBudW1iZXJcbiAgICBpc29sYXRpb25MZXZlbD86IFRyYW5zYWN0aW9uSXNvbGF0aW9uTGV2ZWxcbiAgfVxuICAvKipcbiAgICogR2xvYmFsIGNvbmZpZ3VyYXRpb24gZm9yIG9taXR0aW5nIG1vZGVsIGZpZWxkcyBieSBkZWZhdWx0LlxuICAgKiBcbiAgICogQGV4YW1wbGVcbiAgICogYGBgXG4gICAqIGNvbnN0IHByaXNtYSA9IG5ldyBQcmlzbWFDbGllbnQoe1xuICAgKiAgIG9taXQ6IHtcbiAgICogICAgIHVzZXI6IHtcbiAgICogICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgb21pdD86IEdsb2JhbE9taXRDb25maWdcbn1cbmV4cG9ydCB0eXBlIEdsb2JhbE9taXRDb25maWcgPSB7XG4gIHVzZXI/OiBQcmlzbWEuVXNlck9taXRcbiAgbGF1bmNoZXI/OiBQcmlzbWEuTGF1bmNoZXJPbWl0XG4gIG1vdGQ/OiBQcmlzbWEuTW90ZE9taXRcbiAgc2VydmVyPzogUHJpc21hLlNlcnZlck9taXRcbiAgc2VydmVyVGFnPzogUHJpc21hLlNlcnZlclRhZ09taXRcbiAgYXJ0aWNsZXM/OiBQcmlzbWEuQXJ0aWNsZXNPbWl0XG59XG5cbi8qIFR5cGVzIGZvciBMb2dnaW5nICovXG5leHBvcnQgdHlwZSBMb2dMZXZlbCA9ICdpbmZvJyB8ICdxdWVyeScgfCAnd2FybicgfCAnZXJyb3InXG5leHBvcnQgdHlwZSBMb2dEZWZpbml0aW9uID0ge1xuICBsZXZlbDogTG9nTGV2ZWxcbiAgZW1pdDogJ3N0ZG91dCcgfCAnZXZlbnQnXG59XG5cbmV4cG9ydCB0eXBlIEdldExvZ1R5cGU8VCBleHRlbmRzIExvZ0xldmVsIHwgTG9nRGVmaW5pdGlvbj4gPSBUIGV4dGVuZHMgTG9nRGVmaW5pdGlvbiA/IFRbJ2VtaXQnXSBleHRlbmRzICdldmVudCcgPyBUWydsZXZlbCddIDogbmV2ZXIgOiBuZXZlclxuZXhwb3J0IHR5cGUgR2V0RXZlbnRzPFQgZXh0ZW5kcyBhbnk+ID0gVCBleHRlbmRzIEFycmF5PExvZ0xldmVsIHwgTG9nRGVmaW5pdGlvbj4gP1xuICBHZXRMb2dUeXBlPFRbMF0+IHwgR2V0TG9nVHlwZTxUWzFdPiB8IEdldExvZ1R5cGU8VFsyXT4gfCBHZXRMb2dUeXBlPFRbM10+XG4gIDogbmV2ZXJcblxuZXhwb3J0IHR5cGUgUXVlcnlFdmVudCA9IHtcbiAgdGltZXN0YW1wOiBEYXRlXG4gIHF1ZXJ5OiBzdHJpbmdcbiAgcGFyYW1zOiBzdHJpbmdcbiAgZHVyYXRpb246IG51bWJlclxuICB0YXJnZXQ6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBMb2dFdmVudCA9IHtcbiAgdGltZXN0YW1wOiBEYXRlXG4gIG1lc3NhZ2U6IHN0cmluZ1xuICB0YXJnZXQ6IHN0cmluZ1xufVxuLyogRW5kIFR5cGVzIGZvciBMb2dnaW5nICovXG5cblxuZXhwb3J0IHR5cGUgUHJpc21hQWN0aW9uID1cbiAgfCAnZmluZFVuaXF1ZSdcbiAgfCAnZmluZFVuaXF1ZU9yVGhyb3cnXG4gIHwgJ2ZpbmRNYW55J1xuICB8ICdmaW5kRmlyc3QnXG4gIHwgJ2ZpbmRGaXJzdE9yVGhyb3cnXG4gIHwgJ2NyZWF0ZSdcbiAgfCAnY3JlYXRlTWFueSdcbiAgfCAnY3JlYXRlTWFueUFuZFJldHVybidcbiAgfCAndXBkYXRlJ1xuICB8ICd1cGRhdGVNYW55J1xuICB8ICd1cGRhdGVNYW55QW5kUmV0dXJuJ1xuICB8ICd1cHNlcnQnXG4gIHwgJ2RlbGV0ZSdcbiAgfCAnZGVsZXRlTWFueSdcbiAgfCAnZXhlY3V0ZVJhdydcbiAgfCAncXVlcnlSYXcnXG4gIHwgJ2FnZ3JlZ2F0ZSdcbiAgfCAnY291bnQnXG4gIHwgJ3J1bkNvbW1hbmRSYXcnXG4gIHwgJ2ZpbmRSYXcnIFxuICB8ICdncm91cEJ5J1xuXG4vKipcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGJlaW5nIHBhc3NlZCBpbnRvIHRoZSBtaWRkbGV3YXJlIGFzIFwicGFyYW1zXCJcbiAqL1xuZXhwb3J0IHR5cGUgTWlkZGxld2FyZVBhcmFtcyA9IHtcbiAgbW9kZWw/OiBNb2RlbE5hbWVcbiAgYWN0aW9uOiBQcmlzbWFBY3Rpb25cbiAgYXJnczogYW55XG4gIGRhdGFQYXRoOiBzdHJpbmdbXVxuICBydW5JblRyYW5zYWN0aW9uOiBib29sZWFuXG59XG5cbi8qKlxuICogVGhlIGBUYCB0eXBlIG1ha2VzIHN1cmUsIHRoYXQgdGhlIGByZXR1cm4gcHJvY2VlZGAgaXMgbm90IGZvcmdvdHRlbiBpbiB0aGUgbWlkZGxld2FyZSBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgdHlwZSBNaWRkbGV3YXJlPFQgPSBhbnk+ID0gKFxuICBwYXJhbXM6IE1pZGRsZXdhcmVQYXJhbXMsXG4gIG5leHQ6IChwYXJhbXM6IE1pZGRsZXdhcmVQYXJhbXMpID0+IHJ1bnRpbWUuVHlwZXMuVXRpbHMuSnNQcm9taXNlPFQ+LFxuKSA9PiBydW50aW1lLlR5cGVzLlV0aWxzLkpzUHJvbWlzZTxUPlxuXG4vKipcbiAqIGBQcmlzbWFDbGllbnRgIHByb3h5IGF2YWlsYWJsZSBpbiBpbnRlcmFjdGl2ZSB0cmFuc2FjdGlvbnMuXG4gKi9cbmV4cG9ydCB0eXBlIFRyYW5zYWN0aW9uQ2xpZW50ID0gT21pdDxEZWZhdWx0UHJpc21hQ2xpZW50LCBydW50aW1lLklUWENsaWVudERlbnlMaXN0PlxuXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXBoZW1lcmFsS2V5U2l6ZSA9IGV4cG9ydHMuc3ltbWV0cmljTm9uY2VMZW5ndGggPSBleHBvcnRzLnN5bW1ldHJpY0FsZ29yaXRobSA9IGV4cG9ydHMuaXNIa2RmS2V5Q29tcHJlc3NlZCA9IGV4cG9ydHMuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkID0gZXhwb3J0cy5lbGxpcHRpY0N1cnZlID0gZXhwb3J0cy5FQ0lFU19DT05GSUcgPSB2b2lkIDA7XG52YXIgY29uc3RzXzEgPSByZXF1aXJlKFwiLi9jb25zdHNcIik7XG52YXIgQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbmZpZygpIHtcbiAgICAgICAgdGhpcy5lbGxpcHRpY0N1cnZlID0gXCJzZWNwMjU2azFcIjtcbiAgICAgICAgdGhpcy5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWQgPSBmYWxzZTsgLy8gc2VjcDI1NmsxIG9ubHlcbiAgICAgICAgdGhpcy5pc0hrZGZLZXlDb21wcmVzc2VkID0gZmFsc2U7IC8vIHNlY3AyNTZrMSBvbmx5XG4gICAgICAgIHRoaXMuc3ltbWV0cmljQWxnb3JpdGhtID0gXCJhZXMtMjU2LWdjbVwiO1xuICAgICAgICB0aGlzLnN5bW1ldHJpY05vbmNlTGVuZ3RoID0gMTY7IC8vIGFlcy0yNTYtZ2NtIG9ubHlcbiAgICB9XG4gICAgcmV0dXJuIENvbmZpZztcbn0oKSk7XG5leHBvcnRzLkVDSUVTX0NPTkZJRyA9IG5ldyBDb25maWcoKTtcbnZhciBlbGxpcHRpY0N1cnZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5FQ0lFU19DT05GSUcuZWxsaXB0aWNDdXJ2ZTsgfTtcbmV4cG9ydHMuZWxsaXB0aWNDdXJ2ZSA9IGVsbGlwdGljQ3VydmU7XG52YXIgaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5FQ0lFU19DT05GSUcuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkOyB9O1xuZXhwb3J0cy5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWQgPSBpc0VwaGVtZXJhbEtleUNvbXByZXNzZWQ7XG52YXIgaXNIa2RmS2V5Q29tcHJlc3NlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLmlzSGtkZktleUNvbXByZXNzZWQ7IH07XG5leHBvcnRzLmlzSGtkZktleUNvbXByZXNzZWQgPSBpc0hrZGZLZXlDb21wcmVzc2VkO1xudmFyIHN5bW1ldHJpY0FsZ29yaXRobSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLnN5bW1ldHJpY0FsZ29yaXRobTsgfTtcbmV4cG9ydHMuc3ltbWV0cmljQWxnb3JpdGhtID0gc3ltbWV0cmljQWxnb3JpdGhtO1xudmFyIHN5bW1ldHJpY05vbmNlTGVuZ3RoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZXhwb3J0cy5FQ0lFU19DT05GSUcuc3ltbWV0cmljTm9uY2VMZW5ndGg7IH07XG5leHBvcnRzLnN5bW1ldHJpY05vbmNlTGVuZ3RoID0gc3ltbWV0cmljTm9uY2VMZW5ndGg7XG52YXIgZXBoZW1lcmFsS2V5U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgc2VjcDI1NmsxOiBleHBvcnRzLkVDSUVTX0NPTkZJRy5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWRcbiAgICAgICAgICAgID8gY29uc3RzXzEuQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkVcbiAgICAgICAgICAgIDogY29uc3RzXzEuVU5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSxcbiAgICAgICAgeDI1NTE5OiBjb25zdHNfMS5DVVJWRTI1NTE5X1BVQkxJQ19LRVlfU0laRSxcbiAgICAgICAgZWQyNTUxOTogY29uc3RzXzEuQ1VSVkUyNTUxOV9QVUJMSUNfS0VZX1NJWkUsXG4gICAgfTtcbiAgICBpZiAoZXhwb3J0cy5FQ0lFU19DT05GSUcuZWxsaXB0aWNDdXJ2ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nW2V4cG9ydHMuRUNJRVNfQ09ORklHLmVsbGlwdGljQ3VydmVdO1xuICAgIH0gLyogdjggaWdub3JlIG5leHQgMiAqL1xuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufTtcbmV4cG9ydHMuZXBoZW1lcmFsS2V5U2l6ZSA9IGVwaGVtZXJhbEtleVNpemU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQUVBRF9UQUdfTEVOR1RIID0gZXhwb3J0cy5YQ0hBQ0hBMjBfTk9OQ0VfTEVOR1RIID0gZXhwb3J0cy5DVVJWRTI1NTE5X1BVQkxJQ19LRVlfU0laRSA9IGV4cG9ydHMuRVRIX1BVQkxJQ19LRVlfU0laRSA9IGV4cG9ydHMuVU5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IGV4cG9ydHMuQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkUgPSBleHBvcnRzLlNFQ1JFVF9LRVlfTEVOR1RIID0gdm9pZCAwO1xuLy8gZWxsaXB0aWNcbmV4cG9ydHMuU0VDUkVUX0tFWV9MRU5HVEggPSAzMjtcbmV4cG9ydHMuQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkUgPSAzMztcbmV4cG9ydHMuVU5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IDY1O1xuZXhwb3J0cy5FVEhfUFVCTElDX0tFWV9TSVpFID0gNjQ7XG5leHBvcnRzLkNVUlZFMjU1MTlfUFVCTElDX0tFWV9TSVpFID0gMzI7XG4vLyBzeW1tZXRyaWNcbmV4cG9ydHMuWENIQUNIQTIwX05PTkNFX0xFTkdUSCA9IDI0O1xuZXhwb3J0cy5BRUFEX1RBR19MRU5HVEggPSAxNjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuUHVibGljS2V5ID0gZXhwb3J0cy5Qcml2YXRlS2V5ID0gZXhwb3J0cy5FQ0lFU19DT05GSUcgPSB2b2lkIDA7XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIGtleXNfMSA9IHJlcXVpcmUoXCIuL2tleXNcIik7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBFbmNyeXB0cyBkYXRhIHdpdGggYSByZWNlaXZlcidzIHB1YmxpYyBrZXkuXG4gKiBAZGVzY3JpcHRpb24gRnJvbSB2ZXJzaW9uIDAuNS4wLCBgVWludDhBcnJheWAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBCdWZmZXJgLlxuICogVG8ga2VlcCB0aGUgc2FtZSBiZWhhdmlvciwgdXNlIGBCdWZmZXIuZnJvbShlbmNyeXB0KC4uLikpYC5cbiAqXG4gKiBAcGFyYW0gcmVjZWl2ZXJSYXdQSyAtIFJhdyBwdWJsaWMga2V5IG9mIHRoZSByZWNlaXZlciwgZWl0aGVyIGFzIGEgaGV4IGBzdHJpbmdgIG9yIGEgYFVpbnQ4QXJyYXlgLlxuICogQHBhcmFtIGRhdGEgLSBEYXRhIHRvIGVuY3J5cHQuXG4gKiBAcmV0dXJucyBFbmNyeXB0ZWQgcGF5bG9hZCwgZm9ybWF0OiBgcHVibGljIGtleSB8fCBlbmNyeXB0ZWRgLlxuICovXG5mdW5jdGlvbiBlbmNyeXB0KHJlY2VpdmVyUmF3UEssIGRhdGEpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oX2VuY3J5cHQocmVjZWl2ZXJSYXdQSywgZGF0YSkpO1xufVxuZnVuY3Rpb24gX2VuY3J5cHQocmVjZWl2ZXJSYXdQSywgZGF0YSkge1xuICAgIHZhciBjdXJ2ZSA9ICgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpO1xuICAgIHZhciBlcGhlbWVyYWxTSyA9IG5ldyBrZXlzXzEuUHJpdmF0ZUtleSh1bmRlZmluZWQsIGN1cnZlKTtcbiAgICB2YXIgcmVjZWl2ZXJQSyA9IHJlY2VpdmVyUmF3UEsgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgID8gbmV3IGtleXNfMS5QdWJsaWNLZXkocmVjZWl2ZXJSYXdQSywgY3VydmUpXG4gICAgICAgIDoga2V5c18xLlB1YmxpY0tleS5mcm9tSGV4KHJlY2VpdmVyUmF3UEssIGN1cnZlKTtcbiAgICB2YXIgc2hhcmVkS2V5ID0gZXBoZW1lcmFsU0suZW5jYXBzdWxhdGUocmVjZWl2ZXJQSywgKDAsIGNvbmZpZ18xLmlzSGtkZktleUNvbXByZXNzZWQpKCkpO1xuICAgIHZhciBlcGhlbWVyYWxQSyA9IGVwaGVtZXJhbFNLLnB1YmxpY0tleS50b0J5dGVzKCgwLCBjb25maWdfMS5pc0VwaGVtZXJhbEtleUNvbXByZXNzZWQpKCkpO1xuICAgIHZhciBlbmNyeXB0ZWQgPSAoMCwgdXRpbHNfMi5zeW1FbmNyeXB0KShzaGFyZWRLZXksIGRhdGEpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoZXBoZW1lcmFsUEssIGVuY3J5cHRlZCk7XG59XG4vKipcbiAqIERlY3J5cHRzIGRhdGEgd2l0aCBhIHJlY2VpdmVyJ3MgcHJpdmF0ZSBrZXkuXG4gKiBAZGVzY3JpcHRpb24gRnJvbSB2ZXJzaW9uIDAuNS4wLCBgVWludDhBcnJheWAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBCdWZmZXJgLlxuICogVG8ga2VlcCB0aGUgc2FtZSBiZWhhdmlvciwgdXNlIGBCdWZmZXIuZnJvbShkZWNyeXB0KC4uLikpYC5cbiAqXG4gKiBAcGFyYW0gcmVjZWl2ZXJSYXdTSyAtIFJhdyBwcml2YXRlIGtleSBvZiB0aGUgcmVjZWl2ZXIsIGVpdGhlciBhcyBhIGhleCBgc3RyaW5nYCBvciBhIGBVaW50OEFycmF5YC5cbiAqIEBwYXJhbSBkYXRhIC0gRGF0YSB0byBkZWNyeXB0LlxuICogQHJldHVybnMgRGVjcnlwdGVkIHBsYWluIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHQocmVjZWl2ZXJSYXdTSywgZGF0YSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShfZGVjcnlwdChyZWNlaXZlclJhd1NLLCBkYXRhKSk7XG59XG5mdW5jdGlvbiBfZGVjcnlwdChyZWNlaXZlclJhd1NLLCBkYXRhKSB7XG4gICAgdmFyIGN1cnZlID0gKDAsIGNvbmZpZ18xLmVsbGlwdGljQ3VydmUpKCk7XG4gICAgdmFyIHJlY2VpdmVyU0sgPSByZWNlaXZlclJhd1NLIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICA/IG5ldyBrZXlzXzEuUHJpdmF0ZUtleShyZWNlaXZlclJhd1NLLCBjdXJ2ZSlcbiAgICAgICAgOiBrZXlzXzEuUHJpdmF0ZUtleS5mcm9tSGV4KHJlY2VpdmVyUmF3U0ssIGN1cnZlKTtcbiAgICB2YXIga2V5U2l6ZSA9ICgwLCBjb25maWdfMS5lcGhlbWVyYWxLZXlTaXplKSgpO1xuICAgIHZhciBlcGhlbWVyYWxQSyA9IG5ldyBrZXlzXzEuUHVibGljS2V5KGRhdGEuc3ViYXJyYXkoMCwga2V5U2l6ZSksIGN1cnZlKTtcbiAgICB2YXIgZW5jcnlwdGVkID0gZGF0YS5zdWJhcnJheShrZXlTaXplKTtcbiAgICB2YXIgc2hhcmVkS2V5ID0gZXBoZW1lcmFsUEsuZGVjYXBzdWxhdGUocmVjZWl2ZXJTSywgKDAsIGNvbmZpZ18xLmlzSGtkZktleUNvbXByZXNzZWQpKCkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMi5zeW1EZWNyeXB0KShzaGFyZWRLZXksIGVuY3J5cHRlZCk7XG59XG52YXIgY29uZmlnXzIgPSByZXF1aXJlKFwiLi9jb25maWdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFQ0lFU19DT05GSUdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZ18yLkVDSUVTX0NPTkZJRzsgfSB9KTtcbnZhciBrZXlzXzIgPSByZXF1aXJlKFwiLi9rZXlzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJpdmF0ZUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c18yLlByaXZhdGVLZXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaWNLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGtleXNfMi5QdWJsaWNLZXk7IH0gfSk7XG4vKiogQGRlcHJlY2F0ZWQgLSB1c2UgYGltcG9ydCB1dGlscyBmcm9tIFwiZWNpZXNqcy91dGlsc1wiYCBpbnN0ZWFkLiAqL1xuZXhwb3J0cy51dGlscyA9IHtcbiAgICAvLyBUT0RPOiByZW1vdmUgdGhlc2UgYWZ0ZXIgMC41LjBcbiAgICBhZXNFbmNyeXB0OiB1dGlsc18yLmFlc0VuY3J5cHQsXG4gICAgYWVzRGVjcnlwdDogdXRpbHNfMi5hZXNEZWNyeXB0LFxuICAgIHN5bUVuY3J5cHQ6IHV0aWxzXzIuc3ltRW5jcnlwdCxcbiAgICBzeW1EZWNyeXB0OiB1dGlsc18yLnN5bURlY3J5cHQsXG4gICAgZGVjb2RlSGV4OiB1dGlsc18yLmRlY29kZUhleCxcbiAgICBnZXRWYWxpZFNlY3JldDogdXRpbHNfMi5nZXRWYWxpZFNlY3JldCxcbiAgICByZW1vdmUweDogdXRpbHNfMi5yZW1vdmUweCxcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCIpO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG52YXIgUHVibGljS2V5XzEgPSByZXF1aXJlKFwiLi9QdWJsaWNLZXlcIik7XG52YXIgUHJpdmF0ZUtleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcml2YXRlS2V5KHNlY3JldCwgY3VydmUpIHtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICBpZiAoc2VjcmV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9ICgwLCB1dGlsc18yLmdldFZhbGlkU2VjcmV0KShjdXJ2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHV0aWxzXzIuaXNWYWxpZFByaXZhdGVLZXkpKHNlY3JldCwgY3VydmUpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleSgoMCwgdXRpbHNfMi5nZXRQdWJsaWNLZXkpKHRoaXMuZGF0YSwgY3VydmUpLCBjdXJ2ZSk7XG4gICAgfVxuICAgIFByaXZhdGVLZXkuZnJvbUhleCA9IGZ1bmN0aW9uIChoZXgsIGN1cnZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJpdmF0ZUtleSgoMCwgdXRpbHNfMi5kZWNvZGVIZXgpKGhleCksIGN1cnZlKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJzZWNyZXRcIiwge1xuICAgICAgICAvKiogQGRlc2NyaXB0aW9uIEZyb20gdmVyc2lvbiAwLjUuMCwgYFVpbnQ4QXJyYXlgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBgQnVmZmVyYC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBVaW50OEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkodGhpcy5kYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBzaGFyZWQgc2VjcmV0IGZyb20gZXBoZW1lcmFsIHByaXZhdGUga2V5ICh0aGlzKSBhbmQgcmVjZWl2ZXIncyBwdWJsaWMga2V5IChwaykuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzaGFyZWQga2V5IGlzIDMyIGJ5dGVzLCBkZXJpdmVkIHdpdGggYEhLREYtU0hBMjU2KHNlbmRlclBvaW50IHx8IHNoYXJlZFBvaW50KWAuIFNlZSBpbXBsZW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSBzb21lIHZhcmlhdGlvbnMgaW4gZGlmZmVyZW50IEVDSUVTIGltcGxlbWVudGF0aW9uczpcbiAgICAgKiB3aGljaCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UsIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIGBzZW5kZXJQb2ludGAvYHNoYXJlZFBvaW50YCwgd2hldGhlciB0byBpbmNsdWRlIGBzZW5kZXJQb2ludGAsIGV0Yy5cbiAgICAgKlxuICAgICAqIEJlY2F1c2UgdGhlIGVudHJvcHkgb2YgYHNlbmRlclBvaW50YCwgYHNoYXJlZFBvaW50YCBpcyBlbm91Z2ggaGlnaFsxXSwgd2UgZG9uJ3QgbmVlZCBzYWx0IHRvIGRlcml2ZSBrZXlzLlxuICAgICAqXG4gICAgICogWzFdOiBUd28gcmVhc29uczogdGhlIHB1YmxpYyBrZXlzIGFyZSBcInJhbmRvbVwiIGJ5dGVzIChhbGJlaXQgc2VjcDI1NmsxIHB1YmxpYyBrZXlzIGFyZSAqKm5vdCB1bmlmb3JtbHkqKiByYW5kb20pLCBhbmQgZXBoZW1lcmFsIGtleXMgYXJlIGdlbmVyYXRlZCBpbiBldmVyeSBlbmNyeXB0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBrIC0gUmVjZWl2ZXIncyBwdWJsaWMga2V5LlxuICAgICAqIEBwYXJhbSBjb21wcmVzc2VkIC0gKGRlZmF1bHQ6IGBmYWxzZWApIFdoZXRoZXIgdG8gdXNlIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIHB1YmxpYyBrZXlzIGluIHRoZSBrZXkgZGVyaXZhdGlvbiAoc2VjcDI1NmsxIG9ubHkpLlxuICAgICAqIEByZXR1cm5zIFNoYXJlZCBzZWNyZXQsIGRlcml2ZWQgd2l0aCBIS0RGLVNIQTI1Ni5cbiAgICAgKi9cbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS5lbmNhcHN1bGF0ZSA9IGZ1bmN0aW9uIChwaywgY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc2VuZGVyUG9pbnQgPSB0aGlzLnB1YmxpY0tleS50b0J5dGVzKGNvbXByZXNzZWQpO1xuICAgICAgICB2YXIgc2hhcmVkUG9pbnQgPSB0aGlzLm11bHRpcGx5KHBrLCBjb21wcmVzc2VkKTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18yLmdldFNoYXJlZEtleSkoc2VuZGVyUG9pbnQsIHNoYXJlZFBvaW50KTtcbiAgICB9O1xuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKHBrLCBjb21wcmVzc2VkKSB7XG4gICAgICAgIGlmIChjb21wcmVzc2VkID09PSB2b2lkIDApIHsgY29tcHJlc3NlZCA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5nZXRTaGFyZWRQb2ludCkodGhpcy5kYXRhLCBway50b0J5dGVzKHRydWUpLCBjb21wcmVzc2VkLCB0aGlzLmN1cnZlKTtcbiAgICB9O1xuICAgIFByaXZhdGVLZXkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZXF1YWxCeXRlcykodGhpcy5kYXRhLCBvdGhlci5kYXRhKTtcbiAgICB9O1xuICAgIHJldHVybiBQcml2YXRlS2V5O1xufSgpKTtcbmV4cG9ydHMuUHJpdmF0ZUtleSA9IFByaXZhdGVLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVibGljS2V5ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBQdWJsaWNLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVibGljS2V5KGRhdGEsIGN1cnZlKSB7XG4gICAgICAgIC8vIGRhdGEgY2FuIGJlIGVpdGhlciBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBpZiBzZWNwMjU2azFcbiAgICAgICAgdmFyIGNvbXByZXNzZWQgPSAoMCwgdXRpbHNfMi5jb252ZXJ0UHVibGljS2V5Rm9ybWF0KShkYXRhLCB0cnVlLCBjdXJ2ZSk7XG4gICAgICAgIHZhciB1bmNvbXByZXNzZWQgPSAoMCwgdXRpbHNfMi5jb252ZXJ0UHVibGljS2V5Rm9ybWF0KShkYXRhLCBmYWxzZSwgY3VydmUpO1xuICAgICAgICB0aGlzLmRhdGEgPSBjb21wcmVzc2VkO1xuICAgICAgICB0aGlzLmRhdGFVbmNvbXByZXNzZWQgPVxuICAgICAgICAgICAgY29tcHJlc3NlZC5sZW5ndGggIT09IHVuY29tcHJlc3NlZC5sZW5ndGggPyB1bmNvbXByZXNzZWQgOiBudWxsO1xuICAgIH1cbiAgICBQdWJsaWNLZXkuZnJvbUhleCA9IGZ1bmN0aW9uIChoZXgsIGN1cnZlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KCgwLCB1dGlsc18yLmhleFRvUHVibGljS2V5KShoZXgsIGN1cnZlKSwgY3VydmUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFB1YmxpY0tleS5wcm90b3R5cGUsIFwiX3VuY29tcHJlc3NlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVVuY29tcHJlc3NlZCAhPT0gbnVsbCA/IHRoaXMuZGF0YVVuY29tcHJlc3NlZCA6IHRoaXMuZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQdWJsaWNLZXkucHJvdG90eXBlLCBcInVuY29tcHJlc3NlZFwiLCB7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAtIHVzZSBgUHVibGljS2V5LnRvQnl0ZXMoZmFsc2UpYCBpbnN0ZWFkLiBZb3UgbWF5IGFsc28gbmVlZCBgQnVmZmVyLmZyb21gLiAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLl91bmNvbXByZXNzZWQpOyAvLyBUT0RPOiBkZWxldGVcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQdWJsaWNLZXkucHJvdG90eXBlLCBcImNvbXByZXNzZWRcIiwge1xuICAgICAgICAvKiogQGRlcHJlY2F0ZWQgLSB1c2UgYFB1YmxpY0tleS50b0J5dGVzKClgIGluc3RlYWQuIFlvdSBtYXkgYWxzbyBuZWVkIGBCdWZmZXIuZnJvbWAuICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuZGF0YSk7IC8vIFRPRE86IGRlbGV0ZVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUHVibGljS2V5LnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gKGNvbXByZXNzZWQpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gY29tcHJlc3NlZCA/IHRoaXMuZGF0YSA6IHRoaXMuX3VuY29tcHJlc3NlZDtcbiAgICB9O1xuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvQnl0ZXMoY29tcHJlc3NlZCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyBhIHNoYXJlZCBzZWNyZXQgZnJvbSByZWNlaXZlcidzIHByaXZhdGUga2V5IChzaykgYW5kIGVwaGVtZXJhbCBwdWJsaWMga2V5ICh0aGlzKS5cbiAgICAgKiBPcHBvc2l0ZSBvZiBgZW5jYXBzdWxhdGVgLlxuICAgICAqIEBzZWUgUHJpdmF0ZUtleS5lbmNhcHN1bGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHNrIC0gUmVjZWl2ZXIncyBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gY29tcHJlc3NlZCAtIChkZWZhdWx0OiBgZmFsc2VgKSBXaGV0aGVyIHRvIHVzZSBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cyBpbiB0aGUga2V5IGRlcml2YXRpb24gKHNlY3AyNTZrMSBvbmx5KS5cbiAgICAgKiBAcmV0dXJucyBTaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHdpdGggSEtERi1TSEEyNTYuXG4gICAgICovXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS5kZWNhcHN1bGF0ZSA9IGZ1bmN0aW9uIChzaywgY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc2VuZGVyUG9pbnQgPSB0aGlzLnRvQnl0ZXMoY29tcHJlc3NlZCk7XG4gICAgICAgIHZhciBzaGFyZWRQb2ludCA9IHNrLm11bHRpcGx5KHRoaXMsIGNvbXByZXNzZWQpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuZ2V0U2hhcmVkS2V5KShzZW5kZXJQb2ludCwgc2hhcmVkUG9pbnQpO1xuICAgIH07XG4gICAgUHVibGljS2V5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKHRoaXMuZGF0YSwgb3RoZXIuZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHVibGljS2V5O1xufSgpKTtcbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1YmxpY0tleSA9IGV4cG9ydHMuUHJpdmF0ZUtleSA9IHZvaWQgMDtcbi8vIHRyZWF0IEJ1ZmZlciBhcyBVaW50OGFycmF5LCBpLmUuIG5vIGNhbGwgb2YgQnVmZmVyIHNwZWNpZmljIGZ1bmN0aW9uc1xuLy8gZmluYWxseSBVaW50OEFycmF5IG9ubHlcbnZhciBQcml2YXRlS2V5XzEgPSByZXF1aXJlKFwiLi9Qcml2YXRlS2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJpdmF0ZUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJpdmF0ZUtleV8xLlByaXZhdGVLZXk7IH0gfSk7XG52YXIgUHVibGljS2V5XzEgPSByZXF1aXJlKFwiLi9QdWJsaWNLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaWNLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFB1YmxpY0tleV8xLlB1YmxpY0tleTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhUb1B1YmxpY0tleSA9IGV4cG9ydHMuY29udmVydFB1YmxpY0tleUZvcm1hdCA9IGV4cG9ydHMuZ2V0U2hhcmVkUG9pbnQgPSBleHBvcnRzLmdldFB1YmxpY0tleSA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkgPSBleHBvcnRzLmdldFZhbGlkU2VjcmV0ID0gdm9pZCAwO1xudmFyIHdlYmNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3dlYmNyeXB0b1wiKTtcbnZhciBlZDI1NTE5XzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9lZDI1NTE5XCIpO1xudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG52YXIgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vLyBUT0RPOiByZW1vdmUgYGVsbGlwdGljQ3VydmVgIGFmdGVyIDAuNS4wXG52YXIgZ2V0VmFsaWRTZWNyZXQgPSBmdW5jdGlvbiAoY3VydmUpIHtcbiAgICB2YXIga2V5O1xuICAgIGRvIHtcbiAgICAgICAga2V5ID0gKDAsIHdlYmNyeXB0b18xLnJhbmRvbUJ5dGVzKShjb25zdHNfMS5TRUNSRVRfS0VZX0xFTkdUSCk7XG4gICAgfSB3aGlsZSAoISgwLCBleHBvcnRzLmlzVmFsaWRQcml2YXRlS2V5KShrZXksIGN1cnZlKSk7XG4gICAgcmV0dXJuIGtleTtcbn07XG5leHBvcnRzLmdldFZhbGlkU2VjcmV0ID0gZ2V0VmFsaWRTZWNyZXQ7XG52YXIgaXNWYWxpZFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoc2VjcmV0LCBjdXJ2ZSkge1xuICAgIC8vIG9uIHNlY3AyNTZrMTogb25seSBrZXkg4oiIICgwLCBncm91cCBvcmRlcikgaXMgdmFsaWRcbiAgICAvLyBvbiBjdXJ2ZTI1NTE5OiBhbnkgMzItYnl0ZSBrZXkgaXMgdmFsaWRcbiAgICByZXR1cm4gX2V4ZWMoY3VydmUgfHwgKDAsIGNvbmZpZ18xLmVsbGlwdGljQ3VydmUpKCksIGZ1bmN0aW9uIChjdXJ2ZSkgeyByZXR1cm4gY3VydmUudXRpbHMuaXNWYWxpZFByaXZhdGVLZXkoc2VjcmV0KTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZUtleSA9IGlzVmFsaWRQcml2YXRlS2V5O1xudmFyIGdldFB1YmxpY0tleSA9IGZ1bmN0aW9uIChzZWNyZXQsIGN1cnZlKSB7XG4gICAgcmV0dXJuIF9leGVjKGN1cnZlIHx8ICgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpLCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShzZWNyZXQpOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShzZWNyZXQpOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFB1YmxpY0tleShzZWNyZXQpOyB9KTtcbn07XG5leHBvcnRzLmdldFB1YmxpY0tleSA9IGdldFB1YmxpY0tleTtcbnZhciBnZXRTaGFyZWRQb2ludCA9IGZ1bmN0aW9uIChzaywgcGssIGNvbXByZXNzZWQsIGN1cnZlKSB7XG4gICAgcmV0dXJuIF9leGVjKGN1cnZlIHx8ICgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpLCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChzaywgcGssIGNvbXByZXNzZWQpOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChzaywgcGspOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGdldFNoYXJlZFBvaW50T25FZDI1NTE5KGN1cnZlLCBzaywgcGspOyB9KTtcbn07XG5leHBvcnRzLmdldFNoYXJlZFBvaW50ID0gZ2V0U2hhcmVkUG9pbnQ7XG52YXIgY29udmVydFB1YmxpY0tleUZvcm1hdCA9IGZ1bmN0aW9uIChwaywgY29tcHJlc3NlZCwgY3VydmUpIHtcbiAgICAvLyBvbmx5IGZvciBzZWNwMjU2azFcbiAgICByZXR1cm4gX2V4ZWMoY3VydmUgfHwgKDAsIGNvbmZpZ18xLmVsbGlwdGljQ3VydmUpKCksIGZ1bmN0aW9uIChjdXJ2ZSkgeyByZXR1cm4gY3VydmUuZ2V0U2hhcmVkU2VjcmV0KEJpZ0ludCgxKSwgcGssIGNvbXByZXNzZWQpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBwazsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcGs7IH0pO1xufTtcbmV4cG9ydHMuY29udmVydFB1YmxpY0tleUZvcm1hdCA9IGNvbnZlcnRQdWJsaWNLZXlGb3JtYXQ7XG52YXIgaGV4VG9QdWJsaWNLZXkgPSBmdW5jdGlvbiAoaGV4LCBjdXJ2ZSkge1xuICAgIHZhciBkZWNvZGVkID0gKDAsIGhleF8xLmRlY29kZUhleCkoaGV4KTtcbiAgICByZXR1cm4gX2V4ZWMoY3VydmUgfHwgKDAsIGNvbmZpZ18xLmVsbGlwdGljQ3VydmUpKCksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXBhdEV0aFB1YmxpY0tleShkZWNvZGVkKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlZDsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVjb2RlZDsgfSk7XG59O1xuZXhwb3J0cy5oZXhUb1B1YmxpY0tleSA9IGhleFRvUHVibGljS2V5O1xuZnVuY3Rpb24gX2V4ZWMoY3VydmUsIHNlY3AyNTZrMUNhbGxiYWNrLCB4MjU1MTlDYWxsYmFjaywgZWQyNTUxOUNhbGxiYWNrKSB7XG4gICAgaWYgKGN1cnZlID09PSBcInNlY3AyNTZrMVwiKSB7XG4gICAgICAgIHJldHVybiBzZWNwMjU2azFDYWxsYmFjayhzZWNwMjU2azFfMS5zZWNwMjU2azEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJ2ZSA9PT0gXCJ4MjU1MTlcIikge1xuICAgICAgICByZXR1cm4geDI1NTE5Q2FsbGJhY2soZWQyNTUxOV8xLngyNTUxOSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnZlID09PSBcImVkMjU1MTlcIikge1xuICAgICAgICByZXR1cm4gZWQyNTUxOUNhbGxiYWNrKGVkMjU1MTlfMS5lZDI1NTE5KTtcbiAgICB9IC8qIHY4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn1cbnZhciBjb21wYXRFdGhQdWJsaWNLZXkgPSBmdW5jdGlvbiAocGspIHtcbiAgICBpZiAocGsubGVuZ3RoID09PSBjb25zdHNfMS5FVEhfUFVCTElDX0tFWV9TSVpFKSB7XG4gICAgICAgIHZhciBmaXhlZCA9IG5ldyBVaW50OEFycmF5KDEgKyBway5sZW5ndGgpO1xuICAgICAgICBmaXhlZC5zZXQoWzB4MDRdKTtcbiAgICAgICAgZml4ZWQuc2V0KHBrLCAxKTtcbiAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgIH1cbiAgICByZXR1cm4gcGs7XG59O1xudmFyIGdldFNoYXJlZFBvaW50T25FZDI1NTE5ID0gZnVuY3Rpb24gKGN1cnZlLCBzaywgcGspIHtcbiAgICAvLyBOb3RlOiBzY2FsYXIgaXMgaGFzaGVkIGZyb20gc2tcbiAgICB2YXIgc2NhbGFyID0gY3VydmUudXRpbHMuZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2spLnNjYWxhcjtcbiAgICB2YXIgcG9pbnQgPSBjdXJ2ZS5FeHRlbmRlZFBvaW50LmZyb21IZXgocGspLm11bHRpcGx5KHNjYWxhcik7XG4gICAgcmV0dXJuIHBvaW50LnRvUmF3Qnl0ZXMoKTsgLy8gYGNvbXByZXNzZWRgIGluIHNpZ25hdHVyZSBoYXMgbm8gZWZmZWN0XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNoYXJlZEtleSA9IGV4cG9ydHMuZGVyaXZlS2V5ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgaGtkZl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaGtkZlwiKTtcbnZhciBzaGEyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyXCIpO1xudmFyIGRlcml2ZUtleSA9IGZ1bmN0aW9uIChtYXN0ZXIsIHNhbHQsIGluZm8pIHtcbiAgICAvLyAzMiBieXRlcyBzaGFyZWQgc2VjcmV0IGZvciBhZXMyNTYgYW5kIHhjaGFjaGEyMCBkZXJpdmVkIGZyb20gSEtERi1TSEEyNTZcbiAgICByZXR1cm4gKDAsIGhrZGZfMS5oa2RmKShzaGEyXzEuc2hhMjU2LCBtYXN0ZXIsIHNhbHQsIGluZm8sIDMyKTtcbn07XG5leHBvcnRzLmRlcml2ZUtleSA9IGRlcml2ZUtleTtcbnZhciBnZXRTaGFyZWRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcGFydHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmRlcml2ZUtleSkodXRpbHNfMS5jb25jYXRCeXRlcy5hcHBseSh2b2lkIDAsIHBhcnRzKSk7XG59O1xuZXhwb3J0cy5nZXRTaGFyZWRLZXkgPSBnZXRTaGFyZWRLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlSGV4ID0gZXhwb3J0cy5yZW1vdmUweCA9IHZvaWQgMDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCIpO1xudmFyIHJlbW92ZTB4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgIHJldHVybiBoZXguc3RhcnRzV2l0aChcIjB4XCIpIHx8IGhleC5zdGFydHNXaXRoKFwiMFhcIikgPyBoZXguc2xpY2UoMikgOiBoZXg7XG59O1xuZXhwb3J0cy5yZW1vdmUweCA9IHJlbW92ZTB4O1xudmFyIGRlY29kZUhleCA9IGZ1bmN0aW9uIChoZXgpIHsgcmV0dXJuICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKCgwLCBleHBvcnRzLnJlbW92ZTB4KShoZXgpKTsgfTtcbmV4cG9ydHMuZGVjb2RlSGV4ID0gZGVjb2RlSGV4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbGxpcHRpY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFzaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGV4XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zeW1tZXRyaWNcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFlc0RlY3J5cHQgPSBleHBvcnRzLmFlc0VuY3J5cHQgPSBleHBvcnRzLnN5bURlY3J5cHQgPSBleHBvcnRzLnN5bUVuY3J5cHQgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiKTtcbnZhciB3ZWJjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy93ZWJjcnlwdG9cIik7XG52YXIgYWVzXzEgPSByZXF1aXJlKFwiQGVjaWVzL2NpcGhlcnMvYWVzXCIpO1xudmFyIGNoYWNoYV8xID0gcmVxdWlyZShcIkBlY2llcy9jaXBoZXJzL2NoYWNoYVwiKTtcbnZhciBjb25maWdfMSA9IHJlcXVpcmUoXCIuLi9jb25maWdcIik7XG52YXIgY29uc3RzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RzXCIpO1xudmFyIHN5bUVuY3J5cHQgPSBmdW5jdGlvbiAoa2V5LCBwbGFpblRleHQsIEFBRCkgeyByZXR1cm4gX2V4ZWMoX2VuY3J5cHQsIGtleSwgcGxhaW5UZXh0LCBBQUQpOyB9O1xuZXhwb3J0cy5zeW1FbmNyeXB0ID0gc3ltRW5jcnlwdDtcbnZhciBzeW1EZWNyeXB0ID0gZnVuY3Rpb24gKGtleSwgY2lwaGVyVGV4dCwgQUFEKSB7IHJldHVybiBfZXhlYyhfZGVjcnlwdCwga2V5LCBjaXBoZXJUZXh0LCBBQUQpOyB9O1xuZXhwb3J0cy5zeW1EZWNyeXB0ID0gc3ltRGVjcnlwdDtcbi8qKiBAZGVwcmVjYXRlZCAtIHVzZSBgc3ltRW5jcnlwdGAgaW5zdGVhZC4gKi9cbmV4cG9ydHMuYWVzRW5jcnlwdCA9IGV4cG9ydHMuc3ltRW5jcnlwdDsgLy8gVE9ETzogZGVsZXRlXG4vKiogQGRlcHJlY2F0ZWQgLSB1c2UgYHN5bURlY3J5cHRgIGluc3RlYWQuICovXG5leHBvcnRzLmFlc0RlY3J5cHQgPSBleHBvcnRzLnN5bURlY3J5cHQ7IC8vIFRPRE86IGRlbGV0ZVxuZnVuY3Rpb24gX2V4ZWMoY2FsbGJhY2ssIGtleSwgZGF0YSwgQUFEKSB7XG4gICAgdmFyIGFsZ29yaXRobSA9ICgwLCBjb25maWdfMS5zeW1tZXRyaWNBbGdvcml0aG0pKCk7XG4gICAgaWYgKGFsZ29yaXRobSA9PT0gXCJhZXMtMjU2LWdjbVwiKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhZXNfMS5hZXMyNTZnY20sIGtleSwgZGF0YSwgKDAsIGNvbmZpZ18xLnN5bW1ldHJpY05vbmNlTGVuZ3RoKSgpLCBjb25zdHNfMS5BRUFEX1RBR19MRU5HVEgsIEFBRCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJ4Y2hhY2hhMjBcIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hhY2hhXzEueGNoYWNoYTIwLCBrZXksIGRhdGEsIGNvbnN0c18xLlhDSEFDSEEyMF9OT05DRV9MRU5HVEgsIGNvbnN0c18xLkFFQURfVEFHX0xFTkdUSCwgQUFEKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxnb3JpdGhtID09PSBcImFlcy0yNTYtY2JjXCIpIHtcbiAgICAgICAgLy8gTk9UIFJFQ09NTUVOREVELiBUaGVyZSBpcyBuZWl0aGVyIEFBRCBub3IgQUVBRCB0YWcgaW4gY2JjIG1vZGVcbiAgICAgICAgLy8gYWVzLTI1Ni1jYmMgYWx3YXlzIHVzZXMgMTYgYnl0ZXMgaXZcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFlc18xLmFlczI1NmNiYywga2V5LCBkYXRhLCAxNiwgMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gX2VuY3J5cHQoZnVuYywga2V5LCBkYXRhLCBub25jZUxlbmd0aCwgdGFnTGVuZ3RoLCBBQUQpIHtcbiAgICB2YXIgbm9uY2UgPSAoMCwgd2ViY3J5cHRvXzEucmFuZG9tQnl0ZXMpKG5vbmNlTGVuZ3RoKTtcbiAgICB2YXIgY2lwaGVyID0gZnVuYyhrZXksIG5vbmNlLCBBQUQpO1xuICAgIC8vIEBub2JsZS9jaXBoZXJzIGZvcm1hdDogY2lwaGVyVGV4dCB8fCB0YWdcbiAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmVuY3J5cHQoZGF0YSk7XG4gICAgaWYgKHRhZ0xlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKG5vbmNlLCBlbmNyeXB0ZWQpO1xuICAgIH1cbiAgICB2YXIgY2lwaGVyVGV4dExlbmd0aCA9IGVuY3J5cHRlZC5sZW5ndGggLSB0YWdMZW5ndGg7XG4gICAgdmFyIGNpcGhlclRleHQgPSBlbmNyeXB0ZWQuc3ViYXJyYXkoMCwgY2lwaGVyVGV4dExlbmd0aCk7XG4gICAgdmFyIHRhZyA9IGVuY3J5cHRlZC5zdWJhcnJheShjaXBoZXJUZXh0TGVuZ3RoKTtcbiAgICAvLyBlY2llcyBwYXlsb2FkIGZvcm1hdDogcGsgfHwgbm9uY2UgfHwgdGFnIHx8IGNpcGhlclRleHRcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKG5vbmNlLCB0YWcsIGNpcGhlclRleHQpO1xufVxuZnVuY3Rpb24gX2RlY3J5cHQoZnVuYywga2V5LCBkYXRhLCBub25jZUxlbmd0aCwgdGFnTGVuZ3RoLCBBQUQpIHtcbiAgICB2YXIgbm9uY2UgPSBkYXRhLnN1YmFycmF5KDAsIG5vbmNlTGVuZ3RoKTtcbiAgICB2YXIgY2lwaGVyID0gZnVuYyhrZXksIFVpbnQ4QXJyYXkuZnJvbShub25jZSksIEFBRCk7IC8vIHRvIHJlc2V0IGJ5dGVPZmZzZXRcbiAgICB2YXIgZW5jcnlwdGVkID0gZGF0YS5zdWJhcnJheShub25jZUxlbmd0aCk7XG4gICAgaWYgKHRhZ0xlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2lwaGVyLmRlY3J5cHQoZW5jcnlwdGVkKTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGVuY3J5cHRlZC5zdWJhcnJheSgwLCB0YWdMZW5ndGgpO1xuICAgIHZhciBjaXBoZXJUZXh0ID0gZW5jcnlwdGVkLnN1YmFycmF5KHRhZ0xlbmd0aCk7XG4gICAgcmV0dXJuIGNpcGhlci5kZWNyeXB0KCgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShjaXBoZXJUZXh0LCB0YWcpKTtcbn1cbiIsIi8vIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIG1ha2UtYXJyYXlcbmZ1bmN0aW9uIG1ha2VBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KVxuICAgID8gc3ViamVjdFxuICAgIDogW3N1YmplY3RdXG59XG5cbmNvbnN0IEVNUFRZID0gJydcbmNvbnN0IFNQQUNFID0gJyAnXG5jb25zdCBFU0NBUEUgPSAnXFxcXCdcbmNvbnN0IFJFR0VYX1RFU1RfQkxBTktfTElORSA9IC9eXFxzKyQvXG5jb25zdCBSRUdFWF9JTlZBTElEX1RSQUlMSU5HX0JBQ0tTTEFTSCA9IC8oPzpbXlxcXFxdfF4pXFxcXCQvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiA9IC9eXFxcXCEvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNIID0gL15cXFxcIy9cbmNvbnN0IFJFR0VYX1NQTElUQUxMX0NSTEYgPSAvXFxyP1xcbi9nXG4vLyAvZm9vLFxuLy8gLi9mb28sXG4vLyAuLi9mb28sXG4vLyAuXG4vLyAuLlxuY29uc3QgUkVHRVhfVEVTVF9JTlZBTElEX1BBVEggPSAvXlxcLipcXC98XlxcLiskL1xuXG5jb25zdCBTTEFTSCA9ICcvJ1xuXG4vLyBEbyBub3QgdXNlIHRlcm5hcnkgZXhwcmVzc2lvbiBoZXJlLCBzaW5jZSBcImlzdGFuYnVsIGlnbm9yZSBuZXh0XCIgaXMgYnVnZ3lcbmxldCBUTVBfS0VZX0lHTk9SRSA9ICdub2RlLWlnbm9yZSdcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgVE1QX0tFWV9JR05PUkUgPSBTeW1ib2wuZm9yKCdub2RlLWlnbm9yZScpXG59XG5jb25zdCBLRVlfSUdOT1JFID0gVE1QX0tFWV9JR05PUkVcblxuY29uc3QgZGVmaW5lID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7dmFsdWV9KVxuXG5jb25zdCBSRUdFWF9SRUdFWFBfUkFOR0UgPSAvKFswLXpdKS0oWzAtel0pL2dcblxuY29uc3QgUkVUVVJOX0ZBTFNFID0gKCkgPT4gZmFsc2VcblxuLy8gU2FuaXRpemUgdGhlIHJhbmdlIG9mIGEgcmVndWxhciBleHByZXNzaW9uXG4vLyBUaGUgY2FzZXMgYXJlIGNvbXBsaWNhdGVkLCBzZWUgdGVzdCBjYXNlcyBmb3IgZGV0YWlsc1xuY29uc3Qgc2FuaXRpemVSYW5nZSA9IHJhbmdlID0+IHJhbmdlLnJlcGxhY2UoXG4gIFJFR0VYX1JFR0VYUF9SQU5HRSxcbiAgKG1hdGNoLCBmcm9tLCB0bykgPT4gZnJvbS5jaGFyQ29kZUF0KDApIDw9IHRvLmNoYXJDb2RlQXQoMClcbiAgICA/IG1hdGNoXG4gICAgLy8gSW52YWxpZCByYW5nZSAob3V0IG9mIG9yZGVyKSB3aGljaCBpcyBvayBmb3IgZ2l0aWdub3JlIHJ1bGVzIGJ1dFxuICAgIC8vICAgZmF0YWwgZm9yIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9uLCBzbyBlbGltaW5hdGUgaXQuXG4gICAgOiBFTVBUWVxuKVxuXG4vLyBTZWUgZml4dHVyZXMgIzU5XG5jb25zdCBjbGVhblJhbmdlQmFja1NsYXNoID0gc2xhc2hlcyA9PiB7XG4gIGNvbnN0IHtsZW5ndGh9ID0gc2xhc2hlc1xuICByZXR1cm4gc2xhc2hlcy5zbGljZSgwLCBsZW5ndGggLSBsZW5ndGggJSAyKVxufVxuXG4vLyA+IElmIHRoZSBwYXR0ZXJuIGVuZHMgd2l0aCBhIHNsYXNoLFxuLy8gPiBpdCBpcyByZW1vdmVkIGZvciB0aGUgcHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIGRlc2NyaXB0aW9uLFxuLy8gPiBidXQgaXQgd291bGQgb25seSBmaW5kIGEgbWF0Y2ggd2l0aCBhIGRpcmVjdG9yeS5cbi8vID4gSW4gb3RoZXIgd29yZHMsIGZvby8gd2lsbCBtYXRjaCBhIGRpcmVjdG9yeSBmb28gYW5kIHBhdGhzIHVuZGVybmVhdGggaXQsXG4vLyA+IGJ1dCB3aWxsIG5vdCBtYXRjaCBhIHJlZ3VsYXIgZmlsZSBvciBhIHN5bWJvbGljIGxpbmsgZm9vXG4vLyA+ICAodGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSBob3cgcGF0aHNwZWMgd29ya3MgaW4gZ2VuZXJhbCBpbiBHaXQpLlxuLy8gJ2Bmb28vYCcgd2lsbCBub3QgbWF0Y2ggcmVndWxhciBmaWxlICdgZm9vYCcgb3Igc3ltYm9saWMgbGluayAnYGZvb2AnXG4vLyAtPiBpZ25vcmUtcnVsZXMgd2lsbCBub3QgZGVhbCB3aXRoIGl0LCBiZWNhdXNlIGl0IGNvc3RzIGV4dHJhIGBmcy5zdGF0YCBjYWxsXG4vLyAgICAgIHlvdSBjb3VsZCB1c2Ugb3B0aW9uIGBtYXJrOiB0cnVlYCB3aXRoIGBnbG9iYFxuXG4vLyAnYGZvby9gJyBzaG91bGQgbm90IGNvbnRpbnVlIHdpdGggdGhlICdgLi5gJ1xuY29uc3QgUkVQTEFDRVJTID0gW1xuXG4gIFtcbiAgICAvLyByZW1vdmUgQk9NXG4gICAgLy8gVE9ETzpcbiAgICAvLyBPdGhlciBzaW1pbGFyIHplcm8td2lkdGggY2hhcmFjdGVycz9cbiAgICAvXlxcdUZFRkYvLFxuICAgICgpID0+IEVNUFRZXG4gIF0sXG5cbiAgLy8gPiBUcmFpbGluZyBzcGFjZXMgYXJlIGlnbm9yZWQgdW5sZXNzIHRoZXkgYXJlIHF1b3RlZCB3aXRoIGJhY2tzbGFzaCAoXCJcXFwiKVxuICBbXG4gICAgLy8gKGFcXCApIC0+IChhIClcbiAgICAvLyAoYSAgKSAtPiAoYSlcbiAgICAvLyAoYSApIC0+IChhKVxuICAgIC8vIChhIFxcICkgLT4gKGEgIClcbiAgICAvKCg/OlxcXFxcXFxcKSo/KShcXFxcP1xccyspJC8sXG4gICAgKF8sIG0xLCBtMikgPT4gbTEgKyAoXG4gICAgICBtMi5pbmRleE9mKCdcXFxcJykgPT09IDBcbiAgICAgICAgPyBTUEFDRVxuICAgICAgICA6IEVNUFRZXG4gICAgKVxuICBdLFxuXG4gIC8vIHJlcGxhY2UgKFxcICkgd2l0aCAnICdcbiAgLy8gKFxcICkgLT4gJyAnXG4gIC8vIChcXFxcICkgLT4gJ1xcXFwgJ1xuICAvLyAoXFxcXFxcICkgLT4gJ1xcXFwgJ1xuICBbXG4gICAgLyhcXFxcKz8pXFxzL2csXG4gICAgKF8sIG0xKSA9PiB7XG4gICAgICBjb25zdCB7bGVuZ3RofSA9IG0xXG4gICAgICByZXR1cm4gbTEuc2xpY2UoMCwgbGVuZ3RoIC0gbGVuZ3RoICUgMikgKyBTUEFDRVxuICAgIH1cbiAgXSxcblxuICAvLyBFc2NhcGUgbWV0YWNoYXJhY3RlcnNcbiAgLy8gd2hpY2ggaXMgd3JpdHRlbiBkb3duIGJ5IHVzZXJzIGJ1dCBtZWFucyBzcGVjaWFsIGZvciByZWd1bGFyIGV4cHJlc3Npb25zLlxuXG4gIC8vID4gVGhlcmUgYXJlIDEyIGNoYXJhY3RlcnMgd2l0aCBzcGVjaWFsIG1lYW5pbmdzOlxuICAvLyA+IC0gdGhlIGJhY2tzbGFzaCBcXCxcbiAgLy8gPiAtIHRoZSBjYXJldCBeLFxuICAvLyA+IC0gdGhlIGRvbGxhciBzaWduICQsXG4gIC8vID4gLSB0aGUgcGVyaW9kIG9yIGRvdCAuLFxuICAvLyA+IC0gdGhlIHZlcnRpY2FsIGJhciBvciBwaXBlIHN5bWJvbCB8LFxuICAvLyA+IC0gdGhlIHF1ZXN0aW9uIG1hcmsgPyxcbiAgLy8gPiAtIHRoZSBhc3RlcmlzayBvciBzdGFyICosXG4gIC8vID4gLSB0aGUgcGx1cyBzaWduICssXG4gIC8vID4gLSB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyAoLFxuICAvLyA+IC0gdGhlIGNsb3NpbmcgcGFyZW50aGVzaXMgKSxcbiAgLy8gPiAtIGFuZCB0aGUgb3BlbmluZyBzcXVhcmUgYnJhY2tldCBbLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgY3VybHkgYnJhY2UgeyxcbiAgLy8gPiBUaGVzZSBzcGVjaWFsIGNoYXJhY3RlcnMgYXJlIG9mdGVuIGNhbGxlZCBcIm1ldGFjaGFyYWN0ZXJzXCIuXG4gIFtcbiAgICAvW1xcXFwkLnwqKygpe15dL2csXG4gICAgbWF0Y2ggPT4gYFxcXFwke21hdGNofWBcbiAgXSxcblxuICBbXG4gICAgLy8gPiBhIHF1ZXN0aW9uIG1hcmsgKD8pIG1hdGNoZXMgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgLyg/IVxcXFwpXFw/L2csXG4gICAgKCkgPT4gJ1teL10nXG4gIF0sXG5cbiAgLy8gbGVhZGluZyBzbGFzaFxuICBbXG5cbiAgICAvLyA+IEEgbGVhZGluZyBzbGFzaCBtYXRjaGVzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHBhdGhuYW1lLlxuICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiLyouY1wiIG1hdGNoZXMgXCJjYXQtZmlsZS5jXCIgYnV0IG5vdCBcIm1vemlsbGEtc2hhMS9zaGExLmNcIi5cbiAgICAvLyBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZVxuICAgIC9eXFwvLyxcbiAgICAoKSA9PiAnXidcbiAgXSxcblxuICAvLyByZXBsYWNlIHNwZWNpYWwgbWV0YWNoYXJhY3RlciBzbGFzaCBhZnRlciB0aGUgbGVhZGluZyBzbGFzaFxuICBbXG4gICAgL1xcLy9nLFxuICAgICgpID0+ICdcXFxcLydcbiAgXSxcblxuICBbXG4gICAgLy8gPiBBIGxlYWRpbmcgXCIqKlwiIGZvbGxvd2VkIGJ5IGEgc2xhc2ggbWVhbnMgbWF0Y2ggaW4gYWxsIGRpcmVjdG9yaWVzLlxuICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiKiovZm9vXCIgbWF0Y2hlcyBmaWxlIG9yIGRpcmVjdG9yeSBcImZvb1wiIGFueXdoZXJlLFxuICAgIC8vID4gdGhlIHNhbWUgYXMgcGF0dGVybiBcImZvb1wiLlxuICAgIC8vID4gXCIqKi9mb28vYmFyXCIgbWF0Y2hlcyBmaWxlIG9yIGRpcmVjdG9yeSBcImJhclwiIGFueXdoZXJlIHRoYXQgaXMgZGlyZWN0bHlcbiAgICAvLyA+ICAgdW5kZXIgZGlyZWN0b3J5IFwiZm9vXCIuXG4gICAgLy8gTm90aWNlIHRoYXQgdGhlICcqJ3MgaGF2ZSBiZWVuIHJlcGxhY2VkIGFzICdcXFxcKidcbiAgICAvXlxcXipcXFxcXFwqXFxcXFxcKlxcXFxcXC8vLFxuXG4gICAgLy8gJyoqL2ZvbycgPC0+ICdmb28nXG4gICAgKCkgPT4gJ14oPzouKlxcXFwvKT8nXG4gIF0sXG5cbiAgLy8gc3RhcnRpbmdcbiAgW1xuICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gbGVhZGluZyAnLydcbiAgICAvLyAgICh3aGljaCBoYXMgYmVlbiByZXBsYWNlZCBieSBzZWN0aW9uIFwibGVhZGluZyBzbGFzaFwiKVxuICAgIC8vIElmIHN0YXJ0cyB3aXRoICcqKicsIGFkZGluZyBhICdeJyB0byB0aGUgcmVndWxhciBleHByZXNzaW9uIGFsc28gd29ya3NcbiAgICAvXig/PVteXl0pLyxcbiAgICBmdW5jdGlvbiBzdGFydGluZ1JlcGxhY2VyICgpIHtcbiAgICAgIC8vIElmIGhhcyBhIHNsYXNoIGAvYCBhdCB0aGUgYmVnaW5uaW5nIG9yIG1pZGRsZVxuICAgICAgcmV0dXJuICEvXFwvKD8hJCkvLnRlc3QodGhpcylcbiAgICAgICAgLy8gPiBQcmlvciB0byAyLjIyLjFcbiAgICAgICAgLy8gPiBJZiB0aGUgcGF0dGVybiBkb2VzIG5vdCBjb250YWluIGEgc2xhc2ggLyxcbiAgICAgICAgLy8gPiAgIEdpdCB0cmVhdHMgaXQgYXMgYSBzaGVsbCBnbG9iIHBhdHRlcm5cbiAgICAgICAgLy8gQWN0dWFsbHksIGlmIHRoZXJlIGlzIG9ubHkgYSB0cmFpbGluZyBzbGFzaCxcbiAgICAgICAgLy8gICBnaXQgYWxzbyB0cmVhdHMgaXQgYXMgYSBzaGVsbCBnbG9iIHBhdHRlcm5cblxuICAgICAgICAvLyBBZnRlciAyLjIyLjEgKGNvbXBhdGlibGUgYnV0IGNsZWFyZXIpXG4gICAgICAgIC8vID4gSWYgdGhlcmUgaXMgYSBzZXBhcmF0b3IgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGUgKG9yIGJvdGgpXG4gICAgICAgIC8vID4gb2YgdGhlIHBhdHRlcm4sIHRoZW4gdGhlIHBhdHRlcm4gaXMgcmVsYXRpdmUgdG8gdGhlIGRpcmVjdG9yeVxuICAgICAgICAvLyA+IGxldmVsIG9mIHRoZSBwYXJ0aWN1bGFyIC5naXRpZ25vcmUgZmlsZSBpdHNlbGYuXG4gICAgICAgIC8vID4gT3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIG1heSBhbHNvIG1hdGNoIGF0IGFueSBsZXZlbCBiZWxvd1xuICAgICAgICAvLyA+IHRoZSAuZ2l0aWdub3JlIGxldmVsLlxuICAgICAgICA/ICcoPzpefFxcXFwvKSdcblxuICAgICAgICAvLyA+IE90aGVyd2lzZSwgR2l0IHRyZWF0cyB0aGUgcGF0dGVybiBhcyBhIHNoZWxsIGdsb2Igc3VpdGFibGUgZm9yXG4gICAgICAgIC8vID4gICBjb25zdW1wdGlvbiBieSBmbm1hdGNoKDMpXG4gICAgICAgIDogJ14nXG4gICAgfVxuICBdLFxuXG4gIC8vIHR3byBnbG9ic3RhcnNcbiAgW1xuICAgIC8vIFVzZSBsb29rYWhlYWQgYXNzZXJ0aW9ucyBzbyB0aGF0IHdlIGNvdWxkIG1hdGNoIG1vcmUgdGhhbiBvbmUgYCcvKionYFxuICAgIC9cXFxcXFwvXFxcXFxcKlxcXFxcXCooPz1cXFxcXFwvfCQpL2csXG5cbiAgICAvLyBaZXJvLCBvbmUgb3Igc2V2ZXJhbCBkaXJlY3Rvcmllc1xuICAgIC8vIHNob3VsZCBub3QgdXNlICcqJywgb3IgaXQgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgbmV4dCByZXBsYWNlclxuXG4gICAgLy8gQ2hlY2sgaWYgaXQgaXMgbm90IHRoZSBsYXN0IGAnLyoqJ2BcbiAgICAoXywgaW5kZXgsIHN0cikgPT4gaW5kZXggKyA2IDwgc3RyLmxlbmd0aFxuXG4gICAgICAvLyBjYXNlOiAvKiovXG4gICAgICAvLyA+IEEgc2xhc2ggZm9sbG93ZWQgYnkgdHdvIGNvbnNlY3V0aXZlIGFzdGVyaXNrcyB0aGVuIGEgc2xhc2ggbWF0Y2hlc1xuICAgICAgLy8gPiAgIHplcm8gb3IgbW9yZSBkaXJlY3Rvcmllcy5cbiAgICAgIC8vID4gRm9yIGV4YW1wbGUsIFwiYS8qKi9iXCIgbWF0Y2hlcyBcImEvYlwiLCBcImEveC9iXCIsIFwiYS94L3kvYlwiIGFuZCBzbyBvbi5cbiAgICAgIC8vICcvKiovJ1xuICAgICAgPyAnKD86XFxcXC9bXlxcXFwvXSspKidcblxuICAgICAgLy8gY2FzZTogLyoqXG4gICAgICAvLyA+IEEgdHJhaWxpbmcgYFwiLyoqXCJgIG1hdGNoZXMgZXZlcnl0aGluZyBpbnNpZGUuXG5cbiAgICAgIC8vICMyMTogZXZlcnl0aGluZyBpbnNpZGUgYnV0IGl0IHNob3VsZCBub3QgaW5jbHVkZSB0aGUgY3VycmVudCBmb2xkZXJcbiAgICAgIDogJ1xcXFwvLisnXG4gIF0sXG5cbiAgLy8gbm9ybWFsIGludGVybWVkaWF0ZSB3aWxkY2FyZHNcbiAgW1xuICAgIC8vIE5ldmVyIHJlcGxhY2UgZXNjYXBlZCAnKidcbiAgICAvLyBpZ25vcmUgcnVsZSAnXFwqJyB3aWxsIG1hdGNoIHRoZSBwYXRoICcqJ1xuXG4gICAgLy8gJ2FiYy4qLycgLT4gZ29cbiAgICAvLyAnYWJjLionICAtPiBza2lwIHRoaXMgcnVsZSxcbiAgICAvLyAgICBjb3ogdHJhaWxpbmcgc2luZ2xlIHdpbGRjYXJkIHdpbGwgYmUgaGFuZGVkIGJ5IFt0cmFpbGluZyB3aWxkY2FyZF1cbiAgICAvKF58W15cXFxcXSspKFxcXFxcXCopKyg/PS4rKS9nLFxuXG4gICAgLy8gJyouanMnIG1hdGNoZXMgJy5qcydcbiAgICAvLyAnKi5qcycgZG9lc24ndCBtYXRjaCAnYWJjJ1xuICAgIChfLCBwMSwgcDIpID0+IHtcbiAgICAgIC8vIDEuXG4gICAgICAvLyA+IEFuIGFzdGVyaXNrIFwiKlwiIG1hdGNoZXMgYW55dGhpbmcgZXhjZXB0IGEgc2xhc2guXG4gICAgICAvLyAyLlxuICAgICAgLy8gPiBPdGhlciBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgYXJlIGNvbnNpZGVyZWQgcmVndWxhciBhc3Rlcmlza3NcbiAgICAgIC8vID4gYW5kIHdpbGwgbWF0Y2ggYWNjb3JkaW5nIHRvIHRoZSBwcmV2aW91cyBydWxlcy5cbiAgICAgIGNvbnN0IHVuZXNjYXBlZCA9IHAyLnJlcGxhY2UoL1xcXFxcXCovZywgJ1teXFxcXC9dKicpXG4gICAgICByZXR1cm4gcDEgKyB1bmVzY2FwZWRcbiAgICB9XG4gIF0sXG5cbiAgW1xuICAgIC8vIHVuZXNjYXBlLCByZXZlcnQgc3RlcCAzIGV4Y2VwdCBmb3IgYmFjayBzbGFzaFxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBhIHVzZXIgZXNjYXBlIGEgJ1xcXFwqJyxcbiAgICAvLyBhZnRlciBzdGVwIDMsIHRoZSByZXN1bHQgd2lsbCBiZSAnXFxcXFxcXFxcXFxcKidcbiAgICAvXFxcXFxcXFxcXFxcKD89WyQufCorKCl7Xl0pL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vICdcXFxcXFxcXCcgLT4gJ1xcXFwnXG4gICAgL1xcXFxcXFxcL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gVGhlIHJhbmdlIG5vdGF0aW9uLCBlLmcuIFthLXpBLVpdLFxuICAgIC8vID4gY2FuIGJlIHVzZWQgdG8gbWF0Y2ggb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIGEgcmFuZ2UuXG5cbiAgICAvLyBgXFxgIGlzIGVzY2FwZWQgYnkgc3RlcCAzXG4gICAgLyhcXFxcKT9cXFsoW15cXF0vXSo/KShcXFxcKikoJHxcXF0pL2csXG4gICAgKG1hdGNoLCBsZWFkRXNjYXBlLCByYW5nZSwgZW5kRXNjYXBlLCBjbG9zZSkgPT4gbGVhZEVzY2FwZSA9PT0gRVNDQVBFXG4gICAgICAvLyAnXFxcXFtiYXJdJyAtPiAnXFxcXFxcXFxbYmFyXFxcXF0nXG4gICAgICA/IGBcXFxcWyR7cmFuZ2V9JHtjbGVhblJhbmdlQmFja1NsYXNoKGVuZEVzY2FwZSl9JHtjbG9zZX1gXG4gICAgICA6IGNsb3NlID09PSAnXSdcbiAgICAgICAgPyBlbmRFc2NhcGUubGVuZ3RoICUgMiA9PT0gMFxuICAgICAgICAgIC8vIEEgbm9ybWFsIGNhc2UsIGFuZCBpdCBpcyBhIHJhbmdlIG5vdGF0aW9uXG4gICAgICAgICAgLy8gJ1tiYXJdJ1xuICAgICAgICAgIC8vICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgID8gYFske3Nhbml0aXplUmFuZ2UocmFuZ2UpfSR7ZW5kRXNjYXBlfV1gXG4gICAgICAgICAgLy8gSW52YWxpZCByYW5nZSBub3RhdG9uXG4gICAgICAgICAgLy8gJ1tiYXJcXFxcXScgLT4gJ1tiYXJcXFxcXFxcXF0nXG4gICAgICAgICAgOiAnW10nXG4gICAgICAgIDogJ1tdJ1xuICBdLFxuXG4gIC8vIGVuZGluZ1xuICBbXG4gICAgLy8gJ2pzJyB3aWxsIG5vdCBtYXRjaCAnanMuJ1xuICAgIC8vICdhYicgd2lsbCBub3QgbWF0Y2ggJ2FiYydcbiAgICAvKD86W14qXSkkLyxcblxuICAgIC8vIFdURiFcbiAgICAvLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlXG4gICAgLy8gY2hhbmdlcyBpbiBbMi4yMi4xXShodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlLzIuMjIuMSlcbiAgICAvLyB3aGljaCByZS1maXhlcyAjMjQsICMzOFxuXG4gICAgLy8gPiBJZiB0aGVyZSBpcyBhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHRoZW4gdGhlIHBhdHRlcm5cbiAgICAvLyA+IHdpbGwgb25seSBtYXRjaCBkaXJlY3Rvcmllcywgb3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBib3RoXG4gICAgLy8gPiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMuXG5cbiAgICAvLyAnanMqJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMnIHdpbGwgbWF0Y2ggJ2EuanMnIGFuZCAnYS5qcy8nXG4gICAgbWF0Y2ggPT4gL1xcLyQvLnRlc3QobWF0Y2gpXG4gICAgICAvLyBmb28vIHdpbGwgbm90IG1hdGNoICdmb28nXG4gICAgICA/IGAke21hdGNofSRgXG4gICAgICAvLyBmb28gbWF0Y2hlcyAnZm9vJyBhbmQgJ2Zvby8nXG4gICAgICA6IGAke21hdGNofSg/PSR8XFxcXC8kKWBcbiAgXSxcblxuICAvLyB0cmFpbGluZyB3aWxkY2FyZFxuICBbXG4gICAgLyhcXF58XFxcXFxcLyk/XFxcXFxcKiQvLFxuICAgIChfLCBwMSkgPT4ge1xuICAgICAgY29uc3QgcHJlZml4ID0gcDFcbiAgICAgICAgLy8gJ1xcXic6XG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggRU1QVFlcbiAgICAgICAgLy8gJy8qJyBkb2VzIG5vdCBtYXRjaCBldmVyeXRoaW5nXG5cbiAgICAgICAgLy8gJ1xcXFxcXC8nOlxuICAgICAgICAvLyAnYWJjLyonIGRvZXMgbm90IG1hdGNoICdhYmMvJ1xuICAgICAgICA/IGAke3AxfVteL10rYFxuXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYSdcbiAgICAgICAgLy8gJ2EqJyBtYXRjaGVzICdhYSdcbiAgICAgICAgOiAnW14vXSonXG5cbiAgICAgIHJldHVybiBgJHtwcmVmaXh9KD89JHxcXFxcLyQpYFxuICAgIH1cbiAgXSxcbl1cblxuLy8gQSBzaW1wbGUgY2FjaGUsIGJlY2F1c2UgYW4gaWdub3JlIHJ1bGUgb25seSBoYXMgb25seSBvbmUgY2VydGFpbiBtZWFuaW5nXG5jb25zdCByZWdleENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vLyBAcGFyYW0ge3BhdHRlcm59XG5jb25zdCBtYWtlUmVnZXggPSAocGF0dGVybiwgaWdub3JlQ2FzZSkgPT4ge1xuICBsZXQgc291cmNlID0gcmVnZXhDYWNoZVtwYXR0ZXJuXVxuXG4gIGlmICghc291cmNlKSB7XG4gICAgc291cmNlID0gUkVQTEFDRVJTLnJlZHVjZShcbiAgICAgIChwcmV2LCBbbWF0Y2hlciwgcmVwbGFjZXJdKSA9PlxuICAgICAgICBwcmV2LnJlcGxhY2UobWF0Y2hlciwgcmVwbGFjZXIuYmluZChwYXR0ZXJuKSksXG4gICAgICBwYXR0ZXJuXG4gICAgKVxuICAgIHJlZ2V4Q2FjaGVbcGF0dGVybl0gPSBzb3VyY2VcbiAgfVxuXG4gIHJldHVybiBpZ25vcmVDYXNlXG4gICAgPyBuZXcgUmVnRXhwKHNvdXJjZSwgJ2knKVxuICAgIDogbmV3IFJlZ0V4cChzb3VyY2UpXG59XG5cbmNvbnN0IGlzU3RyaW5nID0gc3ViamVjdCA9PiB0eXBlb2Ygc3ViamVjdCA9PT0gJ3N0cmluZydcblxuLy8gPiBBIGJsYW5rIGxpbmUgbWF0Y2hlcyBubyBmaWxlcywgc28gaXQgY2FuIHNlcnZlIGFzIGEgc2VwYXJhdG9yIGZvciByZWFkYWJpbGl0eS5cbmNvbnN0IGNoZWNrUGF0dGVybiA9IHBhdHRlcm4gPT4gcGF0dGVyblxuICAmJiBpc1N0cmluZyhwYXR0ZXJuKVxuICAmJiAhUkVHRVhfVEVTVF9CTEFOS19MSU5FLnRlc3QocGF0dGVybilcbiAgJiYgIVJFR0VYX0lOVkFMSURfVFJBSUxJTkdfQkFDS1NMQVNILnRlc3QocGF0dGVybilcblxuICAvLyA+IEEgbGluZSBzdGFydGluZyB3aXRoICMgc2VydmVzIGFzIGEgY29tbWVudC5cbiAgJiYgcGF0dGVybi5pbmRleE9mKCcjJykgIT09IDBcblxuY29uc3Qgc3BsaXRQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuLnNwbGl0KFJFR0VYX1NQTElUQUxMX0NSTEYpXG5cbmNsYXNzIElnbm9yZVJ1bGUge1xuICBjb25zdHJ1Y3RvciAoXG4gICAgb3JpZ2luLFxuICAgIHBhdHRlcm4sXG4gICAgbmVnYXRpdmUsXG4gICAgcmVnZXhcbiAgKSB7XG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IG5lZ2F0aXZlXG4gICAgdGhpcy5yZWdleCA9IHJlZ2V4XG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUnVsZSA9IChwYXR0ZXJuLCBpZ25vcmVDYXNlKSA9PiB7XG4gIGNvbnN0IG9yaWdpbiA9IHBhdHRlcm5cbiAgbGV0IG5lZ2F0aXZlID0gZmFsc2VcblxuICAvLyA+IEFuIG9wdGlvbmFsIHByZWZpeCBcIiFcIiB3aGljaCBuZWdhdGVzIHRoZSBwYXR0ZXJuO1xuICBpZiAocGF0dGVybi5pbmRleE9mKCchJykgPT09IDApIHtcbiAgICBuZWdhdGl2ZSA9IHRydWVcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIoMSlcbiAgfVxuXG4gIHBhdHRlcm4gPSBwYXR0ZXJuXG4gIC8vID4gUHV0IGEgYmFja3NsYXNoIChcIlxcXCIpIGluIGZyb250IG9mIHRoZSBmaXJzdCBcIiFcIiBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGxpdGVyYWwgXCIhXCIsIGZvciBleGFtcGxlLCBgXCJcXCFpbXBvcnRhbnQhLnR4dFwiYC5cbiAgLnJlcGxhY2UoUkVHRVhfUkVQTEFDRV9MRUFESU5HX0VYQ0FQRURfRVhDTEFNQVRJT04sICchJylcbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IGhhc2ggZm9yIHBhdHRlcm5zIHRoYXRcbiAgLy8gPiAgIGJlZ2luIHdpdGggYSBoYXNoLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNILCAnIycpXG5cbiAgY29uc3QgcmVnZXggPSBtYWtlUmVnZXgocGF0dGVybiwgaWdub3JlQ2FzZSlcblxuICByZXR1cm4gbmV3IElnbm9yZVJ1bGUoXG4gICAgb3JpZ2luLFxuICAgIHBhdHRlcm4sXG4gICAgbmVnYXRpdmUsXG4gICAgcmVnZXhcbiAgKVxufVxuXG5jb25zdCB0aHJvd0Vycm9yID0gKG1lc3NhZ2UsIEN0b3IpID0+IHtcbiAgdGhyb3cgbmV3IEN0b3IobWVzc2FnZSlcbn1cblxuY29uc3QgY2hlY2tQYXRoID0gKHBhdGgsIG9yaWdpbmFsUGF0aCwgZG9UaHJvdykgPT4ge1xuICBpZiAoIWlzU3RyaW5nKHBhdGgpKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coXG4gICAgICBgcGF0aCBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZ290IFxcYCR7b3JpZ2luYWxQYXRofVxcYGAsXG4gICAgICBUeXBlRXJyb3JcbiAgICApXG4gIH1cblxuICAvLyBXZSBkb24ndCBrbm93IGlmIHdlIHNob3VsZCBpZ25vcmUgRU1QVFksIHNvIHRocm93XG4gIGlmICghcGF0aCkge1xuICAgIHJldHVybiBkb1Rocm93KGBwYXRoIG11c3Qgbm90IGJlIGVtcHR5YCwgVHlwZUVycm9yKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgaXQgaXMgYSByZWxhdGl2ZSBwYXRoXG4gIGlmIChjaGVja1BhdGguaXNOb3RSZWxhdGl2ZShwYXRoKSkge1xuICAgIGNvbnN0IHIgPSAnYHBhdGgucmVsYXRpdmUoKWBkJ1xuICAgIHJldHVybiBkb1Rocm93KFxuICAgICAgYHBhdGggc2hvdWxkIGJlIGEgJHtyfSBzdHJpbmcsIGJ1dCBnb3QgXCIke29yaWdpbmFsUGF0aH1cImAsXG4gICAgICBSYW5nZUVycm9yXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3QgaXNOb3RSZWxhdGl2ZSA9IHBhdGggPT4gUkVHRVhfVEVTVF9JTlZBTElEX1BBVEgudGVzdChwYXRoKVxuXG5jaGVja1BhdGguaXNOb3RSZWxhdGl2ZSA9IGlzTm90UmVsYXRpdmVcbmNoZWNrUGF0aC5jb252ZXJ0ID0gcCA9PiBwXG5cbmNsYXNzIElnbm9yZSB7XG4gIGNvbnN0cnVjdG9yICh7XG4gICAgaWdub3JlY2FzZSA9IHRydWUsXG4gICAgaWdub3JlQ2FzZSA9IGlnbm9yZWNhc2UsXG4gICAgYWxsb3dSZWxhdGl2ZVBhdGhzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgZGVmaW5lKHRoaXMsIEtFWV9JR05PUkUsIHRydWUpXG5cbiAgICB0aGlzLl9ydWxlcyA9IFtdXG4gICAgdGhpcy5faWdub3JlQ2FzZSA9IGlnbm9yZUNhc2VcbiAgICB0aGlzLl9hbGxvd1JlbGF0aXZlUGF0aHMgPSBhbGxvd1JlbGF0aXZlUGF0aHNcbiAgICB0aGlzLl9pbml0Q2FjaGUoKVxuICB9XG5cbiAgX2luaXRDYWNoZSAoKSB7XG4gICAgdGhpcy5faWdub3JlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgdGhpcy5fdGVzdENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB9XG5cbiAgX2FkZFBhdHRlcm4gKHBhdHRlcm4pIHtcbiAgICAvLyAjMzJcbiAgICBpZiAocGF0dGVybiAmJiBwYXR0ZXJuW0tFWV9JR05PUkVdKSB7XG4gICAgICB0aGlzLl9ydWxlcyA9IHRoaXMuX3J1bGVzLmNvbmNhdChwYXR0ZXJuLl9ydWxlcylcbiAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNoZWNrUGF0dGVybihwYXR0ZXJuKSkge1xuICAgICAgY29uc3QgcnVsZSA9IGNyZWF0ZVJ1bGUocGF0dGVybiwgdGhpcy5faWdub3JlQ2FzZSlcbiAgICAgIHRoaXMuX2FkZGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcnVsZXMucHVzaChydWxlKVxuICAgIH1cbiAgfVxuXG4gIC8vIEBwYXJhbSB7QXJyYXk8c3RyaW5nPiB8IHN0cmluZyB8IElnbm9yZX0gcGF0dGVyblxuICBhZGQgKHBhdHRlcm4pIHtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlXG5cbiAgICBtYWtlQXJyYXkoXG4gICAgICBpc1N0cmluZyhwYXR0ZXJuKVxuICAgICAgICA/IHNwbGl0UGF0dGVybihwYXR0ZXJuKVxuICAgICAgICA6IHBhdHRlcm5cbiAgICApLmZvckVhY2godGhpcy5fYWRkUGF0dGVybiwgdGhpcylcblxuICAgIC8vIFNvbWUgcnVsZXMgaGF2ZSBqdXN0IGFkZGVkIHRvIHRoZSBpZ25vcmUsXG4gICAgLy8gbWFraW5nIHRoZSBiZWhhdmlvciBjaGFuZ2VkLlxuICAgIGlmICh0aGlzLl9hZGRlZCkge1xuICAgICAgdGhpcy5faW5pdENhY2hlKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gbGVnYWN5XG4gIGFkZFBhdHRlcm4gKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gdGhpcy5hZGQocGF0dGVybilcbiAgfVxuXG4gIC8vICAgICAgICAgIHwgICAgICAgICAgIGlnbm9yZWQgOiB1bmlnbm9yZWRcbiAgLy8gbmVnYXRpdmUgfCAgIDA6MCAgIHwgICAwOjEgICB8ICAgMTowICAgfCAgIDE6MVxuICAvLyAtLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tXG4gIC8vICAgICAwICAgIHwgIFRFU1QgICB8ICBURVNUICAgfCAgU0tJUCAgIHwgICAgWFxuICAvLyAgICAgMSAgICB8ICBURVNUSUYgfCAgU0tJUCAgIHwgIFRFU1QgICB8ICAgIFhcblxuICAvLyAtIFNLSVA6IGFsd2F5cyBza2lwXG4gIC8vIC0gVEVTVDogYWx3YXlzIHRlc3RcbiAgLy8gLSBURVNUSUY6IG9ubHkgdGVzdCBpZiBjaGVja1VuaWdub3JlZFxuICAvLyAtIFg6IHRoYXQgbmV2ZXIgaGFwcGVuXG5cbiAgLy8gQHBhcmFtIHtib29sZWFufSB3aGV0aGVyIHNob3VsZCBjaGVjayBpZiB0aGUgcGF0aCBpcyB1bmlnbm9yZWQsXG4gIC8vICAgc2V0dGluZyBgY2hlY2tVbmlnbm9yZWRgIHRvIGBmYWxzZWAgY291bGQgcmVkdWNlIGFkZGl0aW9uYWxcbiAgLy8gICBwYXRoIG1hdGNoaW5nLlxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fSB0cnVlIGlmIGEgZmlsZSBpcyBpZ25vcmVkXG4gIF90ZXN0T25lIChwYXRoLCBjaGVja1VuaWdub3JlZCkge1xuICAgIGxldCBpZ25vcmVkID0gZmFsc2VcbiAgICBsZXQgdW5pZ25vcmVkID0gZmFsc2VcblxuICAgIHRoaXMuX3J1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICBjb25zdCB7bmVnYXRpdmV9ID0gcnVsZVxuICAgICAgaWYgKFxuICAgICAgICB1bmlnbm9yZWQgPT09IG5lZ2F0aXZlICYmIGlnbm9yZWQgIT09IHVuaWdub3JlZFxuICAgICAgICB8fCBuZWdhdGl2ZSAmJiAhaWdub3JlZCAmJiAhdW5pZ25vcmVkICYmICFjaGVja1VuaWdub3JlZFxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXRjaGVkID0gcnVsZS5yZWdleC50ZXN0KHBhdGgpXG5cbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIGlnbm9yZWQgPSAhbmVnYXRpdmVcbiAgICAgICAgdW5pZ25vcmVkID0gbmVnYXRpdmVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlnbm9yZWQsXG4gICAgICB1bmlnbm9yZWRcbiAgICB9XG4gIH1cblxuICAvLyBAcmV0dXJucyB7VGVzdFJlc3VsdH1cbiAgX3Rlc3QgKG9yaWdpbmFsUGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpIHtcbiAgICBjb25zdCBwYXRoID0gb3JpZ2luYWxQYXRoXG4gICAgICAvLyBTdXBwb3J0cyBudWxsYWJsZSBwYXRoXG4gICAgICAmJiBjaGVja1BhdGguY29udmVydChvcmlnaW5hbFBhdGgpXG5cbiAgICBjaGVja1BhdGgoXG4gICAgICBwYXRoLFxuICAgICAgb3JpZ2luYWxQYXRoLFxuICAgICAgdGhpcy5fYWxsb3dSZWxhdGl2ZVBhdGhzXG4gICAgICAgID8gUkVUVVJOX0ZBTFNFXG4gICAgICAgIDogdGhyb3dFcnJvclxuICAgIClcblxuICAgIHJldHVybiB0aGlzLl90KHBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKVxuICB9XG5cbiAgX3QgKHBhdGgsIGNhY2hlLCBjaGVja1VuaWdub3JlZCwgc2xpY2VzKSB7XG4gICAgaWYgKHBhdGggaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWNoZVtwYXRoXVxuICAgIH1cblxuICAgIGlmICghc2xpY2VzKSB7XG4gICAgICAvLyBwYXRoL3RvL2EuanNcbiAgICAgIC8vIFsncGF0aCcsICd0bycsICdhLmpzJ11cbiAgICAgIHNsaWNlcyA9IHBhdGguc3BsaXQoU0xBU0gpXG4gICAgfVxuXG4gICAgc2xpY2VzLnBvcCgpXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBoYXMgbm8gcGFyZW50IGRpcmVjdG9yeSwganVzdCB0ZXN0IGl0XG4gICAgaWYgKCFzbGljZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gY2FjaGVbcGF0aF0gPSB0aGlzLl90ZXN0T25lKHBhdGgsIGNoZWNrVW5pZ25vcmVkKVxuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3QoXG4gICAgICBzbGljZXMuam9pbihTTEFTSCkgKyBTTEFTSCxcbiAgICAgIGNhY2hlLFxuICAgICAgY2hlY2tVbmlnbm9yZWQsXG4gICAgICBzbGljZXNcbiAgICApXG5cbiAgICAvLyBJZiB0aGUgcGF0aCBjb250YWlucyBhIHBhcmVudCBkaXJlY3RvcnksIGNoZWNrIHRoZSBwYXJlbnQgZmlyc3RcbiAgICByZXR1cm4gY2FjaGVbcGF0aF0gPSBwYXJlbnQuaWdub3JlZFxuICAgICAgLy8gPiBJdCBpcyBub3QgcG9zc2libGUgdG8gcmUtaW5jbHVkZSBhIGZpbGUgaWYgYSBwYXJlbnQgZGlyZWN0b3J5IG9mXG4gICAgICAvLyA+ICAgdGhhdCBmaWxlIGlzIGV4Y2x1ZGVkLlxuICAgICAgPyBwYXJlbnRcbiAgICAgIDogdGhpcy5fdGVzdE9uZShwYXRoLCBjaGVja1VuaWdub3JlZClcbiAgfVxuXG4gIGlnbm9yZXMgKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVzdChwYXRoLCB0aGlzLl9pZ25vcmVDYWNoZSwgZmFsc2UpLmlnbm9yZWRcbiAgfVxuXG4gIGNyZWF0ZUZpbHRlciAoKSB7XG4gICAgcmV0dXJuIHBhdGggPT4gIXRoaXMuaWdub3JlcyhwYXRoKVxuICB9XG5cbiAgZmlsdGVyIChwYXRocykge1xuICAgIHJldHVybiBtYWtlQXJyYXkocGF0aHMpLmZpbHRlcih0aGlzLmNyZWF0ZUZpbHRlcigpKVxuICB9XG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9XG4gIHRlc3QgKHBhdGgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGVzdChwYXRoLCB0aGlzLl90ZXN0Q2FjaGUsIHRydWUpXG4gIH1cbn1cblxuY29uc3QgZmFjdG9yeSA9IG9wdGlvbnMgPT4gbmV3IElnbm9yZShvcHRpb25zKVxuXG5jb25zdCBpc1BhdGhWYWxpZCA9IHBhdGggPT5cbiAgY2hlY2tQYXRoKHBhdGggJiYgY2hlY2tQYXRoLmNvbnZlcnQocGF0aCksIHBhdGgsIFJFVFVSTl9GQUxTRSlcblxuZmFjdG9yeS5pc1BhdGhWYWxpZCA9IGlzUGF0aFZhbGlkXG5cbi8vIEZpeGVzIHR5cGVzY3JpcHRcbmZhY3RvcnkuZGVmYXVsdCA9IGZhY3RvcnlcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5XG5cbi8vIFdpbmRvd3Ncbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChcbiAgLy8gRGV0ZWN0IGBwcm9jZXNzYCBzbyB0aGF0IGl0IGNhbiBydW4gaW4gYnJvd3NlcnMuXG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAmJiAoXG4gICAgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuSUdOT1JFX1RFU1RfV0lOMzJcbiAgICB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gIClcbikge1xuICAvKiBlc2xpbnQgbm8tY29udHJvbC1yZWdleDogXCJvZmZcIiAqL1xuICBjb25zdCBtYWtlUG9zaXggPSBzdHIgPT4gL15cXFxcXFxcXFxcP1xcXFwvLnRlc3Qoc3RyKVxuICB8fCAvW1wiPD58XFx1MDAwMC1cXHUwMDFGXSsvdS50ZXN0KHN0cilcbiAgICA/IHN0clxuICAgIDogc3RyLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIGNoZWNrUGF0aC5jb252ZXJ0ID0gbWFrZVBvc2l4XG5cbiAgLy8gJ0M6XFxcXGZvbycgICAgIDwtICdDOlxcXFxmb28nIGhhcyBiZWVuIGNvbnZlcnRlZCB0byAnQzovJ1xuICAvLyAnZDpcXFxcZm9vJ1xuICBjb25zdCBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUgPSAvXlthLXpdOlxcLy9pXG4gIGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gcGF0aCA9PlxuICAgIFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURS50ZXN0KHBhdGgpXG4gICAgfHwgaXNOb3RSZWxhdGl2ZShwYXRoKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVjdHJvblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOmFzeW5jX2hvb2tzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOmNyeXB0b1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOmV2ZW50c1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOmZzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6ZnMvcHJvbWlzZXNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTptb2R1bGVcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJub2RlOnBhdGhcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibm9kZTpwcm9jZXNzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6dXJsXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIm5vZGU6dXRpbFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwYXRoXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInR0eVwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfZG90ZW52X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX2RsX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX3NlcnZlX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX3N0b3JlX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2VsZWN0cm9uX3VwZGF0ZXJfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfbG9kYXNoX187IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9maWx0ZXJcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9mb3ItZWFjaFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3BhZC1zdGFydFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL2luc3RhbmNlL3JldmVyc2VcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9pbnN0YW5jZS9zb21lXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2Fzc2lnblwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydGllc1wiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNvcmUtanMtcHVyZS9zdGFibGUvb2JqZWN0L2tleXNcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL3N0YWJsZS9zZXQtdGltZW91dFwiKTsiLCJ2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX1N5bWJvbCR0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sL3RvLXByaW1pdGl2ZS5qc1wiKTtcbnZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtfU3ltYm9sJHRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB0b1ByaW1pdGl2ZSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoXCIuL3RvUHJpbWl0aXZlLmpzXCIpO1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHRvUHJvcGVydHlLZXksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCJ2YXIgX1N5bWJvbCA9IHJlcXVpcmUoXCJjb3JlLWpzLXB1cmUvZmVhdHVyZXMvc3ltYm9sL2luZGV4LmpzXCIpO1xudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSByZXF1aXJlKFwiY29yZS1qcy1wdXJlL2ZlYXR1cmVzL3N5bWJvbC9pdGVyYXRvci5qc1wiKTtcbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgX1N5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBfU3ltYm9sJGl0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgX1N5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sICYmIG8gIT09IF9TeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF90eXBlb2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vc3RhYmxlL29iamVjdC9kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vc3RhYmxlL3N5bWJvbCcpO1xuXG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5mdW5jdGlvbi5tZXRhZGF0YScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLmFzeW5jLWRpc3Bvc2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5kaXNwb3NlJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wubWV0YWRhdGEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vc3RhYmxlL3N5bWJvbC9pdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9zdGFibGUvc3ltYm9sL3RvLXByaW1pdGl2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uLy4uL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyJyk7XG52YXIgZ2V0QnVpbHRJblByb3RvdHlwZU1ldGhvZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4tcHJvdG90eXBlLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW5Qcm90b3R5cGVNZXRob2QoJ0FycmF5JywgJ2ZpbHRlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5mb3ItZWFjaCcpO1xudmFyIGdldEJ1aWx0SW5Qcm90b3R5cGVNZXRob2QgPSByZXF1aXJlKCcuLi8uLi8uLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLXByb3RvdHlwZS1tZXRob2QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluUHJvdG90eXBlTWV0aG9kKCdBcnJheScsICdmb3JFYWNoJyk7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuLi8uLi8uLi9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UnKTtcbnZhciBnZXRCdWlsdEluUHJvdG90eXBlTWV0aG9kID0gcmVxdWlyZSgnLi4vLi4vLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbi1wcm90b3R5cGUtbWV0aG9kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJblByb3RvdHlwZU1ldGhvZCgnQXJyYXknLCAncmV2ZXJzZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5zb21lJyk7XG52YXIgZ2V0QnVpbHRJblByb3RvdHlwZU1ldGhvZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4tcHJvdG90eXBlLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW5Qcm90b3R5cGVNZXRob2QoJ0FycmF5JywgJ3NvbWUnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBtZXRob2QgPSByZXF1aXJlKCcuLi9hcnJheS92aXJ0dWFsL2ZpbHRlcicpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5maWx0ZXI7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGlzUHJvdG90eXBlT2YoQXJyYXlQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLmZpbHRlcikgPyBtZXRob2QgOiBvd247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIG1ldGhvZCA9IHJlcXVpcmUoJy4uL3N0cmluZy92aXJ0dWFsL3BhZC1zdGFydCcpO1xuXG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnBhZFN0YXJ0O1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzdHJpbmcnIHx8IGl0ID09PSBTdHJpbmdQcm90b3R5cGVcbiAgICB8fCAoaXNQcm90b3R5cGVPZihTdHJpbmdQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IFN0cmluZ1Byb3RvdHlwZS5wYWRTdGFydCkgPyBtZXRob2QgOiBvd247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIG1ldGhvZCA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvcmV2ZXJzZScpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5yZXZlcnNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IChpc1Byb3RvdHlwZU9mKEFycmF5UHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5yZXZlcnNlKSA/IG1ldGhvZCA6IG93bjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9vYmplY3QtaXMtcHJvdG90eXBlLW9mJyk7XG52YXIgbWV0aG9kID0gcmVxdWlyZSgnLi4vYXJyYXkvdmlydHVhbC9zb21lJyk7XG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnNvbWU7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUgfHwgKGlzUHJvdG90eXBlT2YoQXJyYXlQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlLnNvbWUpID8gbWV0aG9kIDogb3duO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmFzc2lnbicpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmFzc2lnbjtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy9wYXRoJyk7XG5cbnZhciBPYmplY3QgPSBwYXRoLk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVCwgRCk7XG59O1xuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnRpZXMuc2hhbSkgZGVmaW5lUHJvcGVydGllcy5zaGFtID0gdHJ1ZTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG52YXIgT2JqZWN0ID0gcGF0aC5PYmplY3Q7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5zaGFtKSBkZWZpbmVQcm9wZXJ0eS5zaGFtID0gdHJ1ZTtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG52YXIgT2JqZWN0ID0gcGF0aC5PYmplY3Q7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTtcblxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLnNoYW0gPSB0cnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG4iLCIndXNlIHN0cmljdCc7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbCcpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LmtleXMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5rZXlzO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcucGFkLXN0YXJ0Jyk7XG52YXIgZ2V0QnVpbHRJblByb3RvdHlwZU1ldGhvZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4tcHJvdG90eXBlLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW5Qcm90b3R5cGVNZXRob2QoJ1N0cmluZycsICdwYWRTdGFydCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5hcnJheS5jb25jYXQnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWRpc3Bvc2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuZGlzcG9zZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuaGFzLWluc3RhbmNlJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5pcy1jb25jYXQtc3ByZWFkYWJsZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLnN5bWJvbC5tYXRjaC1hbGwnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnJlcGxhY2UnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnNlYXJjaCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuc3BlY2llcycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wuc3BsaXQnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wudW5zY29wYWJsZXMnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuanNvbi50by1zdHJpbmctdGFnJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzLm1hdGgudG8tc3RyaW5nLXRhZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5yZWZsZWN0LnRvLXN0cmluZy10YWcnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL3BhdGgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXRoLlN5bWJvbDtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yJyk7XG52YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCdpdGVyYXRvcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5kYXRlLnRvLXByaW1pdGl2ZScpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lcy5zeW1ib2wudG8tcHJpbWl0aXZlJyk7XG52YXIgV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uLy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mKCd0b1ByaW1pdGl2ZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9mdWxsL29iamVjdC9kZWZpbmUtcHJvcGVydHknKTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZnVsbC9zeW1ib2wnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZnVsbC9zeW1ib2wvaXRlcmF0b3InKTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vZnVsbC9zeW1ib2wvdG8tcHJpbWl0aXZlJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vYWN0dWFsL29iamVjdC9kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vYWN0dWFsL3N5bWJvbCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLmlzLXJlZ2lzdGVyZWQtc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuaXMtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5jdXN0b20tbWF0Y2hlcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLm9ic2VydmFibGUnKTtcbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wuaXMtcmVnaXN0ZXJlZCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLmlzLXdlbGwta25vd24nKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXNuZXh0LnN5bWJvbC5tYXRjaGVyJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wubWV0YWRhdGEta2V5Jyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzbmV4dC5zeW1ib2wucGF0dGVybi1tYXRjaCcpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lc25leHQuc3ltYm9sLnJlcGxhY2UtYWxsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2FjdHVhbC9zeW1ib2wvaXRlcmF0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vYWN0dWFsL3N5bWJvbC90by1wcmltaXRpdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRyeVRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RyeS10by1zdHJpbmcnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc1Bvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNQb3NzaWJsZVByb3RvdHlwZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBzZXQgXCIgKyAkU3RyaW5nKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCcpO1xuXG52YXIgU1RSSUNUX01FVEhPRCA9IGFycmF5TWV0aG9kSXNTdHJpY3QoJ2ZvckVhY2gnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbm1vZHVsZS5leHBvcnRzID0gIVNUUklDVF9NRVRIT0QgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxufSA6IFtdLmZvckVhY2g7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT09IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbGVuZ3RoLW9mLWFycmF5LWxpa2UnKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHZhciBJU19NQVAgPSBUWVBFID09PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09PSAzO1xuICB2YXIgSVNfRVZFUlkgPSBUWVBFID09PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PT0gNztcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc2VsZik7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2Ugc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSA0OiByZXR1cm4gZmFsc2U7ICAgICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICAgICAgY2FzZSA3OiBwdXNoKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuICBmb3JFYWNoOiBjcmVhdGVNZXRob2QoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuICBzb21lOiBjcmVhdGVNZXRob2QoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAgZmluZEluZGV4OiBjcmVhdGVNZXRob2QoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kKDcpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gMTsgfSwgMSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyhbXS5zbGljZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIGlzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY29uc3RydWN0b3InKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IEM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKGFycmF5U3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsQXJyYXkpKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG5cbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKHt9LnRvU3RyaW5nKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHN0cmluZ1NsaWNlKHRvU3RyaW5nKGl0KSwgOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSAkT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlaXRlcnJlc3VsdG9iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiBkb25lIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoREVTQ1JJUFRPUlMpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtrZXldID0gdmFsdWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eS5mKHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW51bWVyYWJsZSkgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGFyZ2V0LCBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRhcmdldDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsVGhpc1trZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9PSA3O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPiBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyAkVHlwZUVycm9yKCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xuXG52YXIgbmF2aWdhdG9yID0gZ2xvYmFsVGhpcy5uYXZpZ2F0b3I7XG52YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlckFnZW50ID8gU3RyaW5nKHVzZXJBZ2VudCkgOiAnJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQnKTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWxUaGlzLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbFRoaXMuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbjtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBCdW4sIERlbm8gLS0gZGV0ZWN0aW9uICovXG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG52YXIgdXNlckFnZW50U3RhcnRzV2l0aCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIHVzZXJBZ2VudC5zbGljZSgwLCBzdHJpbmcubGVuZ3RoKSA9PT0gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAodXNlckFnZW50U3RhcnRzV2l0aCgnQnVuLycpKSByZXR1cm4gJ0JVTic7XG4gIGlmICh1c2VyQWdlbnRTdGFydHNXaXRoKCdDbG91ZGZsYXJlLVdvcmtlcnMnKSkgcmV0dXJuICdDTE9VREZMQVJFJztcbiAgaWYgKHVzZXJBZ2VudFN0YXJ0c1dpdGgoJ0Rlbm8vJykpIHJldHVybiAnREVOTyc7XG4gIGlmICh1c2VyQWdlbnRTdGFydHNXaXRoKCdOb2RlLmpzLycpKSByZXR1cm4gJ05PREUnO1xuICBpZiAoZ2xvYmFsVGhpcy5CdW4gJiYgdHlwZW9mIEJ1bi52ZXJzaW9uID09ICdzdHJpbmcnKSByZXR1cm4gJ0JVTic7XG4gIGlmIChnbG9iYWxUaGlzLkRlbm8gJiYgdHlwZW9mIERlbm8udmVyc2lvbiA9PSAnb2JqZWN0JykgcmV0dXJuICdERU5PJztcbiAgaWYgKGNsYXNzb2YoZ2xvYmFsVGhpcy5wcm9jZXNzKSA9PT0gJ3Byb2Nlc3MnKSByZXR1cm4gJ05PREUnO1xuICBpZiAoZ2xvYmFsVGhpcy53aW5kb3cgJiYgZ2xvYmFsVGhpcy5kb2N1bWVudCkgcmV0dXJuICdCUk9XU0VSJztcbiAgcmV0dXJuICdSRVNUJztcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzLWNsYXVzZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLWNvbnRleHQnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbi8vIGFkZCBkZWJ1Z2dpbmcgaW5mb1xucmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZScpO1xuXG52YXIgd3JhcENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKE5hdGl2ZUNvbnN0cnVjdG9yKSB7XG4gIHZhciBXcmFwcGVyID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFdyYXBwZXIpIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEpO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYik7XG4gICAgICB9IHJldHVybiBuZXcgTmF0aXZlQ29uc3RydWN0b3IoYSwgYiwgYyk7XG4gICAgfSByZXR1cm4gYXBwbHkoTmF0aXZlQ29uc3RydWN0b3IsIHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gV3JhcHBlcjtcbn07XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87XG5cbiAgdmFyIG5hdGl2ZVNvdXJjZSA9IEdMT0JBTCA/IGdsb2JhbFRoaXMgOiBTVEFUSUMgPyBnbG9iYWxUaGlzW1RBUkdFVF0gOiBnbG9iYWxUaGlzW1RBUkdFVF0gJiYgZ2xvYmFsVGhpc1tUQVJHRVRdLnByb3RvdHlwZTtcblxuICB2YXIgdGFyZ2V0ID0gR0xPQkFMID8gcGF0aCA6IHBhdGhbVEFSR0VUXSB8fCBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocGF0aCwgVEFSR0VULCB7fSlbVEFSR0VUXTtcbiAgdmFyIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG5cbiAgdmFyIEZPUkNFRCwgVVNFX05BVElWRSwgVklSVFVBTF9QUk9UT1RZUEU7XG4gIHZhciBrZXksIHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSwgbmF0aXZlUHJvcGVydHksIHJlc3VsdFByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgVVNFX05BVElWRSA9ICFGT1JDRUQgJiYgbmF0aXZlU291cmNlICYmIGhhc093bihuYXRpdmVTb3VyY2UsIGtleSk7XG5cbiAgICB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuXG4gICAgaWYgKFVTRV9OQVRJVkUpIGlmIChvcHRpb25zLmRvbnRDYWxsR2V0U2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5hdGl2ZVNvdXJjZSwga2V5KTtcbiAgICAgIG5hdGl2ZVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSBuYXRpdmVQcm9wZXJ0eSA9IG5hdGl2ZVNvdXJjZVtrZXldO1xuXG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBpbXBsZW1lbnRhdGlvblxuICAgIHNvdXJjZVByb3BlcnR5ID0gKFVTRV9OQVRJVkUgJiYgbmF0aXZlUHJvcGVydHkpID8gbmF0aXZlUHJvcGVydHkgOiBzb3VyY2Vba2V5XTtcblxuICAgIGlmICghRk9SQ0VEICYmICFQUk9UTyAmJiB0eXBlb2YgdGFyZ2V0UHJvcGVydHkgPT0gdHlwZW9mIHNvdXJjZVByb3BlcnR5KSBjb250aW51ZTtcblxuICAgIC8vIGJpbmQgbWV0aG9kcyB0byBnbG9iYWwgZm9yIGNhbGxpbmcgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBiaW5kKHNvdXJjZVByb3BlcnR5LCBnbG9iYWxUaGlzKTtcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlcyBpbiB0aGlzIHZlcnNpb25cbiAgICBlbHNlIGlmIChvcHRpb25zLndyYXAgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSB3cmFwQ29uc3RydWN0b3Ioc291cmNlUHJvcGVydHkpO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIGVsc2UgaWYgKFBST1RPICYmIGlzQ2FsbGFibGUoc291cmNlUHJvcGVydHkpKSByZXN1bHRQcm9wZXJ0eSA9IHVuY3VycnlUaGlzKHNvdXJjZVByb3BlcnR5KTtcbiAgICAvLyBkZWZhdWx0IGNhc2VcbiAgICBlbHNlIHJlc3VsdFByb3BlcnR5ID0gc291cmNlUHJvcGVydHk7XG5cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAoc291cmNlUHJvcGVydHkgJiYgc291cmNlUHJvcGVydHkuc2hhbSkgfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkocmVzdWx0UHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldCwga2V5LCByZXN1bHRQcm9wZXJ0eSk7XG5cbiAgICBpZiAoUFJPVE8pIHtcbiAgICAgIFZJUlRVQUxfUFJPVE9UWVBFID0gVEFSR0VUICsgJ1Byb3RvdHlwZSc7XG4gICAgICBpZiAoIWhhc093bihwYXRoLCBWSVJUVUFMX1BST1RPVFlQRSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGgsIFZJUlRVQUxfUFJPVE9UWVBFLCB7fSk7XG4gICAgICB9XG4gICAgICAvLyBleHBvcnQgdmlydHVhbCBwcm90b3R5cGUgbWV0aG9kc1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHBhdGhbVklSVFVBTF9QUk9UT1RZUEVdLCBrZXksIHNvdXJjZVByb3BlcnR5KTtcbiAgICAgIC8vIGV4cG9ydCByZWFsIHByb3RvdHlwZSBtZXRob2RzXG4gICAgICBpZiAob3B0aW9ucy5yZWFsICYmIHRhcmdldFByb3RvdHlwZSAmJiAoRk9SQ0VEIHx8ICF0YXJnZXRQcm90b3R5cGVba2V5XSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHRhcmdldFByb3RvdHlwZSwga2V5LCBzb3VyY2VQcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfQklORCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kLW5hdGl2ZScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgYXBwbHkgPSBGdW5jdGlvblByb3RvdHlwZS5hcHBseTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kLCBlcy9uby1yZWZsZWN0IC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFJlZmxlY3QgPT0gJ29iamVjdCcgJiYgUmVmbGVjdC5hcHBseSB8fCAoTkFUSVZFX0JJTkQgPyBjYWxsLmJpbmQoYXBwbHkpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbC5hcHBseShhcHBseSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1jbGF1c2UnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBiaW5kID0gdW5jdXJyeVRoaXModW5jdXJyeVRoaXMuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlKGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIHNhZmVcbiAgdmFyIHRlc3QgPSAoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KS5iaW5kKCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZnVuY3Rpb24tcHJvdG90eXBlLWJpbmQgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwuYXBwbHkoY2FsbCwgYXJndW1lbnRzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24oRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJyk7XG4vLyBhZGRpdGlvbmFsIHByb3RlY3Rpb24gZnJvbSBtaW5pZmllZCAvIG1hbmdsZWQgLyBkcm9wcGVkIGZ1bmN0aW9uIG5hbWVzXG52YXIgUFJPUEVSID0gRVhJU1RTICYmIChmdW5jdGlvbiBzb21ldGhpbmcoKSB7IC8qIGVtcHR5ICovIH0pLm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTIHx8IChERVNDUklQVE9SUyAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpLmNvbmZpZ3VyYWJsZSkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBhQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgbWV0aG9kKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxuICAgIHJldHVybiB1bmN1cnJ5VGhpcyhhQ2FsbGFibGUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNsYXNzb2ZSYXcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gTmFzaG9ybiBidWc6XG4gIC8vICAgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzExMjhcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEzMFxuICBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpIHJldHVybiB1bmN1cnJ5VGhpcyhmbik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIE5BVElWRV9CSU5EID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtbmF0aXZlJyk7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBjYWxsID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG52YXIgdW5jdXJyeVRoaXNXaXRoQmluZCA9IE5BVElWRV9CSU5EICYmIEZ1bmN0aW9uUHJvdG90eXBlLmJpbmQuYmluZChjYWxsLCBjYWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IHVuY3VycnlUaGlzV2l0aEJpbmQgOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbC5hcHBseShmbiwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUiwgTUVUSE9EKSB7XG4gIHZhciBOYW1lc3BhY2UgPSBwYXRoW0NPTlNUUlVDVE9SICsgJ1Byb3RvdHlwZSddO1xuICB2YXIgcHVyZU1ldGhvZCA9IE5hbWVzcGFjZSAmJiBOYW1lc3BhY2VbTUVUSE9EXTtcbiAgaWYgKHB1cmVNZXRob2QpIHJldHVybiBwdXJlTWV0aG9kO1xuICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWxUaGlzW0NPTlNUUlVDVE9SXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgcmV0dXJuIE5hdGl2ZVByb3RvdHlwZSAmJiBOYXRpdmVQcm90b3R5cGVbTUVUSE9EXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGF0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh2YXJpYWJsZSkgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoW25hbWVzcGFjZV0pIHx8IGFGdW5jdGlvbihnbG9iYWxUaGlzW25hbWVzcGFjZV0pXG4gICAgOiBwYXRoW25hbWVzcGFjZV0gJiYgcGF0aFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsVGhpc1tuYW1lc3BhY2VdICYmIGdsb2JhbFRoaXNbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocmVwbGFjZXIpIHtcbiAgaWYgKGlzQ2FsbGFibGUocmVwbGFjZXIpKSByZXR1cm4gcmVwbGFjZXI7XG4gIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJldHVybjtcbiAgdmFyIHJhd0xlbmd0aCA9IHJlcGxhY2VyLmxlbmd0aDtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdMZW5ndGg7IGkrKykge1xuICAgIHZhciBlbGVtZW50ID0gcmVwbGFjZXJbaV07XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnKSBwdXNoKGtleXMsIGVsZW1lbnQpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdudW1iZXInIHx8IGNsYXNzb2YoZWxlbWVudCkgPT09ICdOdW1iZXInIHx8IGNsYXNzb2YoZWxlbWVudCkgPT09ICdTdHJpbmcnKSBwdXNoKGtleXMsIHRvU3RyaW5nKGVsZW1lbnQpKTtcbiAgfVxuICB2YXIga2V5c0xlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgcm9vdCA9IHRydWU7XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChyb290KSB7XG4gICAgICByb290ID0gZmFsc2U7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHRoaXMpKSByZXR1cm4gdmFsdWU7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrZXlzTGVuZ3RoOyBqKyspIGlmIChrZXlzW2pdID09PSBrZXkpIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYUNhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtY2FsbGFibGUnKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1udWxsLW9yLXVuZGVmaW5lZCcpO1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gIHZhciBmdW5jID0gVltQXTtcbiAgcmV0dXJuIGlzTnVsbE9yVW5kZWZpbmVkKGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8XG4gIGNoZWNrKHR5cGVvZiB0aGlzID09ICdvYmplY3QnICYmIHRoaXMpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5cbi8vIGBIYXNPd25Qcm9wZXJ0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWhhc293bnByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWhhc293biAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5KHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9PSA3O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIHNwbGl0ID0gdW5jdXJyeVRoaXMoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhJE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0KGl0KTtcbn0gOiAkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxudmFyIGZ1bmN0aW9uVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlYWstbWFwLWJhc2ljLWRldGVjdGlvbicpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5Jyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlJyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGRlbi1rZXlzJyk7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsVGhpcy5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbFRoaXMuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWFzc2lnbiAtLSBwcm90b3R5cGUgbWV0aG9kcyBwcm90ZWN0aW9uICovXG4gIHN0b3JlLmdldCA9IHN0b3JlLmdldDtcbiAgc3RvcmUuaGFzID0gc3RvcmUuaGFzO1xuICBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHN0b3JlLmhhcyhpdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIHN0b3JlLnNldChpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldChpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBzdG9yZS5oYXMoaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuICBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duKGl0LCBTVEFURSkpIHRocm93IG5ldyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICAgIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBoYXNPd24oaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaGFzT3duKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IHNldCxcbiAgZ2V0OiBnZXQsXG4gIGhhczogaGFzLFxuICBlbmZvcmNlOiBlbmZvcmNlLFxuICBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNhcnJheVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJndW1lbnQpID09PSAnQXJyYXknO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3RcbnZhciBkb2N1bWVudEFsbCA9IHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5hbGw7XG5cbi8vIGBJc0NhbGxhYmxlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNjYWxsYWJsZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vbm8tdHlwZW9mLXVuZGVmaW5lZCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgZG9jdW1lbnRBbGwgPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRBbGwgIT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZicpO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZScpO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBjb25zdHJ1Y3QgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ2NvbnN0cnVjdCcpO1xudmFyIGNvbnN0cnVjdG9yUmVnRXhwID0gL15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLztcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC50ZXN0KG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0cnVjdChub29wLCBbXSwgYXJndW1lbnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGlzQ29uc3RydWN0b3JMZWdhY3kgPSBmdW5jdGlvbiBpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSB7XG4gIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuICAgIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgICBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzogcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gd2UgY2FuJ3QgY2hlY2sgLnByb3RvdHlwZSBzaW5jZSBjb25zdHJ1Y3RvcnMgcHJvZHVjZWQgYnkgLmJpbmQgaGF2ZW4ndCBpdFxuICAgIC8vIGBGdW5jdGlvbiN0b1N0cmluZ2AgdGhyb3dzIG9uIHNvbWUgYnVpbHQtaXQgZnVuY3Rpb24gaW4gc29tZSBsZWdhY3kgZW5naW5lc1xuICAgIC8vIChmb3IgZXhhbXBsZSwgYERPTVF1YWRgIGFuZCBzaW1pbGFyIGluIEZGNDEtKVxuICAgIHJldHVybiBJTkNPUlJFQ1RfVE9fU1RSSU5HIHx8ICEhZXhlYyhjb25zdHJ1Y3RvclJlZ0V4cCwgaW5zcGVjdFNvdXJjZShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsZWQ7XG4gIHJldHVybiBpc0NvbnN0cnVjdG9yTW9kZXJuKGlzQ29uc3RydWN0b3JNb2Rlcm4uY2FsbClcbiAgICB8fCAhaXNDb25zdHJ1Y3Rvck1vZGVybihPYmplY3QpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkgeyBjYWxsZWQgPSB0cnVlOyB9KVxuICAgIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlKGRldGVjdGlvbikgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIHdlIGNhbid0IHVzZSBqdXN0IGBpdCA9PSBudWxsYCBzaW5jZSBvZiBgZG9jdW1lbnQuYWxsYCBzcGVjaWFsIGNhc2Vcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3QtYWVjXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IG51bGwgfHwgaXQgPT09IHVuZGVmaW5lZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc09iamVjdChhcmd1bWVudCkgfHwgYXJndW1lbnQgPT09IG51bGw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JDb25zdHJ1Y3RvciwgVE9fU1RSSU5HX1RBRywgZmFsc2UsIHRydWUpO1xuICBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBGdW5jdGlvbk5hbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tbmFtZScpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9yLWNyZWF0ZS1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcbnZhciBJdGVyYXRvcnNDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJyk7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgJiYgS0lORCBpbiBJdGVyYWJsZVByb3RvdHlwZSkgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuXG4gICAgc3dpdGNoIChLSU5EKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBFTlRSSUVTOiByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTsgfTtcbiAgfTtcblxuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IGZhbHNlO1xuICB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gIHZhciBuYXRpdmVJdGVyYXRvciA9IEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgaWYgKCFJU19QVVJFICYmIGdldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgIHNldFByb3RvdHlwZU9mKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0NhbGxhYmxlKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gICAgICAgICAgZGVmaW5lQnVpbHRJbihDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FICYmIERFRkFVTFQgPT09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBpZiAoIUlTX1BVUkUgJiYgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShJdGVyYWJsZVByb3RvdHlwZSwgJ25hbWUnLCBWQUxVRVMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gY2FsbChuYXRpdmVJdGVyYXRvciwgdGhpcyk7IH07XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwb3J0IGFkZGl0aW9uYWwgbWV0aG9kc1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gICAgfTtcbiAgICBpZiAoRk9SQ0VEKSBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgICBpZiAoQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfHwgIShLRVkgaW4gSXRlcmFibGVQcm90b3R5cGUpKSB7XG4gICAgICAgIGRlZmluZUJ1aWx0SW4oSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgZGVmaW5lQnVpbHRJbihJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvciwgeyBuYW1lOiBERUZBVUxUIH0pO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1hcnJheS1wcm90b3R5cGUta2V5cyAtLSBzYWZlICovXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gIWlzT2JqZWN0KEl0ZXJhdG9yUHJvdG90eXBlKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdLmNhbGwodGVzdCkgIT09IHRlc3Q7XG59KTtcblxuaWYgKE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5lbHNlIGlmIChJU19QVVJFKSBJdGVyYXRvclByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZShJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4oSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlLFxuICBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYExlbmd0aE9mQXJyYXlMaWtlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGVuZ3Rob2ZhcnJheWxpa2Vcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdG9MZW5ndGgob2JqLmxlbmd0aCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hdGgudHJ1bmNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1tYXRoLXRydW5jIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gTWF0aC50cnVuYyB8fCBmdW5jdGlvbiB0cnVuYyh4KSB7XG4gIHZhciBuID0gK3g7XG4gIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHNhZmVcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMgJiYgJGFzc2lnbih7IGI6IDEgfSwgJGFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgnYXNzaWduIGRldGVjdGlvbicpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9PSA3IHx8IG9iamVjdEtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9PSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KG9iamVjdEtleXMoUyksIGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBjYWxsKHByb3BlcnR5SXNFbnVtZXJhYmxlLCBTLCBrZXkpKSBUW2tleV0gPSBTW2tleV07XG4gICAgfVxuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgQWN0aXZlWE9iamVjdCAtLSBvbGQgSUUsIFdTSCAqL1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtYXNzaWdubWVudCAtLSBhdm9pZCBtZW1vcnkgbGVha1xuICBhY3RpdmVYRG9jdW1lbnQgPSBudWxsO1xuICByZXR1cm4gdGVtcDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG5cbi8vIENoZWNrIGZvciBkb2N1bWVudC5kb21haW4gYW5kIGFjdGl2ZSB4IHN1cHBvcnRcbi8vIE5vIG5lZWQgdG8gdXNlIGFjdGl2ZSB4IGFwcHJvYWNoIHdoZW4gZG9jdW1lbnQuZG9tYWluIGlzIG5vdCBzZXRcbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW0vaXNzdWVzLzE1MFxuLy8gdmFyaWF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9raXRjYW1icmlkZ2UvZXM1LXNoaW0vY29tbWl0LzRmNzM4YWMwNjYzNDZcbi8vIGF2b2lkIElFIEdDIGJ1Z1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgYWN0aXZlWERvY3VtZW50ID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGlnbm9yZSAqLyB9XG4gIE51bGxQcm90b09iamVjdCA9IHR5cGVvZiBkb2N1bWVudCAhPSAndW5kZWZpbmVkJ1xuICAgID8gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudFxuICAgICAgPyBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCkgLy8gb2xkIElFXG4gICAgICA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpXG4gICAgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtY3JlYXRlIC0tIHNhZmVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUuZihyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pZTgtZG9tLWRlZmluZScpO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Y4LXByb3RvdHlwZS1kZWZpbmUtYnVnJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXknKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRU5VTUVSQUJMRSA9ICdlbnVtZXJhYmxlJztcbnZhciBDT05GSUdVUkFCTEUgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFXSA6IGN1cnJlbnRbQ09ORklHVVJBQkxFXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IG5ldyAkVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093bihPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gYXJyYXlTbGljZSh3aW5kb3dOYW1lcyk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiBjbGFzc29mKGl0KSA9PT0gJ1dpbmRvdydcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBPYmplY3RQcm90b3R5cGUgPSAkT2JqZWN0LnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/ICRPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXNPd24ob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mICRPYmplY3QgPyBPYmplY3RQcm90b3R5cGUgOiBudWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHB1c2gocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2VudW0tYnVnLWtleXMnKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcy1hY2Nlc3NvcicpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIHNldHRlciA9IHVuY3VycnlUaGlzQWNjZXNzb3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycsICdzZXQnKTtcbiAgICBzZXR0ZXIodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIHJlcXVpcmVPYmplY3RDb2VyY2libGUoTyk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gTztcbiAgICBpZiAoQ09SUkVDVF9TRVRURVIpIHNldHRlcihPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyB7fS50b1N0cmluZyA6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tY2FsbCcpO1xudmFyIGlzQ2FsbGFibGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtY2FsbGFibGUnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBjYWxsKGZuLCBpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdldEJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG5cbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW51bGwtb3ItdW5kZWZpbmVkJyk7XG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpc051bGxPclVuZGVmaW5lZChpdCkpIHRocm93IG5ldyAkVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xudmFyIEVOVklST05NRU5UID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vudmlyb25tZW50Jyk7XG52YXIgVVNFUl9BR0VOVCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC11c2VyLWFnZW50Jyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3ZhbGlkYXRlLWFyZ3VtZW50cy1sZW5ndGgnKTtcblxudmFyIEZ1bmN0aW9uID0gZ2xvYmFsVGhpcy5GdW5jdGlvbjtcbi8vIGRpcnR5IElFOS0gYW5kIEJ1biAwLjMuMC0gY2hlY2tzXG52YXIgV1JBUCA9IC9NU0lFIC5cXC4vLnRlc3QoVVNFUl9BR0VOVCkgfHwgRU5WSVJPTk1FTlQgPT09ICdCVU4nICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZXJzaW9uID0gZ2xvYmFsVGhpcy5CdW4udmVyc2lvbi5zcGxpdCgnLicpO1xuICByZXR1cm4gdmVyc2lvbi5sZW5ndGggPCAzIHx8IHZlcnNpb25bMF0gPT09ICcwJyAmJiAodmVyc2lvblsxXSA8IDMgfHwgdmVyc2lvblsxXSA9PT0gJzMnICYmIHZlcnNpb25bMl0gPT09ICcwJyk7XG59KSgpO1xuXG4vLyBJRTktIC8gQnVuIDAuMy4wLSBzZXRUaW1lb3V0IC8gc2V0SW50ZXJ2YWwgLyBzZXRJbW1lZGlhdGUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCN0aW1lcnNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vdmVuLXNoL2J1bi9pc3N1ZXMvMTYzM1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBoYXNUaW1lQXJnKSB7XG4gIHZhciBmaXJzdFBhcmFtSW5kZXggPSBoYXNUaW1lQXJnID8gMiA6IDE7XG4gIHJldHVybiBXUkFQID8gZnVuY3Rpb24gKGhhbmRsZXIsIHRpbWVvdXQgLyogLCAuLi5hcmd1bWVudHMgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiBmaXJzdFBhcmFtSW5kZXg7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZShoYW5kbGVyKSA/IGhhbmRsZXIgOiBGdW5jdGlvbihoYW5kbGVyKTtcbiAgICB2YXIgcGFyYW1zID0gYm91bmRBcmdzID8gYXJyYXlTbGljZShhcmd1bWVudHMsIGZpcnN0UGFyYW1JbmRleCkgOiBbXTtcbiAgICB2YXIgY2FsbGJhY2sgPSBib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseShmbiwgdGhpcywgcGFyYW1zKTtcbiAgICB9IDogZm47XG4gICAgcmV0dXJuIGhhc1RpbWVBcmcgPyBzY2hlZHVsZXIoY2FsbGJhY2ssIHRpbWVvdXQpIDogc2NoZWR1bGVyKGNhbGxiYWNrKTtcbiAgfSA6IHNjaGVkdWxlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHknKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQywgU0VUX01FVEhPRCkge1xuICB2YXIgdGFyZ2V0ID0gU1RBVElDID8gaXQgOiBpdCAmJiBpdC5wcm90b3R5cGU7XG4gIGlmICh0YXJnZXQpIHtcbiAgICBpZiAoIWhhc093bih0YXJnZXQsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICAgIH1cbiAgICBpZiAoU0VUX01FVEhPRCAmJiAhVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkodGFyZ2V0LCAndG9TdHJpbmcnLCB0b1N0cmluZyk7XG4gICAgfVxuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtZ2xvYmFsLXByb3BlcnR5Jyk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsVGhpc1tTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG4oc3RvcmUudmVyc2lvbnMgfHwgKHN0b3JlLnZlcnNpb25zID0gW10pKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuNDQuMCcsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAxNC0yMDI1IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiAgbGljZW5zZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2Jsb2IvdjMuNDQuMC9MSUNFTlNFJyxcbiAgc291cmNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMnXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzdG9yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQtc3RvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlIHx8IHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyLW9yLWluZmluaXR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJBdCk7XG52YXIgY2hhckNvZGVBdCA9IHVuY3VycnlUaGlzKCcnLmNoYXJDb2RlQXQpO1xudmFyIHN0cmluZ1NsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xuXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0KFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMjgwXG52YXIgdXNlckFnZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Vudmlyb25tZW50LXVzZXItYWdlbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAvVmVyc2lvblxcLzEwKD86XFwuXFxkKyl7MSwyfSg/OiBbXFx3Li9dKyk/KD86IE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciAkcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgcmVwZWF0ID0gdW5jdXJyeVRoaXMoJHJlcGVhdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG52YXIgY2VpbCA9IE1hdGguY2VpbDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBwYWRTdGFydCwgcGFkRW5kIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfRU5EKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICAgIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlsbFN0ciA9IGZpbGxTdHJpbmcgPT09IHVuZGVmaW5lZCA/ICcgJyA6IHRvU3RyaW5nKGZpbGxTdHJpbmcpO1xuICAgIHZhciBmaWxsTGVuLCBzdHJpbmdGaWxsZXI7XG4gICAgaWYgKGludE1heExlbmd0aCA8PSBzdHJpbmdMZW5ndGggfHwgZmlsbFN0ciA9PT0gJycpIHJldHVybiBTO1xuICAgIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gICAgc3RyaW5nRmlsbGVyID0gcmVwZWF0KGZpbGxTdHIsIGNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gICAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdTbGljZShzdHJpbmdGaWxsZXIsIDAsIGZpbGxMZW4pO1xuICAgIHJldHVybiBJU19FTkQgPyBTICsgc3RyaW5nRmlsbGVyIDogc3RyaW5nRmlsbGVyICsgUztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRzdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUucGFkRW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnBhZGVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnJlcGVhdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBlYXQoY291bnQpIHtcbiAgdmFyIHN0ciA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyT3JJbmZpbml0eShjb3VudCk7XG4gIGlmIChuIDwgMCB8fCBuID09PSBJbmZpbml0eSkgdGhyb3cgbmV3ICRSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcbiAgZm9yICg7biA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKSBpZiAobiAmIDEpIHJlc3VsdCArPSBzdHI7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnZpcm9ubWVudC12OC12ZXJzaW9uJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG5cbnZhciAkU3RyaW5nID0gZ2xvYmFsVGhpcy5TdHJpbmc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCdzeW1ib2wgZGV0ZWN0aW9uJyk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgLy8gbmI6IERvIG5vdCBjYWxsIGBTdHJpbmdgIGRpcmVjdGx5IHRvIGF2b2lkIHRoaXMgYmVpbmcgb3B0aW1pemVkIG91dCB0byBgc3ltYm9sKycnYCB3aGljaCB3aWxsLFxuICAvLyBvZiBjb3Vyc2UsIGZhaWwuXG4gIHJldHVybiAhJFN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHZhciBTeW1ib2xQcm90b3R5cGUgPSBTeW1ib2wgJiYgU3ltYm9sLnByb3RvdHlwZTtcbiAgdmFyIHZhbHVlT2YgPSBTeW1ib2xQcm90b3R5cGUgJiYgU3ltYm9sUHJvdG90eXBlLnZhbHVlT2Y7XG4gIHZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbiAgaWYgKFN5bWJvbFByb3RvdHlwZSAmJiAhU3ltYm9sUHJvdG90eXBlW1RPX1BSSU1JVElWRV0pIHtcbiAgICAvLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIC5sZW5ndGhcbiAgICBkZWZpbmVCdWlsdEluKFN5bWJvbFByb3RvdHlwZSwgVE9fUFJJTUlUSVZFLCBmdW5jdGlvbiAoaGludCkge1xuICAgICAgcmV0dXJuIGNhbGwodmFsdWVPZiwgdGhpcyk7XG4gICAgfSwgeyBhcml0eTogMSB9KTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHVuY3VycnlUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLXVuY3VycnktdGhpcycpO1xuXG52YXIgU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG52YXIga2V5Rm9yID0gU3ltYm9sLmtleUZvcjtcbnZhciB0aGlzU3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xuXG4vLyBgU3ltYm9sLmlzUmVnaXN0ZXJlZFN5bWJvbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXNyZWdpc3RlcmVkc3ltYm9sXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbC5pc1JlZ2lzdGVyZWRTeW1ib2wgfHwgZnVuY3Rpb24gaXNSZWdpc3RlcmVkU3ltYm9sKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGtleUZvcih0aGlzU3ltYm9sVmFsdWUodmFsdWUpKSAhPT0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkJyk7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1zeW1ib2wnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xudmFyICRpc1dlbGxLbm93blN5bWJvbCA9IFN5bWJvbC5pc1dlbGxLbm93blN5bWJvbDtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0QnVpbHRJbignT2JqZWN0JywgJ2dldE93blByb3BlcnR5TmFtZXMnKTtcbnZhciB0aGlzU3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG5cbmZvciAodmFyIGkgPSAwLCBzeW1ib2xLZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhTeW1ib2wpLCBzeW1ib2xLZXlzTGVuZ3RoID0gc3ltYm9sS2V5cy5sZW5ndGg7IGkgPCBzeW1ib2xLZXlzTGVuZ3RoOyBpKyspIHtcbiAgLy8gc29tZSBvbGQgZW5naW5lcyB0aHJvd3Mgb24gYWNjZXNzIHRvIHNvbWUga2V5cyBsaWtlIGBhcmd1bWVudHNgIG9yIGBjYWxsZXJgXG4gIHRyeSB7XG4gICAgdmFyIHN5bWJvbEtleSA9IHN5bWJvbEtleXNbaV07XG4gICAgaWYgKGlzU3ltYm9sKFN5bWJvbFtzeW1ib2xLZXldKSkgd2VsbEtub3duU3ltYm9sKHN5bWJvbEtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn1cblxuLy8gYFN5bWJvbC5pc1dlbGxLbm93blN5bWJvbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXN3ZWxsa25vd25zeW1ib2xcbi8vIFdlIHNob3VsZCBwYXRjaCBpdCBmb3IgbmV3bHkgYWRkZWQgd2VsbC1rbm93biBzeW1ib2xzLiBJZiBpdCdzIG5vdCByZXF1aXJlZCwgdGhpcyBtb2R1bGUganVzdCB3aWxsIG5vdCBiZSBpbmplY3RlZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1dlbGxLbm93blN5bWJvbCh2YWx1ZSkge1xuICBpZiAoJGlzV2VsbEtub3duU3ltYm9sICYmICRpc1dlbGxLbm93blN5bWJvbCh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIHZhciBzeW1ib2wgPSB0aGlzU3ltYm9sVmFsdWUodmFsdWUpO1xuICAgIGZvciAodmFyIGogPSAwLCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhXZWxsS25vd25TeW1ib2xzU3RvcmUpLCBrZXlzTGVuZ3RoID0ga2V5cy5sZW5ndGg7IGogPCBrZXlzTGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXEgLS0gcG9seWZpbGxlZCBzeW1ib2xzIGNhc2VcbiAgICAgIGlmIChXZWxsS25vd25TeW1ib2xzU3RvcmVba2V5c1tqXV0gPT0gc3ltYm9sKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHNhZmUgKi9cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJiAhIVN5bWJvbFsnZm9yJ10gJiYgISFTeW1ib2wua2V5Rm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlci1vci1pbmZpbml0eScpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0Jyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0cnVuYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLXRydW5jJyk7XG5cbi8vIGBUb0ludGVnZXJPckluZmluaXR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2Vyb3JpbmZpbml0eVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXItb3ItaW5maW5pdHknKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGxlbiA9IHRvSW50ZWdlck9ySW5maW5pdHkoYXJndW1lbnQpO1xuICByZXR1cm4gbGVuID4gMCA/IG1pbihsZW4sIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgZ2V0TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1tZXRob2QnKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gY2FsbChleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBuZXcgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnc3RyaW5nJyk7XG4gIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZihhcmd1bWVudCkgPT09ICdTeW1ib2wnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMS50b1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtY29uc3RydWN0b3ItZGV0ZWN0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTCAmJlxuICAhU3ltYm9sLnNoYW0gJiZcbiAgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdwcm90b3R5cGUnLCB7XG4gICAgdmFsdWU6IDQyLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KS5wcm90b3R5cGUgIT09IDQyO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93IG5ldyAkVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuICByZXR1cm4gcGFzc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgaXNDYWxsYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1jYWxsYWJsZScpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbFRoaXMuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChTdHJpbmcoV2Vha01hcCkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTtcbiAgaWYgKCFoYXNPd24oU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkoU3ltYm9sLCBOQU1FLCB7XG4gICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZihOQU1FKVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbmV4cG9ydHMuZiA9IHdlbGxLbm93blN5bWJvbDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkJyk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sWydmb3InXSB8fCBTeW1ib2wgOiBTeW1ib2wgJiYgU3ltYm9sLndpdGhvdXRTZXR0ZXIgfHwgdWlkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duKFdlbGxLbm93blN5bWJvbHNTdG9yZSwgbmFtZSkpIHtcbiAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBOQVRJVkVfU1lNQk9MICYmIGhhc093bihTeW1ib2wsIG5hbWUpXG4gICAgICA/IFN5bWJvbFtuYW1lXVxuICAgICAgOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9sZW5ndGgtb2YtYXJyYXktbGlrZScpO1xudmFyIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2VzLW5vdC1leGNlZWQtc2FmZS1pbnRlZ2VyJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCcpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xudmFyIFY4X1ZFUlNJT04gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW52aXJvbm1lbnQtdjgtdmVyc2lvbicpO1xuXG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG4vLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdjb25jYXQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29uY2F0XG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAaXNDb25jYXRTcHJlYWRhYmxlIGFuZCBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBhcml0eTogMSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoRSk7XG4gICAgICAgIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihuICsgbGVuKTtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGxlbjsgaysrLCBuKyspIGlmIChrIGluIEUpIGNyZWF0ZVByb3BlcnR5KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKG4gKyAxKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPT0gZm9yRWFjaCB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2hcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvci1kZWZpbmUnKTtcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyLXJlc3VsdC1vYmplY3QnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZGVmaW5lSXRlcmF0b3IoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdChpdGVyYXRlZCksIC8vIHRhcmdldFxuICAgIGluZGV4OiAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICAgIGtpbmQ6IGtpbmQgICAgICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICB9KTtcbi8vIGAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSBudWxsO1xuICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgc3dpdGNoIChzdGF0ZS5raW5kKSB7XG4gICAgY2FzZSAna2V5cyc6IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KGluZGV4LCBmYWxzZSk7XG4gICAgY2FzZSAndmFsdWVzJzogcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QodGFyZ2V0W2luZGV4XSwgZmFsc2UpO1xuICB9IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGZhbHNlKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxudmFyIHZhbHVlcyA9IEl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vLyBWOCB+IENocm9tZSA0NS0gYnVnXG5pZiAoIUlTX1BVUkUgJiYgREVTQ1JJUFRPUlMgJiYgdmFsdWVzLm5hbWUgIT09ICd2YWx1ZXMnKSB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWFycmF5Jyk7XG5cbnZhciBuYXRpdmVSZXZlcnNlID0gdW5jdXJyeVRoaXMoW10ucmV2ZXJzZSk7XG52YXIgdGVzdCA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJldmVyc2Vcbi8vIGZpeCBmb3IgU2FmYXJpIDEyLjAgYnVnXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg4Nzk0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBTdHJpbmcodGVzdCkgPT09IFN0cmluZyh0ZXN0LnJldmVyc2UoKSkgfSwge1xuICByZXZlcnNlOiBmdW5jdGlvbiByZXZlcnNlKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnbiAtLSBkaXJ0eSBoYWNrXG4gICAgaWYgKGlzQXJyYXkodGhpcykpIHRoaXMubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgcmV0dXJuIG5hdGl2ZVJldmVyc2UodGhpcyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuc29tZTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QnKTtcblxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdzb21lJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCB9LCB7XG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIi8vIGVtcHR5XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFwcGx5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWFwcGx5Jyk7XG52YXIgY2FsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1jYWxsJyk7XG52YXIgdW5jdXJyeVRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdW5jdXJyeS10aGlzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBpc0NhbGxhYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWNhbGxhYmxlJyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgYXJyYXlTbGljZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zbGljZScpO1xudmFyIGdldFJlcGxhY2VyRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWpzb24tcmVwbGFjZXItZnVuY3Rpb24nKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1jb25zdHJ1Y3Rvci1kZXRlY3Rpb24nKTtcblxudmFyICRTdHJpbmcgPSBTdHJpbmc7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKC8uLy5leGVjKTtcbnZhciBjaGFyQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQ29kZUF0KTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcygxLjEudG9TdHJpbmcpO1xuXG52YXIgdGVzdGVyID0gL1tcXHVEODAwLVxcdURGRkZdL2c7XG52YXIgbG93ID0gL15bXFx1RDgwMC1cXHVEQkZGXSQvO1xudmFyIGhpID0gL15bXFx1REMwMC1cXHVERkZGXSQvO1xuXG52YXIgV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJykoJ3N0cmluZ2lmeSBkZXRlY3Rpb24nKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgcmV0dXJuICRzdHJpbmdpZnkoW3N5bWJvbF0pICE9PSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8ICRzdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT09ICd7fSdcbiAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgIHx8ICRzdHJpbmdpZnkoT2JqZWN0KHN5bWJvbCkpICE9PSAne30nO1xufSk7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXdlbGwtZm9ybWVkLXN0cmluZ2lmeVxudmFyIElMTF9GT1JNRURfVU5JQ09ERSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICRzdHJpbmdpZnkoJ1xcdURGMDZcXHVEODM0JykgIT09ICdcIlxcXFx1ZGYwNlxcXFx1ZDgzNFwiJ1xuICAgIHx8ICRzdHJpbmdpZnkoJ1xcdURFQUQnKSAhPT0gJ1wiXFxcXHVkZWFkXCInO1xufSk7XG5cbnZhciBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA9IGZ1bmN0aW9uIChpdCwgcmVwbGFjZXIpIHtcbiAgdmFyIGFyZ3MgPSBhcnJheVNsaWNlKGFyZ3VtZW50cyk7XG4gIHZhciAkcmVwbGFjZXIgPSBnZXRSZXBsYWNlckZ1bmN0aW9uKHJlcGxhY2VyKTtcbiAgaWYgKCFpc0NhbGxhYmxlKCRyZXBsYWNlcikgJiYgKGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gIGFyZ3NbMV0gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIHNvbWUgb2xkIGltcGxlbWVudGF0aW9ucyAobGlrZSBXZWJLaXQpIGNvdWxkIHBhc3MgbnVtYmVycyBhcyBrZXlzXG4gICAgaWYgKGlzQ2FsbGFibGUoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsKCRyZXBsYWNlciwgdGhpcywgJFN0cmluZyhrZXkpLCB2YWx1ZSk7XG4gICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgfTtcbiAgcmV0dXJuIGFwcGx5KCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgLSAxKTtcbiAgdmFyIG5leHQgPSBjaGFyQXQoc3RyaW5nLCBvZmZzZXQgKyAxKTtcbiAgaWYgKChleGVjKGxvdywgbWF0Y2gpICYmICFleGVjKGhpLCBuZXh0KSkgfHwgKGV4ZWMoaGksIG1hdGNoKSAmJiAhZXhlYyhsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgYXJpdHk6IDMsIGZvcmNlZDogV1JPTkdfU1lNQk9MU19DT05WRVJTSU9OIHx8IElMTF9GT1JNRURfVU5JQ09ERSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UoYXJndW1lbnRzKTtcbiAgICAgIHZhciByZXN1bHQgPSBhcHBseShXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPyBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA6ICRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIElMTF9GT1JNRURfVU5JQ09ERSAmJiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZShyZXN1bHQsIHRlc3RlciwgZml4SWxsRm9ybWVkKSA6IHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG4vLyBKU09OW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24tQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsVGhpcy5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiLy8gZW1wdHlcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBhcml0eTogMiwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJykuZjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydGllcyAtLSBzYWZlXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyAhPT0gZGVmaW5lUHJvcGVydGllcywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllc1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAhPT0gZGVmaW5lUHJvcGVydHksIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJykuZjtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xuXG52YXIgRk9SQ0VEID0gIURFU0NSSVBUT1JTIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKDEpOyB9KTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdChpdCksIGtleSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIga2V5LCBkZXNjcmlwdG9yO1xuICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSA9IGtleXNbaW5kZXgrK10pO1xuICAgICAgaWYgKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCkgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcblxuLy8gVjggfiBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRk9SQ0VEID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgICB2YXIgJGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gJGdldE93blByb3BlcnR5U3ltYm9scyh0b09iamVjdChpdCkpIDogW107XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qta2V5cycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVLZXlzKDEpOyB9KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBrZXlzOiBmdW5jdGlvbiBrZXlzKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXModG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG4iLCIvLyBlbXB0eVxuIiwiLy8gZW1wdHlcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciB0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3ItZGVmaW5lJyk7XG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlci1yZXN1bHQtb2JqZWN0Jyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIHBvaW50ID0gY2hhckF0KHN0cmluZywgaW5kZXgpO1xuICBzdGF0ZS5pbmRleCArPSBwb2ludC5sZW5ndGg7XG4gIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHBvaW50LCBmYWxzZSk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRwYWRTdGFydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctcGFkJykuc3RhcnQ7XG52YXIgV0VCS0lUX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctcGFkLXdlYmtpdC1idWcnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnBhZHN0YXJ0XG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogV0VCS0lUX0JVRyB9LCB7XG4gIHBhZFN0YXJ0OiBmdW5jdGlvbiBwYWRTdGFydChtYXhMZW5ndGggLyogLCBmaWxsU3RyaW5nID0gJyAnICovKSB7XG4gICAgcmV0dXJuICRwYWRTdGFydCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLmFzeW5jRGlzcG9zZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFzeW5jLWV4cGxpY2l0LXJlc291cmNlLW1hbmFnZW1lbnRcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnYXN5bmNEaXNwb3NlJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLmFzeW5jSXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5hc3luY2l0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2FzeW5jSXRlcmF0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWNhbGwnKTtcbnZhciB1bmN1cnJ5VGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi11bmN1cnJ5LXRoaXMnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWNvbnN0cnVjdG9yLWRldGVjdGlvbicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcy1vd24tcHJvcGVydHknKTtcbnZhciBpc1Byb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1pcy1wcm90b3R5cGUtb2YnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByb3BlcnR5LWtleScpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1zdHJpbmcnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlJyk7XG52YXIgZGVmaW5lQnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWJ1aWx0LWluLWFjY2Vzc29yJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG52YXIgZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWRlZmluZS10by1wcmltaXRpdmUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xuXG52YXIgSElEREVOID0gc2hhcmVkS2V5KCdoaWRkZW4nKTtcbnZhciBTWU1CT0wgPSAnU3ltYm9sJztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyICRTeW1ib2wgPSBnbG9iYWxUaGlzLlN5bWJvbDtcbnZhciBTeW1ib2xQcm90b3R5cGUgPSAkU3ltYm9sICYmICRTeW1ib2xbUFJPVE9UWVBFXTtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsVGhpcy5SYW5nZUVycm9yO1xudmFyIFR5cGVFcnJvciA9IGdsb2JhbFRoaXMuVHlwZUVycm9yO1xudmFyIFFPYmplY3QgPSBnbG9iYWxUaGlzLlFPYmplY3Q7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xuXG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUgPSBzaGFyZWQoJ3drcycpO1xuXG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgZmFsbGJhY2tEZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIHZhciBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgUCk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKSBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgJiYgTyAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlLCBQLCBPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKTtcbiAgfVxufTtcblxudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT09IDc7XG59KSA/IGZhbGxiYWNrRGVmaW5lUHJvcGVydHkgOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKFN5bWJvbFByb3RvdHlwZSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChoYXNPd24oQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhc093bihPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCBuYXRpdmVPYmplY3RDcmVhdGUobnVsbCkpKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc093bihPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgY2FsbCgkcHJvcGVydHlJc0VudW1lcmFibGUsIHByb3BlcnRpZXMsIGtleSkpICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gIH0pO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IG5hdGl2ZU9iamVjdENyZWF0ZShPKSA6ICRkZWZpbmVQcm9wZXJ0aWVzKG5hdGl2ZU9iamVjdENyZWF0ZShPKSwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgUCA9IHRvUHJvcGVydHlLZXkoVik7XG4gIHZhciBlbnVtZXJhYmxlID0gY2FsbChuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzT3duKEFsbFN5bWJvbHMsIFApICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093bih0aGlzLCBQKSB8fCAhaGFzT3duKEFsbFN5bWJvbHMsIFApIHx8IGhhc093bih0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXVxuICAgID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG90eXBlICYmIGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24oT2JqZWN0UHJvdG90eXBlU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiAgaWYgKGRlc2NyaXB0b3IgJiYgaGFzT3duKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24oaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkge1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgdmFyIG5hbWVzID0gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyh0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24oQWxsU3ltYm9scywga2V5KSAmJiAhaGFzT3duKGhpZGRlbktleXMsIGtleSkpIHB1c2gocmVzdWx0LCBrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhc093bihBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXNPd24oT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcHVzaChyZXN1bHQsIEFsbFN5bWJvbHNba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIGBTeW1ib2xgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YoU3ltYm9sUHJvdG90eXBlLCB0aGlzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgJHRoaXMgPSB0aGlzID09PSB1bmRlZmluZWQgPyBnbG9iYWxUaGlzIDogdGhpcztcbiAgICAgIGlmICgkdGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBjYWxsKHNldHRlciwgT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhc093bigkdGhpcywgSElEREVOKSAmJiBoYXNPd24oJHRoaXNbSElEREVOXSwgdGFnKSkgJHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSk7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKCR0aGlzLCB0YWcsIGRlc2NyaXB0b3IpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgIGZhbGxiYWNrRGVmaW5lUHJvcGVydHkoJHRoaXMsIHRhZywgZGVzY3JpcHRvcik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcblxuICBkZWZpbmVCdWlsdEluKFN5bWJvbFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICBkZWZpbmVCdWlsdEluKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuICB9O1xuXG4gIGlmIChERVNDUklQVE9SUykge1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvblxuICAgIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgZGVmaW5lQnVpbHRJbihPYmplY3RQcm90b3R5cGUsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgeyB1bnNhZmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG59XG5cbiQoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoKG9iamVjdEtleXMoV2VsbEtub3duU3ltYm9sc1N0b3JlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG5cbiQoeyB0YXJnZXQ6IFNZTUJPTCwgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB9LCB7XG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSBmYWxzZTsgfVxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvcnNcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yXG59KTtcblxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzXG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXNbSElEREVOXSA9IHRydWU7XG4iLCIvLyBlbXB0eVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcblxuLy8gYFN5bWJvbC5kaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXhwbGljaXQtcmVzb3VyY2UtbWFuYWdlbWVudFxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdkaXNwb3NlJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgdG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tc3RyaW5nJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLXJlZ2lzdHJ5LWRldGVjdGlvbicpO1xuXG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3RyaW5nLXRvLXN5bWJvbC1yZWdpc3RyeScpO1xudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhc093bihTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSBnZXRCdWlsdEluKCdTeW1ib2wnKShzdHJpbmcpO1xuICAgIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgICBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLmhhc0luc3RhbmNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaGFzaW5zdGFuY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaGFzSW5zdGFuY2UnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXNjb25jYXRzcHJlYWRhYmxlXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBSZW1vdmUgdGhpcyBtb2R1bGUgZnJvbSBgY29yZS1qc0A0YCBzaW5jZSBpdCdzIHNwbGl0IHRvIG1vZHVsZXMgbGlzdGVkIGJlbG93XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wuZm9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5rZXktZm9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmpzb24uc3RyaW5naWZ5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMtb3duLXByb3BlcnR5Jyk7XG52YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtc3ltYm9sJyk7XG52YXIgdHJ5VG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHJ5LXRvLXN0cmluZycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciBOQVRJVkVfU1lNQk9MX1JFR0lTVFJZID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1yZWdpc3RyeS1kZXRlY3Rpb24nKTtcblxudmFyIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5rZXlGb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgbmV3IFR5cGVFcnJvcih0cnlUb1N0cmluZyhzeW0pICsgJyBpcyBub3QgYSBzeW1ib2wnKTtcbiAgICBpZiAoaGFzT3duKFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcblxuLy8gYFN5bWJvbC5tYXRjaEFsbGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoYWxsXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoQWxsJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLm1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wucmVwbGFjZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnJlcGxhY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcblxuLy8gYFN5bWJvbC5zZWFyY2hgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zZWFyY2hcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc2VhcmNoJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLnNwZWNpZXNgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGVjaWVzXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wuc3BsaXRgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5zcGxpdFxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdzcGxpdCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcbnZhciBkZWZpbmVTeW1ib2xUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtZGVmaW5lLXRvLXByaW1pdGl2ZScpO1xuXG4vLyBgU3ltYm9sLnRvUHJpbWl0aXZlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9wcmltaXRpdmVcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmRlZmluZVN5bWJvbFRvUHJpbWl0aXZlKCk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcblxuLy8gYFN5bWJvbC50b1N0cmluZ1RhZ2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddYCBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKGdldEJ1aWx0SW4oJ1N5bWJvbCcpLCAnU3ltYm9sJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLnVuc2NvcGFibGVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudW5zY29wYWJsZXNcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcblxudmFyIE1FVEFEQVRBID0gd2VsbEtub3duU3ltYm9sKCdtZXRhZGF0YScpO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4vLyBGdW5jdGlvbi5wcm90b3R5cGVbQEBtZXRhZGF0YV1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWRlY29yYXRvci1tZXRhZGF0YVxuaWYgKEZ1bmN0aW9uUHJvdG90eXBlW01FVEFEQVRBXSA9PT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5KEZ1bmN0aW9uUHJvdG90eXBlLCBNRVRBREFUQSwge1xuICAgIHZhbHVlOiBudWxsXG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmFzeW5jLWRpc3Bvc2UnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wuY3VzdG9tTWF0Y2hlcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnY3VzdG9tTWF0Y2hlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmRpc3Bvc2UnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzUmVnaXN0ZXJlZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtaXMtcmVnaXN0ZXJlZCcpO1xuXG4vLyBgU3ltYm9sLmlzUmVnaXN0ZXJlZFN5bWJvbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXNyZWdpc3RlcmVkc3ltYm9sXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzUmVnaXN0ZXJlZFN5bWJvbDogaXNSZWdpc3RlcmVkU3ltYm9sXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzUmVnaXN0ZXJlZFN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zeW1ib2wtaXMtcmVnaXN0ZXJlZCcpO1xuXG4vLyBgU3ltYm9sLmlzUmVnaXN0ZXJlZGAgbWV0aG9kXG4vLyBvYnNvbGV0ZSB2ZXJzaW9uIG9mIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3JlZ2lzdGVyZWRzeW1ib2xcbiQoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBuYW1lOiAnaXNSZWdpc3RlcmVkU3ltYm9sJyB9LCB7XG4gIGlzUmVnaXN0ZXJlZDogaXNSZWdpc3RlcmVkU3ltYm9sXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N5bWJvbC1pcy13ZWxsLWtub3duJyk7XG5cbi8vIGBTeW1ib2wuaXNXZWxsS25vd25TeW1ib2xgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXN5bWJvbC1wcmVkaWNhdGVzLyNzZWMtc3ltYm9sLWlzd2VsbGtub3duc3ltYm9sXG4vLyBXZSBzaG91bGQgcGF0Y2ggaXQgZm9yIG5ld2x5IGFkZGVkIHdlbGwta25vd24gc3ltYm9scy4gSWYgaXQncyBub3QgcmVxdWlyZWQsIHRoaXMgbW9kdWxlIGp1c3Qgd2lsbCBub3QgYmUgaW5qZWN0ZWRcbiQoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICBpc1dlbGxLbm93blN5bWJvbDogaXNXZWxsS25vd25TeW1ib2xcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3ltYm9sLWlzLXdlbGwta25vd24nKTtcblxuLy8gYFN5bWJvbC5pc1dlbGxLbm93bmAgbWV0aG9kXG4vLyBvYnNvbGV0ZSB2ZXJzaW9uIG9mIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3dlbGxrbm93bnN5bWJvbFxuLy8gV2Ugc2hvdWxkIHBhdGNoIGl0IGZvciBuZXdseSBhZGRlZCB3ZWxsLWtub3duIHN5bWJvbHMuIElmIGl0J3Mgbm90IHJlcXVpcmVkLCB0aGlzIG1vZHVsZSBqdXN0IHdpbGwgbm90IGJlIGluamVjdGVkXG4kKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgbmFtZTogJ2lzV2VsbEtub3duU3ltYm9sJywgZm9yY2VkOiB0cnVlIH0sIHtcbiAgaXNXZWxsS25vd246IGlzV2VsbEtub3duU3ltYm9sXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wubWF0Y2hlcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnbWF0Y2hlcicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wubWV0YWRhdGFLZXlgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3ItbWV0YWRhdGFcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnbWV0YWRhdGFLZXknKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtZGVmaW5lJyk7XG5cbi8vIGBTeW1ib2wubWV0YWRhdGFgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3JzXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21ldGFkYXRhJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLm9ic2VydmFibGVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYnNlcnZhYmxlXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ29ic2VydmFibGUnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IHJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLWRlZmluZScpO1xuXG4vLyBgU3ltYm9sLnBhdHRlcm5NYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcbmRlZmluZVdlbGxLbm93blN5bWJvbCgncGF0dGVybk1hdGNoJyk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiByZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC1kZWZpbmUnKTtcblxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdyZXBsYWNlQWxsJyk7XG4iLCIvLyBlbXB0eVxuIiwiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIERPTUl0ZXJhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb20taXRlcmFibGVzJyk7XG52YXIgZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwtdGhpcycpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHNldFRvU3RyaW5nVGFnKGdsb2JhbFRoaXNbQ09MTEVDVElPTl9OQU1FXSwgQ09MTEVDVElPTl9OQU1FKTtcbiAgSXRlcmF0b3JzW0NPTExFQ1RJT05fTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWxUaGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbC10aGlzJyk7XG52YXIgc2NoZWR1bGVyc0ZpeCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zY2hlZHVsZXJzLWZpeCcpO1xuXG52YXIgc2V0SW50ZXJ2YWwgPSBzY2hlZHVsZXJzRml4KGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwsIHRydWUpO1xuXG4vLyBCdW4gLyBJRTktIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldGludGVydmFsXG4kKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IGdsb2JhbFRoaXMuc2V0SW50ZXJ2YWwgIT09IHNldEludGVydmFsIH0sIHtcbiAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbFRoaXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsLXRoaXMnKTtcbnZhciBzY2hlZHVsZXJzRml4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NjaGVkdWxlcnMtZml4Jyk7XG5cbnZhciBzZXRUaW1lb3V0ID0gc2NoZWR1bGVyc0ZpeChnbG9iYWxUaGlzLnNldFRpbWVvdXQsIHRydWUpO1xuXG4vLyBCdW4gLyBJRTktIHNldFRpbWVvdXQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuJCh7IGdsb2JhbDogdHJ1ZSwgYmluZDogdHJ1ZSwgZm9yY2VkOiBnbG9iYWxUaGlzLnNldFRpbWVvdXQgIT09IHNldFRpbWVvdXQgfSwge1xuICBzZXRUaW1lb3V0OiBzZXRUaW1lb3V0XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIFRPRE86IFJlbW92ZSB0aGlzIG1vZHVsZSBmcm9tIGBjb3JlLWpzQDRgIHNpbmNlIGl0J3Mgc3BsaXQgdG8gbW9kdWxlcyBsaXN0ZWQgYmVsb3dcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnNldC1pbnRlcnZhbCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuc2V0LXRpbWVvdXQnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9lcy9hcnJheS92aXJ0dWFsL2Zvci1lYWNoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL2ZpbHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvaGFzLW93bi1wcm9wZXJ0eScpO1xudmFyIGlzUHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi8uLi9pbnRlcm5hbHMvb2JqZWN0LWlzLXByb3RvdHlwZS1vZicpO1xudmFyIG1ldGhvZCA9IHJlcXVpcmUoJy4uL2FycmF5L3ZpcnR1YWwvZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaCcpO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5mb3JFYWNoO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlIHx8IChpc1Byb3RvdHlwZU9mKEFycmF5UHJvdG90eXBlLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZS5mb3JFYWNoKVxuICAgIHx8IGhhc093bihET01JdGVyYWJsZXMsIGNsYXNzb2YoaXQpKSA/IG1ldGhvZCA6IG93bjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvaW5zdGFuY2UvcGFkLXN0YXJ0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL2luc3RhbmNlL3JldmVyc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvaW5zdGFuY2Uvc29tZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL29iamVjdC9kZWZpbmUtcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHBhcmVudCA9IHJlcXVpcmUoJy4uLy4uL2VzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJlbnQ7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcGFyZW50ID0gcmVxdWlyZSgnLi4vLi4vZXMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9vYmplY3Qva2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnRpbWVycycpO1xudmFyIHBhdGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguc2V0VGltZW91dDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9zeW1ib2wvaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcmVudDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBwYXJlbnQgPSByZXF1aXJlKCcuLi8uLi9lcy9zeW1ib2wvdG8tcHJpbWl0aXZlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwiaW1wb3J0ICogYXMgX19iYW5uZXJfbm9kZV9tb2R1bGUgZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgKiBhcyBfX2Jhbm5lcl9ub2RlX3BhdGggZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0ICogYXMgcHJvY2VzcyBmcm9tIFwibm9kZTpwcm9jZXNzXCI7XG5pbXBvcnQgKiBhcyBfX2Jhbm5lcl9ub2RlX3VybCBmcm9tIFwibm9kZTp1cmxcIjtcbmNvbnN0IF9fZmlsZW5hbWUgPSBfX2Jhbm5lcl9ub2RlX3VybC5maWxlVVJMVG9QYXRoKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBfX2Rpcm5hbWUgPSBfX2Jhbm5lcl9ub2RlX3BhdGguZGlybmFtZShfX2ZpbGVuYW1lKTtcbmNvbnN0IHJlcXVpcmUgPSBfX2Jhbm5lcl9ub2RlX21vZHVsZS5jcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybCk7XG52YXIgbnU9T2JqZWN0LmNyZWF0ZTt2YXIgS249T2JqZWN0LmRlZmluZVByb3BlcnR5O3ZhciBpdT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO3ZhciBvdT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lczt2YXIgc3U9T2JqZWN0LmdldFByb3RvdHlwZU9mLGF1PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGZyPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0OihyLHQpPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTpyKVt0XX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgUm89KGUscik9PigpPT4oZSYmKHI9ZShlPTApKSxyKTt2YXIgdGU9KGUscik9PigpPT4ocnx8ZSgocj17ZXhwb3J0czp7fX0pLmV4cG9ydHMsciksci5leHBvcnRzKSxncj0oZSxyKT0+e2Zvcih2YXIgdCBpbiByKUtuKGUsdCx7Z2V0OnJbdF0sZW51bWVyYWJsZTohMH0pfSxsdT0oZSxyLHQsbik9PntpZihyJiZ0eXBlb2Ygcj09XCJvYmplY3RcInx8dHlwZW9mIHI9PVwiZnVuY3Rpb25cIilmb3IobGV0IGkgb2Ygb3UocikpIWF1LmNhbGwoZSxpKSYmaSE9PXQmJktuKGUsaSx7Z2V0OigpPT5yW2ldLGVudW1lcmFibGU6IShuPWl1KHIsaSkpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIG5lPShlLHIsdCk9Pih0PWUhPW51bGw/bnUoc3UoZSkpOnt9LGx1KHJ8fCFlfHwhZS5fX2VzTW9kdWxlP0tuKHQsXCJkZWZhdWx0XCIse3ZhbHVlOmUsZW51bWVyYWJsZTohMH0pOnQsZSkpO3ZhciBsaT10ZSgoVmcsWG8pPT57XCJ1c2Ugc3RyaWN0XCI7WG8uZXhwb3J0cz0oZSxyPXByb2Nlc3MuYXJndik9PntsZXQgdD1lLnN0YXJ0c1dpdGgoXCItXCIpP1wiXCI6ZS5sZW5ndGg9PT0xP1wiLVwiOlwiLS1cIixuPXIuaW5kZXhPZih0K2UpLGk9ci5pbmRleE9mKFwiLS1cIik7cmV0dXJuIG4hPT0tMSYmKGk9PT0tMXx8bjxpKX19KTt2YXIgdHM9dGUoKEJnLHJzKT0+e1widXNlIHN0cmljdFwiO3ZhciBTYz1mcihcIm5vZGU6b3NcIiksZXM9ZnIoXCJub2RlOnR0eVwiKSxwZT1saSgpLHtlbnY6VX09cHJvY2VzcyxRZTtwZShcIm5vLWNvbG9yXCIpfHxwZShcIm5vLWNvbG9yc1wiKXx8cGUoXCJjb2xvcj1mYWxzZVwiKXx8cGUoXCJjb2xvcj1uZXZlclwiKT9RZT0wOihwZShcImNvbG9yXCIpfHxwZShcImNvbG9yc1wiKXx8cGUoXCJjb2xvcj10cnVlXCIpfHxwZShcImNvbG9yPWFsd2F5c1wiKSkmJihRZT0xKTtcIkZPUkNFX0NPTE9SXCJpbiBVJiYoVS5GT1JDRV9DT0xPUj09PVwidHJ1ZVwiP1FlPTE6VS5GT1JDRV9DT0xPUj09PVwiZmFsc2VcIj9RZT0wOlFlPVUuRk9SQ0VfQ09MT1IubGVuZ3RoPT09MD8xOk1hdGgubWluKHBhcnNlSW50KFUuRk9SQ0VfQ09MT1IsMTApLDMpKTtmdW5jdGlvbiB1aShlKXtyZXR1cm4gZT09PTA/ITE6e2xldmVsOmUsaGFzQmFzaWM6ITAsaGFzMjU2OmU+PTIsaGFzMTZtOmU+PTN9fWZ1bmN0aW9uIGNpKGUscil7aWYoUWU9PT0wKXJldHVybiAwO2lmKHBlKFwiY29sb3I9MTZtXCIpfHxwZShcImNvbG9yPWZ1bGxcIil8fHBlKFwiY29sb3I9dHJ1ZWNvbG9yXCIpKXJldHVybiAzO2lmKHBlKFwiY29sb3I9MjU2XCIpKXJldHVybiAyO2lmKGUmJiFyJiZRZT09PXZvaWQgMClyZXR1cm4gMDtsZXQgdD1RZXx8MDtpZihVLlRFUk09PT1cImR1bWJcIilyZXR1cm4gdDtpZihwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwiKXtsZXQgbj1TYy5yZWxlYXNlKCkuc3BsaXQoXCIuXCIpO3JldHVybiBOdW1iZXIoblswXSk+PTEwJiZOdW1iZXIoblsyXSk+PTEwNTg2P051bWJlcihuWzJdKT49MTQ5MzE/MzoyOjF9aWYoXCJDSVwiaW4gVSlyZXR1cm5bXCJUUkFWSVNcIixcIkNJUkNMRUNJXCIsXCJBUFBWRVlPUlwiLFwiR0lUTEFCX0NJXCIsXCJHSVRIVUJfQUNUSU9OU1wiLFwiQlVJTERLSVRFXCJdLnNvbWUobj0+biBpbiBVKXx8VS5DSV9OQU1FPT09XCJjb2Rlc2hpcFwiPzE6dDtpZihcIlRFQU1DSVRZX1ZFUlNJT05cImluIFUpcmV0dXJuL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoVS5URUFNQ0lUWV9WRVJTSU9OKT8xOjA7aWYoVS5DT0xPUlRFUk09PT1cInRydWVjb2xvclwiKXJldHVybiAzO2lmKFwiVEVSTV9QUk9HUkFNXCJpbiBVKXtsZXQgbj1wYXJzZUludCgoVS5URVJNX1BST0dSQU1fVkVSU0lPTnx8XCJcIikuc3BsaXQoXCIuXCIpWzBdLDEwKTtzd2l0Y2goVS5URVJNX1BST0dSQU0pe2Nhc2VcImlUZXJtLmFwcFwiOnJldHVybiBuPj0zPzM6MjtjYXNlXCJBcHBsZV9UZXJtaW5hbFwiOnJldHVybiAyfX1yZXR1cm4vLTI1Nihjb2xvcik/JC9pLnRlc3QoVS5URVJNKT8yOi9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChVLlRFUk0pfHxcIkNPTE9SVEVSTVwiaW4gVT8xOnR9ZnVuY3Rpb24gUmMoZSl7bGV0IHI9Y2koZSxlJiZlLmlzVFRZKTtyZXR1cm4gdWkocil9cnMuZXhwb3J0cz17c3VwcG9ydHNDb2xvcjpSYyxzdGRvdXQ6dWkoY2koITAsZXMuaXNhdHR5KDEpKSksc3RkZXJyOnVpKGNpKCEwLGVzLmlzYXR0eSgyKSkpfX0pO3ZhciBvcz10ZSgoVWcsaXMpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEFjPXRzKCksRXI9bGkoKTtmdW5jdGlvbiBucyhlKXtpZigvXlxcZHszLDR9JC8udGVzdChlKSl7bGV0IHQ9LyhcXGR7MSwyfSkoXFxkezJ9KS8uZXhlYyhlKXx8W107cmV0dXJue21ham9yOjAsbWlub3I6cGFyc2VJbnQodFsxXSwxMCkscGF0Y2g6cGFyc2VJbnQodFsyXSwxMCl9fWxldCByPShlfHxcIlwiKS5zcGxpdChcIi5cIikubWFwKHQ9PnBhcnNlSW50KHQsMTApKTtyZXR1cm57bWFqb3I6clswXSxtaW5vcjpyWzFdLHBhdGNoOnJbMl19fWZ1bmN0aW9uIHBpKGUpe2xldHtDSTpyLEZPUkNFX0hZUEVSTElOSzp0LE5FVExJRlk6bixURUFNQ0lUWV9WRVJTSU9OOmksVEVSTV9QUk9HUkFNOm8sVEVSTV9QUk9HUkFNX1ZFUlNJT046cyxWVEVfVkVSU0lPTjphLFRFUk06bH09cHJvY2Vzcy5lbnY7aWYodClyZXR1cm4hKHQubGVuZ3RoPjAmJnBhcnNlSW50KHQsMTApPT09MCk7aWYoRXIoXCJuby1oeXBlcmxpbmtcIil8fEVyKFwibm8taHlwZXJsaW5rc1wiKXx8RXIoXCJoeXBlcmxpbms9ZmFsc2VcIil8fEVyKFwiaHlwZXJsaW5rPW5ldmVyXCIpKXJldHVybiExO2lmKEVyKFwiaHlwZXJsaW5rPXRydWVcIil8fEVyKFwiaHlwZXJsaW5rPWFsd2F5c1wiKXx8bilyZXR1cm4hMDtpZighQWMuc3VwcG9ydHNDb2xvcihlKXx8ZSYmIWUuaXNUVFkpcmV0dXJuITE7aWYoXCJXVF9TRVNTSU9OXCJpbiBwcm9jZXNzLmVudilyZXR1cm4hMDtpZihwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwifHxyfHxpKXJldHVybiExO2lmKG8pe2xldCB1PW5zKHN8fFwiXCIpO3N3aXRjaChvKXtjYXNlXCJpVGVybS5hcHBcIjpyZXR1cm4gdS5tYWpvcj09PTM/dS5taW5vcj49MTp1Lm1ham9yPjM7Y2FzZVwiV2V6VGVybVwiOnJldHVybiB1Lm1ham9yPj0yMDIwMDYyMDtjYXNlXCJ2c2NvZGVcIjpyZXR1cm4gdS5tYWpvcj4xfHx1Lm1ham9yPT09MSYmdS5taW5vcj49NzI7Y2FzZVwiZ2hvc3R0eVwiOnJldHVybiEwfX1pZihhKXtpZihhPT09XCIwLjUwLjBcIilyZXR1cm4hMTtsZXQgdT1ucyhhKTtyZXR1cm4gdS5tYWpvcj4wfHx1Lm1pbm9yPj01MH1zd2l0Y2gobCl7Y2FzZVwiYWxhY3JpdHR5XCI6cmV0dXJuITB9cmV0dXJuITF9aXMuZXhwb3J0cz17c3VwcG9ydHNIeXBlcmxpbms6cGksc3Rkb3V0OnBpKHByb2Nlc3Muc3Rkb3V0KSxzdGRlcnI6cGkocHJvY2Vzcy5zdGRlcnIpfX0pO3ZhciBzcz10ZSgodGgsQ2MpPT57Q2MuZXhwb3J0cz17bmFtZTpcIkBwcmlzbWEvaW50ZXJuYWxzXCIsdmVyc2lvbjpcIjYuMTMuMFwiLGRlc2NyaXB0aW9uOlwiVGhpcyBwYWNrYWdlIGlzIGludGVuZGVkIGZvciBQcmlzbWEncyBpbnRlcm5hbCB1c2VcIixtYWluOlwiZGlzdC9pbmRleC5qc1wiLHR5cGVzOlwiZGlzdC9pbmRleC5kLnRzXCIscmVwb3NpdG9yeTp7dHlwZTpcImdpdFwiLHVybDpcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvcHJpc21hLmdpdFwiLGRpcmVjdG9yeTpcInBhY2thZ2VzL2ludGVybmFsc1wifSxob21lcGFnZTpcImh0dHBzOi8vd3d3LnByaXNtYS5pb1wiLGF1dGhvcjpcIlRpbSBTdWNoYW5layA8c3VjaGFuZWtAcHJpc21hLmlvPlwiLGJ1Z3M6XCJodHRwczovL2dpdGh1Yi5jb20vcHJpc21hL3ByaXNtYS9pc3N1ZXNcIixsaWNlbnNlOlwiQXBhY2hlLTIuMFwiLHNjcmlwdHM6e2RldjpcIkRFVj10cnVlIHRzeCBoZWxwZXJzL2J1aWxkLnRzXCIsYnVpbGQ6XCJ0c3ggaGVscGVycy9idWlsZC50c1wiLHRlc3Q6XCJkb3RlbnYgLWUgLi4vLi4vLmRiLmVudiAtLSBqZXN0IC0tc2lsZW50XCIscHJlcHVibGlzaE9ubHk6XCJwbnBtIHJ1biBidWlsZFwifSxmaWxlczpbXCJSRUFETUUubWRcIixcImRpc3RcIixcIiEqKi9saWJxdWVyeV9lbmdpbmUqXCIsXCIhZGlzdC9nZXQtZ2VuZXJhdG9ycy9lbmdpbmVzLypcIixcInNjcmlwdHNcIl0sZGV2RGVwZW5kZW5jaWVzOntcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIjpcIjcuMjUuOVwiLFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI6XCIxLjkuMFwiLFwiQHN3Yy9jb3JlXCI6XCIxLjExLjVcIixcIkBzd2MvamVzdFwiOlwiMC4yLjM3XCIsXCJAdHlwZXMvYmFiZWxfX2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiOlwiNy4xNS4yXCIsXCJAdHlwZXMvamVzdFwiOlwiMjkuNS4xNFwiLFwiQHR5cGVzL25vZGVcIjpcIjE4LjE5Ljc2XCIsXCJAdHlwZXMvcmVzb2x2ZVwiOlwiMS4yMC42XCIsYXJjaGl2ZXI6XCI2LjAuMlwiLFwiY2hlY2twb2ludC1jbGllbnRcIjpcIjEuMS4zM1wiLFwiY2xpLXRydW5jYXRlXCI6XCI0LjAuMFwiLGRvdGVudjpcIjE2LjUuMFwiLGVzYnVpbGQ6XCIwLjI1LjVcIixcImVzY2FwZS1zdHJpbmctcmVnZXhwXCI6XCI1LjAuMFwiLGV4ZWNhOlwiNS4xLjFcIixcImZhc3QtZ2xvYlwiOlwiMy4zLjNcIixcImZpbmQtdXBcIjpcIjcuMC4wXCIsXCJmcC10c1wiOlwiMi4xNi45XCIsXCJmcy1leHRyYVwiOlwiMTEuMy4wXCIsXCJmcy1qZXRwYWNrXCI6XCI1LjEuMFwiLFwiZ2xvYmFsLWRpcnNcIjpcIjQuMC4wXCIsZ2xvYmJ5OlwiMTEuMS4wXCIsXCJpZGVudGlmaWVyLXJlZ2V4XCI6XCIxLjAuMFwiLFwiaW5kZW50LXN0cmluZ1wiOlwiNC4wLjBcIixcImlzLXdpbmRvd3NcIjpcIjEuMC4yXCIsXCJpcy13c2xcIjpcIjMuMS4wXCIsamVzdDpcIjI5LjcuMFwiLFwiamVzdC1qdW5pdFwiOlwiMTYuMC4wXCIsa2xldXI6XCI0LjEuNVwiLFwibW9jay1zdGRpblwiOlwiMS4wLjBcIixcIm5ldy1naXRodWItaXNzdWUtdXJsXCI6XCIwLjIuMVwiLFwibm9kZS1mZXRjaFwiOlwiMy4zLjJcIixcIm5wbS1wYWNrbGlzdFwiOlwiNS4xLjNcIixvcGVuOlwiNy40LjJcIixcInAtbWFwXCI6XCI0LjAuMFwiLFwicmVhZC1wYWNrYWdlLXVwXCI6XCIxMS4wLjBcIixyZXNvbHZlOlwiMS4yMi4xMFwiLFwic3RyaW5nLXdpZHRoXCI6XCI3LjIuMFwiLFwic3RyaXAtYW5zaVwiOlwiNi4wLjFcIixcInN0cmlwLWluZGVudFwiOlwiNC4wLjBcIixcInRlbXAtZGlyXCI6XCIyLjAuMFwiLHRlbXB5OlwiMS4wLjFcIixcInRlcm1pbmFsLWxpbmtcIjpcIjQuMC4wXCIsdG1wOlwiMC4yLjNcIixcInRzLW5vZGVcIjpcIjEwLjkuMlwiLFwidHMtcGF0dGVyblwiOlwiNS42LjJcIixcInRzLXRvb2xiZWx0XCI6XCI5LjYuMFwiLHR5cGVzY3JpcHQ6XCI1LjQuNVwiLHlhcm46XCIxLjIyLjIyXCJ9LGRlcGVuZGVuY2llczp7XCJAcHJpc21hL2NvbmZpZ1wiOlwid29ya3NwYWNlOipcIixcIkBwcmlzbWEvZGVidWdcIjpcIndvcmtzcGFjZToqXCIsXCJAcHJpc21hL2RtbWZcIjpcIndvcmtzcGFjZToqXCIsXCJAcHJpc21hL2RyaXZlci1hZGFwdGVyLXV0aWxzXCI6XCJ3b3Jrc3BhY2U6KlwiLFwiQHByaXNtYS9lbmdpbmVzXCI6XCJ3b3Jrc3BhY2U6KlwiLFwiQHByaXNtYS9mZXRjaC1lbmdpbmVcIjpcIndvcmtzcGFjZToqXCIsXCJAcHJpc21hL2dlbmVyYXRvclwiOlwid29ya3NwYWNlOipcIixcIkBwcmlzbWEvZ2VuZXJhdG9yLWhlbHBlclwiOlwid29ya3NwYWNlOipcIixcIkBwcmlzbWEvZ2V0LXBsYXRmb3JtXCI6XCJ3b3Jrc3BhY2U6KlwiLFwiQHByaXNtYS9wcmlzbWEtc2NoZW1hLXdhc21cIjpcIjYuMTMuMC0zNS4zNjFlODZkMGVhNDk4N2U5ZjUzYTU2NTMwOWIzZWVkNzk3YTZiY2JkXCIsXCJAcHJpc21hL3NjaGVtYS1lbmdpbmUtd2FzbVwiOlwiNi4xMy4wLTM1LjM2MWU4NmQwZWE0OTg3ZTlmNTNhNTY1MzA5YjNlZWQ3OTdhNmJjYmRcIixcIkBwcmlzbWEvc2NoZW1hLWZpbGVzLWxvYWRlclwiOlwid29ya3NwYWNlOipcIixhcmc6XCI1LjAuMlwiLHByb21wdHM6XCIyLjQuMlwifSxwZWVyRGVwZW5kZW5jaWVzOnt0eXBlc2NyaXB0OlwiPj01LjEuMFwifSxwZWVyRGVwZW5kZW5jaWVzTWV0YTp7dHlwZXNjcmlwdDp7b3B0aW9uYWw6ITB9fSxzaWRlRWZmZWN0czohMX19KTt2YXIgaGk9dGUoKFBoLE5jKT0+e05jLmV4cG9ydHM9e25hbWU6XCJAcHJpc21hL2VuZ2luZXMtdmVyc2lvblwiLHZlcnNpb246XCI2LjEzLjAtMzUuMzYxZTg2ZDBlYTQ5ODdlOWY1M2E1NjUzMDliM2VlZDc5N2E2YmNiZFwiLG1haW46XCJpbmRleC5qc1wiLHR5cGVzOlwiaW5kZXguZC50c1wiLGxpY2Vuc2U6XCJBcGFjaGUtMi4wXCIsYXV0aG9yOlwiVGltIFN1Y2hhbmVrIDxzdWNoYW5la0BwcmlzbWEuaW8+XCIscHJpc21hOntlbmdpbmVzVmVyc2lvbjpcIjM2MWU4NmQwZWE0OTg3ZTlmNTNhNTY1MzA5YjNlZWQ3OTdhNmJjYmRcIn0scmVwb3NpdG9yeTp7dHlwZTpcImdpdFwiLHVybDpcImh0dHBzOi8vZ2l0aHViLmNvbS9wcmlzbWEvZW5naW5lcy13cmFwcGVyLmdpdFwiLGRpcmVjdG9yeTpcInBhY2thZ2VzL2VuZ2luZXMtdmVyc2lvblwifSxkZXZEZXBlbmRlbmNpZXM6e1wiQHR5cGVzL25vZGVcIjpcIjE4LjE5Ljc2XCIsdHlwZXNjcmlwdDpcIjQuOS41XCJ9LGZpbGVzOltcImluZGV4LmpzXCIsXCJpbmRleC5kLnRzXCJdLHNjcmlwdHM6e2J1aWxkOlwidHNjIC1kXCJ9fX0pO3ZhciBadD10ZSh6dD0+e1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh6dCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt6dC5lbmdpbmVzVmVyc2lvbj12b2lkIDA7enQuZW5naW5lc1ZlcnNpb249aGkoKS5wcmlzbWEuZW5naW5lc1ZlcnNpb259KTt2YXIgZHM9dGUoKHFoLHBzKT0+e1widXNlIHN0cmljdFwiO3BzLmV4cG9ydHM9ZT0+e2xldCByPWUubWF0Y2goL15bIFxcdF0qKD89XFxTKS9nbSk7cmV0dXJuIHI/ci5yZWR1Y2UoKHQsbik9Pk1hdGgubWluKHQsbi5sZW5ndGgpLDEvMCk6MH19KTt2YXIgeGk9dGUoKEJoLGdzKT0+e1widXNlIHN0cmljdFwiO2dzLmV4cG9ydHM9KGUscj0xLHQpPT57aWYodD17aW5kZW50OlwiIFwiLGluY2x1ZGVFbXB0eUxpbmVzOiExLC4uLnR9LHR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYGlucHV0XFxgIHRvIGJlIGEgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgZX1cXGBgKTtpZih0eXBlb2YgciE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBcXGBjb3VudFxcYCB0byBiZSBhIFxcYG51bWJlclxcYCwgZ290IFxcYCR7dHlwZW9mIHJ9XFxgYCk7aWYodHlwZW9mIHQuaW5kZW50IT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYG9wdGlvbnMuaW5kZW50XFxgIHRvIGJlIGEgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgdC5pbmRlbnR9XFxgYCk7aWYocj09PTApcmV0dXJuIGU7bGV0IG49dC5pbmNsdWRlRW1wdHlMaW5lcz8vXi9nbTovXig/IVxccyokKS9nbTtyZXR1cm4gZS5yZXBsYWNlKG4sdC5pbmRlbnQucmVwZWF0KHIpKX19KTt2YXIgRXM9dGUoKFFoLGJzKT0+e1widXNlIHN0cmljdFwiO2JzLmV4cG9ydHM9KHtvbmx5Rmlyc3Q6ZT0hMX09e30pPT57bGV0IHI9W1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3ZvaWQgMDpcImdcIil9fSk7dmFyIFNpPXRlKChXaCx3cyk9PntcInVzZSBzdHJpY3RcIjt2YXIgR2M9RXMoKTt3cy5leHBvcnRzPWU9PnR5cGVvZiBlPT1cInN0cmluZ1wiP2UucmVwbGFjZShHYygpLFwiXCIpOmV9KTt2YXIgeHM9dGUoKHpoLFFjKT0+e1FjLmV4cG9ydHM9e25hbWU6XCJkb3RlbnZcIix2ZXJzaW9uOlwiMTYuNS4wXCIsZGVzY3JpcHRpb246XCJMb2FkcyBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSAuZW52IGZpbGVcIixtYWluOlwibGliL21haW4uanNcIix0eXBlczpcImxpYi9tYWluLmQudHNcIixleHBvcnRzOntcIi5cIjp7dHlwZXM6XCIuL2xpYi9tYWluLmQudHNcIixyZXF1aXJlOlwiLi9saWIvbWFpbi5qc1wiLGRlZmF1bHQ6XCIuL2xpYi9tYWluLmpzXCJ9LFwiLi9jb25maWdcIjpcIi4vY29uZmlnLmpzXCIsXCIuL2NvbmZpZy5qc1wiOlwiLi9jb25maWcuanNcIixcIi4vbGliL2Vudi1vcHRpb25zXCI6XCIuL2xpYi9lbnYtb3B0aW9ucy5qc1wiLFwiLi9saWIvZW52LW9wdGlvbnMuanNcIjpcIi4vbGliL2Vudi1vcHRpb25zLmpzXCIsXCIuL2xpYi9jbGktb3B0aW9uc1wiOlwiLi9saWIvY2xpLW9wdGlvbnMuanNcIixcIi4vbGliL2NsaS1vcHRpb25zLmpzXCI6XCIuL2xpYi9jbGktb3B0aW9ucy5qc1wiLFwiLi9wYWNrYWdlLmpzb25cIjpcIi4vcGFja2FnZS5qc29uXCJ9LHNjcmlwdHM6e1wiZHRzLWNoZWNrXCI6XCJ0c2MgLS1wcm9qZWN0IHRlc3RzL3R5cGVzL3RzY29uZmlnLmpzb25cIixsaW50Olwic3RhbmRhcmRcIixwcmV0ZXN0OlwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gZHRzLWNoZWNrXCIsdGVzdDpcInRhcCBydW4gLS1hbGxvdy1lbXB0eS1jb3ZlcmFnZSAtLWRpc2FibGUtY292ZXJhZ2UgLS10aW1lb3V0PTYwMDAwXCIsXCJ0ZXN0OmNvdmVyYWdlXCI6XCJ0YXAgcnVuIC0tc2hvdy1mdWxsLWNvdmVyYWdlIC0tdGltZW91dD02MDAwMCAtLWNvdmVyYWdlLXJlcG9ydD1sY292XCIscHJlcmVsZWFzZTpcIm5wbSB0ZXN0XCIscmVsZWFzZTpcInN0YW5kYXJkLXZlcnNpb25cIn0scmVwb3NpdG9yeTp7dHlwZTpcImdpdFwiLHVybDpcImdpdDovL2dpdGh1Yi5jb20vbW90ZG90bGEvZG90ZW52LmdpdFwifSxob21lcGFnZTpcImh0dHBzOi8vZ2l0aHViLmNvbS9tb3Rkb3RsYS9kb3RlbnYjcmVhZG1lXCIsZnVuZGluZzpcImh0dHBzOi8vZG90ZW52eC5jb21cIixrZXl3b3JkczpbXCJkb3RlbnZcIixcImVudlwiLFwiLmVudlwiLFwiZW52aXJvbm1lbnRcIixcInZhcmlhYmxlc1wiLFwiY29uZmlnXCIsXCJzZXR0aW5nc1wiXSxyZWFkbWVGaWxlbmFtZTpcIlJFQURNRS5tZFwiLGxpY2Vuc2U6XCJCU0QtMi1DbGF1c2VcIixkZXZEZXBlbmRlbmNpZXM6e1wiQHR5cGVzL25vZGVcIjpcIl4xOC4xMS4zXCIsZGVjYWNoZTpcIl40LjYuMlwiLHNpbm9uOlwiXjE0LjAuMVwiLHN0YW5kYXJkOlwiXjE3LjAuMFwiLFwic3RhbmRhcmQtdmVyc2lvblwiOlwiXjkuNS4wXCIsdGFwOlwiXjE5LjIuMFwiLHR5cGVzY3JpcHQ6XCJeNC44LjRcIn0sZW5naW5lczp7bm9kZTpcIj49MTJcIn0sYnJvd3Nlcjp7ZnM6ITF9fX0pO3ZhciBScz10ZSgoWmgsTmUpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIEFpPWZyKFwibm9kZTpmc1wiKSxDaT1mcihcIm5vZGU6cGF0aFwiKSxXYz1mcihcIm5vZGU6b3NcIiksSmM9ZnIoXCJub2RlOmNyeXB0b1wiKSxIYz14cygpLFBzPUhjLnZlcnNpb24sS2M9Lyg/Ol58XilcXHMqKD86ZXhwb3J0XFxzKyk/KFtcXHcuLV0rKSg/Olxccyo9XFxzKj98Olxccys/KShcXHMqJyg/OlxcXFwnfFteJ10pKid8XFxzKlwiKD86XFxcXFwifFteXCJdKSpcInxcXHMqYCg/OlxcXFxgfFteYF0pKmB8W14jXFxyXFxuXSspP1xccyooPzojLiopPyg/OiR8JCkvbWc7ZnVuY3Rpb24gWWMoZSl7bGV0IHI9e30sdD1lLnRvU3RyaW5nKCk7dD10LnJlcGxhY2UoL1xcclxcbj8vbWcsYFxuYCk7bGV0IG47Zm9yKDsobj1LYy5leGVjKHQpKSE9bnVsbDspe2xldCBpPW5bMV0sbz1uWzJdfHxcIlwiO289by50cmltKCk7bGV0IHM9b1swXTtvPW8ucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLFwiJDJcIikscz09PSdcIicmJihvPW8ucmVwbGFjZSgvXFxcXG4vZyxgXG5gKSxvPW8ucmVwbGFjZSgvXFxcXHIvZyxcIlxcclwiKSkscltpXT1vfXJldHVybiByfWZ1bmN0aW9uIHpjKGUpe2xldCByPVNzKGUpLHQ9Vi5jb25maWdEb3RlbnYoe3BhdGg6cn0pO2lmKCF0LnBhcnNlZCl7bGV0IHM9bmV3IEVycm9yKGBNSVNTSU5HX0RBVEE6IENhbm5vdCBwYXJzZSAke3J9IGZvciBhbiB1bmtub3duIHJlYXNvbmApO3Rocm93IHMuY29kZT1cIk1JU1NJTkdfREFUQVwiLHN9bGV0IG49VHMoZSkuc3BsaXQoXCIsXCIpLGk9bi5sZW5ndGgsbztmb3IobGV0IHM9MDtzPGk7cysrKXRyeXtsZXQgYT1uW3NdLnRyaW0oKSxsPVhjKHQsYSk7bz1WLmRlY3J5cHQobC5jaXBoZXJ0ZXh0LGwua2V5KTticmVha31jYXRjaChhKXtpZihzKzE+PWkpdGhyb3cgYX1yZXR1cm4gVi5wYXJzZShvKX1mdW5jdGlvbiBaYyhlKXtjb25zb2xlLmxvZyhgW2RvdGVudkAke1BzfV1bV0FSTl0gJHtlfWApfWZ1bmN0aW9uIHR0KGUpe2NvbnNvbGUubG9nKGBbZG90ZW52QCR7UHN9XVtERUJVR10gJHtlfWApfWZ1bmN0aW9uIFRzKGUpe3JldHVybiBlJiZlLkRPVEVOVl9LRVkmJmUuRE9URU5WX0tFWS5sZW5ndGg+MD9lLkRPVEVOVl9LRVk6cHJvY2Vzcy5lbnYuRE9URU5WX0tFWSYmcHJvY2Vzcy5lbnYuRE9URU5WX0tFWS5sZW5ndGg+MD9wcm9jZXNzLmVudi5ET1RFTlZfS0VZOlwiXCJ9ZnVuY3Rpb24gWGMoZSxyKXtsZXQgdDt0cnl7dD1uZXcgVVJMKHIpfWNhdGNoKGEpe2lmKGEuY29kZT09PVwiRVJSX0lOVkFMSURfVVJMXCIpe2xldCBsPW5ldyBFcnJvcihcIklOVkFMSURfRE9URU5WX0tFWTogV3JvbmcgZm9ybWF0LiBNdXN0IGJlIGluIHZhbGlkIHVyaSBmb3JtYXQgbGlrZSBkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1kZXZlbG9wbWVudFwiKTt0aHJvdyBsLmNvZGU9XCJJTlZBTElEX0RPVEVOVl9LRVlcIixsfXRocm93IGF9bGV0IG49dC5wYXNzd29yZDtpZighbil7bGV0IGE9bmV3IEVycm9yKFwiSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGtleSBwYXJ0XCIpO3Rocm93IGEuY29kZT1cIklOVkFMSURfRE9URU5WX0tFWVwiLGF9bGV0IGk9dC5zZWFyY2hQYXJhbXMuZ2V0KFwiZW52aXJvbm1lbnRcIik7aWYoIWkpe2xldCBhPW5ldyBFcnJvcihcIklOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBlbnZpcm9ubWVudCBwYXJ0XCIpO3Rocm93IGEuY29kZT1cIklOVkFMSURfRE9URU5WX0tFWVwiLGF9bGV0IG89YERPVEVOVl9WQVVMVF8ke2kudG9VcHBlckNhc2UoKX1gLHM9ZS5wYXJzZWRbb107aWYoIXMpe2xldCBhPW5ldyBFcnJvcihgTk9UX0ZPVU5EX0RPVEVOVl9FTlZJUk9OTUVOVDogQ2Fubm90IGxvY2F0ZSBlbnZpcm9ubWVudCAke299IGluIHlvdXIgLmVudi52YXVsdCBmaWxlLmApO3Rocm93IGEuY29kZT1cIk5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlRcIixhfXJldHVybntjaXBoZXJ0ZXh0OnMsa2V5Om59fWZ1bmN0aW9uIFNzKGUpe2xldCByPW51bGw7aWYoZSYmZS5wYXRoJiZlLnBhdGgubGVuZ3RoPjApaWYoQXJyYXkuaXNBcnJheShlLnBhdGgpKWZvcihsZXQgdCBvZiBlLnBhdGgpQWkuZXhpc3RzU3luYyh0KSYmKHI9dC5lbmRzV2l0aChcIi52YXVsdFwiKT90OmAke3R9LnZhdWx0YCk7ZWxzZSByPWUucGF0aC5lbmRzV2l0aChcIi52YXVsdFwiKT9lLnBhdGg6YCR7ZS5wYXRofS52YXVsdGA7ZWxzZSByPUNpLnJlc29sdmUocHJvY2Vzcy5jd2QoKSxcIi5lbnYudmF1bHRcIik7cmV0dXJuIEFpLmV4aXN0c1N5bmMocik/cjpudWxsfWZ1bmN0aW9uIHZzKGUpe3JldHVybiBlWzBdPT09XCJ+XCI/Q2kuam9pbihXYy5ob21lZGlyKCksZS5zbGljZSgxKSk6ZX1mdW5jdGlvbiBlcChlKXshIShlJiZlLmRlYnVnKSYmdHQoXCJMb2FkaW5nIGVudiBmcm9tIGVuY3J5cHRlZCAuZW52LnZhdWx0XCIpO2xldCB0PVYuX3BhcnNlVmF1bHQoZSksbj1wcm9jZXNzLmVudjtyZXR1cm4gZSYmZS5wcm9jZXNzRW52IT1udWxsJiYobj1lLnByb2Nlc3NFbnYpLFYucG9wdWxhdGUobix0LGUpLHtwYXJzZWQ6dH19ZnVuY3Rpb24gcnAoZSl7bGV0IHI9Q2kucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLFwiLmVudlwiKSx0PVwidXRmOFwiLG49ISEoZSYmZS5kZWJ1Zyk7ZSYmZS5lbmNvZGluZz90PWUuZW5jb2Rpbmc6biYmdHQoXCJObyBlbmNvZGluZyBpcyBzcGVjaWZpZWQuIFVURi04IGlzIHVzZWQgYnkgZGVmYXVsdFwiKTtsZXQgaT1bcl07aWYoZSYmZS5wYXRoKWlmKCFBcnJheS5pc0FycmF5KGUucGF0aCkpaT1bdnMoZS5wYXRoKV07ZWxzZXtpPVtdO2ZvcihsZXQgbCBvZiBlLnBhdGgpaS5wdXNoKHZzKGwpKX1sZXQgbyxzPXt9O2ZvcihsZXQgbCBvZiBpKXRyeXtsZXQgdT1WLnBhcnNlKEFpLnJlYWRGaWxlU3luYyhsLHtlbmNvZGluZzp0fSkpO1YucG9wdWxhdGUocyx1LGUpfWNhdGNoKHUpe24mJnR0KGBGYWlsZWQgdG8gbG9hZCAke2x9ICR7dS5tZXNzYWdlfWApLG89dX1sZXQgYT1wcm9jZXNzLmVudjtyZXR1cm4gZSYmZS5wcm9jZXNzRW52IT1udWxsJiYoYT1lLnByb2Nlc3NFbnYpLFYucG9wdWxhdGUoYSxzLGUpLG8/e3BhcnNlZDpzLGVycm9yOm99OntwYXJzZWQ6c319ZnVuY3Rpb24gdHAoZSl7aWYoVHMoZSkubGVuZ3RoPT09MClyZXR1cm4gVi5jb25maWdEb3RlbnYoZSk7bGV0IHI9U3MoZSk7cmV0dXJuIHI/Vi5fY29uZmlnVmF1bHQoZSk6KFpjKGBZb3Ugc2V0IERPVEVOVl9LRVkgYnV0IHlvdSBhcmUgbWlzc2luZyBhIC5lbnYudmF1bHQgZmlsZSBhdCAke3J9LiBEaWQgeW91IGZvcmdldCB0byBidWlsZCBpdD9gKSxWLmNvbmZpZ0RvdGVudihlKSl9ZnVuY3Rpb24gbnAoZSxyKXtsZXQgdD1CdWZmZXIuZnJvbShyLnNsaWNlKC02NCksXCJoZXhcIiksbj1CdWZmZXIuZnJvbShlLFwiYmFzZTY0XCIpLGk9bi5zdWJhcnJheSgwLDEyKSxvPW4uc3ViYXJyYXkoLTE2KTtuPW4uc3ViYXJyYXkoMTIsLTE2KTt0cnl7bGV0IHM9SmMuY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtZ2NtXCIsdCxpKTtyZXR1cm4gcy5zZXRBdXRoVGFnKG8pLGAke3MudXBkYXRlKG4pfSR7cy5maW5hbCgpfWB9Y2F0Y2gocyl7bGV0IGE9cyBpbnN0YW5jZW9mIFJhbmdlRXJyb3IsbD1zLm1lc3NhZ2U9PT1cIkludmFsaWQga2V5IGxlbmd0aFwiLHU9cy5tZXNzYWdlPT09XCJVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGFcIjtpZihhfHxsKXtsZXQgYz1uZXcgRXJyb3IoXCJJTlZBTElEX0RPVEVOVl9LRVk6IEl0IG11c3QgYmUgNjQgY2hhcmFjdGVycyBsb25nIChvciBtb3JlKVwiKTt0aHJvdyBjLmNvZGU9XCJJTlZBTElEX0RPVEVOVl9LRVlcIixjfWVsc2UgaWYodSl7bGV0IGM9bmV3IEVycm9yKFwiREVDUllQVElPTl9GQUlMRUQ6IFBsZWFzZSBjaGVjayB5b3VyIERPVEVOVl9LRVlcIik7dGhyb3cgYy5jb2RlPVwiREVDUllQVElPTl9GQUlMRURcIixjfWVsc2UgdGhyb3cgc319ZnVuY3Rpb24gaXAoZSxyLHQ9e30pe2xldCBuPSEhKHQmJnQuZGVidWcpLGk9ISEodCYmdC5vdmVycmlkZSk7aWYodHlwZW9mIHIhPVwib2JqZWN0XCIpe2xldCBvPW5ldyBFcnJvcihcIk9CSkVDVF9SRVFVSVJFRDogUGxlYXNlIGNoZWNrIHRoZSBwcm9jZXNzRW52IGFyZ3VtZW50IGJlaW5nIHBhc3NlZCB0byBwb3B1bGF0ZVwiKTt0aHJvdyBvLmNvZGU9XCJPQkpFQ1RfUkVRVUlSRURcIixvfWZvcihsZXQgbyBvZiBPYmplY3Qua2V5cyhyKSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKT8oaT09PSEwJiYoZVtvXT1yW29dKSxuJiZ0dChpPT09ITA/YFwiJHtvfVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhbmQgV0FTIG92ZXJ3cml0dGVuYDpgXCIke299XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCB3YXMgTk9UIG92ZXJ3cml0dGVuYCkpOmVbb109cltvXX12YXIgVj17Y29uZmlnRG90ZW52OnJwLF9jb25maWdWYXVsdDplcCxfcGFyc2VWYXVsdDp6Yyxjb25maWc6dHAsZGVjcnlwdDpucCxwYXJzZTpZYyxwb3B1bGF0ZTppcH07TmUuZXhwb3J0cy5jb25maWdEb3RlbnY9Vi5jb25maWdEb3RlbnY7TmUuZXhwb3J0cy5fY29uZmlnVmF1bHQ9Vi5fY29uZmlnVmF1bHQ7TmUuZXhwb3J0cy5fcGFyc2VWYXVsdD1WLl9wYXJzZVZhdWx0O05lLmV4cG9ydHMuY29uZmlnPVYuY29uZmlnO05lLmV4cG9ydHMuZGVjcnlwdD1WLmRlY3J5cHQ7TmUuZXhwb3J0cy5wYXJzZT1WLnBhcnNlO05lLmV4cG9ydHMucG9wdWxhdGU9Vi5wb3B1bGF0ZTtOZS5leHBvcnRzPVZ9KTt2YXIga3M9dGUoKHN5LG5uKT0+e1widXNlIHN0cmljdFwiO25uLmV4cG9ydHM9KGU9e30pPT57bGV0IHI7aWYoZS5yZXBvVXJsKXI9ZS5yZXBvVXJsO2Vsc2UgaWYoZS51c2VyJiZlLnJlcG8pcj1gaHR0cHM6Ly9naXRodWIuY29tLyR7ZS51c2VyfS8ke2UucmVwb31gO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiWW91IG5lZWQgdG8gc3BlY2lmeSBlaXRoZXIgdGhlIGByZXBvVXJsYCBvcHRpb24gb3IgYm90aCB0aGUgYHVzZXJgIGFuZCBgcmVwb2Agb3B0aW9uc1wiKTtsZXQgdD1uZXcgVVJMKGAke3J9L2lzc3Vlcy9uZXdgKSxuPVtcImJvZHlcIixcInRpdGxlXCIsXCJsYWJlbHNcIixcInRlbXBsYXRlXCIsXCJtaWxlc3RvbmVcIixcImFzc2lnbmVlXCIsXCJwcm9qZWN0c1wiXTtmb3IobGV0IGkgb2Ygbil7bGV0IG89ZVtpXTtpZihvIT09dm9pZCAwKXtpZihpPT09XCJsYWJlbHNcInx8aT09PVwicHJvamVjdHNcIil7aWYoIUFycmF5LmlzQXJyYXkobykpdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFxcYCR7aX1cXGAgb3B0aW9uIHNob3VsZCBiZSBhbiBhcnJheWApO289by5qb2luKFwiLFwiKX10LnNlYXJjaFBhcmFtcy5zZXQoaSxvKX19cmV0dXJuIHQudG9TdHJpbmcoKX07bm4uZXhwb3J0cy5kZWZhdWx0PW5uLmV4cG9ydHN9KTt2YXIgamk9dGUoKCRiLHpzKT0+e1widXNlIHN0cmljdFwiO3pzLmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHIsdCxuLGksbyl7cmV0dXJuIHI8dHx8bjx0P3I+bj9uKzE6cisxOmk9PT1vP3Q6dCsxfXJldHVybiBmdW5jdGlvbihyLHQpe2lmKHI9PT10KXJldHVybiAwO2lmKHIubGVuZ3RoPnQubGVuZ3RoKXt2YXIgbj1yO3I9dCx0PW59Zm9yKHZhciBpPXIubGVuZ3RoLG89dC5sZW5ndGg7aT4wJiZyLmNoYXJDb2RlQXQoaS0xKT09PXQuY2hhckNvZGVBdChvLTEpOylpLS0sby0tO2Zvcih2YXIgcz0wO3M8aSYmci5jaGFyQ29kZUF0KHMpPT09dC5jaGFyQ29kZUF0KHMpOylzKys7aWYoaS09cyxvLT1zLGk9PT0wfHxvPDMpcmV0dXJuIG87dmFyIGE9MCxsLHUsYyxwLGQsZixoLGcsUyxQLFIsYixrPVtdO2ZvcihsPTA7bDxpO2wrKylrLnB1c2gobCsxKSxrLnB1c2goci5jaGFyQ29kZUF0KHMrbCkpO2Zvcih2YXIgbWU9ay5sZW5ndGgtMTthPG8tMzspZm9yKFM9dC5jaGFyQ29kZUF0KHMrKHU9YSkpLFA9dC5jaGFyQ29kZUF0KHMrKGM9YSsxKSksUj10LmNoYXJDb2RlQXQocysocD1hKzIpKSxiPXQuY2hhckNvZGVBdChzKyhkPWErMykpLGY9YSs9NCxsPTA7bDxtZTtsKz0yKWg9a1tsXSxnPWtbbCsxXSx1PWUoaCx1LGMsUyxnKSxjPWUodSxjLHAsUCxnKSxwPWUoYyxwLGQsUixnKSxmPWUocCxkLGYsYixnKSxrW2xdPWYsZD1wLHA9YyxjPXUsdT1oO2Zvcig7YTxvOylmb3IoUz10LmNoYXJDb2RlQXQocysodT1hKSksZj0rK2EsbD0wO2w8bWU7bCs9MiloPWtbbF0sa1tsXT1mPWUoaCx1LGYsUyxrW2wrMV0pLHU9aDtyZXR1cm4gZn19KCl9KTt2YXIgdGE9Um8oKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBuYT1SbygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIElvPXt9O2dyKElvLHtkZWZpbmVFeHRlbnNpb246KCk9PkFvLGdldEV4dGVuc2lvbkNvbnRleHQ6KCk9PkNvfSk7ZnVuY3Rpb24gQW8oZSl7cmV0dXJuIHR5cGVvZiBlPT1cImZ1bmN0aW9uXCI/ZTpyPT5yLiRleHRlbmRzKGUpfWZ1bmN0aW9uIENvKGUpe3JldHVybiBlfXZhciBEbz17fTtncihEbyx7dmFsaWRhdG9yOigpPT5rb30pO2Z1bmN0aW9uIGtvKC4uLmUpe3JldHVybiByPT5yfXZhciAkdD17fTtncigkdCx7JDooKT0+Rm8sYmdCbGFjazooKT0+YnUsYmdCbHVlOigpPT52dSxiZ0N5YW46KCk9PlR1LGJnR3JlZW46KCk9Pnd1LGJnTWFnZW50YTooKT0+UHUsYmdSZWQ6KCk9PkV1LGJnV2hpdGU6KCk9PlN1LGJnWWVsbG93OigpPT54dSxibGFjazooKT0+ZnUsYmx1ZTooKT0+dHIsYm9sZDooKT0+USxjeWFuOigpPT5rZSxkaW06KCk9PkNlLGdyYXk6KCk9PkpyLGdyZWVuOigpPT5xZSxncmV5OigpPT55dSxoaWRkZW46KCk9PmR1LGludmVyc2U6KCk9PnB1LGl0YWxpYzooKT0+Y3UsbWFnZW50YTooKT0+Z3UscmVkOigpPT51ZSxyZXNldDooKT0+dXUsc3RyaWtldGhyb3VnaDooKT0+bXUsdW5kZXJsaW5lOigpPT5LLHdoaXRlOigpPT5odSx5ZWxsb3c6KCk9PkllfSk7dmFyIFluLE9vLF9vLE5vLExvPSEwO3R5cGVvZiBwcm9jZXNzPFwidVwiJiYoe0ZPUkNFX0NPTE9SOlluLE5PREVfRElTQUJMRV9DT0xPUlM6T28sTk9fQ09MT1I6X28sVEVSTTpOb309cHJvY2Vzcy5lbnZ8fHt9LExvPXByb2Nlc3Muc3Rkb3V0JiZwcm9jZXNzLnN0ZG91dC5pc1RUWSk7dmFyIEZvPXtlbmFibGVkOiFPbyYmX289PW51bGwmJk5vIT09XCJkdW1iXCImJihZbiE9bnVsbCYmWW4hPT1cIjBcInx8TG8pfTtmdW5jdGlvbiBOKGUscil7bGV0IHQ9bmV3IFJlZ0V4cChgXFxcXHgxYlxcXFxbJHtyfW1gLFwiZ1wiKSxuPWBcXHgxQlske2V9bWAsaT1gXFx4MUJbJHtyfW1gO3JldHVybiBmdW5jdGlvbihvKXtyZXR1cm4hRm8uZW5hYmxlZHx8bz09bnVsbD9vOm4rKH4oXCJcIitvKS5pbmRleE9mKGkpP28ucmVwbGFjZSh0LGkrbik6bykraX19dmFyIHV1PU4oMCwwKSxRPU4oMSwyMiksQ2U9TigyLDIyKSxjdT1OKDMsMjMpLEs9Tig0LDI0KSxwdT1OKDcsMjcpLGR1PU4oOCwyOCksbXU9Tig5LDI5KSxmdT1OKDMwLDM5KSx1ZT1OKDMxLDM5KSxxZT1OKDMyLDM5KSxJZT1OKDMzLDM5KSx0cj1OKDM0LDM5KSxndT1OKDM1LDM5KSxrZT1OKDM2LDM5KSxodT1OKDM3LDM5KSxKcj1OKDkwLDM5KSx5dT1OKDkwLDM5KSxidT1OKDQwLDQ5KSxFdT1OKDQxLDQ5KSx3dT1OKDQyLDQ5KSx4dT1OKDQzLDQ5KSx2dT1OKDQ0LDQ5KSxQdT1OKDQ1LDQ5KSxUdT1OKDQ2LDQ5KSxTdT1OKDQ3LDQ5KTt2YXIgUnU9MTAwLE1vPVtcImdyZWVuXCIsXCJ5ZWxsb3dcIixcImJsdWVcIixcIm1hZ2VudGFcIixcImN5YW5cIixcInJlZFwiXSxIcj1bXSwkbz1EYXRlLm5vdygpLEF1PTAsem49dHlwZW9mIHByb2Nlc3M8XCJ1XCI/cHJvY2Vzcy5lbnY6e307Z2xvYmFsVGhpcy5ERUJVRz8/PXpuLkRFQlVHPz9cIlwiO2dsb2JhbFRoaXMuREVCVUdfQ09MT1JTPz89em4uREVCVUdfQ09MT1JTP3puLkRFQlVHX0NPTE9SUz09PVwidHJ1ZVwiOiEwO3ZhciBLcj17ZW5hYmxlKGUpe3R5cGVvZiBlPT1cInN0cmluZ1wiJiYoZ2xvYmFsVGhpcy5ERUJVRz1lKX0sZGlzYWJsZSgpe2xldCBlPWdsb2JhbFRoaXMuREVCVUc7cmV0dXJuIGdsb2JhbFRoaXMuREVCVUc9XCJcIixlfSxlbmFibGVkKGUpe2xldCByPWdsb2JhbFRoaXMuREVCVUcuc3BsaXQoXCIsXCIpLm1hcChpPT5pLnJlcGxhY2UoL1suKz9eJHt9KCl8W1xcXVxcXFxdL2csXCJcXFxcJCZcIikpLHQ9ci5zb21lKGk9Pmk9PT1cIlwifHxpWzBdPT09XCItXCI/ITE6ZS5tYXRjaChSZWdFeHAoaS5zcGxpdChcIipcIikuam9pbihcIi4qXCIpK1wiJFwiKSkpLG49ci5zb21lKGk9Pmk9PT1cIlwifHxpWzBdIT09XCItXCI/ITE6ZS5tYXRjaChSZWdFeHAoaS5zbGljZSgxKS5zcGxpdChcIipcIikuam9pbihcIi4qXCIpK1wiJFwiKSkpO3JldHVybiB0JiYhbn0sbG9nOiguLi5lKT0+e2xldFtyLHQsLi4ubl09ZTsoY29uc29sZS53YXJuPz9jb25zb2xlLmxvZykoYCR7cn0gJHt0fWAsLi4ubil9LGZvcm1hdHRlcnM6e319O2Z1bmN0aW9uIEN1KGUpe2xldCByPXtjb2xvcjpNb1tBdSsrJU1vLmxlbmd0aF0sZW5hYmxlZDpLci5lbmFibGVkKGUpLG5hbWVzcGFjZTplLGxvZzpLci5sb2csZXh0ZW5kOigpPT57fX0sdD0oLi4ubik9PntsZXR7ZW5hYmxlZDppLG5hbWVzcGFjZTpvLGNvbG9yOnMsbG9nOmF9PXI7aWYobi5sZW5ndGghPT0wJiZIci5wdXNoKFtvLC4uLm5dKSxIci5sZW5ndGg+UnUmJkhyLnNoaWZ0KCksS3IuZW5hYmxlZChvKXx8aSl7bGV0IGw9bi5tYXAoYz0+dHlwZW9mIGM9PVwic3RyaW5nXCI/YzpJdShjKSksdT1gKyR7RGF0ZS5ub3coKS0kb31tc2A7JG89RGF0ZS5ub3coKSxnbG9iYWxUaGlzLkRFQlVHX0NPTE9SUz9hKCR0W3NdKFEobykpLC4uLmwsJHRbc10odSkpOmEobywuLi5sLHUpfX07cmV0dXJuIG5ldyBQcm94eSh0LHtnZXQ6KG4saSk9PnJbaV0sc2V0OihuLGksbyk9PnJbaV09b30pfXZhciBMPW5ldyBQcm94eShDdSx7Z2V0OihlLHIpPT5LcltyXSxzZXQ6KGUscix0KT0+S3Jbcl09dH0pO2Z1bmN0aW9uIEl1KGUscj0yKXtsZXQgdD1uZXcgU2V0O3JldHVybiBKU09OLnN0cmluZ2lmeShlLChuLGkpPT57aWYodHlwZW9mIGk9PVwib2JqZWN0XCImJmkhPT1udWxsKXtpZih0LmhhcyhpKSlyZXR1cm5cIltDaXJjdWxhciAqXVwiO3QuYWRkKGkpfWVsc2UgaWYodHlwZW9mIGk9PVwiYmlnaW50XCIpcmV0dXJuIGkudG9TdHJpbmcoKTtyZXR1cm4gaX0scil9ZnVuY3Rpb24gcW8oZT03NTAwKXtsZXQgcj1Ici5tYXAoKFt0LC4uLm5dKT0+YCR7dH0gJHtuLm1hcChpPT50eXBlb2YgaT09XCJzdHJpbmdcIj9pOkpTT04uc3RyaW5naWZ5KGkpKS5qb2luKFwiIFwiKX1gKS5qb2luKGBcbmApO3JldHVybiByLmxlbmd0aDxlP3I6ci5zbGljZSgtZSl9ZnVuY3Rpb24gam8oKXtIci5sZW5ndGg9MH12YXIgaHI9TDtpbXBvcnQga3UgZnJvbVwibm9kZTpmc1wiO2Z1bmN0aW9uIFpuKCl7bGV0IGU9cHJvY2Vzcy5lbnYuUFJJU01BX1FVRVJZX0VOR0lORV9MSUJSQVJZO2lmKCEoZSYma3UuZXhpc3RzU3luYyhlKSkmJnByb2Nlc3MuYXJjaD09PVwiaWEzMlwiKXRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgcXVlcnkgZW5naW5lIHR5cGUgKE5vZGUtQVBJLCBcImxpYnJhcnlcIikgaXMgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgZm9yIDMyYml0IE5vZGUuIFBsZWFzZSBzZXQgYGVuZ2luZVR5cGUgPSBcImJpbmFyeVwiYCBpbiB0aGUgXCJnZW5lcmF0b3JcIiBibG9jayBvZiB5b3VyIFwic2NoZW1hLnByaXNtYVwiIGZpbGUgKG9yIHVzZSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIFwiUFJJU01BX0NMSUVOVF9FTkdJTkVfVFlQRT1iaW5hcnlcIiBhbmQvb3IgXCJQUklTTUFfQ0xJX1FVRVJZX0VOR0lORV9UWVBFPWJpbmFyeVwiLiknKX12YXIgWG49W1wiZGFyd2luXCIsXCJkYXJ3aW4tYXJtNjRcIixcImRlYmlhbi1vcGVuc3NsLTEuMC54XCIsXCJkZWJpYW4tb3BlbnNzbC0xLjEueFwiLFwiZGViaWFuLW9wZW5zc2wtMy4wLnhcIixcInJoZWwtb3BlbnNzbC0xLjAueFwiLFwicmhlbC1vcGVuc3NsLTEuMS54XCIsXCJyaGVsLW9wZW5zc2wtMy4wLnhcIixcImxpbnV4LWFybTY0LW9wZW5zc2wtMS4xLnhcIixcImxpbnV4LWFybTY0LW9wZW5zc2wtMS4wLnhcIixcImxpbnV4LWFybTY0LW9wZW5zc2wtMy4wLnhcIixcImxpbnV4LWFybS1vcGVuc3NsLTEuMS54XCIsXCJsaW51eC1hcm0tb3BlbnNzbC0xLjAueFwiLFwibGludXgtYXJtLW9wZW5zc2wtMy4wLnhcIixcImxpbnV4LW11c2xcIixcImxpbnV4LW11c2wtb3BlbnNzbC0zLjAueFwiLFwibGludXgtbXVzbC1hcm02NC1vcGVuc3NsLTEuMS54XCIsXCJsaW51eC1tdXNsLWFybTY0LW9wZW5zc2wtMy4wLnhcIixcImxpbnV4LW5peG9zXCIsXCJsaW51eC1zdGF0aWMteDY0XCIsXCJsaW51eC1zdGF0aWMtYXJtNjRcIixcIndpbmRvd3NcIixcImZyZWVic2QxMVwiLFwiZnJlZWJzZDEyXCIsXCJmcmVlYnNkMTNcIixcImZyZWVic2QxNFwiLFwiZnJlZWJzZDE1XCIsXCJvcGVuYnNkXCIsXCJuZXRic2RcIixcImFybVwiXTt2YXIgcXQ9XCJsaWJxdWVyeV9lbmdpbmVcIjtmdW5jdGlvbiBqdChlLHIpe2xldCB0PXI9PT1cInVybFwiO3JldHVybiBlLmluY2x1ZGVzKFwid2luZG93c1wiKT90P1wicXVlcnlfZW5naW5lLmRsbC5ub2RlXCI6YHF1ZXJ5X2VuZ2luZS0ke2V9LmRsbC5ub2RlYDplLmluY2x1ZGVzKFwiZGFyd2luXCIpP3Q/YCR7cXR9LmR5bGliLm5vZGVgOmAke3F0fS0ke2V9LmR5bGliLm5vZGVgOnQ/YCR7cXR9LnNvLm5vZGVgOmAke3F0fS0ke2V9LnNvLm5vZGVgfWltcG9ydCBGdSBmcm9tXCJub2RlOmNoaWxkX3Byb2Nlc3NcIjtpbXBvcnQgR28gZnJvbVwibm9kZTpmcy9wcm9taXNlc1wiO2ltcG9ydCBpaSBmcm9tXCJub2RlOm9zXCI7dmFyIERlPVN5bWJvbC5mb3IoXCJAdHMtcGF0dGVybi9tYXRjaGVyXCIpLER1PVN5bWJvbC5mb3IoXCJAdHMtcGF0dGVybi9pc1ZhcmlhZGljXCIpLEJ0PVwiQHRzLXBhdHRlcm4vYW5vbnltb3VzLXNlbGVjdC1rZXlcIixlaT1lPT4hIShlJiZ0eXBlb2YgZT09XCJvYmplY3RcIiksVnQ9ZT0+ZSYmISFlW0RlXSxFZT0oZSxyLHQpPT57aWYoVnQoZSkpe2xldCBuPWVbRGVdKCkse21hdGNoZWQ6aSxzZWxlY3Rpb25zOm99PW4ubWF0Y2gocik7cmV0dXJuIGkmJm8mJk9iamVjdC5rZXlzKG8pLmZvckVhY2gocz0+dChzLG9bc10pKSxpfWlmKGVpKGUpKXtpZighZWkocikpcmV0dXJuITE7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIUFycmF5LmlzQXJyYXkocikpcmV0dXJuITE7bGV0IG49W10saT1bXSxvPVtdO2ZvcihsZXQgcyBvZiBlLmtleXMoKSl7bGV0IGE9ZVtzXTtWdChhKSYmYVtEdV0/by5wdXNoKGEpOm8ubGVuZ3RoP2kucHVzaChhKTpuLnB1c2goYSl9aWYoby5sZW5ndGgpe2lmKG8ubGVuZ3RoPjEpdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBlcnJvcjogVXNpbmcgYC4uLlAuYXJyYXkoLi4uKWAgc2V2ZXJhbCB0aW1lcyBpbiBhIHNpbmdsZSBwYXR0ZXJuIGlzIG5vdCBhbGxvd2VkLlwiKTtpZihyLmxlbmd0aDxuLmxlbmd0aCtpLmxlbmd0aClyZXR1cm4hMTtsZXQgcz1yLnNsaWNlKDAsbi5sZW5ndGgpLGE9aS5sZW5ndGg9PT0wP1tdOnIuc2xpY2UoLWkubGVuZ3RoKSxsPXIuc2xpY2Uobi5sZW5ndGgsaS5sZW5ndGg9PT0wPzEvMDotaS5sZW5ndGgpO3JldHVybiBuLmV2ZXJ5KCh1LGMpPT5FZSh1LHNbY10sdCkpJiZpLmV2ZXJ5KCh1LGMpPT5FZSh1LGFbY10sdCkpJiYoby5sZW5ndGg9PT0wfHxFZShvWzBdLGwsdCkpfXJldHVybiBlLmxlbmd0aD09PXIubGVuZ3RoJiZlLmV2ZXJ5KChzLGEpPT5FZShzLHJbYV0sdCkpfXJldHVybiBSZWZsZWN0Lm93bktleXMoZSkuZXZlcnkobj0+e2xldCBpPWVbbl07cmV0dXJuKG4gaW4gcnx8VnQobz1pKSYmb1tEZV0oKS5tYXRjaGVyVHlwZT09PVwib3B0aW9uYWxcIikmJkVlKGkscltuXSx0KTt2YXIgb30pfXJldHVybiBPYmplY3QuaXMocixlKX0sR2U9ZT0+e3ZhciByLHQsbjtyZXR1cm4gZWkoZSk/VnQoZSk/KHI9KHQ9KG49ZVtEZV0oKSkuZ2V0U2VsZWN0aW9uS2V5cyk9PW51bGw/dm9pZCAwOnQuY2FsbChuKSkhPW51bGw/cjpbXTpBcnJheS5pc0FycmF5KGUpP1lyKGUsR2UpOllyKE9iamVjdC52YWx1ZXMoZSksR2UpOltdfSxZcj0oZSxyKT0+ZS5yZWR1Y2UoKHQsbik9PnQuY29uY2F0KHIobikpLFtdKTtmdW5jdGlvbiBjZShlKXtyZXR1cm4gT2JqZWN0LmFzc2lnbihlLHtvcHRpb25hbDooKT0+T3UoZSksYW5kOnI9PiQoZSxyKSxvcjpyPT5fdShlLHIpLHNlbGVjdDpyPT5yPT09dm9pZCAwP1ZvKGUpOlZvKHIsZSl9KX1mdW5jdGlvbiBPdShlKXtyZXR1cm4gY2Uoe1tEZV06KCk9Pih7bWF0Y2g6cj0+e2xldCB0PXt9LG49KGksbyk9Pnt0W2ldPW99O3JldHVybiByPT09dm9pZCAwPyhHZShlKS5mb3JFYWNoKGk9Pm4oaSx2b2lkIDApKSx7bWF0Y2hlZDohMCxzZWxlY3Rpb25zOnR9KTp7bWF0Y2hlZDpFZShlLHIsbiksc2VsZWN0aW9uczp0fX0sZ2V0U2VsZWN0aW9uS2V5czooKT0+R2UoZSksbWF0Y2hlclR5cGU6XCJvcHRpb25hbFwifSl9KX1mdW5jdGlvbiAkKC4uLmUpe3JldHVybiBjZSh7W0RlXTooKT0+KHttYXRjaDpyPT57bGV0IHQ9e30sbj0oaSxvKT0+e3RbaV09b307cmV0dXJue21hdGNoZWQ6ZS5ldmVyeShpPT5FZShpLHIsbikpLHNlbGVjdGlvbnM6dH19LGdldFNlbGVjdGlvbktleXM6KCk9PllyKGUsR2UpLG1hdGNoZXJUeXBlOlwiYW5kXCJ9KX0pfWZ1bmN0aW9uIF91KC4uLmUpe3JldHVybiBjZSh7W0RlXTooKT0+KHttYXRjaDpyPT57bGV0IHQ9e30sbj0oaSxvKT0+e3RbaV09b307cmV0dXJuIFlyKGUsR2UpLmZvckVhY2goaT0+bihpLHZvaWQgMCkpLHttYXRjaGVkOmUuc29tZShpPT5FZShpLHIsbikpLHNlbGVjdGlvbnM6dH19LGdldFNlbGVjdGlvbktleXM6KCk9PllyKGUsR2UpLG1hdGNoZXJUeXBlOlwib3JcIn0pfSl9ZnVuY3Rpb24gQyhlKXtyZXR1cm57W0RlXTooKT0+KHttYXRjaDpyPT4oe21hdGNoZWQ6ISFlKHIpfSl9KX19ZnVuY3Rpb24gVm8oLi4uZSl7bGV0IHI9dHlwZW9mIGVbMF09PVwic3RyaW5nXCI/ZVswXTp2b2lkIDAsdD1lLmxlbmd0aD09PTI/ZVsxXTp0eXBlb2YgZVswXT09XCJzdHJpbmdcIj92b2lkIDA6ZVswXTtyZXR1cm4gY2Uoe1tEZV06KCk9Pih7bWF0Y2g6bj0+e2xldCBpPXtbcj8/QnRdOm59O3JldHVybnttYXRjaGVkOnQ9PT12b2lkIDB8fEVlKHQsbiwobyxzKT0+e2lbb109c30pLHNlbGVjdGlvbnM6aX19LGdldFNlbGVjdGlvbktleXM6KCk9PltyPz9CdF0uY29uY2F0KHQ9PT12b2lkIDA/W106R2UodCkpfSl9KX1mdW5jdGlvbiB5ZShlKXtyZXR1cm4gdHlwZW9mIGU9PVwibnVtYmVyXCJ9ZnVuY3Rpb24gamUoZSl7cmV0dXJuIHR5cGVvZiBlPT1cInN0cmluZ1wifWZ1bmN0aW9uIFZlKGUpe3JldHVybiB0eXBlb2YgZT09XCJiaWdpbnRcIn12YXIgbmc9Y2UoQyhmdW5jdGlvbihlKXtyZXR1cm4hMH0pKTt2YXIgQmU9ZT0+T2JqZWN0LmFzc2lnbihjZShlKSx7c3RhcnRzV2l0aDpyPT57cmV0dXJuIEJlKCQoZSwodD1yLEMobj0+amUobikmJm4uc3RhcnRzV2l0aCh0KSkpKSk7dmFyIHR9LGVuZHNXaXRoOnI9PntyZXR1cm4gQmUoJChlLCh0PXIsQyhuPT5qZShuKSYmbi5lbmRzV2l0aCh0KSkpKSk7dmFyIHR9LG1pbkxlbmd0aDpyPT5CZSgkKGUsKHQ9PkMobj0+amUobikmJm4ubGVuZ3RoPj10KSkocikpKSxsZW5ndGg6cj0+QmUoJChlLCh0PT5DKG49PmplKG4pJiZuLmxlbmd0aD09PXQpKShyKSkpLG1heExlbmd0aDpyPT5CZSgkKGUsKHQ9PkMobj0+amUobikmJm4ubGVuZ3RoPD10KSkocikpKSxpbmNsdWRlczpyPT57cmV0dXJuIEJlKCQoZSwodD1yLEMobj0+amUobikmJm4uaW5jbHVkZXModCkpKSkpO3ZhciB0fSxyZWdleDpyPT57cmV0dXJuIEJlKCQoZSwodD1yLEMobj0+amUobikmJiEhbi5tYXRjaCh0KSkpKSk7dmFyIHR9fSksaWc9QmUoQyhqZSkpLGJlPWU9Pk9iamVjdC5hc3NpZ24oY2UoZSkse2JldHdlZW46KHIsdCk9PmJlKCQoZSwoKG4saSk9PkMobz0+eWUobykmJm48PW8mJmk+PW8pKShyLHQpKSksbHQ6cj0+YmUoJChlLCh0PT5DKG49PnllKG4pJiZuPHQpKShyKSkpLGd0OnI9PmJlKCQoZSwodD0+QyhuPT55ZShuKSYmbj50KSkocikpKSxsdGU6cj0+YmUoJChlLCh0PT5DKG49PnllKG4pJiZuPD10KSkocikpKSxndGU6cj0+YmUoJChlLCh0PT5DKG49PnllKG4pJiZuPj10KSkocikpKSxpbnQ6KCk9PmJlKCQoZSxDKHI9PnllKHIpJiZOdW1iZXIuaXNJbnRlZ2VyKHIpKSkpLGZpbml0ZTooKT0+YmUoJChlLEMocj0+eWUocikmJk51bWJlci5pc0Zpbml0ZShyKSkpKSxwb3NpdGl2ZTooKT0+YmUoJChlLEMocj0+eWUocikmJnI+MCkpKSxuZWdhdGl2ZTooKT0+YmUoJChlLEMocj0+eWUocikmJnI8MCkpKX0pLG9nPWJlKEMoeWUpKSxVZT1lPT5PYmplY3QuYXNzaWduKGNlKGUpLHtiZXR3ZWVuOihyLHQpPT5VZSgkKGUsKChuLGkpPT5DKG89PlZlKG8pJiZuPD1vJiZpPj1vKSkocix0KSkpLGx0OnI9PlVlKCQoZSwodD0+QyhuPT5WZShuKSYmbjx0KSkocikpKSxndDpyPT5VZSgkKGUsKHQ9PkMobj0+VmUobikmJm4+dCkpKHIpKSksbHRlOnI9PlVlKCQoZSwodD0+QyhuPT5WZShuKSYmbjw9dCkpKHIpKSksZ3RlOnI9PlVlKCQoZSwodD0+QyhuPT5WZShuKSYmbj49dCkpKHIpKSkscG9zaXRpdmU6KCk9PlVlKCQoZSxDKHI9PlZlKHIpJiZyPjApKSksbmVnYXRpdmU6KCk9PlVlKCQoZSxDKHI9PlZlKHIpJiZyPDApKSl9KSxzZz1VZShDKFZlKSksYWc9Y2UoQyhmdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PVwiYm9vbGVhblwifSkpLGxnPWNlKEMoZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlPT1cInN5bWJvbFwifSkpLHVnPWNlKEMoZnVuY3Rpb24oZSl7cmV0dXJuIGU9PW51bGx9KSksY2c9Y2UoQyhmdW5jdGlvbihlKXtyZXR1cm4gZSE9bnVsbH0pKTt2YXIgcmk9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihyKXtsZXQgdDt0cnl7dD1KU09OLnN0cmluZ2lmeShyKX1jYXRjaHt0PXJ9c3VwZXIoYFBhdHRlcm4gbWF0Y2hpbmcgZXJyb3I6IG5vIHBhdHRlcm4gbWF0Y2hlcyB2YWx1ZSAke3R9YCksdGhpcy5pbnB1dD12b2lkIDAsdGhpcy5pbnB1dD1yfX0sdGk9e21hdGNoZWQ6ITEsdmFsdWU6dm9pZCAwfTtmdW5jdGlvbiB5cihlKXtyZXR1cm4gbmV3IG5pKGUsdGkpfXZhciBuaT1jbGFzcyBle2NvbnN0cnVjdG9yKHIsdCl7dGhpcy5pbnB1dD12b2lkIDAsdGhpcy5zdGF0ZT12b2lkIDAsdGhpcy5pbnB1dD1yLHRoaXMuc3RhdGU9dH13aXRoKC4uLnIpe2lmKHRoaXMuc3RhdGUubWF0Y2hlZClyZXR1cm4gdGhpcztsZXQgdD1yW3IubGVuZ3RoLTFdLG49W3JbMF1dLGk7ci5sZW5ndGg9PT0zJiZ0eXBlb2YgclsxXT09XCJmdW5jdGlvblwiP2k9clsxXTpyLmxlbmd0aD4yJiZuLnB1c2goLi4uci5zbGljZSgxLHIubGVuZ3RoLTEpKTtsZXQgbz0hMSxzPXt9LGE9KHUsYyk9PntvPSEwLHNbdV09Y30sbD0hbi5zb21lKHU9PkVlKHUsdGhpcy5pbnB1dCxhKSl8fGkmJiFpKHRoaXMuaW5wdXQpP3RpOnttYXRjaGVkOiEwLHZhbHVlOnQobz9CdCBpbiBzP3NbQnRdOnM6dGhpcy5pbnB1dCx0aGlzLmlucHV0KX07cmV0dXJuIG5ldyBlKHRoaXMuaW5wdXQsbCl9d2hlbihyLHQpe2lmKHRoaXMuc3RhdGUubWF0Y2hlZClyZXR1cm4gdGhpcztsZXQgbj0hIXIodGhpcy5pbnB1dCk7cmV0dXJuIG5ldyBlKHRoaXMuaW5wdXQsbj97bWF0Y2hlZDohMCx2YWx1ZTp0KHRoaXMuaW5wdXQsdGhpcy5pbnB1dCl9OnRpKX1vdGhlcndpc2Uocil7cmV0dXJuIHRoaXMuc3RhdGUubWF0Y2hlZD90aGlzLnN0YXRlLnZhbHVlOnIodGhpcy5pbnB1dCl9ZXhoYXVzdGl2ZSgpe2lmKHRoaXMuc3RhdGUubWF0Y2hlZClyZXR1cm4gdGhpcy5zdGF0ZS52YWx1ZTt0aHJvdyBuZXcgcmkodGhpcy5pbnB1dCl9cnVuKCl7cmV0dXJuIHRoaXMuZXhoYXVzdGl2ZSgpfXJldHVyblR5cGUoKXtyZXR1cm4gdGhpc319O2ltcG9ydHtwcm9taXNpZnkgYXMgTXV9ZnJvbVwibm9kZTp1dGlsXCI7dmFyIE51PXt3YXJuOkllKFwicHJpc21hOndhcm5cIil9LEx1PXt3YXJuOigpPT4hcHJvY2Vzcy5lbnYuUFJJU01BX0RJU0FCTEVfV0FSTklOR1N9O2Z1bmN0aW9uIFV0KGUsLi4ucil7THUud2FybigpJiZjb25zb2xlLndhcm4oYCR7TnUud2Fybn0gJHtlfWAsLi4ucil9dmFyICR1PU11KEZ1LmV4ZWMpLHo9aHIoXCJwcmlzbWE6Z2V0LXBsYXRmb3JtXCIpLHF1PVtcIjEuMC54XCIsXCIxLjEueFwiLFwiMy4wLnhcIl07YXN5bmMgZnVuY3Rpb24gUW8oKXtsZXQgZT1paS5wbGF0Zm9ybSgpLHI9cHJvY2Vzcy5hcmNoO2lmKGU9PT1cImZyZWVic2RcIil7bGV0IHM9YXdhaXQgUXQoXCJmcmVlYnNkLXZlcnNpb25cIik7aWYocyYmcy50cmltKCkubGVuZ3RoPjApe2xldCBsPS9eKFxcZCspXFwuPy8uZXhlYyhzKTtpZihsKXJldHVybntwbGF0Zm9ybTpcImZyZWVic2RcIix0YXJnZXREaXN0cm86YGZyZWVic2Qke2xbMV19YCxhcmNoOnJ9fX1pZihlIT09XCJsaW51eFwiKXJldHVybntwbGF0Zm9ybTplLGFyY2g6cn07bGV0IHQ9YXdhaXQgVnUoKSxuPWF3YWl0IEt1KCksaT1VdSh7YXJjaDpyLGFyY2hGcm9tVW5hbWU6bixmYW1pbHlEaXN0cm86dC5mYW1pbHlEaXN0cm99KSx7bGlic3NsOm99PWF3YWl0IEd1KGkpO3JldHVybntwbGF0Zm9ybTpcImxpbnV4XCIsbGlic3NsOm8sYXJjaDpyLGFyY2hGcm9tVW5hbWU6biwuLi50fX1mdW5jdGlvbiBqdShlKXtsZXQgcj0vXklEPVwiPyhbXlwiXFxuXSopXCI/JC9pbSx0PS9eSURfTElLRT1cIj8oW15cIlxcbl0qKVwiPyQvaW0sbj1yLmV4ZWMoZSksaT1uJiZuWzFdJiZuWzFdLnRvTG93ZXJDYXNlKCl8fFwiXCIsbz10LmV4ZWMoZSkscz1vJiZvWzFdJiZvWzFdLnRvTG93ZXJDYXNlKCl8fFwiXCIsYT15cih7aWQ6aSxpZExpa2U6c30pLndpdGgoe2lkOlwiYWxwaW5lXCJ9LCh7aWQ6bH0pPT4oe3RhcmdldERpc3RybzpcIm11c2xcIixmYW1pbHlEaXN0cm86bCxvcmlnaW5hbERpc3RybzpsfSkpLndpdGgoe2lkOlwicmFzcGJpYW5cIn0sKHtpZDpsfSk9Pih7dGFyZ2V0RGlzdHJvOlwiYXJtXCIsZmFtaWx5RGlzdHJvOlwiZGViaWFuXCIsb3JpZ2luYWxEaXN0cm86bH0pKS53aXRoKHtpZDpcIm5peG9zXCJ9LCh7aWQ6bH0pPT4oe3RhcmdldERpc3RybzpcIm5peG9zXCIsb3JpZ2luYWxEaXN0cm86bCxmYW1pbHlEaXN0cm86XCJuaXhvc1wifSkpLndpdGgoe2lkOlwiZGViaWFuXCJ9LHtpZDpcInVidW50dVwifSwoe2lkOmx9KT0+KHt0YXJnZXREaXN0cm86XCJkZWJpYW5cIixmYW1pbHlEaXN0cm86XCJkZWJpYW5cIixvcmlnaW5hbERpc3RybzpsfSkpLndpdGgoe2lkOlwicmhlbFwifSx7aWQ6XCJjZW50b3NcIn0se2lkOlwiZmVkb3JhXCJ9LCh7aWQ6bH0pPT4oe3RhcmdldERpc3RybzpcInJoZWxcIixmYW1pbHlEaXN0cm86XCJyaGVsXCIsb3JpZ2luYWxEaXN0cm86bH0pKS53aGVuKCh7aWRMaWtlOmx9KT0+bC5pbmNsdWRlcyhcImRlYmlhblwiKXx8bC5pbmNsdWRlcyhcInVidW50dVwiKSwoe2lkOmx9KT0+KHt0YXJnZXREaXN0cm86XCJkZWJpYW5cIixmYW1pbHlEaXN0cm86XCJkZWJpYW5cIixvcmlnaW5hbERpc3RybzpsfSkpLndoZW4oKHtpZExpa2U6bH0pPT5pPT09XCJhcmNoXCJ8fGwuaW5jbHVkZXMoXCJhcmNoXCIpLCh7aWQ6bH0pPT4oe3RhcmdldERpc3RybzpcImRlYmlhblwiLGZhbWlseURpc3RybzpcImFyY2hcIixvcmlnaW5hbERpc3RybzpsfSkpLndoZW4oKHtpZExpa2U6bH0pPT5sLmluY2x1ZGVzKFwiY2VudG9zXCIpfHxsLmluY2x1ZGVzKFwiZmVkb3JhXCIpfHxsLmluY2x1ZGVzKFwicmhlbFwiKXx8bC5pbmNsdWRlcyhcInN1c2VcIiksKHtpZDpsfSk9Pih7dGFyZ2V0RGlzdHJvOlwicmhlbFwiLGZhbWlseURpc3RybzpcInJoZWxcIixvcmlnaW5hbERpc3RybzpsfSkpLm90aGVyd2lzZSgoe2lkOmx9KT0+KHt0YXJnZXREaXN0cm86dm9pZCAwLGZhbWlseURpc3Rybzp2b2lkIDAsb3JpZ2luYWxEaXN0cm86bH0pKTtyZXR1cm4geihgRm91bmQgZGlzdHJvIGluZm86XG4ke0pTT04uc3RyaW5naWZ5KGEsbnVsbCwyKX1gKSxhfWFzeW5jIGZ1bmN0aW9uIFZ1KCl7bGV0IGU9XCIvZXRjL29zLXJlbGVhc2VcIjt0cnl7bGV0IHI9YXdhaXQgR28ucmVhZEZpbGUoZSx7ZW5jb2Rpbmc6XCJ1dGYtOFwifSk7cmV0dXJuIGp1KHIpfWNhdGNoe3JldHVybnt0YXJnZXREaXN0cm86dm9pZCAwLGZhbWlseURpc3Rybzp2b2lkIDAsb3JpZ2luYWxEaXN0cm86dm9pZCAwfX19ZnVuY3Rpb24gQnUoZSl7bGV0IHI9L15PcGVuU1NMXFxzKFxcZCtcXC5cXGQrKVxcLlxcZCsvLmV4ZWMoZSk7aWYocil7bGV0IHQ9YCR7clsxXX0ueGA7cmV0dXJuIFdvKHQpfX1mdW5jdGlvbiBCbyhlKXtsZXQgcj0vbGlic3NsXFwuc29cXC4oXFxkKShcXC5cXGQpPy8uZXhlYyhlKTtpZihyKXtsZXQgdD1gJHtyWzFdfSR7clsyXT8/XCIuMFwifS54YDtyZXR1cm4gV28odCl9fWZ1bmN0aW9uIFdvKGUpe2xldCByPSgoKT0+e2lmKEhvKGUpKXJldHVybiBlO2xldCB0PWUuc3BsaXQoXCIuXCIpO3JldHVybiB0WzFdPVwiMFwiLHQuam9pbihcIi5cIil9KSgpO2lmKHF1LmluY2x1ZGVzKHIpKXJldHVybiByfWZ1bmN0aW9uIFV1KGUpe3JldHVybiB5cihlKS53aXRoKHtmYW1pbHlEaXN0cm86XCJtdXNsXCJ9LCgpPT4oeignVHJ5aW5nIHBsYXRmb3JtLXNwZWNpZmljIHBhdGhzIGZvciBcImFscGluZVwiJyksW1wiL2xpYlwiLFwiL3Vzci9saWJcIl0pKS53aXRoKHtmYW1pbHlEaXN0cm86XCJkZWJpYW5cIn0sKHthcmNoRnJvbVVuYW1lOnJ9KT0+KHooJ1RyeWluZyBwbGF0Zm9ybS1zcGVjaWZpYyBwYXRocyBmb3IgXCJkZWJpYW5cIiAoYW5kIFwidWJ1bnR1XCIpJyksW2AvdXNyL2xpYi8ke3J9LWxpbnV4LWdudWAsYC9saWIvJHtyfS1saW51eC1nbnVgXSkpLndpdGgoe2ZhbWlseURpc3RybzpcInJoZWxcIn0sKCk9Pih6KCdUcnlpbmcgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aHMgZm9yIFwicmhlbFwiJyksW1wiL2xpYjY0XCIsXCIvdXNyL2xpYjY0XCJdKSkub3RoZXJ3aXNlKCh7ZmFtaWx5RGlzdHJvOnIsYXJjaDp0LGFyY2hGcm9tVW5hbWU6bn0pPT4oeihgRG9uJ3Qga25vdyBhbnkgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aHMgZm9yIFwiJHtyfVwiIG9uICR7dH0gKCR7bn0pYCksW10pKX1hc3luYyBmdW5jdGlvbiBHdShlKXtsZXQgcj0nZ3JlcCAtdiBcImxpYnNzbC5zby4wXCInLHQ9YXdhaXQgVW8oZSk7aWYodCl7eihgRm91bmQgbGlic3NsLnNvIGZpbGUgdXNpbmcgcGxhdGZvcm0tc3BlY2lmaWMgcGF0aHM6ICR7dH1gKTtsZXQgbz1Cbyh0KTtpZih6KGBUaGUgcGFyc2VkIGxpYnNzbCB2ZXJzaW9uIGlzOiAke299YCksbylyZXR1cm57bGlic3NsOm8sc3RyYXRlZ3k6XCJsaWJzc2wtc3BlY2lmaWMtcGF0aFwifX16KCdGYWxsaW5nIGJhY2sgdG8gXCJsZGNvbmZpZ1wiIGFuZCBvdGhlciBnZW5lcmljIHBhdGhzJyk7bGV0IG49YXdhaXQgUXQoYGxkY29uZmlnIC1wIHwgc2VkIFwicy8uKj0+cyovL1wiIHwgc2VkIFwic3wuKi98fFwiIHwgZ3JlcCBsaWJzc2wgfCBzb3J0IHwgJHtyfWApO2lmKG58fChuPWF3YWl0IFVvKFtcIi9saWI2NFwiLFwiL3Vzci9saWI2NFwiLFwiL2xpYlwiLFwiL3Vzci9saWJcIl0pKSxuKXt6KGBGb3VuZCBsaWJzc2wuc28gZmlsZSB1c2luZyBcImxkY29uZmlnXCIgb3Igb3RoZXIgZ2VuZXJpYyBwYXRoczogJHtufWApO2xldCBvPUJvKG4pO2lmKHooYFRoZSBwYXJzZWQgbGlic3NsIHZlcnNpb24gaXM6ICR7b31gKSxvKXJldHVybntsaWJzc2w6byxzdHJhdGVneTpcImxkY29uZmlnXCJ9fWxldCBpPWF3YWl0IFF0KFwib3BlbnNzbCB2ZXJzaW9uIC12XCIpO2lmKGkpe3ooYEZvdW5kIG9wZW5zc2wgYmluYXJ5IHdpdGggdmVyc2lvbjogJHtpfWApO2xldCBvPUJ1KGkpO2lmKHooYFRoZSBwYXJzZWQgb3BlbnNzbCB2ZXJzaW9uIGlzOiAke299YCksbylyZXR1cm57bGlic3NsOm8sc3RyYXRlZ3k6XCJvcGVuc3NsLWJpbmFyeVwifX1yZXR1cm4geihcIkNvdWxkbid0IGZpbmQgYW55IHZlcnNpb24gb2YgbGlic3NsIG9yIE9wZW5TU0wgaW4gdGhlIHN5c3RlbVwiKSx7fX1hc3luYyBmdW5jdGlvbiBVbyhlKXtmb3IobGV0IHIgb2YgZSl7bGV0IHQ9YXdhaXQgUXUocik7aWYodClyZXR1cm4gdH19YXN5bmMgZnVuY3Rpb24gUXUoZSl7dHJ5e3JldHVybihhd2FpdCBHby5yZWFkZGlyKGUpKS5maW5kKHQ9PnQuc3RhcnRzV2l0aChcImxpYnNzbC5zby5cIikmJiF0LnN0YXJ0c1dpdGgoXCJsaWJzc2wuc28uMFwiKSl9Y2F0Y2gocil7aWYoci5jb2RlPT09XCJFTk9FTlRcIilyZXR1cm47dGhyb3cgcn19YXN5bmMgZnVuY3Rpb24gbnIoKXtsZXR7YmluYXJ5VGFyZ2V0OmV9PWF3YWl0IEpvKCk7cmV0dXJuIGV9ZnVuY3Rpb24gV3UoZSl7cmV0dXJuIGUuYmluYXJ5VGFyZ2V0IT09dm9pZCAwfWFzeW5jIGZ1bmN0aW9uIG9pKCl7bGV0e21lbW9pemVkOmUsLi4ucn09YXdhaXQgSm8oKTtyZXR1cm4gcn12YXIgR3Q9e307YXN5bmMgZnVuY3Rpb24gSm8oKXtpZihXdShHdCkpcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7Li4uR3QsbWVtb2l6ZWQ6ITB9KTtsZXQgZT1hd2FpdCBRbygpLHI9SnUoZSk7cmV0dXJuIEd0PXsuLi5lLGJpbmFyeVRhcmdldDpyfSx7Li4uR3QsbWVtb2l6ZWQ6ITF9fWZ1bmN0aW9uIEp1KGUpe2xldHtwbGF0Zm9ybTpyLGFyY2g6dCxhcmNoRnJvbVVuYW1lOm4sbGlic3NsOmksdGFyZ2V0RGlzdHJvOm8sZmFtaWx5RGlzdHJvOnMsb3JpZ2luYWxEaXN0cm86YX09ZTtyPT09XCJsaW51eFwiJiYhW1wieDY0XCIsXCJhcm02NFwiXS5pbmNsdWRlcyh0KSYmVXQoYFByaXNtYSBvbmx5IG9mZmljaWFsbHkgc3VwcG9ydHMgTGludXggb24gYW1kNjQgKHg4Nl82NCkgYW5kIGFybTY0IChhYXJjaDY0KSBzeXN0ZW0gYXJjaGl0ZWN0dXJlcyAoZGV0ZWN0ZWQgXCIke3R9XCIgaW5zdGVhZCkuIElmIHlvdSBhcmUgdXNpbmcgeW91ciBvd24gY3VzdG9tIFByaXNtYSBlbmdpbmVzLCB5b3UgY2FuIGlnbm9yZSB0aGlzIHdhcm5pbmcsIGFzIGxvbmcgYXMgeW91J3ZlIGNvbXBpbGVkIHRoZSBlbmdpbmVzIGZvciB5b3VyIHN5c3RlbSBhcmNoaXRlY3R1cmUgXCIke259XCIuYCk7bGV0IGw9XCIxLjEueFwiO2lmKHI9PT1cImxpbnV4XCImJmk9PT12b2lkIDApe2xldCBjPXlyKHtmYW1pbHlEaXN0cm86c30pLndpdGgoe2ZhbWlseURpc3RybzpcImRlYmlhblwifSwoKT0+XCJQbGVhc2UgbWFudWFsbHkgaW5zdGFsbCBPcGVuU1NMIHZpYSBgYXB0LWdldCB1cGRhdGUgLXkgJiYgYXB0LWdldCBpbnN0YWxsIC15IG9wZW5zc2xgIGFuZCB0cnkgaW5zdGFsbGluZyBQcmlzbWEgYWdhaW4uIElmIHlvdSdyZSBydW5uaW5nIFByaXNtYSBvbiBEb2NrZXIsIGFkZCB0aGlzIGNvbW1hbmQgdG8geW91ciBEb2NrZXJmaWxlLCBvciBzd2l0Y2ggdG8gYW4gaW1hZ2UgdGhhdCBhbHJlYWR5IGhhcyBPcGVuU1NMIGluc3RhbGxlZC5cIikub3RoZXJ3aXNlKCgpPT5cIlBsZWFzZSBtYW51YWxseSBpbnN0YWxsIE9wZW5TU0wgYW5kIHRyeSBpbnN0YWxsaW5nIFByaXNtYSBhZ2Fpbi5cIik7VXQoYFByaXNtYSBmYWlsZWQgdG8gZGV0ZWN0IHRoZSBsaWJzc2wvb3BlbnNzbCB2ZXJzaW9uIHRvIHVzZSwgYW5kIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC4gRGVmYXVsdGluZyB0byBcIm9wZW5zc2wtJHtsfVwiLlxuJHtjfWApfWxldCB1PVwiZGViaWFuXCI7aWYocj09PVwibGludXhcIiYmbz09PXZvaWQgMCYmeihgRGlzdHJvIGlzIFwiJHthfVwiLiBGYWxsaW5nIGJhY2sgdG8gUHJpc21hIGVuZ2luZXMgYnVpbHQgZm9yIFwiJHt1fVwiLmApLHI9PT1cImRhcndpblwiJiZ0PT09XCJhcm02NFwiKXJldHVyblwiZGFyd2luLWFybTY0XCI7aWYocj09PVwiZGFyd2luXCIpcmV0dXJuXCJkYXJ3aW5cIjtpZihyPT09XCJ3aW4zMlwiKXJldHVyblwid2luZG93c1wiO2lmKHI9PT1cImZyZWVic2RcIilyZXR1cm4gbztpZihyPT09XCJvcGVuYnNkXCIpcmV0dXJuXCJvcGVuYnNkXCI7aWYocj09PVwibmV0YnNkXCIpcmV0dXJuXCJuZXRic2RcIjtpZihyPT09XCJsaW51eFwiJiZvPT09XCJuaXhvc1wiKXJldHVyblwibGludXgtbml4b3NcIjtpZihyPT09XCJsaW51eFwiJiZ0PT09XCJhcm02NFwiKXJldHVybmAke289PT1cIm11c2xcIj9cImxpbnV4LW11c2wtYXJtNjRcIjpcImxpbnV4LWFybTY0XCJ9LW9wZW5zc2wtJHtpfHxsfWA7aWYocj09PVwibGludXhcIiYmdD09PVwiYXJtXCIpcmV0dXJuYGxpbnV4LWFybS1vcGVuc3NsLSR7aXx8bH1gO2lmKHI9PT1cImxpbnV4XCImJm89PT1cIm11c2xcIil7bGV0IGM9XCJsaW51eC1tdXNsXCI7cmV0dXJuIWl8fEhvKGkpP2M6YCR7Y30tb3BlbnNzbC0ke2l9YH1yZXR1cm4gcj09PVwibGludXhcIiYmbyYmaT9gJHtvfS1vcGVuc3NsLSR7aX1gOihyIT09XCJsaW51eFwiJiZVdChgUHJpc21hIGRldGVjdGVkIHVua25vd24gT1MgXCIke3J9XCIgYW5kIG1heSBub3Qgd29yayBhcyBleHBlY3RlZC4gRGVmYXVsdGluZyB0byBcImxpbnV4XCIuYCksaT9gJHt1fS1vcGVuc3NsLSR7aX1gOm8/YCR7b30tb3BlbnNzbC0ke2x9YDpgJHt1fS1vcGVuc3NsLSR7bH1gKX1hc3luYyBmdW5jdGlvbiBIdShlKXt0cnl7cmV0dXJuIGF3YWl0IGUoKX1jYXRjaHtyZXR1cm59fWZ1bmN0aW9uIFF0KGUpe3JldHVybiBIdShhc3luYygpPT57bGV0IHI9YXdhaXQgJHUoZSk7cmV0dXJuIHooYENvbW1hbmQgXCIke2V9XCIgc3VjY2Vzc2Z1bGx5IHJldHVybmVkIFwiJHtyLnN0ZG91dH1cImApLHIuc3Rkb3V0fSl9YXN5bmMgZnVuY3Rpb24gS3UoKXtyZXR1cm4gdHlwZW9mIGlpLm1hY2hpbmU9PVwiZnVuY3Rpb25cIj9paS5tYWNoaW5lKCk6KGF3YWl0IFF0KFwidW5hbWUgLW1cIikpPy50cmltKCl9ZnVuY3Rpb24gSG8oZSl7cmV0dXJuIGUuc3RhcnRzV2l0aChcIjEuXCIpfXZhciBKdD17fTtncihKdCx7YmVlcDooKT0+eGMsY2xlYXJTY3JlZW46KCk9PnljLGNsZWFyVGVybWluYWw6KCk9PmJjLGN1cnNvckJhY2t3YXJkOigpPT50YyxjdXJzb3JEb3duOigpPT5lYyxjdXJzb3JGb3J3YXJkOigpPT5yYyxjdXJzb3JHZXRQb3NpdGlvbjooKT0+b2MsY3Vyc29ySGlkZTooKT0+bGMsY3Vyc29yTGVmdDooKT0+em8sY3Vyc29yTW92ZTooKT0+WHUsY3Vyc29yTmV4dExpbmU6KCk9PnNjLGN1cnNvclByZXZMaW5lOigpPT5hYyxjdXJzb3JSZXN0b3JlUG9zaXRpb246KCk9PmljLGN1cnNvclNhdmVQb3NpdGlvbjooKT0+bmMsY3Vyc29yU2hvdzooKT0+dWMsY3Vyc29yVG86KCk9Plp1LGN1cnNvclVwOigpPT5ZbyxlbnRlckFsdGVybmF0aXZlU2NyZWVuOigpPT5FYyxlcmFzZURvd246KCk9Pm1jLGVyYXNlRW5kTGluZTooKT0+cGMsZXJhc2VMaW5lOigpPT5abyxlcmFzZUxpbmVzOigpPT5jYyxlcmFzZVNjcmVlbjooKT0+c2ksZXJhc2VTdGFydExpbmU6KCk9PmRjLGVyYXNlVXA6KCk9PmZjLGV4aXRBbHRlcm5hdGl2ZVNjcmVlbjooKT0+d2MsaVRlcm06KCk9PlRjLGltYWdlOigpPT5QYyxsaW5rOigpPT52YyxzY3JvbGxEb3duOigpPT5oYyxzY3JvbGxVcDooKT0+Z2N9KTtpbXBvcnQgYWkgZnJvbVwibm9kZTpwcm9jZXNzXCI7dmFyIFd0PWdsb2JhbFRoaXMud2luZG93Py5kb2N1bWVudCE9PXZvaWQgMCx2Zz1nbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5ub2RlIT09dm9pZCAwLFBnPWdsb2JhbFRoaXMucHJvY2Vzcz8udmVyc2lvbnM/LmJ1biE9PXZvaWQgMCxUZz1nbG9iYWxUaGlzLkRlbm8/LnZlcnNpb24/LmRlbm8hPT12b2lkIDAsU2c9Z2xvYmFsVGhpcy5wcm9jZXNzPy52ZXJzaW9ucz8uZWxlY3Ryb24hPT12b2lkIDAsUmc9Z2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5jbHVkZXMoXCJqc2RvbVwiKT09PSEwLEFnPXR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZTxcInVcIiYmZ2xvYmFsVGhpcyBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlLENnPXR5cGVvZiBEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZTxcInVcIiYmZ2xvYmFsVGhpcyBpbnN0YW5jZW9mIERlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlLElnPXR5cGVvZiBTaGFyZWRXb3JrZXJHbG9iYWxTY29wZTxcInVcIiYmZ2xvYmFsVGhpcyBpbnN0YW5jZW9mIFNoYXJlZFdvcmtlckdsb2JhbFNjb3BlLGtnPXR5cGVvZiBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGU8XCJ1XCImJmdsb2JhbFRoaXMgaW5zdGFuY2VvZiBTZXJ2aWNlV29ya2VyR2xvYmFsU2NvcGUsenI9Z2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnVzZXJBZ2VudERhdGE/LnBsYXRmb3JtLERnPXpyPT09XCJtYWNPU1wifHxnbG9iYWxUaGlzLm5hdmlnYXRvcj8ucGxhdGZvcm09PT1cIk1hY0ludGVsXCJ8fGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluY2x1ZGVzKFwiIE1hYyBcIik9PT0hMHx8Z2xvYmFsVGhpcy5wcm9jZXNzPy5wbGF0Zm9ybT09PVwiZGFyd2luXCIsT2c9enI9PT1cIldpbmRvd3NcInx8Z2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnBsYXRmb3JtPT09XCJXaW4zMlwifHxnbG9iYWxUaGlzLnByb2Nlc3M/LnBsYXRmb3JtPT09XCJ3aW4zMlwiLF9nPXpyPT09XCJMaW51eFwifHxnbG9iYWxUaGlzLm5hdmlnYXRvcj8ucGxhdGZvcm0/LnN0YXJ0c1dpdGgoXCJMaW51eFwiKT09PSEwfHxnbG9iYWxUaGlzLm5hdmlnYXRvcj8udXNlckFnZW50Py5pbmNsdWRlcyhcIiBMaW51eCBcIik9PT0hMHx8Z2xvYmFsVGhpcy5wcm9jZXNzPy5wbGF0Zm9ybT09PVwibGludXhcIixOZz16cj09PVwiaU9TXCJ8fGdsb2JhbFRoaXMubmF2aWdhdG9yPy5wbGF0Zm9ybT09PVwiTWFjSW50ZWxcIiYmZ2xvYmFsVGhpcy5uYXZpZ2F0b3I/Lm1heFRvdWNoUG9pbnRzPjF8fC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KGdsb2JhbFRoaXMubmF2aWdhdG9yPy5wbGF0Zm9ybSksTGc9enI9PT1cIkFuZHJvaWRcInx8Z2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnBsYXRmb3JtPT09XCJBbmRyb2lkXCJ8fGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluY2x1ZGVzKFwiIEFuZHJvaWQgXCIpPT09ITB8fGdsb2JhbFRoaXMucHJvY2Vzcz8ucGxhdGZvcm09PT1cImFuZHJvaWRcIjt2YXIgST1cIlxceDFCW1wiLFhyPVwiXFx4MUJdXCIsYnI9XCJcXHgwN1wiLFpyPVwiO1wiLEtvPSFXdCYmYWkuZW52LlRFUk1fUFJPR1JBTT09PVwiQXBwbGVfVGVybWluYWxcIixZdT0hV3QmJmFpLnBsYXRmb3JtPT09XCJ3aW4zMlwiLHp1PVd0PygpPT57dGhyb3cgbmV3IEVycm9yKFwiYHByb2Nlc3MuY3dkKClgIG9ubHkgd29ya3MgaW4gTm9kZS5qcywgbm90IHRoZSBicm93c2VyLlwiKX06YWkuY3dkLFp1PShlLHIpPT57aWYodHlwZW9mIGUhPVwibnVtYmVyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBgeGAgYXJndW1lbnQgaXMgcmVxdWlyZWRcIik7cmV0dXJuIHR5cGVvZiByIT1cIm51bWJlclwiP0krKGUrMSkrXCJHXCI6SSsocisxKStacisoZSsxKStcIkhcIn0sWHU9KGUscik9PntpZih0eXBlb2YgZSE9XCJudW1iZXJcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGB4YCBhcmd1bWVudCBpcyByZXF1aXJlZFwiKTtsZXQgdD1cIlwiO3JldHVybiBlPDA/dCs9SSstZStcIkRcIjplPjAmJih0Kz1JK2UrXCJDXCIpLHI8MD90Kz1JKy1yK1wiQVwiOnI+MCYmKHQrPUkrcitcIkJcIiksdH0sWW89KGU9MSk9PkkrZStcIkFcIixlYz0oZT0xKT0+SStlK1wiQlwiLHJjPShlPTEpPT5JK2UrXCJDXCIsdGM9KGU9MSk9PkkrZStcIkRcIix6bz1JK1wiR1wiLG5jPUtvP1wiXFx4MUI3XCI6SStcInNcIixpYz1Lbz9cIlxceDFCOFwiOkkrXCJ1XCIsb2M9SStcIjZuXCIsc2M9SStcIkVcIixhYz1JK1wiRlwiLGxjPUkrXCI/MjVsXCIsdWM9SStcIj8yNWhcIixjYz1lPT57bGV0IHI9XCJcIjtmb3IobGV0IHQ9MDt0PGU7dCsrKXIrPVpvKyh0PGUtMT9ZbygpOlwiXCIpO3JldHVybiBlJiYocis9em8pLHJ9LHBjPUkrXCJLXCIsZGM9SStcIjFLXCIsWm89SStcIjJLXCIsbWM9SStcIkpcIixmYz1JK1wiMUpcIixzaT1JK1wiMkpcIixnYz1JK1wiU1wiLGhjPUkrXCJUXCIseWM9XCJcXHgxQmNcIixiYz1ZdT9gJHtzaX0ke0l9MGZgOmAke3NpfSR7SX0zSiR7SX1IYCxFYz1JK1wiPzEwNDloXCIsd2M9SStcIj8xMDQ5bFwiLHhjPWJyLHZjPShlLHIpPT5bWHIsXCI4XCIsWnIsWnIscixicixlLFhyLFwiOFwiLFpyLFpyLGJyXS5qb2luKFwiXCIpLFBjPShlLHI9e30pPT57bGV0IHQ9YCR7WHJ9MTMzNztGaWxlPWlubGluZT0xYDtyZXR1cm4gci53aWR0aCYmKHQrPWA7d2lkdGg9JHtyLndpZHRofWApLHIuaGVpZ2h0JiYodCs9YDtoZWlnaHQ9JHtyLmhlaWdodH1gKSxyLnByZXNlcnZlQXNwZWN0UmF0aW89PT0hMSYmKHQrPVwiO3ByZXNlcnZlQXNwZWN0UmF0aW89MFwiKSx0K1wiOlwiK0J1ZmZlci5mcm9tKGUpLnRvU3RyaW5nKFwiYmFzZTY0XCIpK2JyfSxUYz17c2V0Q3dkOihlPXp1KCkpPT5gJHtYcn01MDtDdXJyZW50RGlyPSR7ZX0ke2JyfWAsYW5ub3RhdGlvbihlLHI9e30pe2xldCB0PWAke1hyfTEzMzc7YCxuPXIueCE9PXZvaWQgMCxpPXIueSE9PXZvaWQgMDtpZigobnx8aSkmJiEobiYmaSYmci5sZW5ndGghPT12b2lkIDApKXRocm93IG5ldyBFcnJvcihcImB4YCwgYHlgIGFuZCBgbGVuZ3RoYCBtdXN0IGJlIGRlZmluZWQgd2hlbiBgeGAgb3IgYHlgIGlzIGRlZmluZWRcIik7cmV0dXJuIGU9ZS5yZXBsYWNlQWxsKFwifFwiLFwiXCIpLHQrPXIuaXNIaWRkZW4/XCJBZGRIaWRkZW5Bbm5vdGF0aW9uPVwiOlwiQWRkQW5ub3RhdGlvbj1cIixyLmxlbmd0aD4wP3QrPShuP1tlLHIubGVuZ3RoLHIueCxyLnldOltyLmxlbmd0aCxlXSkuam9pbihcInxcIik6dCs9ZSx0K2JyfX07dmFyIEh0PW5lKG9zKCksMSk7ZnVuY3Rpb24gaXIoZSxyLHt0YXJnZXQ6dD1cInN0ZG91dFwiLC4uLm59PXt9KXtyZXR1cm4gSHQuZGVmYXVsdFt0XT9KdC5saW5rKGUscik6bi5mYWxsYmFjaz09PSExP2U6dHlwZW9mIG4uZmFsbGJhY2s9PVwiZnVuY3Rpb25cIj9uLmZhbGxiYWNrKGUscik6YCR7ZX0gKFxcdTIwMEIke3J9XFx1MjAwQilgfWlyLmlzU3VwcG9ydGVkPUh0LmRlZmF1bHQuc3Rkb3V0O2lyLnN0ZGVycj0oZSxyLHQ9e30pPT5pcihlLHIse3RhcmdldDpcInN0ZGVyclwiLC4uLnR9KTtpci5zdGRlcnIuaXNTdXBwb3J0ZWQ9SHQuZGVmYXVsdC5zdGRlcnI7ZnVuY3Rpb24gZGkoZSl7cmV0dXJuIGlyKGUsZSx7ZmFsbGJhY2s6S30pfXZhciBJYz1zcygpLG1pPUljLnZlcnNpb247ZnVuY3Rpb24gd3IoZSl7bGV0IHI9a2MoKTtyZXR1cm4gcnx8KGU/LmNvbmZpZy5lbmdpbmVUeXBlPT09XCJsaWJyYXJ5XCI/XCJsaWJyYXJ5XCI6ZT8uY29uZmlnLmVuZ2luZVR5cGU9PT1cImJpbmFyeVwiP1wiYmluYXJ5XCI6ZT8uY29uZmlnLmVuZ2luZVR5cGU9PT1cImNsaWVudFwiP1wiY2xpZW50XCI6RGMoZSkpfWZ1bmN0aW9uIGtjKCl7bGV0IGU9cHJvY2Vzcy5lbnYuUFJJU01BX0NMSUVOVF9FTkdJTkVfVFlQRTtyZXR1cm4gZT09PVwibGlicmFyeVwiP1wibGlicmFyeVwiOmU9PT1cImJpbmFyeVwiP1wiYmluYXJ5XCI6ZT09PVwiY2xpZW50XCI/XCJjbGllbnRcIjp2b2lkIDB9ZnVuY3Rpb24gRGMoZSl7cmV0dXJuIGU/LnByZXZpZXdGZWF0dXJlcy5pbmNsdWRlcyhcInF1ZXJ5Q29tcGlsZXJcIik/XCJjbGllbnRcIjpcImxpYnJhcnlcIn1mdW5jdGlvbiBmaShlKXtyZXR1cm4gZS5uYW1lPT09XCJEcml2ZXJBZGFwdGVyRXJyb3JcIiYmdHlwZW9mIGUuY2F1c2U9PVwib2JqZWN0XCJ9ZnVuY3Rpb24gS3QoZSl7cmV0dXJue29rOiEwLHZhbHVlOmUsbWFwKHIpe3JldHVybiBLdChyKGUpKX0sZmxhdE1hcChyKXtyZXR1cm4gcihlKX19fWZ1bmN0aW9uIG9yKGUpe3JldHVybntvazohMSxlcnJvcjplLG1hcCgpe3JldHVybiBvcihlKX0sZmxhdE1hcCgpe3JldHVybiBvcihlKX19fXZhciBhcz1MKFwiZHJpdmVyLWFkYXB0ZXItdXRpbHNcIiksZ2k9Y2xhc3N7cmVnaXN0ZXJlZEVycm9ycz1bXTtjb25zdW1lRXJyb3Iocil7cmV0dXJuIHRoaXMucmVnaXN0ZXJlZEVycm9yc1tyXX1yZWdpc3Rlck5ld0Vycm9yKHIpe2xldCB0PTA7Zm9yKDt0aGlzLnJlZ2lzdGVyZWRFcnJvcnNbdF0hPT12b2lkIDA7KXQrKztyZXR1cm4gdGhpcy5yZWdpc3RlcmVkRXJyb3JzW3RdPXtlcnJvcjpyfSx0fX07dmFyIFl0PShlLHI9bmV3IGdpKT0+e2xldCB0PXthZGFwdGVyTmFtZTplLmFkYXB0ZXJOYW1lLGVycm9yUmVnaXN0cnk6cixxdWVyeVJhdzpPZShyLGUucXVlcnlSYXcuYmluZChlKSksZXhlY3V0ZVJhdzpPZShyLGUuZXhlY3V0ZVJhdy5iaW5kKGUpKSxleGVjdXRlU2NyaXB0Ok9lKHIsZS5leGVjdXRlU2NyaXB0LmJpbmQoZSkpLGRpc3Bvc2U6T2UocixlLmRpc3Bvc2UuYmluZChlKSkscHJvdmlkZXI6ZS5wcm92aWRlcixzdGFydFRyYW5zYWN0aW9uOmFzeW5jKC4uLm4pPT4oYXdhaXQgT2UocixlLnN0YXJ0VHJhbnNhY3Rpb24uYmluZChlKSkoLi4ubikpLm1hcChvPT5PYyhyLG8pKX07cmV0dXJuIGUuZ2V0Q29ubmVjdGlvbkluZm8mJih0LmdldENvbm5lY3Rpb25JbmZvPV9jKHIsZS5nZXRDb25uZWN0aW9uSW5mby5iaW5kKGUpKSksdH0sT2M9KGUscik9Pih7YWRhcHRlck5hbWU6ci5hZGFwdGVyTmFtZSxwcm92aWRlcjpyLnByb3ZpZGVyLG9wdGlvbnM6ci5vcHRpb25zLHF1ZXJ5UmF3Ok9lKGUsci5xdWVyeVJhdy5iaW5kKHIpKSxleGVjdXRlUmF3Ok9lKGUsci5leGVjdXRlUmF3LmJpbmQocikpLGNvbW1pdDpPZShlLHIuY29tbWl0LmJpbmQocikpLHJvbGxiYWNrOk9lKGUsci5yb2xsYmFjay5iaW5kKHIpKX0pO2Z1bmN0aW9uIE9lKGUscil7cmV0dXJuIGFzeW5jKC4uLnQpPT57dHJ5e3JldHVybiBLdChhd2FpdCByKC4uLnQpKX1jYXRjaChuKXtpZihhcyhcIltlcnJvckB3cmFwQXN5bmNdXCIsbiksZmkobikpcmV0dXJuIG9yKG4uY2F1c2UpO2xldCBpPWUucmVnaXN0ZXJOZXdFcnJvcihuKTtyZXR1cm4gb3Ioe2tpbmQ6XCJHZW5lcmljSnNcIixpZDppfSl9fX1mdW5jdGlvbiBfYyhlLHIpe3JldHVybiguLi50KT0+e3RyeXtyZXR1cm4gS3QociguLi50KSl9Y2F0Y2gobil7aWYoYXMoXCJbZXJyb3JAd3JhcFN5bmNdXCIsbiksZmkobikpcmV0dXJuIG9yKG4uY2F1c2UpO2xldCBpPWUucmVnaXN0ZXJOZXdFcnJvcihuKTtyZXR1cm4gb3Ioe2tpbmQ6XCJHZW5lcmljSnNcIixpZDppfSl9fX12YXIgTGM9bmUoWnQoKSk7dmFyIEZjPW5lKFp0KCkpO2ltcG9ydCBNIGZyb21cIm5vZGU6cGF0aFwiO3ZhciBJaD1MKFwicHJpc21hOmVuZ2luZXNcIik7ZnVuY3Rpb24gbHMoKXtyZXR1cm4gTS5qb2luKF9fZGlybmFtZSxcIi4uL1wiKX12YXIga2g9XCJsaWJxdWVyeS1lbmdpbmVcIjtNLmpvaW4oX19kaXJuYW1lLFwiLi4vcXVlcnktZW5naW5lLWRhcndpblwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vcXVlcnktZW5naW5lLWRhcndpbi1hcm02NFwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vcXVlcnktZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMC54XCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9xdWVyeS1lbmdpbmUtZGViaWFuLW9wZW5zc2wtMS4xLnhcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5LWVuZ2luZS1kZWJpYW4tb3BlbnNzbC0zLjAueFwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vcXVlcnktZW5naW5lLWxpbnV4LXN0YXRpYy14NjRcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5LWVuZ2luZS1saW51eC1zdGF0aWMtYXJtNjRcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5LWVuZ2luZS1yaGVsLW9wZW5zc2wtMS4wLnhcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5LWVuZ2luZS1yaGVsLW9wZW5zc2wtMS4xLnhcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5LWVuZ2luZS1yaGVsLW9wZW5zc2wtMy4wLnhcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1kYXJ3aW4uZHlsaWIubm9kZVwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vbGlicXVlcnlfZW5naW5lLWRhcndpbi1hcm02NC5keWxpYi5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtZGViaWFuLW9wZW5zc2wtMS4wLnguc28ubm9kZVwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vbGlicXVlcnlfZW5naW5lLWRlYmlhbi1vcGVuc3NsLTEuMS54LnNvLm5vZGVcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1kZWJpYW4tb3BlbnNzbC0zLjAueC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtbGludXgtYXJtNjQtb3BlbnNzbC0xLjAueC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtbGludXgtYXJtNjQtb3BlbnNzbC0xLjEueC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtbGludXgtYXJtNjQtb3BlbnNzbC0zLjAueC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtbGludXgtbXVzbC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtbGludXgtbXVzbC1vcGVuc3NsLTMuMC54LnNvLm5vZGVcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL2xpYnF1ZXJ5X2VuZ2luZS1yaGVsLW9wZW5zc2wtMS4wLnguc28ubm9kZVwiKTtNLmpvaW4oX19kaXJuYW1lLFwiLi4vbGlicXVlcnlfZW5naW5lLXJoZWwtb3BlbnNzbC0xLjEueC5zby5ub2RlXCIpO00uam9pbihfX2Rpcm5hbWUsXCIuLi9saWJxdWVyeV9lbmdpbmUtcmhlbC1vcGVuc3NsLTMuMC54LnNvLm5vZGVcIik7TS5qb2luKF9fZGlybmFtZSxcIi4uL3F1ZXJ5X2VuZ2luZS13aW5kb3dzLmRsbC5ub2RlXCIpO2ltcG9ydCB1cyBmcm9tXCJub2RlOmZzXCI7dmFyIGNzPWhyKFwiY2htb2RQbHVzWFwiKTtmdW5jdGlvbiB5aShlKXtpZihwcm9jZXNzLnBsYXRmb3JtPT09XCJ3aW4zMlwiKXJldHVybjtsZXQgcj11cy5zdGF0U3luYyhlKSx0PXIubW9kZXw2NHw4fDE7aWYoci5tb2RlPT09dCl7Y3MoYEV4ZWN1dGlvbiBwZXJtaXNzaW9ucyBvZiAke2V9IGFyZSBmaW5lYCk7cmV0dXJufWxldCBuPXQudG9TdHJpbmcoOCkuc2xpY2UoLTMpO2NzKGBIYXZlIHRvIGNhbGwgY2htb2RQbHVzWCBvbiAke2V9YCksdXMuY2htb2RTeW5jKGUsbil9ZnVuY3Rpb24gYmkoZSl7bGV0IHI9ZS5lLHQ9YT0+YFByaXNtYSBjYW5ub3QgZmluZCB0aGUgcmVxdWlyZWQgXFxgJHthfVxcYCBzeXN0ZW0gbGlicmFyeSBpbiB5b3VyIHN5c3RlbWAsbj1yLm1lc3NhZ2UuaW5jbHVkZXMoXCJjYW5ub3Qgb3BlbiBzaGFyZWQgb2JqZWN0IGZpbGVcIiksaT1gUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uIGFib3V0IFByaXNtYSdzIHN5c3RlbSByZXF1aXJlbWVudHM6ICR7ZGkoXCJodHRwczovL3ByaXMubHkvZC9zeXN0ZW0tcmVxdWlyZW1lbnRzXCIpfWAsbz1gVW5hYmxlIHRvIHJlcXVpcmUoXFxgJHtDZShlLmlkKX1cXGApLmAscz15cih7bWVzc2FnZTpyLm1lc3NhZ2UsY29kZTpyLmNvZGV9KS53aXRoKHtjb2RlOlwiRU5PRU5UXCJ9LCgpPT5cIkZpbGUgZG9lcyBub3QgZXhpc3QuXCIpLndoZW4oKHttZXNzYWdlOmF9KT0+biYmYS5pbmNsdWRlcyhcImxpYnpcIiksKCk9PmAke3QoXCJsaWJ6XCIpfS4gUGxlYXNlIGluc3RhbGwgaXQgYW5kIHRyeSBhZ2Fpbi5gKS53aGVuKCh7bWVzc2FnZTphfSk9Pm4mJmEuaW5jbHVkZXMoXCJsaWJnY2Nfc1wiKSwoKT0+YCR7dChcImxpYmdjY19zXCIpfS4gUGxlYXNlIGluc3RhbGwgaXQgYW5kIHRyeSBhZ2Fpbi5gKS53aGVuKCh7bWVzc2FnZTphfSk9Pm4mJmEuaW5jbHVkZXMoXCJsaWJzc2xcIiksKCk9PntsZXQgYT1lLnBsYXRmb3JtSW5mby5saWJzc2w/YG9wZW5zc2wtJHtlLnBsYXRmb3JtSW5mby5saWJzc2x9YDpcIm9wZW5zc2xcIjtyZXR1cm5gJHt0KFwibGlic3NsXCIpfS4gUGxlYXNlIGluc3RhbGwgJHthfSBhbmQgdHJ5IGFnYWluLmB9KS53aGVuKCh7bWVzc2FnZTphfSk9PmEuaW5jbHVkZXMoXCJHTElCQ1wiKSwoKT0+YFByaXNtYSBoYXMgZGV0ZWN0ZWQgYW4gaW5jb21wYXRpYmxlIHZlcnNpb24gb2YgdGhlIFxcYGdsaWJjXFxgIEMgc3RhbmRhcmQgbGlicmFyeSBpbnN0YWxsZWQgaW4geW91ciBzeXN0ZW0uIFRoaXMgcHJvYmFibHkgbWVhbnMgeW91ciBzeXN0ZW0gbWF5IGJlIHRvbyBvbGQgdG8gcnVuIFByaXNtYS4gJHtpfWApLndoZW4oKHttZXNzYWdlOmF9KT0+ZS5wbGF0Zm9ybUluZm8ucGxhdGZvcm09PT1cImxpbnV4XCImJmEuaW5jbHVkZXMoXCJzeW1ib2wgbm90IGZvdW5kXCIpLCgpPT5gVGhlIFByaXNtYSBlbmdpbmVzIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIHlvdXIgc3lzdGVtICR7ZS5wbGF0Zm9ybUluZm8ub3JpZ2luYWxEaXN0cm99IG9uICgke2UucGxhdGZvcm1JbmZvLmFyY2hGcm9tVW5hbWV9KSB3aGljaCB1c2VzIHRoZSBcXGAke2UucGxhdGZvcm1JbmZvLmJpbmFyeVRhcmdldH1cXGAgYmluYXJ5VGFyZ2V0IGJ5IGRlZmF1bHQuICR7aX1gKS5vdGhlcndpc2UoKCk9PmBUaGUgUHJpc21hIGVuZ2luZXMgZG8gbm90IHNlZW0gdG8gYmUgY29tcGF0aWJsZSB3aXRoIHlvdXIgc3lzdGVtLiAke2l9YCk7cmV0dXJuYCR7b31cbiR7c31cblxuRGV0YWlsczogJHtyLm1lc3NhZ2V9YH12YXIgbXM9bmUoZHMoKSwxKTtmdW5jdGlvbiBFaShlKXtsZXQgcj0oMCxtcy5kZWZhdWx0KShlKTtpZihyPT09MClyZXR1cm4gZTtsZXQgdD1uZXcgUmVnRXhwKGBeWyBcXFxcdF17JHtyfX1gLFwiZ21cIik7cmV0dXJuIGUucmVwbGFjZSh0LFwiXCIpfXZhciBmcz1cInByaXNtYStwb3N0Z3Jlc1wiLFh0PWAke2ZzfTpgO2Z1bmN0aW9uIGVuKGUpe3JldHVybiBlPy50b1N0cmluZygpLnN0YXJ0c1dpdGgoYCR7WHR9Ly9gKT8/ITF9ZnVuY3Rpb24gd2koZSl7aWYoIWVuKGUpKXJldHVybiExO2xldHtob3N0OnJ9PW5ldyBVUkwoZSk7cmV0dXJuIHIuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIil8fHIuaW5jbHVkZXMoXCIxMjcuMC4wLjFcIil8fHIuaW5jbHVkZXMoXCJbOjoxXVwiKX12YXIgaHM9bmUoeGkoKSk7ZnVuY3Rpb24gUGkoZSl7cmV0dXJuIFN0cmluZyhuZXcgdmkoZSkpfXZhciB2aT1jbGFzc3tjb25zdHJ1Y3RvcihyKXt0aGlzLmNvbmZpZz1yfXRvU3RyaW5nKCl7bGV0e2NvbmZpZzpyfT10aGlzLHQ9ci5wcm92aWRlci5mcm9tRW52VmFyP2BlbnYoXCIke3IucHJvdmlkZXIuZnJvbUVudlZhcn1cIilgOnIucHJvdmlkZXIudmFsdWUsbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHtwcm92aWRlcjp0LGJpbmFyeVRhcmdldHM6TWMoci5iaW5hcnlUYXJnZXRzKX0pKTtyZXR1cm5gZ2VuZXJhdG9yICR7ci5uYW1lfSB7XG4keygwLGhzLmRlZmF1bHQpKCRjKG4pLDIpfVxufWB9fTtmdW5jdGlvbiBNYyhlKXtsZXQgcjtpZihlLmxlbmd0aD4wKXtsZXQgdD1lLmZpbmQobj0+bi5mcm9tRW52VmFyIT09bnVsbCk7dD9yPWBlbnYoXCIke3QuZnJvbUVudlZhcn1cIilgOnI9ZS5tYXAobj0+bi5uYXRpdmU/XCJuYXRpdmVcIjpuLnZhbHVlKX1lbHNlIHI9dm9pZCAwO3JldHVybiByfWZ1bmN0aW9uICRjKGUpe2xldCByPU9iamVjdC5rZXlzKGUpLnJlZHVjZSgodCxuKT0+TWF0aC5tYXgodCxuLmxlbmd0aCksMCk7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLm1hcCgoW3Qsbl0pPT5gJHt0LnBhZEVuZChyKX0gPSAke3FjKG4pfWApLmpvaW4oYFxuYCl9ZnVuY3Rpb24gcWMoZSl7cmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSwocix0KT0+QXJyYXkuaXNBcnJheSh0KT9gWyR7dC5tYXAobj0+SlNPTi5zdHJpbmdpZnkobikpLmpvaW4oXCIsIFwiKX1dYDpKU09OLnN0cmluZ2lmeSh0KSkpfXZhciBydD17fTtncihydCx7ZXJyb3I6KCk9PkJjLGluZm86KCk9PlZjLGxvZzooKT0+amMscXVlcnk6KCk9PlVjLHNob3VsZDooKT0+eXMsdGFnczooKT0+ZXQsd2FybjooKT0+VGl9KTt2YXIgZXQ9e2Vycm9yOnVlKFwicHJpc21hOmVycm9yXCIpLHdhcm46SWUoXCJwcmlzbWE6d2FyblwiKSxpbmZvOmtlKFwicHJpc21hOmluZm9cIikscXVlcnk6dHIoXCJwcmlzbWE6cXVlcnlcIil9LHlzPXt3YXJuOigpPT4hcHJvY2Vzcy5lbnYuUFJJU01BX0RJU0FCTEVfV0FSTklOR1N9O2Z1bmN0aW9uIGpjKC4uLmUpe2NvbnNvbGUubG9nKC4uLmUpfWZ1bmN0aW9uIFRpKGUsLi4ucil7eXMud2FybigpJiZjb25zb2xlLndhcm4oYCR7ZXQud2Fybn0gJHtlfWAsLi4ucil9ZnVuY3Rpb24gVmMoZSwuLi5yKXtjb25zb2xlLmluZm8oYCR7ZXQuaW5mb30gJHtlfWAsLi4ucil9ZnVuY3Rpb24gQmMoZSwuLi5yKXtjb25zb2xlLmVycm9yKGAke2V0LmVycm9yfSAke2V9YCwuLi5yKX1mdW5jdGlvbiBVYyhlLC4uLnIpe2NvbnNvbGUubG9nKGAke2V0LnF1ZXJ5fSAke2V9YCwuLi5yKX1mdW5jdGlvbiBybihlLHIpe2lmKCFlKXRocm93IG5ldyBFcnJvcihgJHtyfS4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiBJZiB5b3Ugc2VlIHRoaXMgZXJyb3IsIHBsZWFzZSwgb3BlbiBhbiBpc3N1ZSBhdCBodHRwczovL3ByaXMubHkvcHJpc21hLXByaXNtYS1idWctcmVwb3J0YCl9ZnVuY3Rpb24gX2UoZSxyKXt0aHJvdyBuZXcgRXJyb3Iocil9aW1wb3J0IHRuIGZyb21cIm5vZGU6cGF0aFwiO2Z1bmN0aW9uIFJpKGUpe3JldHVybiB0bi5zZXA9PT10bi5wb3NpeC5zZXA/ZTplLnNwbGl0KHRuLnNlcCkuam9pbih0bi5wb3NpeC5zZXApfXZhciBEaT1uZShScygpKTtpbXBvcnQgSWkgZnJvbVwibm9kZTpmc1wiO2ltcG9ydCBudCBmcm9tXCJub2RlOnBhdGhcIjtmdW5jdGlvbiBBcyhlKXtsZXQgcj1lLmlnbm9yZVByb2Nlc3NFbnY/e306cHJvY2Vzcy5lbnYsdD1uPT5uLm1hdGNoKC8oLj9cXCR7KD86W2EtekEtWjAtOV9dKyk/fSkvZyk/LnJlZHVjZShmdW5jdGlvbihvLHMpe2xldCBhPS8oLj8pXFwkeyhbYS16QS1aMC05X10rKT99L2cuZXhlYyhzKTtpZighYSlyZXR1cm4gbztsZXQgbD1hWzFdLHUsYztpZihsPT09XCJcXFxcXCIpYz1hWzBdLHU9Yy5yZXBsYWNlKFwiXFxcXCRcIixcIiRcIik7ZWxzZXtsZXQgcD1hWzJdO2M9YVswXS5zdWJzdHJpbmcobC5sZW5ndGgpLHU9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixwKT9yW3BdOmUucGFyc2VkW3BdfHxcIlwiLHU9dCh1KX1yZXR1cm4gby5yZXBsYWNlKGMsdSl9LG4pPz9uO2ZvcihsZXQgbiBpbiBlLnBhcnNlZCl7bGV0IGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixuKT9yW25dOmUucGFyc2VkW25dO2UucGFyc2VkW25dPXQoaSl9Zm9yKGxldCBuIGluIGUucGFyc2VkKXJbbl09ZS5wYXJzZWRbbl07cmV0dXJuIGV9dmFyIGtpPWhyKFwicHJpc21hOnRyeUxvYWRFbnZcIik7ZnVuY3Rpb24gaXQoe3Jvb3RFbnZQYXRoOmUsc2NoZW1hRW52UGF0aDpyfSx0PXtjb25mbGljdENoZWNrOlwibm9uZVwifSl7bGV0IG49Q3MoZSk7dC5jb25mbGljdENoZWNrIT09XCJub25lXCImJm9wKG4scix0LmNvbmZsaWN0Q2hlY2spO2xldCBpPW51bGw7cmV0dXJuIElzKG4/LnBhdGgscil8fChpPUNzKHIpKSwhbiYmIWkmJmtpKFwiTm8gRW52aXJvbm1lbnQgdmFyaWFibGVzIGxvYWRlZFwiKSxpPy5kb3RlbnZSZXN1bHQuZXJyb3I/Y29uc29sZS5lcnJvcih1ZShRKFwiU2NoZW1hIEVudiBFcnJvcjogXCIpKStpLmRvdGVudlJlc3VsdC5lcnJvcik6e21lc3NhZ2U6W24/Lm1lc3NhZ2UsaT8ubWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oYFxuYCkscGFyc2VkOnsuLi5uPy5kb3RlbnZSZXN1bHQ/LnBhcnNlZCwuLi5pPy5kb3RlbnZSZXN1bHQ/LnBhcnNlZH19fWZ1bmN0aW9uIG9wKGUscix0KXtsZXQgbj1lPy5kb3RlbnZSZXN1bHQucGFyc2VkLGk9IUlzKGU/LnBhdGgscik7aWYobiYmciYmaSYmSWkuZXhpc3RzU3luYyhyKSl7bGV0IG89RGkuZGVmYXVsdC5wYXJzZShJaS5yZWFkRmlsZVN5bmMocikpLHM9W107Zm9yKGxldCBhIGluIG8pblthXT09PW9bYV0mJnMucHVzaChhKTtpZihzLmxlbmd0aD4wKXtsZXQgYT1udC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLGUucGF0aCksbD1udC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLHIpO2lmKHQ9PT1cImVycm9yXCIpe2xldCB1PWBUaGVyZSBpcyBhIGNvbmZsaWN0IGJldHdlZW4gZW52IHZhciR7cy5sZW5ndGg+MT9cInNcIjpcIlwifSBpbiAke0soYSl9IGFuZCAke0sobCl9XG5Db25mbGljdGluZyBlbnYgdmFyczpcbiR7cy5tYXAoYz0+YCAgJHtRKGMpfWApLmpvaW4oYFxuYCl9XG5cbldlIHN1Z2dlc3QgdG8gbW92ZSB0aGUgY29udGVudHMgb2YgJHtLKGwpfSB0byAke0soYSl9IHRvIGNvbnNvbGlkYXRlIHlvdXIgZW52IHZhcnMuXG5gO3Rocm93IG5ldyBFcnJvcih1KX1lbHNlIGlmKHQ9PT1cIndhcm5cIil7bGV0IHU9YENvbmZsaWN0IGZvciBlbnYgdmFyJHtzLmxlbmd0aD4xP1wic1wiOlwiXCJ9ICR7cy5tYXAoYz0+UShjKSkuam9pbihcIiwgXCIpfSBpbiAke0soYSl9IGFuZCAke0sobCl9XG5FbnYgdmFycyBmcm9tICR7SyhsKX0gb3ZlcndyaXRlIHRoZSBvbmVzIGZyb20gJHtLKGEpfVxuICAgICAgYDtjb25zb2xlLndhcm4oYCR7SWUoXCJ3YXJuKHByaXNtYSlcIil9ICR7dX1gKX19fX1mdW5jdGlvbiBDcyhlKXtpZihzcChlKSl7a2koYEVudmlyb25tZW50IHZhcmlhYmxlcyBsb2FkZWQgZnJvbSAke2V9YCk7bGV0IHI9RGkuZGVmYXVsdC5jb25maWcoe3BhdGg6ZSxkZWJ1Zzpwcm9jZXNzLmVudi5ET1RFTlZfQ09ORklHX0RFQlVHPyEwOnZvaWQgMH0pO3JldHVybntkb3RlbnZSZXN1bHQ6QXMociksbWVzc2FnZTpDZShgRW52aXJvbm1lbnQgdmFyaWFibGVzIGxvYWRlZCBmcm9tICR7bnQucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSxlKX1gKSxwYXRoOmV9fWVsc2Uga2koYEVudmlyb25tZW50IHZhcmlhYmxlcyBub3QgZm91bmQgYXQgJHtlfWApO3JldHVybiBudWxsfWZ1bmN0aW9uIElzKGUscil7cmV0dXJuIGUmJnImJm50LnJlc29sdmUoZSk9PT1udC5yZXNvbHZlKHIpfWZ1bmN0aW9uIHNwKGUpe3JldHVybiEhKGUmJklpLmV4aXN0c1N5bmMoZSkpfWZ1bmN0aW9uIE9pKGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfWZ1bmN0aW9uIHhyKGUscil7bGV0IHQ9e307Zm9yKGxldCBuIG9mIE9iamVjdC5rZXlzKGUpKXRbbl09cihlW25dLG4pO3JldHVybiB0fWZ1bmN0aW9uIF9pKGUscil7aWYoZS5sZW5ndGg9PT0wKXJldHVybjtsZXQgdD1lWzBdO2ZvcihsZXQgbj0xO248ZS5sZW5ndGg7bisrKXIodCxlW25dKTwwJiYodD1lW25dKTtyZXR1cm4gdH1mdW5jdGlvbiB4KGUscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJuYW1lXCIse3ZhbHVlOnIsY29uZmlndXJhYmxlOiEwfSl9dmFyIERzPW5ldyBTZXQsb249KGUsciwuLi50KT0+e0RzLmhhcyhlKXx8KERzLmFkZChlKSxUaShyLC4uLnQpKX07dmFyIFQ9Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NsaWVudFZlcnNpb247ZXJyb3JDb2RlO3JldHJ5YWJsZTtjb25zdHJ1Y3RvcihyLHQsbil7c3VwZXIociksdGhpcy5uYW1lPVwiUHJpc21hQ2xpZW50SW5pdGlhbGl6YXRpb25FcnJvclwiLHRoaXMuY2xpZW50VmVyc2lvbj10LHRoaXMuZXJyb3JDb2RlPW4sRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm5cIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIn19O3goVCxcIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3JcIik7dmFyIFo9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb2RlO21ldGE7Y2xpZW50VmVyc2lvbjtiYXRjaFJlcXVlc3RJZHg7Y29uc3RydWN0b3Iocix7Y29kZTp0LGNsaWVudFZlcnNpb246bixtZXRhOmksYmF0Y2hSZXF1ZXN0SWR4Om99KXtzdXBlcihyKSx0aGlzLm5hbWU9XCJQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvclwiLHRoaXMuY29kZT10LHRoaXMuY2xpZW50VmVyc2lvbj1uLHRoaXMubWV0YT1pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiYmF0Y2hSZXF1ZXN0SWR4XCIse3ZhbHVlOm8sZW51bWVyYWJsZTohMSx3cml0YWJsZTohMH0pfWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvclwifX07eChaLFwiUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3JcIik7dmFyIGRlPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y2xpZW50VmVyc2lvbjtjb25zdHJ1Y3RvcihyLHQpe3N1cGVyKHIpLHRoaXMubmFtZT1cIlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXCIsdGhpcy5jbGllbnRWZXJzaW9uPXR9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm5cIlByaXNtYUNsaWVudFJ1c3RQYW5pY0Vycm9yXCJ9fTt4KGRlLFwiUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3JcIik7dmFyIHE9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjbGllbnRWZXJzaW9uO2JhdGNoUmVxdWVzdElkeDtjb25zdHJ1Y3RvcihyLHtjbGllbnRWZXJzaW9uOnQsYmF0Y2hSZXF1ZXN0SWR4Om59KXtzdXBlcihyKSx0aGlzLm5hbWU9XCJQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yXCIsdGhpcy5jbGllbnRWZXJzaW9uPXQsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJiYXRjaFJlcXVlc3RJZHhcIix7dmFsdWU6bix3cml0YWJsZTohMCxlbnVtZXJhYmxlOiExfSl9Z2V0W1N5bWJvbC50b1N0cmluZ1RhZ10oKXtyZXR1cm5cIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIn19O3gocSxcIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3JcIik7dmFyIFg9Y2xhc3MgZXh0ZW5kcyBFcnJvcntuYW1lPVwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCI7Y2xpZW50VmVyc2lvbjtjb25zdHJ1Y3RvcihyLHtjbGllbnRWZXJzaW9uOnR9KXtzdXBlcihyKSx0aGlzLmNsaWVudFZlcnNpb249dH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yXCJ9fTt4KFgsXCJQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3JcIik7dmFyIHZyPTllMTUsS2U9MWU5LE5pPVwiMDEyMzQ1Njc4OWFiY2RlZlwiLHVuPVwiMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4XCIsY249XCIzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODlcIixMaT17cHJlY2lzaW9uOjIwLHJvdW5kaW5nOjQsbW9kdWxvOjEsdG9FeHBOZWc6LTcsdG9FeHBQb3M6MjEsbWluRTotdnIsbWF4RTp2cixjcnlwdG86ITF9LExzLExlLHc9ITAsZG49XCJbRGVjaW1hbEVycm9yXSBcIixIZT1kbitcIkludmFsaWQgYXJndW1lbnQ6IFwiLEZzPWRuK1wiUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkXCIsTXM9ZG4rXCJjcnlwdG8gdW5hdmFpbGFibGVcIiwkcz1cIltvYmplY3QgRGVjaW1hbF1cIixZPU1hdGguZmxvb3IsQj1NYXRoLnBvdyxhcD0vXjBiKFswMV0rKFxcLlswMV0qKT98XFwuWzAxXSspKHBbKy1dP1xcZCspPyQvaSxscD0vXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSx1cD0vXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxxcz0vXihcXGQrKFxcLlxcZCopP3xcXC5cXGQrKShlWystXT9cXGQrKT8kL2ksZmU9MWU3LEU9NyxjcD05MDA3MTk5MjU0NzQwOTkxLHBwPXVuLmxlbmd0aC0xLEZpPWNuLmxlbmd0aC0xLG09e3RvU3RyaW5nVGFnOiRzfTttLmFic29sdXRlVmFsdWU9bS5hYnM9ZnVuY3Rpb24oKXt2YXIgZT1uZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtyZXR1cm4gZS5zPDAmJihlLnM9MSkseShlKX07bS5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIHkobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksdGhpcy5lKzEsMil9O20uY2xhbXBlZFRvPW0uY2xhbXA9ZnVuY3Rpb24oZSxyKXt2YXIgdCxuPXRoaXMsaT1uLmNvbnN0cnVjdG9yO2lmKGU9bmV3IGkoZSkscj1uZXcgaShyKSwhZS5zfHwhci5zKXJldHVybiBuZXcgaShOYU4pO2lmKGUuZ3QocikpdGhyb3cgRXJyb3IoSGUrcik7cmV0dXJuIHQ9bi5jbXAoZSksdDwwP2U6bi5jbXAocik+MD9yOm5ldyBpKG4pfTttLmNvbXBhcmVkVG89bS5jbXA9ZnVuY3Rpb24oZSl7dmFyIHIsdCxuLGksbz10aGlzLHM9by5kLGE9KGU9bmV3IG8uY29uc3RydWN0b3IoZSkpLmQsbD1vLnMsdT1lLnM7aWYoIXN8fCFhKXJldHVybiFsfHwhdT9OYU46bCE9PXU/bDpzPT09YT8wOiFzXmw8MD8xOi0xO2lmKCFzWzBdfHwhYVswXSlyZXR1cm4gc1swXT9sOmFbMF0/LXU6MDtpZihsIT09dSlyZXR1cm4gbDtpZihvLmUhPT1lLmUpcmV0dXJuIG8uZT5lLmVebDwwPzE6LTE7Zm9yKG49cy5sZW5ndGgsaT1hLmxlbmd0aCxyPTAsdD1uPGk/bjppO3I8dDsrK3IpaWYoc1tyXSE9PWFbcl0pcmV0dXJuIHNbcl0+YVtyXV5sPDA/MTotMTtyZXR1cm4gbj09PWk/MDpuPmlebDwwPzE6LTF9O20uY29zaW5lPW0uY29zPWZ1bmN0aW9uKCl7dmFyIGUscix0PXRoaXMsbj10LmNvbnN0cnVjdG9yO3JldHVybiB0LmQ/dC5kWzBdPyhlPW4ucHJlY2lzaW9uLHI9bi5yb3VuZGluZyxuLnByZWNpc2lvbj1lK01hdGgubWF4KHQuZSx0LnNkKCkpK0Usbi5yb3VuZGluZz0xLHQ9ZHAobixHcyhuLHQpKSxuLnByZWNpc2lvbj1lLG4ucm91bmRpbmc9cix5KExlPT0yfHxMZT09Mz90Lm5lZygpOnQsZSxyLCEwKSk6bmV3IG4oMSk6bmV3IG4oTmFOKX07bS5jdWJlUm9vdD1tLmNicnQ9ZnVuY3Rpb24oKXt2YXIgZSxyLHQsbixpLG8scyxhLGwsdSxjPXRoaXMscD1jLmNvbnN0cnVjdG9yO2lmKCFjLmlzRmluaXRlKCl8fGMuaXNaZXJvKCkpcmV0dXJuIG5ldyBwKGMpO2Zvcih3PSExLG89Yy5zKkIoYy5zKmMsMS8zKSwhb3x8TWF0aC5hYnMobyk9PTEvMD8odD1XKGMuZCksZT1jLmUsKG89KGUtdC5sZW5ndGgrMSklMykmJih0Kz1vPT0xfHxvPT0tMj9cIjBcIjpcIjAwXCIpLG89Qih0LDEvMyksZT1ZKChlKzEpLzMpLShlJTM9PShlPDA/LTE6MikpLG89PTEvMD90PVwiNWVcIitlOih0PW8udG9FeHBvbmVudGlhbCgpLHQ9dC5zbGljZSgwLHQuaW5kZXhPZihcImVcIikrMSkrZSksbj1uZXcgcCh0KSxuLnM9Yy5zKTpuPW5ldyBwKG8udG9TdHJpbmcoKSkscz0oZT1wLnByZWNpc2lvbikrMzs7KWlmKGE9bixsPWEudGltZXMoYSkudGltZXMoYSksdT1sLnBsdXMoYyksbj1fKHUucGx1cyhjKS50aW1lcyhhKSx1LnBsdXMobCkscysyLDEpLFcoYS5kKS5zbGljZSgwLHMpPT09KHQ9VyhuLmQpKS5zbGljZSgwLHMpKWlmKHQ9dC5zbGljZShzLTMscysxKSx0PT1cIjk5OTlcInx8IWkmJnQ9PVwiNDk5OVwiKXtpZighaSYmKHkoYSxlKzEsMCksYS50aW1lcyhhKS50aW1lcyhhKS5lcShjKSkpe249YTticmVha31zKz00LGk9MX1lbHNleyghK3R8fCErdC5zbGljZSgxKSYmdC5jaGFyQXQoMCk9PVwiNVwiKSYmKHkobixlKzEsMSkscj0hbi50aW1lcyhuKS50aW1lcyhuKS5lcShjKSk7YnJlYWt9cmV0dXJuIHc9ITAseShuLGUscC5yb3VuZGluZyxyKX07bS5kZWNpbWFsUGxhY2VzPW0uZHA9ZnVuY3Rpb24oKXt2YXIgZSxyPXRoaXMuZCx0PU5hTjtpZihyKXtpZihlPXIubGVuZ3RoLTEsdD0oZS1ZKHRoaXMuZS9FKSkqRSxlPXJbZV0sZSlmb3IoO2UlMTA9PTA7ZS89MTApdC0tO3Q8MCYmKHQ9MCl9cmV0dXJuIHR9O20uZGl2aWRlZEJ5PW0uZGl2PWZ1bmN0aW9uKGUpe3JldHVybiBfKHRoaXMsbmV3IHRoaXMuY29uc3RydWN0b3IoZSkpfTttLmRpdmlkZWRUb0ludGVnZXJCeT1tLmRpdlRvSW50PWZ1bmN0aW9uKGUpe3ZhciByPXRoaXMsdD1yLmNvbnN0cnVjdG9yO3JldHVybiB5KF8ocixuZXcgdChlKSwwLDEsMSksdC5wcmVjaXNpb24sdC5yb3VuZGluZyl9O20uZXF1YWxzPW0uZXE9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY21wKGUpPT09MH07bS5mbG9vcj1mdW5jdGlvbigpe3JldHVybiB5KG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLHRoaXMuZSsxLDMpfTttLmdyZWF0ZXJUaGFuPW0uZ3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuY21wKGUpPjB9O20uZ3JlYXRlclRoYW5PckVxdWFsVG89bS5ndGU9ZnVuY3Rpb24oZSl7dmFyIHI9dGhpcy5jbXAoZSk7cmV0dXJuIHI9PTF8fHI9PT0wfTttLmh5cGVyYm9saWNDb3NpbmU9bS5jb3NoPWZ1bmN0aW9uKCl7dmFyIGUscix0LG4saSxvPXRoaXMscz1vLmNvbnN0cnVjdG9yLGE9bmV3IHMoMSk7aWYoIW8uaXNGaW5pdGUoKSlyZXR1cm4gbmV3IHMoby5zPzEvMDpOYU4pO2lmKG8uaXNaZXJvKCkpcmV0dXJuIGE7dD1zLnByZWNpc2lvbixuPXMucm91bmRpbmcscy5wcmVjaXNpb249dCtNYXRoLm1heChvLmUsby5zZCgpKSs0LHMucm91bmRpbmc9MSxpPW8uZC5sZW5ndGgsaTwzMj8oZT1NYXRoLmNlaWwoaS8zKSxyPSgxL2ZuKDQsZSkpLnRvU3RyaW5nKCkpOihlPTE2LHI9XCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCIpLG89UHIocywxLG8udGltZXMociksbmV3IHMoMSksITApO2Zvcih2YXIgbCx1PWUsYz1uZXcgcyg4KTt1LS07KWw9by50aW1lcyhvKSxvPWEubWludXMobC50aW1lcyhjLm1pbnVzKGwudGltZXMoYykpKSk7cmV0dXJuIHkobyxzLnByZWNpc2lvbj10LHMucm91bmRpbmc9biwhMCl9O20uaHlwZXJib2xpY1NpbmU9bS5zaW5oPWZ1bmN0aW9uKCl7dmFyIGUscix0LG4saT10aGlzLG89aS5jb25zdHJ1Y3RvcjtpZighaS5pc0Zpbml0ZSgpfHxpLmlzWmVybygpKXJldHVybiBuZXcgbyhpKTtpZihyPW8ucHJlY2lzaW9uLHQ9by5yb3VuZGluZyxvLnByZWNpc2lvbj1yK01hdGgubWF4KGkuZSxpLnNkKCkpKzQsby5yb3VuZGluZz0xLG49aS5kLmxlbmd0aCxuPDMpaT1QcihvLDIsaSxpLCEwKTtlbHNle2U9MS40Kk1hdGguc3FydChuKSxlPWU+MTY/MTY6ZXwwLGk9aS50aW1lcygxL2ZuKDUsZSkpLGk9UHIobywyLGksaSwhMCk7Zm9yKHZhciBzLGE9bmV3IG8oNSksbD1uZXcgbygxNiksdT1uZXcgbygyMCk7ZS0tOylzPWkudGltZXMoaSksaT1pLnRpbWVzKGEucGx1cyhzLnRpbWVzKGwudGltZXMocykucGx1cyh1KSkpKX1yZXR1cm4gby5wcmVjaXNpb249cixvLnJvdW5kaW5nPXQseShpLHIsdCwhMCl9O20uaHlwZXJib2xpY1RhbmdlbnQ9bS50YW5oPWZ1bmN0aW9uKCl7dmFyIGUscix0PXRoaXMsbj10LmNvbnN0cnVjdG9yO3JldHVybiB0LmlzRmluaXRlKCk/dC5pc1plcm8oKT9uZXcgbih0KTooZT1uLnByZWNpc2lvbixyPW4ucm91bmRpbmcsbi5wcmVjaXNpb249ZSs3LG4ucm91bmRpbmc9MSxfKHQuc2luaCgpLHQuY29zaCgpLG4ucHJlY2lzaW9uPWUsbi5yb3VuZGluZz1yKSk6bmV3IG4odC5zKX07bS5pbnZlcnNlQ29zaW5lPW0uYWNvcz1mdW5jdGlvbigpe3ZhciBlPXRoaXMscj1lLmNvbnN0cnVjdG9yLHQ9ZS5hYnMoKS5jbXAoMSksbj1yLnByZWNpc2lvbixpPXIucm91bmRpbmc7cmV0dXJuIHQhPT0tMT90PT09MD9lLmlzTmVnKCk/d2UocixuLGkpOm5ldyByKDApOm5ldyByKE5hTik6ZS5pc1plcm8oKT93ZShyLG4rNCxpKS50aW1lcyguNSk6KHIucHJlY2lzaW9uPW4rNixyLnJvdW5kaW5nPTEsZT1uZXcgcigxKS5taW51cyhlKS5kaXYoZS5wbHVzKDEpKS5zcXJ0KCkuYXRhbigpLHIucHJlY2lzaW9uPW4sci5yb3VuZGluZz1pLGUudGltZXMoMikpfTttLmludmVyc2VIeXBlcmJvbGljQ29zaW5lPW0uYWNvc2g9ZnVuY3Rpb24oKXt2YXIgZSxyLHQ9dGhpcyxuPXQuY29uc3RydWN0b3I7cmV0dXJuIHQubHRlKDEpP25ldyBuKHQuZXEoMSk/MDpOYU4pOnQuaXNGaW5pdGUoKT8oZT1uLnByZWNpc2lvbixyPW4ucm91bmRpbmcsbi5wcmVjaXNpb249ZStNYXRoLm1heChNYXRoLmFicyh0LmUpLHQuc2QoKSkrNCxuLnJvdW5kaW5nPTEsdz0hMSx0PXQudGltZXModCkubWludXMoMSkuc3FydCgpLnBsdXModCksdz0hMCxuLnByZWNpc2lvbj1lLG4ucm91bmRpbmc9cix0LmxuKCkpOm5ldyBuKHQpfTttLmludmVyc2VIeXBlcmJvbGljU2luZT1tLmFzaW5oPWZ1bmN0aW9uKCl7dmFyIGUscix0PXRoaXMsbj10LmNvbnN0cnVjdG9yO3JldHVybiF0LmlzRmluaXRlKCl8fHQuaXNaZXJvKCk/bmV3IG4odCk6KGU9bi5wcmVjaXNpb24scj1uLnJvdW5kaW5nLG4ucHJlY2lzaW9uPWUrMipNYXRoLm1heChNYXRoLmFicyh0LmUpLHQuc2QoKSkrNixuLnJvdW5kaW5nPTEsdz0hMSx0PXQudGltZXModCkucGx1cygxKS5zcXJ0KCkucGx1cyh0KSx3PSEwLG4ucHJlY2lzaW9uPWUsbi5yb3VuZGluZz1yLHQubG4oKSl9O20uaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50PW0uYXRhbmg9ZnVuY3Rpb24oKXt2YXIgZSxyLHQsbixpPXRoaXMsbz1pLmNvbnN0cnVjdG9yO3JldHVybiBpLmlzRmluaXRlKCk/aS5lPj0wP25ldyBvKGkuYWJzKCkuZXEoMSk/aS5zLzA6aS5pc1plcm8oKT9pOk5hTik6KGU9by5wcmVjaXNpb24scj1vLnJvdW5kaW5nLG49aS5zZCgpLE1hdGgubWF4KG4sZSk8MiotaS5lLTE/eShuZXcgbyhpKSxlLHIsITApOihvLnByZWNpc2lvbj10PW4taS5lLGk9XyhpLnBsdXMoMSksbmV3IG8oMSkubWludXMoaSksdCtlLDEpLG8ucHJlY2lzaW9uPWUrNCxvLnJvdW5kaW5nPTEsaT1pLmxuKCksby5wcmVjaXNpb249ZSxvLnJvdW5kaW5nPXIsaS50aW1lcyguNSkpKTpuZXcgbyhOYU4pfTttLmludmVyc2VTaW5lPW0uYXNpbj1mdW5jdGlvbigpe3ZhciBlLHIsdCxuLGk9dGhpcyxvPWkuY29uc3RydWN0b3I7cmV0dXJuIGkuaXNaZXJvKCk/bmV3IG8oaSk6KHI9aS5hYnMoKS5jbXAoMSksdD1vLnByZWNpc2lvbixuPW8ucm91bmRpbmcsciE9PS0xP3I9PT0wPyhlPXdlKG8sdCs0LG4pLnRpbWVzKC41KSxlLnM9aS5zLGUpOm5ldyBvKE5hTik6KG8ucHJlY2lzaW9uPXQrNixvLnJvdW5kaW5nPTEsaT1pLmRpdihuZXcgbygxKS5taW51cyhpLnRpbWVzKGkpKS5zcXJ0KCkucGx1cygxKSkuYXRhbigpLG8ucHJlY2lzaW9uPXQsby5yb3VuZGluZz1uLGkudGltZXMoMikpKX07bS5pbnZlcnNlVGFuZ2VudD1tLmF0YW49ZnVuY3Rpb24oKXt2YXIgZSxyLHQsbixpLG8scyxhLGwsdT10aGlzLGM9dS5jb25zdHJ1Y3RvcixwPWMucHJlY2lzaW9uLGQ9Yy5yb3VuZGluZztpZih1LmlzRmluaXRlKCkpe2lmKHUuaXNaZXJvKCkpcmV0dXJuIG5ldyBjKHUpO2lmKHUuYWJzKCkuZXEoMSkmJnArNDw9RmkpcmV0dXJuIHM9d2UoYyxwKzQsZCkudGltZXMoLjI1KSxzLnM9dS5zLHN9ZWxzZXtpZighdS5zKXJldHVybiBuZXcgYyhOYU4pO2lmKHArNDw9RmkpcmV0dXJuIHM9d2UoYyxwKzQsZCkudGltZXMoLjUpLHMucz11LnMsc31mb3IoYy5wcmVjaXNpb249YT1wKzEwLGMucm91bmRpbmc9MSx0PU1hdGgubWluKDI4LGEvRSsyfDApLGU9dDtlOy0tZSl1PXUuZGl2KHUudGltZXModSkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7Zm9yKHc9ITEscj1NYXRoLmNlaWwoYS9FKSxuPTEsbD11LnRpbWVzKHUpLHM9bmV3IGModSksaT11O2UhPT0tMTspaWYoaT1pLnRpbWVzKGwpLG89cy5taW51cyhpLmRpdihuKz0yKSksaT1pLnRpbWVzKGwpLHM9by5wbHVzKGkuZGl2KG4rPTIpKSxzLmRbcl0hPT12b2lkIDApZm9yKGU9cjtzLmRbZV09PT1vLmRbZV0mJmUtLTspO3JldHVybiB0JiYocz1zLnRpbWVzKDI8PHQtMSkpLHc9ITAseShzLGMucHJlY2lzaW9uPXAsYy5yb3VuZGluZz1kLCEwKX07bS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5kfTttLmlzSW50ZWdlcj1tLmlzSW50PWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmQmJlkodGhpcy5lL0UpPnRoaXMuZC5sZW5ndGgtMn07bS5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9O20uaXNOZWdhdGl2ZT1tLmlzTmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuczwwfTttLmlzUG9zaXRpdmU9bS5pc1Bvcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnM+MH07bS5pc1plcm89ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMuZCYmdGhpcy5kWzBdPT09MH07bS5sZXNzVGhhbj1tLmx0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNtcChlKTwwfTttLmxlc3NUaGFuT3JFcXVhbFRvPW0ubHRlPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmNtcChlKTwxfTttLmxvZ2FyaXRobT1tLmxvZz1mdW5jdGlvbihlKXt2YXIgcix0LG4saSxvLHMsYSxsLHU9dGhpcyxjPXUuY29uc3RydWN0b3IscD1jLnByZWNpc2lvbixkPWMucm91bmRpbmcsZj01O2lmKGU9PW51bGwpZT1uZXcgYygxMCkscj0hMDtlbHNle2lmKGU9bmV3IGMoZSksdD1lLmQsZS5zPDB8fCF0fHwhdFswXXx8ZS5lcSgxKSlyZXR1cm4gbmV3IGMoTmFOKTtyPWUuZXEoMTApfWlmKHQ9dS5kLHUuczwwfHwhdHx8IXRbMF18fHUuZXEoMSkpcmV0dXJuIG5ldyBjKHQmJiF0WzBdPy0xLzA6dS5zIT0xP05hTjp0PzA6MS8wKTtpZihyKWlmKHQubGVuZ3RoPjEpbz0hMDtlbHNle2ZvcihpPXRbMF07aSUxMD09PTA7KWkvPTEwO289aSE9PTF9aWYodz0hMSxhPXArZixzPUplKHUsYSksbj1yP3BuKGMsYSsxMCk6SmUoZSxhKSxsPV8ocyxuLGEsMSksb3QobC5kLGk9cCxkKSlkbyBpZihhKz0xMCxzPUplKHUsYSksbj1yP3BuKGMsYSsxMCk6SmUoZSxhKSxsPV8ocyxuLGEsMSksIW8peytXKGwuZCkuc2xpY2UoaSsxLGkrMTUpKzE9PTFlMTQmJihsPXkobCxwKzEsMCkpO2JyZWFrfXdoaWxlKG90KGwuZCxpKz0xMCxkKSk7cmV0dXJuIHc9ITAseShsLHAsZCl9O20ubWludXM9bS5zdWI9ZnVuY3Rpb24oZSl7dmFyIHIsdCxuLGksbyxzLGEsbCx1LGMscCxkLGY9dGhpcyxoPWYuY29uc3RydWN0b3I7aWYoZT1uZXcgaChlKSwhZi5kfHwhZS5kKXJldHVybiFmLnN8fCFlLnM/ZT1uZXcgaChOYU4pOmYuZD9lLnM9LWUuczplPW5ldyBoKGUuZHx8Zi5zIT09ZS5zP2Y6TmFOKSxlO2lmKGYucyE9ZS5zKXJldHVybiBlLnM9LWUucyxmLnBsdXMoZSk7aWYodT1mLmQsZD1lLmQsYT1oLnByZWNpc2lvbixsPWgucm91bmRpbmcsIXVbMF18fCFkWzBdKXtpZihkWzBdKWUucz0tZS5zO2Vsc2UgaWYodVswXSllPW5ldyBoKGYpO2Vsc2UgcmV0dXJuIG5ldyBoKGw9PT0zPy0wOjApO3JldHVybiB3P3koZSxhLGwpOmV9aWYodD1ZKGUuZS9FKSxjPVkoZi5lL0UpLHU9dS5zbGljZSgpLG89Yy10LG8pe2ZvcihwPW88MCxwPyhyPXUsbz0tbyxzPWQubGVuZ3RoKToocj1kLHQ9YyxzPXUubGVuZ3RoKSxuPU1hdGgubWF4KE1hdGguY2VpbChhL0UpLHMpKzIsbz5uJiYobz1uLHIubGVuZ3RoPTEpLHIucmV2ZXJzZSgpLG49bztuLS07KXIucHVzaCgwKTtyLnJldmVyc2UoKX1lbHNle2ZvcihuPXUubGVuZ3RoLHM9ZC5sZW5ndGgscD1uPHMscCYmKHM9biksbj0wO248cztuKyspaWYodVtuXSE9ZFtuXSl7cD11W25dPGRbbl07YnJlYWt9bz0wfWZvcihwJiYocj11LHU9ZCxkPXIsZS5zPS1lLnMpLHM9dS5sZW5ndGgsbj1kLmxlbmd0aC1zO24+MDstLW4pdVtzKytdPTA7Zm9yKG49ZC5sZW5ndGg7bj5vOyl7aWYodVstLW5dPGRbbl0pe2ZvcihpPW47aSYmdVstLWldPT09MDspdVtpXT1mZS0xOy0tdVtpXSx1W25dKz1mZX11W25dLT1kW25dfWZvcig7dVstLXNdPT09MDspdS5wb3AoKTtmb3IoO3VbMF09PT0wO3Uuc2hpZnQoKSktLXQ7cmV0dXJuIHVbMF0/KGUuZD11LGUuZT1tbih1LHQpLHc/eShlLGEsbCk6ZSk6bmV3IGgobD09PTM/LTA6MCl9O20ubW9kdWxvPW0ubW9kPWZ1bmN0aW9uKGUpe3ZhciByLHQ9dGhpcyxuPXQuY29uc3RydWN0b3I7cmV0dXJuIGU9bmV3IG4oZSksIXQuZHx8IWUuc3x8ZS5kJiYhZS5kWzBdP25ldyBuKE5hTik6IWUuZHx8dC5kJiYhdC5kWzBdP3kobmV3IG4odCksbi5wcmVjaXNpb24sbi5yb3VuZGluZyk6KHc9ITEsbi5tb2R1bG89PTk/KHI9Xyh0LGUuYWJzKCksMCwzLDEpLHIucyo9ZS5zKTpyPV8odCxlLDAsbi5tb2R1bG8sMSkscj1yLnRpbWVzKGUpLHc9ITAsdC5taW51cyhyKSl9O20ubmF0dXJhbEV4cG9uZW50aWFsPW0uZXhwPWZ1bmN0aW9uKCl7cmV0dXJuIE1pKHRoaXMpfTttLm5hdHVyYWxMb2dhcml0aG09bS5sbj1mdW5jdGlvbigpe3JldHVybiBKZSh0aGlzKX07bS5uZWdhdGVkPW0ubmVnPWZ1bmN0aW9uKCl7dmFyIGU9bmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7cmV0dXJuIGUucz0tZS5zLHkoZSl9O20ucGx1cz1tLmFkZD1mdW5jdGlvbihlKXt2YXIgcix0LG4saSxvLHMsYSxsLHUsYyxwPXRoaXMsZD1wLmNvbnN0cnVjdG9yO2lmKGU9bmV3IGQoZSksIXAuZHx8IWUuZClyZXR1cm4hcC5zfHwhZS5zP2U9bmV3IGQoTmFOKTpwLmR8fChlPW5ldyBkKGUuZHx8cC5zPT09ZS5zP3A6TmFOKSksZTtpZihwLnMhPWUucylyZXR1cm4gZS5zPS1lLnMscC5taW51cyhlKTtpZih1PXAuZCxjPWUuZCxhPWQucHJlY2lzaW9uLGw9ZC5yb3VuZGluZywhdVswXXx8IWNbMF0pcmV0dXJuIGNbMF18fChlPW5ldyBkKHApKSx3P3koZSxhLGwpOmU7aWYobz1ZKHAuZS9FKSxuPVkoZS5lL0UpLHU9dS5zbGljZSgpLGk9by1uLGkpe2ZvcihpPDA/KHQ9dSxpPS1pLHM9Yy5sZW5ndGgpOih0PWMsbj1vLHM9dS5sZW5ndGgpLG89TWF0aC5jZWlsKGEvRSkscz1vPnM/bysxOnMrMSxpPnMmJihpPXMsdC5sZW5ndGg9MSksdC5yZXZlcnNlKCk7aS0tOyl0LnB1c2goMCk7dC5yZXZlcnNlKCl9Zm9yKHM9dS5sZW5ndGgsaT1jLmxlbmd0aCxzLWk8MCYmKGk9cyx0PWMsYz11LHU9dCkscj0wO2k7KXI9KHVbLS1pXT11W2ldK2NbaV0rcikvZmV8MCx1W2ldJT1mZTtmb3IociYmKHUudW5zaGlmdChyKSwrK24pLHM9dS5sZW5ndGg7dVstLXNdPT0wOyl1LnBvcCgpO3JldHVybiBlLmQ9dSxlLmU9bW4odSxuKSx3P3koZSxhLGwpOmV9O20ucHJlY2lzaW9uPW0uc2Q9ZnVuY3Rpb24oZSl7dmFyIHIsdD10aGlzO2lmKGUhPT12b2lkIDAmJmUhPT0hIWUmJmUhPT0xJiZlIT09MCl0aHJvdyBFcnJvcihIZStlKTtyZXR1cm4gdC5kPyhyPWpzKHQuZCksZSYmdC5lKzE+ciYmKHI9dC5lKzEpKTpyPU5hTixyfTttLnJvdW5kPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxyPWUuY29uc3RydWN0b3I7cmV0dXJuIHkobmV3IHIoZSksZS5lKzEsci5yb3VuZGluZyl9O20uc2luZT1tLnNpbj1mdW5jdGlvbigpe3ZhciBlLHIsdD10aGlzLG49dC5jb25zdHJ1Y3RvcjtyZXR1cm4gdC5pc0Zpbml0ZSgpP3QuaXNaZXJvKCk/bmV3IG4odCk6KGU9bi5wcmVjaXNpb24scj1uLnJvdW5kaW5nLG4ucHJlY2lzaW9uPWUrTWF0aC5tYXgodC5lLHQuc2QoKSkrRSxuLnJvdW5kaW5nPTEsdD1mcChuLEdzKG4sdCkpLG4ucHJlY2lzaW9uPWUsbi5yb3VuZGluZz1yLHkoTGU+Mj90Lm5lZygpOnQsZSxyLCEwKSk6bmV3IG4oTmFOKX07bS5zcXVhcmVSb290PW0uc3FydD1mdW5jdGlvbigpe3ZhciBlLHIsdCxuLGksbyxzPXRoaXMsYT1zLmQsbD1zLmUsdT1zLnMsYz1zLmNvbnN0cnVjdG9yO2lmKHUhPT0xfHwhYXx8IWFbMF0pcmV0dXJuIG5ldyBjKCF1fHx1PDAmJighYXx8YVswXSk/TmFOOmE/czoxLzApO2Zvcih3PSExLHU9TWF0aC5zcXJ0KCtzKSx1PT0wfHx1PT0xLzA/KHI9VyhhKSwoci5sZW5ndGgrbCklMj09MCYmKHIrPVwiMFwiKSx1PU1hdGguc3FydChyKSxsPVkoKGwrMSkvMiktKGw8MHx8bCUyKSx1PT0xLzA/cj1cIjVlXCIrbDoocj11LnRvRXhwb25lbnRpYWwoKSxyPXIuc2xpY2UoMCxyLmluZGV4T2YoXCJlXCIpKzEpK2wpLG49bmV3IGMocikpOm49bmV3IGModS50b1N0cmluZygpKSx0PShsPWMucHJlY2lzaW9uKSszOzspaWYobz1uLG49by5wbHVzKF8ocyxvLHQrMiwxKSkudGltZXMoLjUpLFcoby5kKS5zbGljZSgwLHQpPT09KHI9VyhuLmQpKS5zbGljZSgwLHQpKWlmKHI9ci5zbGljZSh0LTMsdCsxKSxyPT1cIjk5OTlcInx8IWkmJnI9PVwiNDk5OVwiKXtpZighaSYmKHkobyxsKzEsMCksby50aW1lcyhvKS5lcShzKSkpe249bzticmVha310Kz00LGk9MX1lbHNleyghK3J8fCErci5zbGljZSgxKSYmci5jaGFyQXQoMCk9PVwiNVwiKSYmKHkobixsKzEsMSksZT0hbi50aW1lcyhuKS5lcShzKSk7YnJlYWt9cmV0dXJuIHc9ITAseShuLGwsYy5yb3VuZGluZyxlKX07bS50YW5nZW50PW0udGFuPWZ1bmN0aW9uKCl7dmFyIGUscix0PXRoaXMsbj10LmNvbnN0cnVjdG9yO3JldHVybiB0LmlzRmluaXRlKCk/dC5pc1plcm8oKT9uZXcgbih0KTooZT1uLnByZWNpc2lvbixyPW4ucm91bmRpbmcsbi5wcmVjaXNpb249ZSsxMCxuLnJvdW5kaW5nPTEsdD10LnNpbigpLHQucz0xLHQ9Xyh0LG5ldyBuKDEpLm1pbnVzKHQudGltZXModCkpLnNxcnQoKSxlKzEwLDApLG4ucHJlY2lzaW9uPWUsbi5yb3VuZGluZz1yLHkoTGU9PTJ8fExlPT00P3QubmVnKCk6dCxlLHIsITApKTpuZXcgbihOYU4pfTttLnRpbWVzPW0ubXVsPWZ1bmN0aW9uKGUpe3ZhciByLHQsbixpLG8scyxhLGwsdSxjPXRoaXMscD1jLmNvbnN0cnVjdG9yLGQ9Yy5kLGY9KGU9bmV3IHAoZSkpLmQ7aWYoZS5zKj1jLnMsIWR8fCFkWzBdfHwhZnx8IWZbMF0pcmV0dXJuIG5ldyBwKCFlLnN8fGQmJiFkWzBdJiYhZnx8ZiYmIWZbMF0mJiFkP05hTjohZHx8IWY/ZS5zLzA6ZS5zKjApO2Zvcih0PVkoYy5lL0UpK1koZS5lL0UpLGw9ZC5sZW5ndGgsdT1mLmxlbmd0aCxsPHUmJihvPWQsZD1mLGY9byxzPWwsbD11LHU9cyksbz1bXSxzPWwrdSxuPXM7bi0tOylvLnB1c2goMCk7Zm9yKG49dTstLW4+PTA7KXtmb3Iocj0wLGk9bCtuO2k+bjspYT1vW2ldK2Zbbl0qZFtpLW4tMV0rcixvW2ktLV09YSVmZXwwLHI9YS9mZXwwO29baV09KG9baV0rciklZmV8MH1mb3IoOyFvWy0tc107KW8ucG9wKCk7cmV0dXJuIHI/Kyt0Om8uc2hpZnQoKSxlLmQ9byxlLmU9bW4obyx0KSx3P3koZSxwLnByZWNpc2lvbixwLnJvdW5kaW5nKTplfTttLnRvQmluYXJ5PWZ1bmN0aW9uKGUscil7cmV0dXJuICRpKHRoaXMsMixlLHIpfTttLnRvRGVjaW1hbFBsYWNlcz1tLnRvRFA9ZnVuY3Rpb24oZSxyKXt2YXIgdD10aGlzLG49dC5jb25zdHJ1Y3RvcjtyZXR1cm4gdD1uZXcgbih0KSxlPT09dm9pZCAwP3Q6KGllKGUsMCxLZSkscj09PXZvaWQgMD9yPW4ucm91bmRpbmc6aWUociwwLDgpLHkodCxlK3QuZSsxLHIpKX07bS50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKGUscil7dmFyIHQsbj10aGlzLGk9bi5jb25zdHJ1Y3RvcjtyZXR1cm4gZT09PXZvaWQgMD90PXhlKG4sITApOihpZShlLDAsS2UpLHI9PT12b2lkIDA/cj1pLnJvdW5kaW5nOmllKHIsMCw4KSxuPXkobmV3IGkobiksZSsxLHIpLHQ9eGUobiwhMCxlKzEpKSxuLmlzTmVnKCkmJiFuLmlzWmVybygpP1wiLVwiK3Q6dH07bS50b0ZpeGVkPWZ1bmN0aW9uKGUscil7dmFyIHQsbixpPXRoaXMsbz1pLmNvbnN0cnVjdG9yO3JldHVybiBlPT09dm9pZCAwP3Q9eGUoaSk6KGllKGUsMCxLZSkscj09PXZvaWQgMD9yPW8ucm91bmRpbmc6aWUociwwLDgpLG49eShuZXcgbyhpKSxlK2kuZSsxLHIpLHQ9eGUobiwhMSxlK24uZSsxKSksaS5pc05lZygpJiYhaS5pc1plcm8oKT9cIi1cIit0OnR9O20udG9GcmFjdGlvbj1mdW5jdGlvbihlKXt2YXIgcix0LG4saSxvLHMsYSxsLHUsYyxwLGQsZj10aGlzLGg9Zi5kLGc9Zi5jb25zdHJ1Y3RvcjtpZighaClyZXR1cm4gbmV3IGcoZik7aWYodT10PW5ldyBnKDEpLG49bD1uZXcgZygwKSxyPW5ldyBnKG4pLG89ci5lPWpzKGgpLWYuZS0xLHM9byVFLHIuZFswXT1CKDEwLHM8MD9FK3M6cyksZT09bnVsbCllPW8+MD9yOnU7ZWxzZXtpZihhPW5ldyBnKGUpLCFhLmlzSW50KCl8fGEubHQodSkpdGhyb3cgRXJyb3IoSGUrYSk7ZT1hLmd0KHIpP28+MD9yOnU6YX1mb3Iodz0hMSxhPW5ldyBnKFcoaCkpLGM9Zy5wcmVjaXNpb24sZy5wcmVjaXNpb249bz1oLmxlbmd0aCpFKjI7cD1fKGEsciwwLDEsMSksaT10LnBsdXMocC50aW1lcyhuKSksaS5jbXAoZSkhPTE7KXQ9bixuPWksaT11LHU9bC5wbHVzKHAudGltZXMoaSkpLGw9aSxpPXIscj1hLm1pbnVzKHAudGltZXMoaSkpLGE9aTtyZXR1cm4gaT1fKGUubWludXModCksbiwwLDEsMSksbD1sLnBsdXMoaS50aW1lcyh1KSksdD10LnBsdXMoaS50aW1lcyhuKSksbC5zPXUucz1mLnMsZD1fKHUsbixvLDEpLm1pbnVzKGYpLmFicygpLmNtcChfKGwsdCxvLDEpLm1pbnVzKGYpLmFicygpKTwxP1t1LG5dOltsLHRdLGcucHJlY2lzaW9uPWMsdz0hMCxkfTttLnRvSGV4YWRlY2ltYWw9bS50b0hleD1mdW5jdGlvbihlLHIpe3JldHVybiAkaSh0aGlzLDE2LGUscil9O20udG9OZWFyZXN0PWZ1bmN0aW9uKGUscil7dmFyIHQ9dGhpcyxuPXQuY29uc3RydWN0b3I7aWYodD1uZXcgbih0KSxlPT1udWxsKXtpZighdC5kKXJldHVybiB0O2U9bmV3IG4oMSkscj1uLnJvdW5kaW5nfWVsc2V7aWYoZT1uZXcgbihlKSxyPT09dm9pZCAwP3I9bi5yb3VuZGluZzppZShyLDAsOCksIXQuZClyZXR1cm4gZS5zP3Q6ZTtpZighZS5kKXJldHVybiBlLnMmJihlLnM9dC5zKSxlfXJldHVybiBlLmRbMF0/KHc9ITEsdD1fKHQsZSwwLHIsMSkudGltZXMoZSksdz0hMCx5KHQpKTooZS5zPXQucyx0PWUpLHR9O20udG9OdW1iZXI9ZnVuY3Rpb24oKXtyZXR1cm4rdGhpc307bS50b09jdGFsPWZ1bmN0aW9uKGUscil7cmV0dXJuICRpKHRoaXMsOCxlLHIpfTttLnRvUG93ZXI9bS5wb3c9ZnVuY3Rpb24oZSl7dmFyIHIsdCxuLGksbyxzLGE9dGhpcyxsPWEuY29uc3RydWN0b3IsdT0rKGU9bmV3IGwoZSkpO2lmKCFhLmR8fCFlLmR8fCFhLmRbMF18fCFlLmRbMF0pcmV0dXJuIG5ldyBsKEIoK2EsdSkpO2lmKGE9bmV3IGwoYSksYS5lcSgxKSlyZXR1cm4gYTtpZihuPWwucHJlY2lzaW9uLG89bC5yb3VuZGluZyxlLmVxKDEpKXJldHVybiB5KGEsbixvKTtpZihyPVkoZS5lL0UpLHI+PWUuZC5sZW5ndGgtMSYmKHQ9dTwwPy11OnUpPD1jcClyZXR1cm4gaT1WcyhsLGEsdCxuKSxlLnM8MD9uZXcgbCgxKS5kaXYoaSk6eShpLG4sbyk7aWYocz1hLnMsczwwKXtpZihyPGUuZC5sZW5ndGgtMSlyZXR1cm4gbmV3IGwoTmFOKTtpZigoZS5kW3JdJjEpPT0wJiYocz0xKSxhLmU9PTAmJmEuZFswXT09MSYmYS5kLmxlbmd0aD09MSlyZXR1cm4gYS5zPXMsYX1yZXR1cm4gdD1CKCthLHUpLHI9dD09MHx8IWlzRmluaXRlKHQpP1kodSooTWF0aC5sb2coXCIwLlwiK1coYS5kKSkvTWF0aC5MTjEwK2EuZSsxKSk6bmV3IGwodCtcIlwiKS5lLHI+bC5tYXhFKzF8fHI8bC5taW5FLTE/bmV3IGwocj4wP3MvMDowKToodz0hMSxsLnJvdW5kaW5nPWEucz0xLHQ9TWF0aC5taW4oMTIsKHIrXCJcIikubGVuZ3RoKSxpPU1pKGUudGltZXMoSmUoYSxuK3QpKSxuKSxpLmQmJihpPXkoaSxuKzUsMSksb3QoaS5kLG4sbykmJihyPW4rMTAsaT15KE1pKGUudGltZXMoSmUoYSxyK3QpKSxyKSxyKzUsMSksK1coaS5kKS5zbGljZShuKzEsbisxNSkrMT09MWUxNCYmKGk9eShpLG4rMSwwKSkpKSxpLnM9cyx3PSEwLGwucm91bmRpbmc9byx5KGksbixvKSl9O20udG9QcmVjaXNpb249ZnVuY3Rpb24oZSxyKXt2YXIgdCxuPXRoaXMsaT1uLmNvbnN0cnVjdG9yO3JldHVybiBlPT09dm9pZCAwP3Q9eGUobixuLmU8PWkudG9FeHBOZWd8fG4uZT49aS50b0V4cFBvcyk6KGllKGUsMSxLZSkscj09PXZvaWQgMD9yPWkucm91bmRpbmc6aWUociwwLDgpLG49eShuZXcgaShuKSxlLHIpLHQ9eGUobixlPD1uLmV8fG4uZTw9aS50b0V4cE5lZyxlKSksbi5pc05lZygpJiYhbi5pc1plcm8oKT9cIi1cIit0OnR9O20udG9TaWduaWZpY2FudERpZ2l0cz1tLnRvU0Q9ZnVuY3Rpb24oZSxyKXt2YXIgdD10aGlzLG49dC5jb25zdHJ1Y3RvcjtyZXR1cm4gZT09PXZvaWQgMD8oZT1uLnByZWNpc2lvbixyPW4ucm91bmRpbmcpOihpZShlLDEsS2UpLHI9PT12b2lkIDA/cj1uLnJvdW5kaW5nOmllKHIsMCw4KSkseShuZXcgbih0KSxlLHIpfTttLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxyPWUuY29uc3RydWN0b3IsdD14ZShlLGUuZTw9ci50b0V4cE5lZ3x8ZS5lPj1yLnRvRXhwUG9zKTtyZXR1cm4gZS5pc05lZygpJiYhZS5pc1plcm8oKT9cIi1cIit0OnR9O20udHJ1bmNhdGVkPW0udHJ1bmM9ZnVuY3Rpb24oKXtyZXR1cm4geShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSx0aGlzLmUrMSwxKX07bS52YWx1ZU9mPW0udG9KU09OPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcyxyPWUuY29uc3RydWN0b3IsdD14ZShlLGUuZTw9ci50b0V4cE5lZ3x8ZS5lPj1yLnRvRXhwUG9zKTtyZXR1cm4gZS5pc05lZygpP1wiLVwiK3Q6dH07ZnVuY3Rpb24gVyhlKXt2YXIgcix0LG4saT1lLmxlbmd0aC0xLG89XCJcIixzPWVbMF07aWYoaT4wKXtmb3Iobys9cyxyPTE7cjxpO3IrKyluPWVbcl0rXCJcIix0PUUtbi5sZW5ndGgsdCYmKG8rPVdlKHQpKSxvKz1uO3M9ZVtyXSxuPXMrXCJcIix0PUUtbi5sZW5ndGgsdCYmKG8rPVdlKHQpKX1lbHNlIGlmKHM9PT0wKXJldHVyblwiMFwiO2Zvcig7cyUxMD09PTA7KXMvPTEwO3JldHVybiBvK3N9ZnVuY3Rpb24gaWUoZSxyLHQpe2lmKGUhPT1+fmV8fGU8cnx8ZT50KXRocm93IEVycm9yKEhlK2UpfWZ1bmN0aW9uIG90KGUscix0LG4pe3ZhciBpLG8scyxhO2ZvcihvPWVbMF07bz49MTA7by89MTApLS1yO3JldHVybi0tcjwwPyhyKz1FLGk9MCk6KGk9TWF0aC5jZWlsKChyKzEpL0UpLHIlPUUpLG89QigxMCxFLXIpLGE9ZVtpXSVvfDAsbj09bnVsbD9yPDM/KHI9PTA/YT1hLzEwMHwwOnI9PTEmJihhPWEvMTB8MCkscz10PDQmJmE9PTk5OTk5fHx0PjMmJmE9PTQ5OTk5fHxhPT01ZTR8fGE9PTApOnM9KHQ8NCYmYSsxPT1vfHx0PjMmJmErMT09by8yKSYmKGVbaSsxXS9vLzEwMHwwKT09QigxMCxyLTIpLTF8fChhPT1vLzJ8fGE9PTApJiYoZVtpKzFdL28vMTAwfDApPT0wOnI8ND8ocj09MD9hPWEvMWUzfDA6cj09MT9hPWEvMTAwfDA6cj09MiYmKGE9YS8xMHwwKSxzPShufHx0PDQpJiZhPT05OTk5fHwhbiYmdD4zJiZhPT00OTk5KTpzPSgobnx8dDw0KSYmYSsxPT1vfHwhbiYmdD4zJiZhKzE9PW8vMikmJihlW2krMV0vby8xZTN8MCk9PUIoMTAsci0zKS0xLHN9ZnVuY3Rpb24gYW4oZSxyLHQpe2Zvcih2YXIgbixpPVswXSxvLHM9MCxhPWUubGVuZ3RoO3M8YTspe2ZvcihvPWkubGVuZ3RoO28tLTspaVtvXSo9cjtmb3IoaVswXSs9TmkuaW5kZXhPZihlLmNoYXJBdChzKyspKSxuPTA7bjxpLmxlbmd0aDtuKyspaVtuXT50LTEmJihpW24rMV09PT12b2lkIDAmJihpW24rMV09MCksaVtuKzFdKz1pW25dL3R8MCxpW25dJT10KX1yZXR1cm4gaS5yZXZlcnNlKCl9ZnVuY3Rpb24gZHAoZSxyKXt2YXIgdCxuLGk7aWYoci5pc1plcm8oKSlyZXR1cm4gcjtuPXIuZC5sZW5ndGgsbjwzMj8odD1NYXRoLmNlaWwobi8zKSxpPSgxL2ZuKDQsdCkpLnRvU3RyaW5nKCkpOih0PTE2LGk9XCIyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwXCIpLGUucHJlY2lzaW9uKz10LHI9UHIoZSwxLHIudGltZXMoaSksbmV3IGUoMSkpO2Zvcih2YXIgbz10O28tLTspe3ZhciBzPXIudGltZXMocik7cj1zLnRpbWVzKHMpLm1pbnVzKHMpLnRpbWVzKDgpLnBsdXMoMSl9cmV0dXJuIGUucHJlY2lzaW9uLT10LHJ9dmFyIF89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKG4saSxvKXt2YXIgcyxhPTAsbD1uLmxlbmd0aDtmb3Iobj1uLnNsaWNlKCk7bC0tOylzPW5bbF0qaSthLG5bbF09cyVvfDAsYT1zL298MDtyZXR1cm4gYSYmbi51bnNoaWZ0KGEpLG59ZnVuY3Rpb24gcihuLGksbyxzKXt2YXIgYSxsO2lmKG8hPXMpbD1vPnM/MTotMTtlbHNlIGZvcihhPWw9MDthPG87YSsrKWlmKG5bYV0hPWlbYV0pe2w9blthXT5pW2FdPzE6LTE7YnJlYWt9cmV0dXJuIGx9ZnVuY3Rpb24gdChuLGksbyxzKXtmb3IodmFyIGE9MDtvLS07KW5bb10tPWEsYT1uW29dPGlbb10/MTowLG5bb109YSpzK25bb10taVtvXTtmb3IoOyFuWzBdJiZuLmxlbmd0aD4xOyluLnNoaWZ0KCl9cmV0dXJuIGZ1bmN0aW9uKG4saSxvLHMsYSxsKXt2YXIgdSxjLHAsZCxmLGgsZyxTLFAsUixiLGssbWUsc2UsV3IsaixyZSxBZSxKLG1yLE10PW4uY29uc3RydWN0b3IsSG49bi5zPT1pLnM/MTotMSxIPW4uZCxPPWkuZDtpZighSHx8IUhbMF18fCFPfHwhT1swXSlyZXR1cm4gbmV3IE10KCFuLnN8fCFpLnN8fChIP08mJkhbMF09PU9bMF06IU8pP05hTjpIJiZIWzBdPT0wfHwhTz9IbiowOkhuLzApO2ZvcihsPyhmPTEsYz1uLmUtaS5lKToobD1mZSxmPUUsYz1ZKG4uZS9mKS1ZKGkuZS9mKSksSj1PLmxlbmd0aCxyZT1ILmxlbmd0aCxQPW5ldyBNdChIbiksUj1QLmQ9W10scD0wO09bcF09PShIW3BdfHwwKTtwKyspO2lmKE9bcF0+KEhbcF18fDApJiZjLS0sbz09bnVsbD8oc2U9bz1NdC5wcmVjaXNpb24scz1NdC5yb3VuZGluZyk6YT9zZT1vKyhuLmUtaS5lKSsxOnNlPW8sc2U8MClSLnB1c2goMSksaD0hMDtlbHNle2lmKHNlPXNlL2YrMnwwLHA9MCxKPT0xKXtmb3IoZD0wLE89T1swXSxzZSsrOyhwPHJlfHxkKSYmc2UtLTtwKyspV3I9ZCpsKyhIW3BdfHwwKSxSW3BdPVdyL098MCxkPVdyJU98MDtoPWR8fHA8cmV9ZWxzZXtmb3IoZD1sLyhPWzBdKzEpfDAsZD4xJiYoTz1lKE8sZCxsKSxIPWUoSCxkLGwpLEo9Ty5sZW5ndGgscmU9SC5sZW5ndGgpLGo9SixiPUguc2xpY2UoMCxKKSxrPWIubGVuZ3RoO2s8SjspYltrKytdPTA7bXI9Ty5zbGljZSgpLG1yLnVuc2hpZnQoMCksQWU9T1swXSxPWzFdPj1sLzImJisrQWU7ZG8gZD0wLHU9cihPLGIsSixrKSx1PDA/KG1lPWJbMF0sSiE9ayYmKG1lPW1lKmwrKGJbMV18fDApKSxkPW1lL0FlfDAsZD4xPyhkPj1sJiYoZD1sLTEpLGc9ZShPLGQsbCksUz1nLmxlbmd0aCxrPWIubGVuZ3RoLHU9cihnLGIsUyxrKSx1PT0xJiYoZC0tLHQoZyxKPFM/bXI6TyxTLGwpKSk6KGQ9PTAmJih1PWQ9MSksZz1PLnNsaWNlKCkpLFM9Zy5sZW5ndGgsUzxrJiZnLnVuc2hpZnQoMCksdChiLGcsayxsKSx1PT0tMSYmKGs9Yi5sZW5ndGgsdT1yKE8sYixKLGspLHU8MSYmKGQrKyx0KGIsSjxrP21yOk8sayxsKSkpLGs9Yi5sZW5ndGgpOnU9PT0wJiYoZCsrLGI9WzBdKSxSW3ArK109ZCx1JiZiWzBdP2JbaysrXT1IW2pdfHwwOihiPVtIW2pdXSxrPTEpO3doaWxlKChqKys8cmV8fGJbMF0hPT12b2lkIDApJiZzZS0tKTtoPWJbMF0hPT12b2lkIDB9UlswXXx8Ui5zaGlmdCgpfWlmKGY9PTEpUC5lPWMsTHM9aDtlbHNle2ZvcihwPTEsZD1SWzBdO2Q+PTEwO2QvPTEwKXArKztQLmU9cCtjKmYtMSx5KFAsYT9vK1AuZSsxOm8scyxoKX1yZXR1cm4gUH19KCk7ZnVuY3Rpb24geShlLHIsdCxuKXt2YXIgaSxvLHMsYSxsLHUsYyxwLGQsZj1lLmNvbnN0cnVjdG9yO2U6aWYociE9bnVsbCl7aWYocD1lLmQsIXApcmV0dXJuIGU7Zm9yKGk9MSxhPXBbMF07YT49MTA7YS89MTApaSsrO2lmKG89ci1pLG88MClvKz1FLHM9cixjPXBbZD0wXSxsPWMvQigxMCxpLXMtMSklMTB8MDtlbHNlIGlmKGQ9TWF0aC5jZWlsKChvKzEpL0UpLGE9cC5sZW5ndGgsZD49YSlpZihuKXtmb3IoO2ErKzw9ZDspcC5wdXNoKDApO2M9bD0wLGk9MSxvJT1FLHM9by1FKzF9ZWxzZSBicmVhayBlO2Vsc2V7Zm9yKGM9YT1wW2RdLGk9MTthPj0xMDthLz0xMClpKys7byU9RSxzPW8tRStpLGw9czwwPzA6Yy9CKDEwLGktcy0xKSUxMHwwfWlmKG49bnx8cjwwfHxwW2QrMV0hPT12b2lkIDB8fChzPDA/YzpjJUIoMTAsaS1zLTEpKSx1PXQ8ND8obHx8bikmJih0PT0wfHx0PT0oZS5zPDA/MzoyKSk6bD41fHxsPT01JiYodD09NHx8bnx8dD09NiYmKG8+MD9zPjA/Yy9CKDEwLGktcyk6MDpwW2QtMV0pJTEwJjF8fHQ9PShlLnM8MD84OjcpKSxyPDF8fCFwWzBdKXJldHVybiBwLmxlbmd0aD0wLHU/KHItPWUuZSsxLHBbMF09QigxMCwoRS1yJUUpJUUpLGUuZT0tcnx8MCk6cFswXT1lLmU9MCxlO2lmKG89PTA/KHAubGVuZ3RoPWQsYT0xLGQtLSk6KHAubGVuZ3RoPWQrMSxhPUIoMTAsRS1vKSxwW2RdPXM+MD8oYy9CKDEwLGktcyklQigxMCxzKXwwKSphOjApLHUpZm9yKDs7KWlmKGQ9PTApe2ZvcihvPTEscz1wWzBdO3M+PTEwO3MvPTEwKW8rKztmb3Iocz1wWzBdKz1hLGE9MTtzPj0xMDtzLz0xMClhKys7byE9YSYmKGUuZSsrLHBbMF09PWZlJiYocFswXT0xKSk7YnJlYWt9ZWxzZXtpZihwW2RdKz1hLHBbZF0hPWZlKWJyZWFrO3BbZC0tXT0wLGE9MX1mb3Iobz1wLmxlbmd0aDtwWy0tb109PT0wOylwLnBvcCgpfXJldHVybiB3JiYoZS5lPmYubWF4RT8oZS5kPW51bGwsZS5lPU5hTik6ZS5lPGYubWluRSYmKGUuZT0wLGUuZD1bMF0pKSxlfWZ1bmN0aW9uIHhlKGUscix0KXtpZighZS5pc0Zpbml0ZSgpKXJldHVybiBVcyhlKTt2YXIgbixpPWUuZSxvPVcoZS5kKSxzPW8ubGVuZ3RoO3JldHVybiByPyh0JiYobj10LXMpPjA/bz1vLmNoYXJBdCgwKStcIi5cIitvLnNsaWNlKDEpK1dlKG4pOnM+MSYmKG89by5jaGFyQXQoMCkrXCIuXCIrby5zbGljZSgxKSksbz1vKyhlLmU8MD9cImVcIjpcImUrXCIpK2UuZSk6aTwwPyhvPVwiMC5cIitXZSgtaS0xKStvLHQmJihuPXQtcyk+MCYmKG8rPVdlKG4pKSk6aT49cz8obys9V2UoaSsxLXMpLHQmJihuPXQtaS0xKT4wJiYobz1vK1wiLlwiK1dlKG4pKSk6KChuPWkrMSk8cyYmKG89by5zbGljZSgwLG4pK1wiLlwiK28uc2xpY2UobikpLHQmJihuPXQtcyk+MCYmKGkrMT09PXMmJihvKz1cIi5cIiksbys9V2UobikpKSxvfWZ1bmN0aW9uIG1uKGUscil7dmFyIHQ9ZVswXTtmb3Iocio9RTt0Pj0xMDt0Lz0xMClyKys7cmV0dXJuIHJ9ZnVuY3Rpb24gcG4oZSxyLHQpe2lmKHI+cHApdGhyb3cgdz0hMCx0JiYoZS5wcmVjaXNpb249dCksRXJyb3IoRnMpO3JldHVybiB5KG5ldyBlKHVuKSxyLDEsITApfWZ1bmN0aW9uIHdlKGUscix0KXtpZihyPkZpKXRocm93IEVycm9yKEZzKTtyZXR1cm4geShuZXcgZShjbikscix0LCEwKX1mdW5jdGlvbiBqcyhlKXt2YXIgcj1lLmxlbmd0aC0xLHQ9cipFKzE7aWYocj1lW3JdLHIpe2Zvcig7ciUxMD09MDtyLz0xMCl0LS07Zm9yKHI9ZVswXTtyPj0xMDtyLz0xMCl0Kyt9cmV0dXJuIHR9ZnVuY3Rpb24gV2UoZSl7Zm9yKHZhciByPVwiXCI7ZS0tOylyKz1cIjBcIjtyZXR1cm4gcn1mdW5jdGlvbiBWcyhlLHIsdCxuKXt2YXIgaSxvPW5ldyBlKDEpLHM9TWF0aC5jZWlsKG4vRSs0KTtmb3Iodz0hMTs7KXtpZih0JTImJihvPW8udGltZXMociksX3Moby5kLHMpJiYoaT0hMCkpLHQ9WSh0LzIpLHQ9PT0wKXt0PW8uZC5sZW5ndGgtMSxpJiZvLmRbdF09PT0wJiYrK28uZFt0XTticmVha31yPXIudGltZXMociksX3Moci5kLHMpfXJldHVybiB3PSEwLG99ZnVuY3Rpb24gT3MoZSl7cmV0dXJuIGUuZFtlLmQubGVuZ3RoLTFdJjF9ZnVuY3Rpb24gQnMoZSxyLHQpe2Zvcih2YXIgbixpLG89bmV3IGUoclswXSkscz0wOysrczxyLmxlbmd0aDspe2lmKGk9bmV3IGUocltzXSksIWkucyl7bz1pO2JyZWFrfW49by5jbXAoaSksKG49PT10fHxuPT09MCYmby5zPT09dCkmJihvPWkpfXJldHVybiBvfWZ1bmN0aW9uIE1pKGUscil7dmFyIHQsbixpLG8scyxhLGwsdT0wLGM9MCxwPTAsZD1lLmNvbnN0cnVjdG9yLGY9ZC5yb3VuZGluZyxoPWQucHJlY2lzaW9uO2lmKCFlLmR8fCFlLmRbMF18fGUuZT4xNylyZXR1cm4gbmV3IGQoZS5kP2UuZFswXT9lLnM8MD8wOjEvMDoxOmUucz9lLnM8MD8wOmU6TmFOKTtmb3Iocj09bnVsbD8odz0hMSxsPWgpOmw9cixhPW5ldyBkKC4wMzEyNSk7ZS5lPi0yOyllPWUudGltZXMoYSkscCs9NTtmb3Iobj1NYXRoLmxvZyhCKDIscCkpL01hdGguTE4xMCoyKzV8MCxsKz1uLHQ9bz1zPW5ldyBkKDEpLGQucHJlY2lzaW9uPWw7Oyl7aWYobz15KG8udGltZXMoZSksbCwxKSx0PXQudGltZXMoKytjKSxhPXMucGx1cyhfKG8sdCxsLDEpKSxXKGEuZCkuc2xpY2UoMCxsKT09PVcocy5kKS5zbGljZSgwLGwpKXtmb3IoaT1wO2ktLTspcz15KHMudGltZXMocyksbCwxKTtpZihyPT1udWxsKWlmKHU8MyYmb3Qocy5kLGwtbixmLHUpKWQucHJlY2lzaW9uPWwrPTEwLHQ9bz1hPW5ldyBkKDEpLGM9MCx1Kys7ZWxzZSByZXR1cm4geShzLGQucHJlY2lzaW9uPWgsZix3PSEwKTtlbHNlIHJldHVybiBkLnByZWNpc2lvbj1oLHN9cz1hfX1mdW5jdGlvbiBKZShlLHIpe3ZhciB0LG4saSxvLHMsYSxsLHUsYyxwLGQsZj0xLGg9MTAsZz1lLFM9Zy5kLFA9Zy5jb25zdHJ1Y3RvcixSPVAucm91bmRpbmcsYj1QLnByZWNpc2lvbjtpZihnLnM8MHx8IVN8fCFTWzBdfHwhZy5lJiZTWzBdPT0xJiZTLmxlbmd0aD09MSlyZXR1cm4gbmV3IFAoUyYmIVNbMF0/LTEvMDpnLnMhPTE/TmFOOlM/MDpnKTtpZihyPT1udWxsPyh3PSExLGM9Yik6Yz1yLFAucHJlY2lzaW9uPWMrPWgsdD1XKFMpLG49dC5jaGFyQXQoMCksTWF0aC5hYnMobz1nLmUpPDE1ZTE0KXtmb3IoO248NyYmbiE9MXx8bj09MSYmdC5jaGFyQXQoMSk+MzspZz1nLnRpbWVzKGUpLHQ9VyhnLmQpLG49dC5jaGFyQXQoMCksZisrO289Zy5lLG4+MT8oZz1uZXcgUChcIjAuXCIrdCksbysrKTpnPW5ldyBQKG4rXCIuXCIrdC5zbGljZSgxKSl9ZWxzZSByZXR1cm4gdT1wbihQLGMrMixiKS50aW1lcyhvK1wiXCIpLGc9SmUobmV3IFAobitcIi5cIit0LnNsaWNlKDEpKSxjLWgpLnBsdXModSksUC5wcmVjaXNpb249YixyPT1udWxsP3koZyxiLFIsdz0hMCk6Zztmb3IocD1nLGw9cz1nPV8oZy5taW51cygxKSxnLnBsdXMoMSksYywxKSxkPXkoZy50aW1lcyhnKSxjLDEpLGk9Mzs7KXtpZihzPXkocy50aW1lcyhkKSxjLDEpLHU9bC5wbHVzKF8ocyxuZXcgUChpKSxjLDEpKSxXKHUuZCkuc2xpY2UoMCxjKT09PVcobC5kKS5zbGljZSgwLGMpKWlmKGw9bC50aW1lcygyKSxvIT09MCYmKGw9bC5wbHVzKHBuKFAsYysyLGIpLnRpbWVzKG8rXCJcIikpKSxsPV8obCxuZXcgUChmKSxjLDEpLHI9PW51bGwpaWYob3QobC5kLGMtaCxSLGEpKVAucHJlY2lzaW9uPWMrPWgsdT1zPWc9XyhwLm1pbnVzKDEpLHAucGx1cygxKSxjLDEpLGQ9eShnLnRpbWVzKGcpLGMsMSksaT1hPTE7ZWxzZSByZXR1cm4geShsLFAucHJlY2lzaW9uPWIsUix3PSEwKTtlbHNlIHJldHVybiBQLnByZWNpc2lvbj1iLGw7bD11LGkrPTJ9fWZ1bmN0aW9uIFVzKGUpe3JldHVybiBTdHJpbmcoZS5zKmUucy8wKX1mdW5jdGlvbiBsbihlLHIpe3ZhciB0LG4saTtmb3IoKHQ9ci5pbmRleE9mKFwiLlwiKSk+LTEmJihyPXIucmVwbGFjZShcIi5cIixcIlwiKSksKG49ci5zZWFyY2goL2UvaSkpPjA/KHQ8MCYmKHQ9biksdCs9K3Iuc2xpY2UobisxKSxyPXIuc3Vic3RyaW5nKDAsbikpOnQ8MCYmKHQ9ci5sZW5ndGgpLG49MDtyLmNoYXJDb2RlQXQobik9PT00ODtuKyspO2ZvcihpPXIubGVuZ3RoO3IuY2hhckNvZGVBdChpLTEpPT09NDg7LS1pKTtpZihyPXIuc2xpY2UobixpKSxyKXtpZihpLT1uLGUuZT10PXQtbi0xLGUuZD1bXSxuPSh0KzEpJUUsdDwwJiYobis9RSksbjxpKXtmb3IobiYmZS5kLnB1c2goK3Iuc2xpY2UoMCxuKSksaS09RTtuPGk7KWUuZC5wdXNoKCtyLnNsaWNlKG4sbis9RSkpO3I9ci5zbGljZShuKSxuPUUtci5sZW5ndGh9ZWxzZSBuLT1pO2Zvcig7bi0tOylyKz1cIjBcIjtlLmQucHVzaCgrciksdyYmKGUuZT5lLmNvbnN0cnVjdG9yLm1heEU/KGUuZD1udWxsLGUuZT1OYU4pOmUuZTxlLmNvbnN0cnVjdG9yLm1pbkUmJihlLmU9MCxlLmQ9WzBdKSl9ZWxzZSBlLmU9MCxlLmQ9WzBdO3JldHVybiBlfWZ1bmN0aW9uIG1wKGUscil7dmFyIHQsbixpLG8scyxhLGwsdSxjO2lmKHIuaW5kZXhPZihcIl9cIik+LTEpe2lmKHI9ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csXCIkMVwiKSxxcy50ZXN0KHIpKXJldHVybiBsbihlLHIpfWVsc2UgaWYocj09PVwiSW5maW5pdHlcInx8cj09PVwiTmFOXCIpcmV0dXJuK3J8fChlLnM9TmFOKSxlLmU9TmFOLGUuZD1udWxsLGU7aWYobHAudGVzdChyKSl0PTE2LHI9ci50b0xvd2VyQ2FzZSgpO2Vsc2UgaWYoYXAudGVzdChyKSl0PTI7ZWxzZSBpZih1cC50ZXN0KHIpKXQ9ODtlbHNlIHRocm93IEVycm9yKEhlK3IpO2ZvcihvPXIuc2VhcmNoKC9wL2kpLG8+MD8obD0rci5zbGljZShvKzEpLHI9ci5zdWJzdHJpbmcoMixvKSk6cj1yLnNsaWNlKDIpLG89ci5pbmRleE9mKFwiLlwiKSxzPW8+PTAsbj1lLmNvbnN0cnVjdG9yLHMmJihyPXIucmVwbGFjZShcIi5cIixcIlwiKSxhPXIubGVuZ3RoLG89YS1vLGk9VnMobixuZXcgbih0KSxvLG8qMikpLHU9YW4ocix0LGZlKSxjPXUubGVuZ3RoLTEsbz1jO3Vbb109PT0wOy0tbyl1LnBvcCgpO3JldHVybiBvPDA/bmV3IG4oZS5zKjApOihlLmU9bW4odSxjKSxlLmQ9dSx3PSExLHMmJihlPV8oZSxpLGEqNCkpLGwmJihlPWUudGltZXMoTWF0aC5hYnMobCk8NTQ/QigyLGwpOnNyLnBvdygyLGwpKSksdz0hMCxlKX1mdW5jdGlvbiBmcChlLHIpe3ZhciB0LG49ci5kLmxlbmd0aDtpZihuPDMpcmV0dXJuIHIuaXNaZXJvKCk/cjpQcihlLDIscixyKTt0PTEuNCpNYXRoLnNxcnQobiksdD10PjE2PzE2OnR8MCxyPXIudGltZXMoMS9mbig1LHQpKSxyPVByKGUsMixyLHIpO2Zvcih2YXIgaSxvPW5ldyBlKDUpLHM9bmV3IGUoMTYpLGE9bmV3IGUoMjApO3QtLTspaT1yLnRpbWVzKHIpLHI9ci50aW1lcyhvLnBsdXMoaS50aW1lcyhzLnRpbWVzKGkpLm1pbnVzKGEpKSkpO3JldHVybiByfWZ1bmN0aW9uIFByKGUscix0LG4saSl7dmFyIG8scyxhLGwsdT0xLGM9ZS5wcmVjaXNpb24scD1NYXRoLmNlaWwoYy9FKTtmb3Iodz0hMSxsPXQudGltZXModCksYT1uZXcgZShuKTs7KXtpZihzPV8oYS50aW1lcyhsKSxuZXcgZShyKysqcisrKSxjLDEpLGE9aT9uLnBsdXMocyk6bi5taW51cyhzKSxuPV8ocy50aW1lcyhsKSxuZXcgZShyKysqcisrKSxjLDEpLHM9YS5wbHVzKG4pLHMuZFtwXSE9PXZvaWQgMCl7Zm9yKG89cDtzLmRbb109PT1hLmRbb10mJm8tLTspO2lmKG89PS0xKWJyZWFrfW89YSxhPW4sbj1zLHM9byx1Kyt9cmV0dXJuIHc9ITAscy5kLmxlbmd0aD1wKzEsc31mdW5jdGlvbiBmbihlLHIpe2Zvcih2YXIgdD1lOy0tcjspdCo9ZTtyZXR1cm4gdH1mdW5jdGlvbiBHcyhlLHIpe3ZhciB0LG49ci5zPDAsaT13ZShlLGUucHJlY2lzaW9uLDEpLG89aS50aW1lcyguNSk7aWYocj1yLmFicygpLHIubHRlKG8pKXJldHVybiBMZT1uPzQ6MSxyO2lmKHQ9ci5kaXZUb0ludChpKSx0LmlzWmVybygpKUxlPW4/MzoyO2Vsc2V7aWYocj1yLm1pbnVzKHQudGltZXMoaSkpLHIubHRlKG8pKXJldHVybiBMZT1Pcyh0KT9uPzI6MzpuPzQ6MSxyO0xlPU9zKHQpP24/MTo0Om4/MzoyfXJldHVybiByLm1pbnVzKGkpLmFicygpfWZ1bmN0aW9uICRpKGUscix0LG4pe3ZhciBpLG8scyxhLGwsdSxjLHAsZCxmPWUuY29uc3RydWN0b3IsaD10IT09dm9pZCAwO2lmKGg/KGllKHQsMSxLZSksbj09PXZvaWQgMD9uPWYucm91bmRpbmc6aWUobiwwLDgpKToodD1mLnByZWNpc2lvbixuPWYucm91bmRpbmcpLCFlLmlzRmluaXRlKCkpYz1VcyhlKTtlbHNle2ZvcihjPXhlKGUpLHM9Yy5pbmRleE9mKFwiLlwiKSxoPyhpPTIscj09MTY/dD10KjQtMzpyPT04JiYodD10KjMtMikpOmk9cixzPj0wJiYoYz1jLnJlcGxhY2UoXCIuXCIsXCJcIiksZD1uZXcgZigxKSxkLmU9Yy5sZW5ndGgtcyxkLmQ9YW4oeGUoZCksMTAsaSksZC5lPWQuZC5sZW5ndGgpLHA9YW4oYywxMCxpKSxvPWw9cC5sZW5ndGg7cFstLWxdPT0wOylwLnBvcCgpO2lmKCFwWzBdKWM9aD9cIjBwKzBcIjpcIjBcIjtlbHNle2lmKHM8MD9vLS06KGU9bmV3IGYoZSksZS5kPXAsZS5lPW8sZT1fKGUsZCx0LG4sMCxpKSxwPWUuZCxvPWUuZSx1PUxzKSxzPXBbdF0sYT1pLzIsdT11fHxwW3QrMV0hPT12b2lkIDAsdT1uPDQ/KHMhPT12b2lkIDB8fHUpJiYobj09PTB8fG49PT0oZS5zPDA/MzoyKSk6cz5hfHxzPT09YSYmKG49PT00fHx1fHxuPT09NiYmcFt0LTFdJjF8fG49PT0oZS5zPDA/ODo3KSkscC5sZW5ndGg9dCx1KWZvcig7KytwWy0tdF0+aS0xOylwW3RdPTAsdHx8KCsrbyxwLnVuc2hpZnQoMSkpO2ZvcihsPXAubGVuZ3RoOyFwW2wtMV07LS1sKTtmb3Iocz0wLGM9XCJcIjtzPGw7cysrKWMrPU5pLmNoYXJBdChwW3NdKTtpZihoKXtpZihsPjEpaWYocj09MTZ8fHI9PTgpe2ZvcihzPXI9PTE2PzQ6MywtLWw7bCVzO2wrKyljKz1cIjBcIjtmb3IocD1hbihjLGksciksbD1wLmxlbmd0aDshcFtsLTFdOy0tbCk7Zm9yKHM9MSxjPVwiMS5cIjtzPGw7cysrKWMrPU5pLmNoYXJBdChwW3NdKX1lbHNlIGM9Yy5jaGFyQXQoMCkrXCIuXCIrYy5zbGljZSgxKTtjPWMrKG88MD9cInBcIjpcInArXCIpK299ZWxzZSBpZihvPDApe2Zvcig7KytvOyljPVwiMFwiK2M7Yz1cIjAuXCIrY31lbHNlIGlmKCsrbz5sKWZvcihvLT1sO28tLTspYys9XCIwXCI7ZWxzZSBvPGwmJihjPWMuc2xpY2UoMCxvKStcIi5cIitjLnNsaWNlKG8pKX1jPShyPT0xNj9cIjB4XCI6cj09Mj9cIjBiXCI6cj09OD9cIjBvXCI6XCJcIikrY31yZXR1cm4gZS5zPDA/XCItXCIrYzpjfWZ1bmN0aW9uIF9zKGUscil7aWYoZS5sZW5ndGg+cilyZXR1cm4gZS5sZW5ndGg9ciwhMH1mdW5jdGlvbiBncChlKXtyZXR1cm4gbmV3IHRoaXMoZSkuYWJzKCl9ZnVuY3Rpb24gaHAoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmFjb3MoKX1mdW5jdGlvbiB5cChlKXtyZXR1cm4gbmV3IHRoaXMoZSkuYWNvc2goKX1mdW5jdGlvbiBicChlLHIpe3JldHVybiBuZXcgdGhpcyhlKS5wbHVzKHIpfWZ1bmN0aW9uIEVwKGUpe3JldHVybiBuZXcgdGhpcyhlKS5hc2luKCl9ZnVuY3Rpb24gd3AoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmFzaW5oKCl9ZnVuY3Rpb24geHAoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmF0YW4oKX1mdW5jdGlvbiB2cChlKXtyZXR1cm4gbmV3IHRoaXMoZSkuYXRhbmgoKX1mdW5jdGlvbiBQcChlLHIpe2U9bmV3IHRoaXMoZSkscj1uZXcgdGhpcyhyKTt2YXIgdCxuPXRoaXMucHJlY2lzaW9uLGk9dGhpcy5yb3VuZGluZyxvPW4rNDtyZXR1cm4hZS5zfHwhci5zP3Q9bmV3IHRoaXMoTmFOKTohZS5kJiYhci5kPyh0PXdlKHRoaXMsbywxKS50aW1lcyhyLnM+MD8uMjU6Ljc1KSx0LnM9ZS5zKTohci5kfHxlLmlzWmVybygpPyh0PXIuczwwP3dlKHRoaXMsbixpKTpuZXcgdGhpcygwKSx0LnM9ZS5zKTohZS5kfHxyLmlzWmVybygpPyh0PXdlKHRoaXMsbywxKS50aW1lcyguNSksdC5zPWUucyk6ci5zPDA/KHRoaXMucHJlY2lzaW9uPW8sdGhpcy5yb3VuZGluZz0xLHQ9dGhpcy5hdGFuKF8oZSxyLG8sMSkpLHI9d2UodGhpcyxvLDEpLHRoaXMucHJlY2lzaW9uPW4sdGhpcy5yb3VuZGluZz1pLHQ9ZS5zPDA/dC5taW51cyhyKTp0LnBsdXMocikpOnQ9dGhpcy5hdGFuKF8oZSxyLG8sMSkpLHR9ZnVuY3Rpb24gVHAoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmNicnQoKX1mdW5jdGlvbiBTcChlKXtyZXR1cm4geShlPW5ldyB0aGlzKGUpLGUuZSsxLDIpfWZ1bmN0aW9uIFJwKGUscix0KXtyZXR1cm4gbmV3IHRoaXMoZSkuY2xhbXAocix0KX1mdW5jdGlvbiBBcChlKXtpZighZXx8dHlwZW9mIGUhPVwib2JqZWN0XCIpdGhyb3cgRXJyb3IoZG4rXCJPYmplY3QgZXhwZWN0ZWRcIik7dmFyIHIsdCxuLGk9ZS5kZWZhdWx0cz09PSEwLG89W1wicHJlY2lzaW9uXCIsMSxLZSxcInJvdW5kaW5nXCIsMCw4LFwidG9FeHBOZWdcIiwtdnIsMCxcInRvRXhwUG9zXCIsMCx2cixcIm1heEVcIiwwLHZyLFwibWluRVwiLC12ciwwLFwibW9kdWxvXCIsMCw5XTtmb3Iocj0wO3I8by5sZW5ndGg7cis9MylpZih0PW9bcl0saSYmKHRoaXNbdF09TGlbdF0pLChuPWVbdF0pIT09dm9pZCAwKWlmKFkobik9PT1uJiZuPj1vW3IrMV0mJm48PW9bcisyXSl0aGlzW3RdPW47ZWxzZSB0aHJvdyBFcnJvcihIZSt0K1wiOiBcIituKTtpZih0PVwiY3J5cHRvXCIsaSYmKHRoaXNbdF09TGlbdF0pLChuPWVbdF0pIT09dm9pZCAwKWlmKG49PT0hMHx8bj09PSExfHxuPT09MHx8bj09PTEpaWYobilpZih0eXBlb2YgY3J5cHRvPFwidVwiJiZjcnlwdG8mJihjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzfHxjcnlwdG8ucmFuZG9tQnl0ZXMpKXRoaXNbdF09ITA7ZWxzZSB0aHJvdyBFcnJvcihNcyk7ZWxzZSB0aGlzW3RdPSExO2Vsc2UgdGhyb3cgRXJyb3IoSGUrdCtcIjogXCIrbik7cmV0dXJuIHRoaXN9ZnVuY3Rpb24gQ3AoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmNvcygpfWZ1bmN0aW9uIElwKGUpe3JldHVybiBuZXcgdGhpcyhlKS5jb3NoKCl9ZnVuY3Rpb24gUXMoZSl7dmFyIHIsdCxuO2Z1bmN0aW9uIGkobyl7dmFyIHMsYSxsLHU9dGhpcztpZighKHUgaW5zdGFuY2VvZiBpKSlyZXR1cm4gbmV3IGkobyk7aWYodS5jb25zdHJ1Y3Rvcj1pLE5zKG8pKXt1LnM9by5zLHc/IW8uZHx8by5lPmkubWF4RT8odS5lPU5hTix1LmQ9bnVsbCk6by5lPGkubWluRT8odS5lPTAsdS5kPVswXSk6KHUuZT1vLmUsdS5kPW8uZC5zbGljZSgpKToodS5lPW8uZSx1LmQ9by5kP28uZC5zbGljZSgpOm8uZCk7cmV0dXJufWlmKGw9dHlwZW9mIG8sbD09PVwibnVtYmVyXCIpe2lmKG89PT0wKXt1LnM9MS9vPDA/LTE6MSx1LmU9MCx1LmQ9WzBdO3JldHVybn1pZihvPDA/KG89LW8sdS5zPS0xKTp1LnM9MSxvPT09fn5vJiZvPDFlNyl7Zm9yKHM9MCxhPW87YT49MTA7YS89MTApcysrO3c/cz5pLm1heEU/KHUuZT1OYU4sdS5kPW51bGwpOnM8aS5taW5FPyh1LmU9MCx1LmQ9WzBdKToodS5lPXMsdS5kPVtvXSk6KHUuZT1zLHUuZD1bb10pO3JldHVybn1pZihvKjAhPT0wKXtvfHwodS5zPU5hTiksdS5lPU5hTix1LmQ9bnVsbDtyZXR1cm59cmV0dXJuIGxuKHUsby50b1N0cmluZygpKX1pZihsPT09XCJzdHJpbmdcIilyZXR1cm4oYT1vLmNoYXJDb2RlQXQoMCkpPT09NDU/KG89by5zbGljZSgxKSx1LnM9LTEpOihhPT09NDMmJihvPW8uc2xpY2UoMSkpLHUucz0xKSxxcy50ZXN0KG8pP2xuKHUsbyk6bXAodSxvKTtpZihsPT09XCJiaWdpbnRcIilyZXR1cm4gbzwwPyhvPS1vLHUucz0tMSk6dS5zPTEsbG4odSxvLnRvU3RyaW5nKCkpO3Rocm93IEVycm9yKEhlK28pfWlmKGkucHJvdG90eXBlPW0saS5ST1VORF9VUD0wLGkuUk9VTkRfRE9XTj0xLGkuUk9VTkRfQ0VJTD0yLGkuUk9VTkRfRkxPT1I9MyxpLlJPVU5EX0hBTEZfVVA9NCxpLlJPVU5EX0hBTEZfRE9XTj01LGkuUk9VTkRfSEFMRl9FVkVOPTYsaS5ST1VORF9IQUxGX0NFSUw9NyxpLlJPVU5EX0hBTEZfRkxPT1I9OCxpLkVVQ0xJRD05LGkuY29uZmlnPWkuc2V0PUFwLGkuY2xvbmU9UXMsaS5pc0RlY2ltYWw9TnMsaS5hYnM9Z3AsaS5hY29zPWhwLGkuYWNvc2g9eXAsaS5hZGQ9YnAsaS5hc2luPUVwLGkuYXNpbmg9d3AsaS5hdGFuPXhwLGkuYXRhbmg9dnAsaS5hdGFuMj1QcCxpLmNicnQ9VHAsaS5jZWlsPVNwLGkuY2xhbXA9UnAsaS5jb3M9Q3AsaS5jb3NoPUlwLGkuZGl2PWtwLGkuZXhwPURwLGkuZmxvb3I9T3AsaS5oeXBvdD1fcCxpLmxuPU5wLGkubG9nPUxwLGkubG9nMTA9TXAsaS5sb2cyPUZwLGkubWF4PSRwLGkubWluPXFwLGkubW9kPWpwLGkubXVsPVZwLGkucG93PUJwLGkucmFuZG9tPVVwLGkucm91bmQ9R3AsaS5zaWduPVFwLGkuc2luPVdwLGkuc2luaD1KcCxpLnNxcnQ9SHAsaS5zdWI9S3AsaS5zdW09WXAsaS50YW49enAsaS50YW5oPVpwLGkudHJ1bmM9WHAsZT09PXZvaWQgMCYmKGU9e30pLGUmJmUuZGVmYXVsdHMhPT0hMClmb3Iobj1bXCJwcmVjaXNpb25cIixcInJvdW5kaW5nXCIsXCJ0b0V4cE5lZ1wiLFwidG9FeHBQb3NcIixcIm1heEVcIixcIm1pbkVcIixcIm1vZHVsb1wiLFwiY3J5cHRvXCJdLHI9MDtyPG4ubGVuZ3RoOyllLmhhc093blByb3BlcnR5KHQ9bltyKytdKXx8KGVbdF09dGhpc1t0XSk7cmV0dXJuIGkuY29uZmlnKGUpLGl9ZnVuY3Rpb24ga3AoZSxyKXtyZXR1cm4gbmV3IHRoaXMoZSkuZGl2KHIpfWZ1bmN0aW9uIERwKGUpe3JldHVybiBuZXcgdGhpcyhlKS5leHAoKX1mdW5jdGlvbiBPcChlKXtyZXR1cm4geShlPW5ldyB0aGlzKGUpLGUuZSsxLDMpfWZ1bmN0aW9uIF9wKCl7dmFyIGUscix0PW5ldyB0aGlzKDApO2Zvcih3PSExLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7KWlmKHI9bmV3IHRoaXMoYXJndW1lbnRzW2UrK10pLHIuZCl0LmQmJih0PXQucGx1cyhyLnRpbWVzKHIpKSk7ZWxzZXtpZihyLnMpcmV0dXJuIHc9ITAsbmV3IHRoaXMoMS8wKTt0PXJ9cmV0dXJuIHc9ITAsdC5zcXJ0KCl9ZnVuY3Rpb24gTnMoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBzcnx8ZSYmZS50b1N0cmluZ1RhZz09PSRzfHwhMX1mdW5jdGlvbiBOcChlKXtyZXR1cm4gbmV3IHRoaXMoZSkubG4oKX1mdW5jdGlvbiBMcChlLHIpe3JldHVybiBuZXcgdGhpcyhlKS5sb2cocil9ZnVuY3Rpb24gRnAoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLmxvZygyKX1mdW5jdGlvbiBNcChlKXtyZXR1cm4gbmV3IHRoaXMoZSkubG9nKDEwKX1mdW5jdGlvbiAkcCgpe3JldHVybiBCcyh0aGlzLGFyZ3VtZW50cywtMSl9ZnVuY3Rpb24gcXAoKXtyZXR1cm4gQnModGhpcyxhcmd1bWVudHMsMSl9ZnVuY3Rpb24ganAoZSxyKXtyZXR1cm4gbmV3IHRoaXMoZSkubW9kKHIpfWZ1bmN0aW9uIFZwKGUscil7cmV0dXJuIG5ldyB0aGlzKGUpLm11bChyKX1mdW5jdGlvbiBCcChlLHIpe3JldHVybiBuZXcgdGhpcyhlKS5wb3cocil9ZnVuY3Rpb24gVXAoZSl7dmFyIHIsdCxuLGksbz0wLHM9bmV3IHRoaXMoMSksYT1bXTtpZihlPT09dm9pZCAwP2U9dGhpcy5wcmVjaXNpb246aWUoZSwxLEtlKSxuPU1hdGguY2VpbChlL0UpLHRoaXMuY3J5cHRvKWlmKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpZm9yKHI9Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkobikpO288bjspaT1yW29dLGk+PTQyOWU3P3Jbb109Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdOmFbbysrXT1pJTFlNztlbHNlIGlmKGNyeXB0by5yYW5kb21CeXRlcyl7Zm9yKHI9Y3J5cHRvLnJhbmRvbUJ5dGVzKG4qPTQpO288bjspaT1yW29dKyhyW28rMV08PDgpKyhyW28rMl08PDE2KSsoKHJbbyszXSYxMjcpPDwyNCksaT49MjE0ZTc/Y3J5cHRvLnJhbmRvbUJ5dGVzKDQpLmNvcHkocixvKTooYS5wdXNoKGklMWU3KSxvKz00KTtvPW4vNH1lbHNlIHRocm93IEVycm9yKE1zKTtlbHNlIGZvcig7bzxuOylhW28rK109TWF0aC5yYW5kb20oKSoxZTd8MDtmb3Iobj1hWy0tb10sZSU9RSxuJiZlJiYoaT1CKDEwLEUtZSksYVtvXT0obi9pfDApKmkpO2Fbb109PT0wO28tLSlhLnBvcCgpO2lmKG88MCl0PTAsYT1bMF07ZWxzZXtmb3IodD0tMTthWzBdPT09MDt0LT1FKWEuc2hpZnQoKTtmb3Iobj0xLGk9YVswXTtpPj0xMDtpLz0xMCluKys7bjxFJiYodC09RS1uKX1yZXR1cm4gcy5lPXQscy5kPWEsc31mdW5jdGlvbiBHcChlKXtyZXR1cm4geShlPW5ldyB0aGlzKGUpLGUuZSsxLHRoaXMucm91bmRpbmcpfWZ1bmN0aW9uIFFwKGUpe3JldHVybiBlPW5ldyB0aGlzKGUpLGUuZD9lLmRbMF0/ZS5zOjAqZS5zOmUuc3x8TmFOfWZ1bmN0aW9uIFdwKGUpe3JldHVybiBuZXcgdGhpcyhlKS5zaW4oKX1mdW5jdGlvbiBKcChlKXtyZXR1cm4gbmV3IHRoaXMoZSkuc2luaCgpfWZ1bmN0aW9uIEhwKGUpe3JldHVybiBuZXcgdGhpcyhlKS5zcXJ0KCl9ZnVuY3Rpb24gS3AoZSxyKXtyZXR1cm4gbmV3IHRoaXMoZSkuc3ViKHIpfWZ1bmN0aW9uIFlwKCl7dmFyIGU9MCxyPWFyZ3VtZW50cyx0PW5ldyB0aGlzKHJbZV0pO2Zvcih3PSExO3QucyYmKytlPHIubGVuZ3RoOyl0PXQucGx1cyhyW2VdKTtyZXR1cm4gdz0hMCx5KHQsdGhpcy5wcmVjaXNpb24sdGhpcy5yb3VuZGluZyl9ZnVuY3Rpb24genAoZSl7cmV0dXJuIG5ldyB0aGlzKGUpLnRhbigpfWZ1bmN0aW9uIFpwKGUpe3JldHVybiBuZXcgdGhpcyhlKS50YW5oKCl9ZnVuY3Rpb24gWHAoZSl7cmV0dXJuIHkoZT1uZXcgdGhpcyhlKSxlLmUrMSwxKX1tW1N5bWJvbC5mb3IoXCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbVwiKV09bS50b1N0cmluZzttW1N5bWJvbC50b1N0cmluZ1RhZ109XCJEZWNpbWFsXCI7dmFyIHNyPW0uY29uc3RydWN0b3I9UXMoTGkpO3VuPW5ldyBzcih1bik7Y249bmV3IHNyKGNuKTt2YXIgRmU9c3I7ZnVuY3Rpb24gc3QoZSl7cmV0dXJuIGU9PT1udWxsP2U6QXJyYXkuaXNBcnJheShlKT9lLm1hcChzdCk6dHlwZW9mIGU9PVwib2JqZWN0XCI/ZWQoZSk/cmQoZSk6ZS5jb25zdHJ1Y3RvciE9PW51bGwmJmUuY29uc3RydWN0b3IubmFtZSE9PVwiT2JqZWN0XCI/ZTp4cihlLHN0KTplfWZ1bmN0aW9uIGVkKGUpe3JldHVybiBlIT09bnVsbCYmdHlwZW9mIGU9PVwib2JqZWN0XCImJnR5cGVvZiBlLiR0eXBlPT1cInN0cmluZ1wifWZ1bmN0aW9uIHJkKHskdHlwZTplLHZhbHVlOnJ9KXtzd2l0Y2goZSl7Y2FzZVwiQmlnSW50XCI6cmV0dXJuIEJpZ0ludChyKTtjYXNlXCJCeXRlc1wiOntsZXR7YnVmZmVyOnQsYnl0ZU9mZnNldDpuLGJ5dGVMZW5ndGg6aX09QnVmZmVyLmZyb20ocixcImJhc2U2NFwiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCxuLGkpfWNhc2VcIkRhdGVUaW1lXCI6cmV0dXJuIG5ldyBEYXRlKHIpO2Nhc2VcIkRlY2ltYWxcIjpyZXR1cm4gbmV3IEZlKHIpO2Nhc2VcIkpzb25cIjpyZXR1cm4gSlNPTi5wYXJzZShyKTtkZWZhdWx0Ol9lKHIsXCJVbmtub3duIHRhZ2dlZCB2YWx1ZVwiKX19dmFyIHZlPWNsYXNze19tYXA9bmV3IE1hcDtnZXQocil7cmV0dXJuIHRoaXMuX21hcC5nZXQocik/LnZhbHVlfXNldChyLHQpe3RoaXMuX21hcC5zZXQocix7dmFsdWU6dH0pfWdldE9yQ3JlYXRlKHIsdCl7bGV0IG49dGhpcy5fbWFwLmdldChyKTtpZihuKXJldHVybiBuLnZhbHVlO2xldCBpPXQoKTtyZXR1cm4gdGhpcy5zZXQocixpKSxpfX07ZnVuY3Rpb24gWWUoZSl7cmV0dXJuIGUuc3Vic3RyaW5nKDAsMSkudG9Mb3dlckNhc2UoKStlLnN1YnN0cmluZygxKX1mdW5jdGlvbiBXcyhlLHIpe2xldCB0PXt9O2ZvcihsZXQgbiBvZiBlKXtsZXQgaT1uW3JdO3RbaV09bn1yZXR1cm4gdH1mdW5jdGlvbiBhdChlKXtsZXQgcjtyZXR1cm57Z2V0KCl7cmV0dXJuIHJ8fChyPXt2YWx1ZTplKCl9KSxyLnZhbHVlfX19ZnVuY3Rpb24gdGQoZSl7cmV0dXJue21vZGVsczpxaShlLm1vZGVscyksZW51bXM6cWkoZS5lbnVtcyksdHlwZXM6cWkoZS50eXBlcyl9fWZ1bmN0aW9uIHFpKGUpe2xldCByPXt9O2ZvcihsZXR7bmFtZTp0LC4uLm59b2YgZSlyW3RdPW47cmV0dXJuIHJ9ZnVuY3Rpb24gVHIoZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBEYXRlfHxPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSk9PT1cIltvYmplY3QgRGF0ZV1cIn1mdW5jdGlvbiBnbihlKXtyZXR1cm4gZS50b1N0cmluZygpIT09XCJJbnZhbGlkIERhdGVcIn1mdW5jdGlvbiBTcihlKXtyZXR1cm4gc3IuaXNEZWNpbWFsKGUpPyEwOmUhPT1udWxsJiZ0eXBlb2YgZT09XCJvYmplY3RcIiYmdHlwZW9mIGUucz09XCJudW1iZXJcIiYmdHlwZW9mIGUuZT09XCJudW1iZXJcIiYmdHlwZW9mIGUudG9GaXhlZD09XCJmdW5jdGlvblwiJiZBcnJheS5pc0FycmF5KGUuZCl9dmFyIGhuPXt9O2dyKGhuLHtNb2RlbEFjdGlvbjooKT0+UnIsZGF0YW1vZGVsRW51bVRvU2NoZW1hRW51bTooKT0+bmR9KTtmdW5jdGlvbiBuZChlKXtyZXR1cm57bmFtZTplLm5hbWUsdmFsdWVzOmUudmFsdWVzLm1hcChyPT5yLm5hbWUpfX12YXIgUnI9KGI9PihiLmZpbmRVbmlxdWU9XCJmaW5kVW5pcXVlXCIsYi5maW5kVW5pcXVlT3JUaHJvdz1cImZpbmRVbmlxdWVPclRocm93XCIsYi5maW5kRmlyc3Q9XCJmaW5kRmlyc3RcIixiLmZpbmRGaXJzdE9yVGhyb3c9XCJmaW5kRmlyc3RPclRocm93XCIsYi5maW5kTWFueT1cImZpbmRNYW55XCIsYi5jcmVhdGU9XCJjcmVhdGVcIixiLmNyZWF0ZU1hbnk9XCJjcmVhdGVNYW55XCIsYi5jcmVhdGVNYW55QW5kUmV0dXJuPVwiY3JlYXRlTWFueUFuZFJldHVyblwiLGIudXBkYXRlPVwidXBkYXRlXCIsYi51cGRhdGVNYW55PVwidXBkYXRlTWFueVwiLGIudXBkYXRlTWFueUFuZFJldHVybj1cInVwZGF0ZU1hbnlBbmRSZXR1cm5cIixiLnVwc2VydD1cInVwc2VydFwiLGIuZGVsZXRlPVwiZGVsZXRlXCIsYi5kZWxldGVNYW55PVwiZGVsZXRlTWFueVwiLGIuZ3JvdXBCeT1cImdyb3VwQnlcIixiLmNvdW50PVwiY291bnRcIixiLmFnZ3JlZ2F0ZT1cImFnZ3JlZ2F0ZVwiLGIuZmluZFJhdz1cImZpbmRSYXdcIixiLmFnZ3JlZ2F0ZVJhdz1cImFnZ3JlZ2F0ZVJhd1wiLGIpKShScnx8e30pO3ZhciBZcz1uZSh4aSgpKTtpbXBvcnQgbGQgZnJvbVwibm9kZTpmc1wiO3ZhciBKcz17a2V5d29yZDprZSxlbnRpdHk6a2UsdmFsdWU6ZT0+USh0cihlKSkscHVuY3R1YXRpb246dHIsZGlyZWN0aXZlOmtlLGZ1bmN0aW9uOmtlLHZhcmlhYmxlOmU9PlEodHIoZSkpLHN0cmluZzplPT5RKHFlKGUpKSxib29sZWFuOkllLG51bWJlcjprZSxjb21tZW50OkpyfTt2YXIgaWQ9ZT0+ZSx5bj17fSxvZD0wLHY9e21hbnVhbDp5bi5QcmlzbSYmeW4uUHJpc20ubWFudWFsLGRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcjp5bi5QcmlzbSYmeW4uUHJpc20uZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyLHV0aWw6e2VuY29kZTpmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgZ2Upe2xldCByPWU7cmV0dXJuIG5ldyBnZShyLnR5cGUsdi51dGlsLmVuY29kZShyLmNvbnRlbnQpLHIuYWxpYXMpfWVsc2UgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSk/ZS5tYXAodi51dGlsLmVuY29kZSk6ZS5yZXBsYWNlKC8mL2csXCImYW1wO1wiKS5yZXBsYWNlKC88L2csXCImbHQ7XCIpLnJlcGxhY2UoL1xcdTAwYTAvZyxcIiBcIil9LHR5cGU6ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LC0xKX0sb2JqSWQ6ZnVuY3Rpb24oZSl7cmV0dXJuIGUuX19pZHx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2lkXCIse3ZhbHVlOisrb2R9KSxlLl9faWR9LGNsb25lOmZ1bmN0aW9uIGUocix0KXtsZXQgbixpLG89di51dGlsLnR5cGUocik7c3dpdGNoKHQ9dHx8e30sbyl7Y2FzZVwiT2JqZWN0XCI6aWYoaT12LnV0aWwub2JqSWQociksdFtpXSlyZXR1cm4gdFtpXTtuPXt9LHRbaV09bjtmb3IobGV0IHMgaW4gcilyLmhhc093blByb3BlcnR5KHMpJiYobltzXT1lKHJbc10sdCkpO3JldHVybiBuO2Nhc2VcIkFycmF5XCI6cmV0dXJuIGk9di51dGlsLm9iaklkKHIpLHRbaV0/dFtpXToobj1bXSx0W2ldPW4sci5mb3JFYWNoKGZ1bmN0aW9uKHMsYSl7blthXT1lKHMsdCl9KSxuKTtkZWZhdWx0OnJldHVybiByfX19LGxhbmd1YWdlczp7ZXh0ZW5kOmZ1bmN0aW9uKGUscil7bGV0IHQ9di51dGlsLmNsb25lKHYubGFuZ3VhZ2VzW2VdKTtmb3IobGV0IG4gaW4gcil0W25dPXJbbl07cmV0dXJuIHR9LGluc2VydEJlZm9yZTpmdW5jdGlvbihlLHIsdCxuKXtuPW58fHYubGFuZ3VhZ2VzO2xldCBpPW5bZV0sbz17fTtmb3IobGV0IGEgaW4gaSlpZihpLmhhc093blByb3BlcnR5KGEpKXtpZihhPT1yKWZvcihsZXQgbCBpbiB0KXQuaGFzT3duUHJvcGVydHkobCkmJihvW2xdPXRbbF0pO3QuaGFzT3duUHJvcGVydHkoYSl8fChvW2FdPWlbYV0pfWxldCBzPW5bZV07cmV0dXJuIG5bZV09byx2Lmxhbmd1YWdlcy5ERlModi5sYW5ndWFnZXMsZnVuY3Rpb24oYSxsKXtsPT09cyYmYSE9ZSYmKHRoaXNbYV09byl9KSxvfSxERlM6ZnVuY3Rpb24gZShyLHQsbixpKXtpPWl8fHt9O2xldCBvPXYudXRpbC5vYmpJZDtmb3IobGV0IHMgaW4gcilpZihyLmhhc093blByb3BlcnR5KHMpKXt0LmNhbGwocixzLHJbc10sbnx8cyk7bGV0IGE9cltzXSxsPXYudXRpbC50eXBlKGEpO2w9PT1cIk9iamVjdFwiJiYhaVtvKGEpXT8oaVtvKGEpXT0hMCxlKGEsdCxudWxsLGkpKTpsPT09XCJBcnJheVwiJiYhaVtvKGEpXSYmKGlbbyhhKV09ITAsZShhLHQscyxpKSl9fX0scGx1Z2luczp7fSxoaWdobGlnaHQ6ZnVuY3Rpb24oZSxyLHQpe2xldCBuPXtjb2RlOmUsZ3JhbW1hcjpyLGxhbmd1YWdlOnR9O3JldHVybiB2Lmhvb2tzLnJ1bihcImJlZm9yZS10b2tlbml6ZVwiLG4pLG4udG9rZW5zPXYudG9rZW5pemUobi5jb2RlLG4uZ3JhbW1hciksdi5ob29rcy5ydW4oXCJhZnRlci10b2tlbml6ZVwiLG4pLGdlLnN0cmluZ2lmeSh2LnV0aWwuZW5jb2RlKG4udG9rZW5zKSxuLmxhbmd1YWdlKX0sbWF0Y2hHcmFtbWFyOmZ1bmN0aW9uKGUscix0LG4saSxvLHMpe2ZvcihsZXQgZyBpbiB0KXtpZighdC5oYXNPd25Qcm9wZXJ0eShnKXx8IXRbZ10pY29udGludWU7aWYoZz09cylyZXR1cm47bGV0IFM9dFtnXTtTPXYudXRpbC50eXBlKFMpPT09XCJBcnJheVwiP1M6W1NdO2ZvcihsZXQgUD0wO1A8Uy5sZW5ndGg7KytQKXtsZXQgUj1TW1BdLGI9Ui5pbnNpZGUsaz0hIVIubG9va2JlaGluZCxtZT0hIVIuZ3JlZWR5LHNlPTAsV3I9Ui5hbGlhcztpZihtZSYmIVIucGF0dGVybi5nbG9iYWwpe2xldCBqPVIucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW11eV0qJC8pWzBdO1IucGF0dGVybj1SZWdFeHAoUi5wYXR0ZXJuLnNvdXJjZSxqK1wiZ1wiKX1SPVIucGF0dGVybnx8Ujtmb3IobGV0IGo9bixyZT1pO2o8ci5sZW5ndGg7cmUrPXJbal0ubGVuZ3RoLCsrail7bGV0IEFlPXJbal07aWYoci5sZW5ndGg+ZS5sZW5ndGgpcmV0dXJuO2lmKEFlIGluc3RhbmNlb2YgZ2UpY29udGludWU7aWYobWUmJmohPXIubGVuZ3RoLTEpe1IubGFzdEluZGV4PXJlO3ZhciBwPVIuZXhlYyhlKTtpZighcClicmVhazt2YXIgYz1wLmluZGV4KyhrP3BbMV0ubGVuZ3RoOjApLGQ9cC5pbmRleCtwWzBdLmxlbmd0aCxhPWosbD1yZTtmb3IobGV0IE89ci5sZW5ndGg7YTxPJiYobDxkfHwhclthXS50eXBlJiYhclthLTFdLmdyZWVkeSk7KythKWwrPXJbYV0ubGVuZ3RoLGM+PWwmJigrK2oscmU9bCk7aWYocltqXWluc3RhbmNlb2YgZ2UpY29udGludWU7dT1hLWosQWU9ZS5zbGljZShyZSxsKSxwLmluZGV4LT1yZX1lbHNle1IubGFzdEluZGV4PTA7dmFyIHA9Ui5leGVjKEFlKSx1PTF9aWYoIXApe2lmKG8pYnJlYWs7Y29udGludWV9ayYmKHNlPXBbMV0/cFsxXS5sZW5ndGg6MCk7dmFyIGM9cC5pbmRleCtzZSxwPXBbMF0uc2xpY2Uoc2UpLGQ9YytwLmxlbmd0aCxmPUFlLnNsaWNlKDAsYyksaD1BZS5zbGljZShkKTtsZXQgSj1baix1XTtmJiYoKytqLHJlKz1mLmxlbmd0aCxKLnB1c2goZikpO2xldCBtcj1uZXcgZ2UoZyxiP3YudG9rZW5pemUocCxiKTpwLFdyLHAsbWUpO2lmKEoucHVzaChtciksaCYmSi5wdXNoKGgpLEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkocixKKSx1IT0xJiZ2Lm1hdGNoR3JhbW1hcihlLHIsdCxqLHJlLCEwLGcpLG8pYnJlYWt9fX19LHRva2VuaXplOmZ1bmN0aW9uKGUscil7bGV0IHQ9W2VdLG49ci5yZXN0O2lmKG4pe2ZvcihsZXQgaSBpbiBuKXJbaV09bltpXTtkZWxldGUgci5yZXN0fXJldHVybiB2Lm1hdGNoR3JhbW1hcihlLHQsciwwLDAsITEpLHR9LGhvb2tzOnthbGw6e30sYWRkOmZ1bmN0aW9uKGUscil7bGV0IHQ9di5ob29rcy5hbGw7dFtlXT10W2VdfHxbXSx0W2VdLnB1c2gocil9LHJ1bjpmdW5jdGlvbihlLHIpe2xldCB0PXYuaG9va3MuYWxsW2VdO2lmKCEoIXR8fCF0Lmxlbmd0aCkpZm9yKHZhciBuPTAsaTtpPXRbbisrXTspaShyKX19LFRva2VuOmdlfTt2Lmxhbmd1YWdlcy5jbGlrZT17Y29tbWVudDpbe3BhdHRlcm46LyhefFteXFxcXF0pXFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sbG9va2JlaGluZDohMH0se3BhdHRlcm46LyhefFteXFxcXDpdKVxcL1xcLy4qLyxsb29rYmVoaW5kOiEwLGdyZWVkeTohMH1dLHN0cmluZzp7cGF0dGVybjovKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLGdyZWVkeTohMH0sXCJjbGFzcy1uYW1lXCI6e3BhdHRlcm46LygoPzpcXGIoPzpjbGFzc3xpbnRlcmZhY2V8ZXh0ZW5kc3xpbXBsZW1lbnRzfHRyYWl0fGluc3RhbmNlb2Z8bmV3KVxccyspfCg/OmNhdGNoXFxzK1xcKCkpW1xcdy5cXFxcXSsvaSxsb29rYmVoaW5kOiEwLGluc2lkZTp7cHVuY3R1YXRpb246L1suXFxcXF0vfX0sa2V5d29yZDovXFxiKD86aWZ8ZWxzZXx3aGlsZXxkb3xmb3J8cmV0dXJufGlufGluc3RhbmNlb2Z8ZnVuY3Rpb258bmV3fHRyeXx0aHJvd3xjYXRjaHxmaW5hbGx5fG51bGx8YnJlYWt8Y29udGludWUpXFxiLyxib29sZWFuOi9cXGIoPzp0cnVlfGZhbHNlKVxcYi8sZnVuY3Rpb246L1xcdysoPz1cXCgpLyxudW1iZXI6L1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCtcXC4/XFxkKnxcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLG9wZXJhdG9yOi8tLT98XFwrXFwrP3whPT89P3w8PT98Pj0/fD09Pz0/fCYmP3xcXHxcXHw/fFxcP3xcXCp8XFwvfH58XFxefCUvLHB1bmN0dWF0aW9uOi9be31bXFxdOygpLC46XS99O3YubGFuZ3VhZ2VzLmphdmFzY3JpcHQ9di5sYW5ndWFnZXMuZXh0ZW5kKFwiY2xpa2VcIix7XCJjbGFzcy1uYW1lXCI6W3YubGFuZ3VhZ2VzLmNsaWtlW1wiY2xhc3MtbmFtZVwiXSx7cGF0dGVybjovKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pW18kQS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxcLig/OnByb3RvdHlwZXxjb25zdHJ1Y3RvcikpLyxsb29rYmVoaW5kOiEwfV0sa2V5d29yZDpbe3BhdHRlcm46LygoPzpefH0pXFxzKikoPzpjYXRjaHxmaW5hbGx5KVxcYi8sbG9va2JlaGluZDohMH0se3BhdHRlcm46LyhefFteLl0pXFxiKD86YXN8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLGxvb2tiZWhpbmQ6ITB9XSxudW1iZXI6L1xcYig/Oig/OjBbeFhdKD86W1xcZEEtRmEtZl0oPzpfW1xcZEEtRmEtZl0pPykrfDBbYkJdKD86WzAxXSg/Ol9bMDFdKT8pK3wwW29PXSg/OlswLTddKD86X1swLTddKT8pKyluP3woPzpcXGQoPzpfXFxkKT8pK258TmFOfEluZmluaXR5KVxcYnwoPzpcXGIoPzpcXGQoPzpfXFxkKT8pK1xcLj8oPzpcXGQoPzpfXFxkKT8pKnxcXEJcXC4oPzpcXGQoPzpfXFxkKT8pKykoPzpbRWVdWystXT8oPzpcXGQoPzpfXFxkKT8pKyk/LyxmdW5jdGlvbjovW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxccyooPzpcXC5cXHMqKD86YXBwbHl8YmluZHxjYWxsKVxccyopP1xcKCkvLG9wZXJhdG9yOi8tWy09XT98XFwrWys9XT98IT0/PT98PDw/PT98Pj4/Pj89P3w9KD86PT0/fD4pP3wmWyY9XT98XFx8W3w9XT98XFwqXFwqPz0/fFxcLz0/fH58XFxePT98JT0/fFxcP3xcXC57M30vfSk7di5sYW5ndWFnZXMuamF2YXNjcmlwdFtcImNsYXNzLW5hbWVcIl1bMF0ucGF0dGVybj0vKFxcYig/OmNsYXNzfGludGVyZmFjZXxleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxuZXcpXFxzKylbXFx3LlxcXFxdKy87di5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwiamF2YXNjcmlwdFwiLFwia2V5d29yZFwiLHtyZWdleDp7cGF0dGVybjovKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXSlcXHMqKVxcLyhcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZ2lteXVzXXswLDZ9KD89XFxzKigkfFtcXHJcXG4sLjt9KVxcXV0pKS8sbG9va2JlaGluZDohMCxncmVlZHk6ITB9LFwiZnVuY3Rpb24tdmFyaWFibGVcIjp7cGF0dGVybjovW18kYS16QS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8W18kYS16QS1aXFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKilcXHMqPT4pKS8sYWxpYXM6XCJmdW5jdGlvblwifSxwYXJhbWV0ZXI6W3twYXR0ZXJuOi8oZnVuY3Rpb24oPzpcXHMrW18kQS1aYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKCldfFxcKFteKCldKlxcKSkrPyg/PVxccypcXCkpLyxsb29rYmVoaW5kOiEwLGluc2lkZTp2Lmxhbmd1YWdlcy5qYXZhc2NyaXB0fSx7cGF0dGVybjovW18kYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKig/PVxccyo9PikvaSxpbnNpZGU6di5sYW5ndWFnZXMuamF2YXNjcmlwdH0se3BhdHRlcm46LyhcXChcXHMqKSg/IVxccykoPzpbXigpXXxcXChbXigpXSpcXCkpKz8oPz1cXHMqXFwpXFxzKj0+KS8sbG9va2JlaGluZDohMCxpbnNpZGU6di5sYW5ndWFnZXMuamF2YXNjcmlwdH0se3BhdHRlcm46LygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86W18kQS1aYS16XFx4QTAtXFx1RkZGRl1bJFxcd1xceEEwLVxcdUZGRkZdKlxccyopXFwoXFxzKikoPyFcXHMpKD86W14oKV18XFwoW14oKV0qXFwpKSs/KD89XFxzKlxcKVxccypcXHspLyxsb29rYmVoaW5kOiEwLGluc2lkZTp2Lmxhbmd1YWdlcy5qYXZhc2NyaXB0fV0sY29uc3RhbnQ6L1xcYltBLVpdKD86W0EtWl9dfFxcZHg/KSpcXGIvfSk7di5sYW5ndWFnZXMubWFya3VwJiZ2Lmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoXCJzY3JpcHRcIixcImphdmFzY3JpcHRcIik7di5sYW5ndWFnZXMuanM9di5sYW5ndWFnZXMuamF2YXNjcmlwdDt2Lmxhbmd1YWdlcy50eXBlc2NyaXB0PXYubGFuZ3VhZ2VzLmV4dGVuZChcImphdmFzY3JpcHRcIix7a2V5d29yZDovXFxiKD86YWJzdHJhY3R8YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb25zdHJ1Y3Rvcnxjb250aW51ZXxkZWJ1Z2dlcnxkZWNsYXJlfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxpc3xrZXlvZnxsZXR8bW9kdWxlfG5hbWVzcGFjZXxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZWFkb25seXxyZXR1cm58cmVxdWlyZXxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlfHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKVxcYi8sYnVpbHRpbjovXFxiKD86c3RyaW5nfEZ1bmN0aW9ufGFueXxudW1iZXJ8Ym9vbGVhbnxBcnJheXxzeW1ib2x8Y29uc29sZXxQcm9taXNlfHVua25vd258bmV2ZXIpXFxiL30pO3YubGFuZ3VhZ2VzLnRzPXYubGFuZ3VhZ2VzLnR5cGVzY3JpcHQ7ZnVuY3Rpb24gZ2UoZSxyLHQsbixpKXt0aGlzLnR5cGU9ZSx0aGlzLmNvbnRlbnQ9cix0aGlzLmFsaWFzPXQsdGhpcy5sZW5ndGg9KG58fFwiXCIpLmxlbmd0aHwwLHRoaXMuZ3JlZWR5PSEhaX1nZS5zdHJpbmdpZnk9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gdHlwZW9mIGU9PVwic3RyaW5nXCI/ZTpBcnJheS5pc0FycmF5KGUpP2UubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBnZS5zdHJpbmdpZnkodCxyKX0pLmpvaW4oXCJcIik6c2QoZS50eXBlKShlLmNvbnRlbnQpfTtmdW5jdGlvbiBzZChlKXtyZXR1cm4gSnNbZV18fGlkfWZ1bmN0aW9uIEhzKGUpe3JldHVybiBhZChlLHYubGFuZ3VhZ2VzLmphdmFzY3JpcHQpfWZ1bmN0aW9uIGFkKGUscil7cmV0dXJuIHYudG9rZW5pemUoZSxyKS5tYXAobj0+Z2Uuc3RyaW5naWZ5KG4pKS5qb2luKFwiXCIpfWZ1bmN0aW9uIEtzKGUpe3JldHVybiBFaShlKX12YXIgYm49Y2xhc3MgZXtmaXJzdExpbmVOdW1iZXI7bGluZXM7c3RhdGljIHJlYWQocil7bGV0IHQ7dHJ5e3Q9bGQucmVhZEZpbGVTeW5jKHIsXCJ1dGYtOFwiKX1jYXRjaHtyZXR1cm4gbnVsbH1yZXR1cm4gZS5mcm9tQ29udGVudCh0KX1zdGF0aWMgZnJvbUNvbnRlbnQocil7bGV0IHQ9ci5zcGxpdCgvXFxyP1xcbi8pO3JldHVybiBuZXcgZSgxLHQpfWNvbnN0cnVjdG9yKHIsdCl7dGhpcy5maXJzdExpbmVOdW1iZXI9cix0aGlzLmxpbmVzPXR9Z2V0IGxhc3RMaW5lTnVtYmVyKCl7cmV0dXJuIHRoaXMuZmlyc3RMaW5lTnVtYmVyK3RoaXMubGluZXMubGVuZ3RoLTF9bWFwTGluZUF0KHIsdCl7aWYocjx0aGlzLmZpcnN0TGluZU51bWJlcnx8cj50aGlzLmxpbmVzLmxlbmd0aCt0aGlzLmZpcnN0TGluZU51bWJlcilyZXR1cm4gdGhpcztsZXQgbj1yLXRoaXMuZmlyc3RMaW5lTnVtYmVyLGk9Wy4uLnRoaXMubGluZXNdO3JldHVybiBpW25dPXQoaVtuXSksbmV3IGUodGhpcy5maXJzdExpbmVOdW1iZXIsaSl9bWFwTGluZXMocil7cmV0dXJuIG5ldyBlKHRoaXMuZmlyc3RMaW5lTnVtYmVyLHRoaXMubGluZXMubWFwKCh0LG4pPT5yKHQsdGhpcy5maXJzdExpbmVOdW1iZXIrbikpKX1saW5lQXQocil7cmV0dXJuIHRoaXMubGluZXNbci10aGlzLmZpcnN0TGluZU51bWJlcl19cHJlcGVuZFN5bWJvbEF0KHIsdCl7cmV0dXJuIHRoaXMubWFwTGluZXMoKG4saSk9Pmk9PT1yP2Ake3R9ICR7bn1gOmAgICR7bn1gKX1zbGljZShyLHQpe2xldCBuPXRoaXMubGluZXMuc2xpY2Uoci0xLHQpLmpvaW4oYFxuYCk7cmV0dXJuIG5ldyBlKHIsS3Mobikuc3BsaXQoYFxuYCkpfWhpZ2hsaWdodCgpe2xldCByPUhzKHRoaXMudG9TdHJpbmcoKSk7cmV0dXJuIG5ldyBlKHRoaXMuZmlyc3RMaW5lTnVtYmVyLHIuc3BsaXQoYFxuYCkpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMubGluZXMuam9pbihgXG5gKX19O3ZhciB1ZD17cmVkOnVlLGdyYXk6SnIsZGltOkNlLGJvbGQ6USx1bmRlcmxpbmU6SyxoaWdobGlnaHRTb3VyY2U6ZT0+ZS5oaWdobGlnaHQoKX0sY2Q9e3JlZDplPT5lLGdyYXk6ZT0+ZSxkaW06ZT0+ZSxib2xkOmU9PmUsdW5kZXJsaW5lOmU9PmUsaGlnaGxpZ2h0U291cmNlOmU9PmV9O2Z1bmN0aW9uIHBkKHttZXNzYWdlOmUsb3JpZ2luYWxNZXRob2Q6cixpc1BhbmljOnQsY2FsbEFyZ3VtZW50czpufSl7cmV0dXJue2Z1bmN0aW9uTmFtZTpgcHJpc21hLiR7cn0oKWAsbWVzc2FnZTplLGlzUGFuaWM6dD8/ITEsY2FsbEFyZ3VtZW50czpufX1mdW5jdGlvbiBkZCh7Y2FsbHNpdGU6ZSxtZXNzYWdlOnIsb3JpZ2luYWxNZXRob2Q6dCxpc1BhbmljOm4sY2FsbEFyZ3VtZW50czppfSxvKXtsZXQgcz1wZCh7bWVzc2FnZTpyLG9yaWdpbmFsTWV0aG9kOnQsaXNQYW5pYzpuLGNhbGxBcmd1bWVudHM6aX0pO2lmKCFlfHx0eXBlb2Ygd2luZG93PFwidVwifHxwcm9jZXNzLmVudi5OT0RFX0VOVj09PVwicHJvZHVjdGlvblwiKXJldHVybiBzO2xldCBhPWUuZ2V0TG9jYXRpb24oKTtpZighYXx8IWEubGluZU51bWJlcnx8IWEuY29sdW1uTnVtYmVyKXJldHVybiBzO2xldCBsPU1hdGgubWF4KDEsYS5saW5lTnVtYmVyLTMpLHU9Ym4ucmVhZChhLmZpbGVOYW1lKT8uc2xpY2UobCxhLmxpbmVOdW1iZXIpLGM9dT8ubGluZUF0KGEubGluZU51bWJlcik7aWYodSYmYyl7bGV0IHA9ZmQoYyksZD1tZChjKTtpZighZClyZXR1cm4gcztzLmZ1bmN0aW9uTmFtZT1gJHtkLmNvZGV9KWAscy5sb2NhdGlvbj1hLG58fCh1PXUubWFwTGluZUF0KGEubGluZU51bWJlcixoPT5oLnNsaWNlKDAsZC5vcGVuaW5nQnJhY2VJbmRleCkpKSx1PW8uaGlnaGxpZ2h0U291cmNlKHUpO2xldCBmPVN0cmluZyh1Lmxhc3RMaW5lTnVtYmVyKS5sZW5ndGg7aWYocy5jb250ZXh0TGluZXM9dS5tYXBMaW5lcygoaCxnKT0+by5ncmF5KFN0cmluZyhnKS5wYWRTdGFydChmKSkrXCIgXCIraCkubWFwTGluZXMoaD0+by5kaW0oaCkpLnByZXBlbmRTeW1ib2xBdChhLmxpbmVOdW1iZXIsby5ib2xkKG8ucmVkKFwiXFx1MjE5MlwiKSkpLGkpe2xldCBoPXArZisxO2grPTIscy5jYWxsQXJndW1lbnRzPSgwLFlzLmRlZmF1bHQpKGksaCkuc2xpY2UoaCl9fXJldHVybiBzfWZ1bmN0aW9uIG1kKGUpe2xldCByPU9iamVjdC5rZXlzKFJyKS5qb2luKFwifFwiKSxuPW5ldyBSZWdFeHAoU3RyaW5nLnJhd2BcXC4oJHtyfSlcXChgKS5leGVjKGUpO2lmKG4pe2xldCBpPW4uaW5kZXgrblswXS5sZW5ndGgsbz1lLmxhc3RJbmRleE9mKFwiIFwiLG4uaW5kZXgpKzE7cmV0dXJue2NvZGU6ZS5zbGljZShvLGkpLG9wZW5pbmdCcmFjZUluZGV4Oml9fXJldHVybiBudWxsfWZ1bmN0aW9uIGZkKGUpe2xldCByPTA7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspe2lmKGUuY2hhckF0KHQpIT09XCIgXCIpcmV0dXJuIHI7cisrfXJldHVybiByfWZ1bmN0aW9uIGdkKHtmdW5jdGlvbk5hbWU6ZSxsb2NhdGlvbjpyLG1lc3NhZ2U6dCxpc1BhbmljOm4sY29udGV4dExpbmVzOmksY2FsbEFyZ3VtZW50czpvfSxzKXtsZXQgYT1bXCJcIl0sbD1yP1wiIGluXCI6XCI6XCI7aWYobj8oYS5wdXNoKHMucmVkKGBPb3BzLCBhbiB1bmtub3duIGVycm9yIG9jY3VycmVkISBUaGlzIGlzICR7cy5ib2xkKFwib24gdXNcIil9LCB5b3UgZGlkIG5vdGhpbmcgd3JvbmcuYCkpLGEucHVzaChzLnJlZChgSXQgb2NjdXJyZWQgaW4gdGhlICR7cy5ib2xkKGBcXGAke2V9XFxgYCl9IGludm9jYXRpb24ke2x9YCkpKTphLnB1c2gocy5yZWQoYEludmFsaWQgJHtzLmJvbGQoYFxcYCR7ZX1cXGBgKX0gaW52b2NhdGlvbiR7bH1gKSksciYmYS5wdXNoKHMudW5kZXJsaW5lKGhkKHIpKSksaSl7YS5wdXNoKFwiXCIpO2xldCB1PVtpLnRvU3RyaW5nKCldO28mJih1LnB1c2gobyksdS5wdXNoKHMuZGltKFwiKVwiKSkpLGEucHVzaCh1LmpvaW4oXCJcIikpLG8mJmEucHVzaChcIlwiKX1lbHNlIGEucHVzaChcIlwiKSxvJiZhLnB1c2gobyksYS5wdXNoKFwiXCIpO3JldHVybiBhLnB1c2godCksYS5qb2luKGBcbmApfWZ1bmN0aW9uIGhkKGUpe2xldCByPVtlLmZpbGVOYW1lXTtyZXR1cm4gZS5saW5lTnVtYmVyJiZyLnB1c2goU3RyaW5nKGUubGluZU51bWJlcikpLGUuY29sdW1uTnVtYmVyJiZyLnB1c2goU3RyaW5nKGUuY29sdW1uTnVtYmVyKSksci5qb2luKFwiOlwiKX1mdW5jdGlvbiBFbihlKXtsZXQgcj1lLnNob3dDb2xvcnM/dWQ6Y2QsdDtyZXR1cm4gdD1kZChlLHIpLGdkKHQscil9dmFyIG9hPW5lKGppKCkpO2Z1bmN0aW9uIGVhKGUscix0KXtsZXQgbj1yYShlKSxpPXlkKG4pLG89RWQoaSk7bz93bihvLHIsdCk6ci5hZGRFcnJvck1lc3NhZ2UoKCk9PlwiVW5rbm93biBlcnJvclwiKX1mdW5jdGlvbiByYShlKXtyZXR1cm4gZS5lcnJvcnMuZmxhdE1hcChyPT5yLmtpbmQ9PT1cIlVuaW9uXCI/cmEocik6W3JdKX1mdW5jdGlvbiB5ZChlKXtsZXQgcj1uZXcgTWFwLHQ9W107Zm9yKGxldCBuIG9mIGUpe2lmKG4ua2luZCE9PVwiSW52YWxpZEFyZ3VtZW50VHlwZVwiKXt0LnB1c2gobik7Y29udGludWV9bGV0IGk9YCR7bi5zZWxlY3Rpb25QYXRoLmpvaW4oXCIuXCIpfToke24uYXJndW1lbnRQYXRoLmpvaW4oXCIuXCIpfWAsbz1yLmdldChpKTtvP3Iuc2V0KGksey4uLm4sYXJndW1lbnQ6ey4uLm4uYXJndW1lbnQsdHlwZU5hbWVzOmJkKG8uYXJndW1lbnQudHlwZU5hbWVzLG4uYXJndW1lbnQudHlwZU5hbWVzKX19KTpyLnNldChpLG4pfXJldHVybiB0LnB1c2goLi4uci52YWx1ZXMoKSksdH1mdW5jdGlvbiBiZChlLHIpe3JldHVyblsuLi5uZXcgU2V0KGUuY29uY2F0KHIpKV19ZnVuY3Rpb24gRWQoZSl7cmV0dXJuIF9pKGUsKHIsdCk9PntsZXQgbj1acyhyKSxpPVpzKHQpO3JldHVybiBuIT09aT9uLWk6WHMociktWHModCl9KX1mdW5jdGlvbiBacyhlKXtsZXQgcj0wO3JldHVybiBBcnJheS5pc0FycmF5KGUuc2VsZWN0aW9uUGF0aCkmJihyKz1lLnNlbGVjdGlvblBhdGgubGVuZ3RoKSxBcnJheS5pc0FycmF5KGUuYXJndW1lbnRQYXRoKSYmKHIrPWUuYXJndW1lbnRQYXRoLmxlbmd0aCkscn1mdW5jdGlvbiBYcyhlKXtzd2l0Y2goZS5raW5kKXtjYXNlXCJJbnZhbGlkQXJndW1lbnRWYWx1ZVwiOmNhc2VcIlZhbHVlVG9vTGFyZ2VcIjpyZXR1cm4gMjA7Y2FzZVwiSW52YWxpZEFyZ3VtZW50VHlwZVwiOnJldHVybiAxMDtjYXNlXCJSZXF1aXJlZEFyZ3VtZW50TWlzc2luZ1wiOnJldHVybi0xMDtkZWZhdWx0OnJldHVybiAwfX12YXIgYWU9Y2xhc3N7Y29uc3RydWN0b3Iocix0KXt0aGlzLm5hbWU9cjt0aGlzLnZhbHVlPXR9aXNSZXF1aXJlZD0hMTttYWtlUmVxdWlyZWQoKXtyZXR1cm4gdGhpcy5pc1JlcXVpcmVkPSEwLHRoaXN9d3JpdGUocil7bGV0e2NvbG9yczp7Z3JlZW46dH19PXIuY29udGV4dDtyLmFkZE1hcmdpblN5bWJvbCh0KHRoaXMuaXNSZXF1aXJlZD9cIitcIjpcIj9cIikpLHIud3JpdGUodCh0aGlzLm5hbWUpKSx0aGlzLmlzUmVxdWlyZWR8fHIud3JpdGUodChcIj9cIikpLHIud3JpdGUodChcIjogXCIpKSx0eXBlb2YgdGhpcy52YWx1ZT09XCJzdHJpbmdcIj9yLndyaXRlKHQodGhpcy52YWx1ZSkpOnIud3JpdGUodGhpcy52YWx1ZSl9fTtuYSgpO3ZhciBBcj1jbGFzc3tjb25zdHJ1Y3RvcihyPTAsdCl7dGhpcy5jb250ZXh0PXQ7dGhpcy5jdXJyZW50SW5kZW50PXJ9bGluZXM9W107Y3VycmVudExpbmU9XCJcIjtjdXJyZW50SW5kZW50PTA7bWFyZ2luU3ltYm9sO2FmdGVyTmV4dE5ld0xpbmVDYWxsYmFjazt3cml0ZShyKXtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/dGhpcy5jdXJyZW50TGluZSs9cjpyLndyaXRlKHRoaXMpLHRoaXN9d3JpdGVKb2luZWQocix0LG49KGksbyk9Pm8ud3JpdGUoaSkpe2xldCBpPXQubGVuZ3RoLTE7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspbih0W29dLHRoaXMpLG8hPT1pJiZ0aGlzLndyaXRlKHIpO3JldHVybiB0aGlzfXdyaXRlTGluZShyKXtyZXR1cm4gdGhpcy53cml0ZShyKS5uZXdMaW5lKCl9bmV3TGluZSgpe3RoaXMubGluZXMucHVzaCh0aGlzLmluZGVudGVkQ3VycmVudExpbmUoKSksdGhpcy5jdXJyZW50TGluZT1cIlwiLHRoaXMubWFyZ2luU3ltYm9sPXZvaWQgMDtsZXQgcj10aGlzLmFmdGVyTmV4dE5ld0xpbmVDYWxsYmFjaztyZXR1cm4gdGhpcy5hZnRlck5leHROZXdMaW5lQ2FsbGJhY2s9dm9pZCAwLHI/LigpLHRoaXN9d2l0aEluZGVudChyKXtyZXR1cm4gdGhpcy5pbmRlbnQoKSxyKHRoaXMpLHRoaXMudW5pbmRlbnQoKSx0aGlzfWFmdGVyTmV4dE5ld2xpbmUocil7cmV0dXJuIHRoaXMuYWZ0ZXJOZXh0TmV3TGluZUNhbGxiYWNrPXIsdGhpc31pbmRlbnQoKXtyZXR1cm4gdGhpcy5jdXJyZW50SW5kZW50KyssdGhpc311bmluZGVudCgpe3JldHVybiB0aGlzLmN1cnJlbnRJbmRlbnQ+MCYmdGhpcy5jdXJyZW50SW5kZW50LS0sdGhpc31hZGRNYXJnaW5TeW1ib2wocil7cmV0dXJuIHRoaXMubWFyZ2luU3ltYm9sPXIsdGhpc310b1N0cmluZygpe3JldHVybiB0aGlzLmxpbmVzLmNvbmNhdCh0aGlzLmluZGVudGVkQ3VycmVudExpbmUoKSkuam9pbihgXG5gKX1nZXRDdXJyZW50TGluZUxlbmd0aCgpe3JldHVybiB0aGlzLmN1cnJlbnRMaW5lLmxlbmd0aH1pbmRlbnRlZEN1cnJlbnRMaW5lKCl7bGV0IHI9dGhpcy5jdXJyZW50TGluZS5wYWRTdGFydCh0aGlzLmN1cnJlbnRMaW5lLmxlbmd0aCsyKnRoaXMuY3VycmVudEluZGVudCk7cmV0dXJuIHRoaXMubWFyZ2luU3ltYm9sP3RoaXMubWFyZ2luU3ltYm9sK3Iuc2xpY2UoMSk6cn19O3RhKCk7dmFyIHhuPWNsYXNze2NvbnN0cnVjdG9yKHIpe3RoaXMudmFsdWU9cn13cml0ZShyKXtyLndyaXRlKHRoaXMudmFsdWUpfW1hcmtBc0Vycm9yKCl7dGhpcy52YWx1ZS5tYXJrQXNFcnJvcigpfX07dmFyIHZuPWU9PmUsUG49e2JvbGQ6dm4scmVkOnZuLGdyZWVuOnZuLGRpbTp2bixlbmFibGVkOiExfSxpYT17Ym9sZDpRLHJlZDp1ZSxncmVlbjpxZSxkaW06Q2UsZW5hYmxlZDohMH0sQ3I9e3dyaXRlKGUpe2Uud3JpdGVMaW5lKFwiLFwiKX19O3ZhciBQZT1jbGFzc3tjb25zdHJ1Y3RvcihyKXt0aGlzLmNvbnRlbnRzPXJ9aXNVbmRlcmxpbmVkPSExO2NvbG9yPXI9PnI7dW5kZXJsaW5lKCl7cmV0dXJuIHRoaXMuaXNVbmRlcmxpbmVkPSEwLHRoaXN9c2V0Q29sb3Iocil7cmV0dXJuIHRoaXMuY29sb3I9cix0aGlzfXdyaXRlKHIpe2xldCB0PXIuZ2V0Q3VycmVudExpbmVMZW5ndGgoKTtyLndyaXRlKHRoaXMuY29sb3IodGhpcy5jb250ZW50cykpLHRoaXMuaXNVbmRlcmxpbmVkJiZyLmFmdGVyTmV4dE5ld2xpbmUoKCk9PntyLndyaXRlKFwiIFwiLnJlcGVhdCh0KSkud3JpdGVMaW5lKHRoaXMuY29sb3IoXCJ+XCIucmVwZWF0KHRoaXMuY29udGVudHMubGVuZ3RoKSkpfSl9fTt2YXIgemU9Y2xhc3N7aGFzRXJyb3I9ITE7bWFya0FzRXJyb3IoKXtyZXR1cm4gdGhpcy5oYXNFcnJvcj0hMCx0aGlzfX07dmFyIElyPWNsYXNzIGV4dGVuZHMgemV7aXRlbXM9W107YWRkSXRlbShyKXtyZXR1cm4gdGhpcy5pdGVtcy5wdXNoKG5ldyB4bihyKSksdGhpc31nZXRGaWVsZChyKXtyZXR1cm4gdGhpcy5pdGVtc1tyXX1nZXRQcmludFdpZHRoKCl7cmV0dXJuIHRoaXMuaXRlbXMubGVuZ3RoPT09MD8yOk1hdGgubWF4KC4uLnRoaXMuaXRlbXMubWFwKHQ9PnQudmFsdWUuZ2V0UHJpbnRXaWR0aCgpKSkrMn13cml0ZShyKXtpZih0aGlzLml0ZW1zLmxlbmd0aD09PTApe3RoaXMud3JpdGVFbXB0eShyKTtyZXR1cm59dGhpcy53cml0ZVdpdGhJdGVtcyhyKX13cml0ZUVtcHR5KHIpe2xldCB0PW5ldyBQZShcIltdXCIpO3RoaXMuaGFzRXJyb3ImJnQuc2V0Q29sb3Ioci5jb250ZXh0LmNvbG9ycy5yZWQpLnVuZGVybGluZSgpLHIud3JpdGUodCl9d3JpdGVXaXRoSXRlbXMocil7bGV0e2NvbG9yczp0fT1yLmNvbnRleHQ7ci53cml0ZUxpbmUoXCJbXCIpLndpdGhJbmRlbnQoKCk9PnIud3JpdGVKb2luZWQoQ3IsdGhpcy5pdGVtcykubmV3TGluZSgpKS53cml0ZShcIl1cIiksdGhpcy5oYXNFcnJvciYmci5hZnRlck5leHROZXdsaW5lKCgpPT57ci53cml0ZUxpbmUodC5yZWQoXCJ+XCIucmVwZWF0KHRoaXMuZ2V0UHJpbnRXaWR0aCgpKSkpfSl9YXNPYmplY3QoKXt9fTt2YXIga3I9Y2xhc3MgZSBleHRlbmRzIHple2ZpZWxkcz17fTtzdWdnZXN0aW9ucz1bXTthZGRGaWVsZChyKXt0aGlzLmZpZWxkc1tyLm5hbWVdPXJ9YWRkU3VnZ2VzdGlvbihyKXt0aGlzLnN1Z2dlc3Rpb25zLnB1c2gocil9Z2V0RmllbGQocil7cmV0dXJuIHRoaXMuZmllbGRzW3JdfWdldERlZXBGaWVsZChyKXtsZXRbdCwuLi5uXT1yLGk9dGhpcy5nZXRGaWVsZCh0KTtpZighaSlyZXR1cm47bGV0IG89aTtmb3IobGV0IHMgb2Ygbil7bGV0IGE7aWYoby52YWx1ZSBpbnN0YW5jZW9mIGU/YT1vLnZhbHVlLmdldEZpZWxkKHMpOm8udmFsdWUgaW5zdGFuY2VvZiBJciYmKGE9by52YWx1ZS5nZXRGaWVsZChOdW1iZXIocykpKSwhYSlyZXR1cm47bz1hfXJldHVybiBvfWdldERlZXBGaWVsZFZhbHVlKHIpe3JldHVybiByLmxlbmd0aD09PTA/dGhpczp0aGlzLmdldERlZXBGaWVsZChyKT8udmFsdWV9aGFzRmllbGQocil7cmV0dXJuISF0aGlzLmdldEZpZWxkKHIpfXJlbW92ZUFsbEZpZWxkcygpe3RoaXMuZmllbGRzPXt9fXJlbW92ZUZpZWxkKHIpe2RlbGV0ZSB0aGlzLmZpZWxkc1tyXX1nZXRGaWVsZHMoKXtyZXR1cm4gdGhpcy5maWVsZHN9aXNFbXB0eSgpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykubGVuZ3RoPT09MH1nZXRGaWVsZFZhbHVlKHIpe3JldHVybiB0aGlzLmdldEZpZWxkKHIpPy52YWx1ZX1nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUocil7bGV0IHQ9dGhpcztmb3IobGV0IG4gb2Ygcil7aWYoISh0IGluc3RhbmNlb2YgZSkpcmV0dXJuO2xldCBpPXQuZ2V0U3ViU2VsZWN0aW9uVmFsdWUobik7aWYoIWkpcmV0dXJuO3Q9aX1yZXR1cm4gdH1nZXREZWVwU2VsZWN0aW9uUGFyZW50KHIpe2xldCB0PXRoaXMuZ2V0U2VsZWN0aW9uUGFyZW50KCk7aWYoIXQpcmV0dXJuO2xldCBuPXQ7Zm9yKGxldCBpIG9mIHIpe2xldCBvPW4udmFsdWUuZ2V0RmllbGRWYWx1ZShpKTtpZighb3x8IShvIGluc3RhbmNlb2YgZSkpcmV0dXJuO2xldCBzPW8uZ2V0U2VsZWN0aW9uUGFyZW50KCk7aWYoIXMpcmV0dXJuO249c31yZXR1cm4gbn1nZXRTZWxlY3Rpb25QYXJlbnQoKXtsZXQgcj10aGlzLmdldEZpZWxkKFwic2VsZWN0XCIpPy52YWx1ZS5hc09iamVjdCgpO2lmKHIpcmV0dXJue2tpbmQ6XCJzZWxlY3RcIix2YWx1ZTpyfTtsZXQgdD10aGlzLmdldEZpZWxkKFwiaW5jbHVkZVwiKT8udmFsdWUuYXNPYmplY3QoKTtpZih0KXJldHVybntraW5kOlwiaW5jbHVkZVwiLHZhbHVlOnR9fWdldFN1YlNlbGVjdGlvblZhbHVlKHIpe3JldHVybiB0aGlzLmdldFNlbGVjdGlvblBhcmVudCgpPy52YWx1ZS5maWVsZHNbcl0udmFsdWV9Z2V0UHJpbnRXaWR0aCgpe2xldCByPU9iamVjdC52YWx1ZXModGhpcy5maWVsZHMpO3JldHVybiByLmxlbmd0aD09MD8yOk1hdGgubWF4KC4uLnIubWFwKG49Pm4uZ2V0UHJpbnRXaWR0aCgpKSkrMn13cml0ZShyKXtsZXQgdD1PYmplY3QudmFsdWVzKHRoaXMuZmllbGRzKTtpZih0Lmxlbmd0aD09PTAmJnRoaXMuc3VnZ2VzdGlvbnMubGVuZ3RoPT09MCl7dGhpcy53cml0ZUVtcHR5KHIpO3JldHVybn10aGlzLndyaXRlV2l0aENvbnRlbnRzKHIsdCl9YXNPYmplY3QoKXtyZXR1cm4gdGhpc313cml0ZUVtcHR5KHIpe2xldCB0PW5ldyBQZShcInt9XCIpO3RoaXMuaGFzRXJyb3ImJnQuc2V0Q29sb3Ioci5jb250ZXh0LmNvbG9ycy5yZWQpLnVuZGVybGluZSgpLHIud3JpdGUodCl9d3JpdGVXaXRoQ29udGVudHMocix0KXtyLndyaXRlTGluZShcIntcIikud2l0aEluZGVudCgoKT0+e3Iud3JpdGVKb2luZWQoQ3IsWy4uLnQsLi4udGhpcy5zdWdnZXN0aW9uc10pLm5ld0xpbmUoKX0pLHIud3JpdGUoXCJ9XCIpLHRoaXMuaGFzRXJyb3ImJnIuYWZ0ZXJOZXh0TmV3bGluZSgoKT0+e3Iud3JpdGVMaW5lKHIuY29udGV4dC5jb2xvcnMucmVkKFwiflwiLnJlcGVhdCh0aGlzLmdldFByaW50V2lkdGgoKSkpKX0pfX07dmFyIEc9Y2xhc3MgZXh0ZW5kcyB6ZXtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpO3RoaXMudGV4dD10fWdldFByaW50V2lkdGgoKXtyZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aH13cml0ZSh0KXtsZXQgbj1uZXcgUGUodGhpcy50ZXh0KTt0aGlzLmhhc0Vycm9yJiZuLnVuZGVybGluZSgpLnNldENvbG9yKHQuY29udGV4dC5jb2xvcnMucmVkKSx0LndyaXRlKG4pfWFzT2JqZWN0KCl7fX07dmFyIGx0PWNsYXNze2ZpZWxkcz1bXTthZGRGaWVsZChyLHQpe3JldHVybiB0aGlzLmZpZWxkcy5wdXNoKHt3cml0ZShuKXtsZXR7Z3JlZW46aSxkaW06b309bi5jb250ZXh0LmNvbG9ycztuLndyaXRlKGkobyhgJHtyfTogJHt0fWApKSkuYWRkTWFyZ2luU3ltYm9sKGkobyhcIitcIikpKX19KSx0aGlzfXdyaXRlKHIpe2xldHtjb2xvcnM6e2dyZWVuOnR9fT1yLmNvbnRleHQ7ci53cml0ZUxpbmUodChcIntcIikpLndpdGhJbmRlbnQoKCk9PntyLndyaXRlSm9pbmVkKENyLHRoaXMuZmllbGRzKS5uZXdMaW5lKCl9KS53cml0ZSh0KFwifVwiKSkuYWRkTWFyZ2luU3ltYm9sKHQoXCIrXCIpKX19O2Z1bmN0aW9uIHduKGUscix0KXtzd2l0Y2goZS5raW5kKXtjYXNlXCJNdXR1YWxseUV4Y2x1c2l2ZUZpZWxkc1wiOndkKGUscik7YnJlYWs7Y2FzZVwiSW5jbHVkZU9uU2NhbGFyXCI6eGQoZSxyKTticmVhaztjYXNlXCJFbXB0eVNlbGVjdGlvblwiOnZkKGUscix0KTticmVhaztjYXNlXCJVbmtub3duU2VsZWN0aW9uRmllbGRcIjpSZChlLHIpO2JyZWFrO2Nhc2VcIkludmFsaWRTZWxlY3Rpb25WYWx1ZVwiOkFkKGUscik7YnJlYWs7Y2FzZVwiVW5rbm93bkFyZ3VtZW50XCI6Q2QoZSxyKTticmVhaztjYXNlXCJVbmtub3duSW5wdXRGaWVsZFwiOklkKGUscik7YnJlYWs7Y2FzZVwiUmVxdWlyZWRBcmd1bWVudE1pc3NpbmdcIjprZChlLHIpO2JyZWFrO2Nhc2VcIkludmFsaWRBcmd1bWVudFR5cGVcIjpEZChlLHIpO2JyZWFrO2Nhc2VcIkludmFsaWRBcmd1bWVudFZhbHVlXCI6T2QoZSxyKTticmVhaztjYXNlXCJWYWx1ZVRvb0xhcmdlXCI6X2QoZSxyKTticmVhaztjYXNlXCJTb21lRmllbGRzTWlzc2luZ1wiOk5kKGUscik7YnJlYWs7Y2FzZVwiVG9vTWFueUZpZWxkc0dpdmVuXCI6TGQoZSxyKTticmVhaztjYXNlXCJVbmlvblwiOmVhKGUscix0KTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDogXCIrZS5raW5kKX19ZnVuY3Rpb24gd2QoZSxyKXtsZXQgdD1yLmFyZ3VtZW50cy5nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUoZS5zZWxlY3Rpb25QYXRoKT8uYXNPYmplY3QoKTt0JiYodC5nZXRGaWVsZChlLmZpcnN0RmllbGQpPy5tYXJrQXNFcnJvcigpLHQuZ2V0RmllbGQoZS5zZWNvbmRGaWVsZCk/Lm1hcmtBc0Vycm9yKCkpLHIuYWRkRXJyb3JNZXNzYWdlKG49PmBQbGVhc2UgJHtuLmJvbGQoXCJlaXRoZXJcIil9IHVzZSAke24uZ3JlZW4oYFxcYCR7ZS5maXJzdEZpZWxkfVxcYGApfSBvciAke24uZ3JlZW4oYFxcYCR7ZS5zZWNvbmRGaWVsZH1cXGBgKX0sIGJ1dCAke24ucmVkKFwibm90IGJvdGhcIil9IGF0IHRoZSBzYW1lIHRpbWUuYCl9ZnVuY3Rpb24geGQoZSxyKXtsZXRbdCxuXT1EcihlLnNlbGVjdGlvblBhdGgpLGk9ZS5vdXRwdXRUeXBlLG89ci5hcmd1bWVudHMuZ2V0RGVlcFNlbGVjdGlvblBhcmVudCh0KT8udmFsdWU7aWYobyYmKG8uZ2V0RmllbGQobik/Lm1hcmtBc0Vycm9yKCksaSkpZm9yKGxldCBzIG9mIGkuZmllbGRzKXMuaXNSZWxhdGlvbiYmby5hZGRTdWdnZXN0aW9uKG5ldyBhZShzLm5hbWUsXCJ0cnVlXCIpKTtyLmFkZEVycm9yTWVzc2FnZShzPT57bGV0IGE9YEludmFsaWQgc2NhbGFyIGZpZWxkICR7cy5yZWQoYFxcYCR7bn1cXGBgKX0gZm9yICR7cy5ib2xkKFwiaW5jbHVkZVwiKX0gc3RhdGVtZW50YDtyZXR1cm4gaT9hKz1gIG9uIG1vZGVsICR7cy5ib2xkKGkubmFtZSl9LiAke3V0KHMpfWA6YSs9XCIuXCIsYSs9YFxuTm90ZSB0aGF0ICR7cy5ib2xkKFwiaW5jbHVkZVwiKX0gc3RhdGVtZW50cyBvbmx5IGFjY2VwdCByZWxhdGlvbiBmaWVsZHMuYCxhfSl9ZnVuY3Rpb24gdmQoZSxyLHQpe2xldCBuPXIuYXJndW1lbnRzLmdldERlZXBTdWJTZWxlY3Rpb25WYWx1ZShlLnNlbGVjdGlvblBhdGgpPy5hc09iamVjdCgpO2lmKG4pe2xldCBpPW4uZ2V0RmllbGQoXCJvbWl0XCIpPy52YWx1ZS5hc09iamVjdCgpO2lmKGkpe1BkKGUscixpKTtyZXR1cm59aWYobi5oYXNGaWVsZChcInNlbGVjdFwiKSl7VGQoZSxyKTtyZXR1cm59fWlmKHQ/LltZZShlLm91dHB1dFR5cGUubmFtZSldKXtTZChlLHIpO3JldHVybn1yLmFkZEVycm9yTWVzc2FnZSgoKT0+YFVua25vd24gZmllbGQgYXQgXCIke2Uuc2VsZWN0aW9uUGF0aC5qb2luKFwiLlwiKX0gc2VsZWN0aW9uXCJgKX1mdW5jdGlvbiBQZChlLHIsdCl7dC5yZW1vdmVBbGxGaWVsZHMoKTtmb3IobGV0IG4gb2YgZS5vdXRwdXRUeXBlLmZpZWxkcyl0LmFkZFN1Z2dlc3Rpb24obmV3IGFlKG4ubmFtZSxcImZhbHNlXCIpKTtyLmFkZEVycm9yTWVzc2FnZShuPT5gVGhlICR7bi5yZWQoXCJvbWl0XCIpfSBzdGF0ZW1lbnQgaW5jbHVkZXMgZXZlcnkgZmllbGQgb2YgdGhlIG1vZGVsICR7bi5ib2xkKGUub3V0cHV0VHlwZS5uYW1lKX0uIEF0IGxlYXN0IG9uZSBmaWVsZCBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRgKX1mdW5jdGlvbiBUZChlLHIpe2xldCB0PWUub3V0cHV0VHlwZSxuPXIuYXJndW1lbnRzLmdldERlZXBTZWxlY3Rpb25QYXJlbnQoZS5zZWxlY3Rpb25QYXRoKT8udmFsdWUsaT1uPy5pc0VtcHR5KCk/PyExO24mJihuLnJlbW92ZUFsbEZpZWxkcygpLGxhKG4sdCkpLHIuYWRkRXJyb3JNZXNzYWdlKG89Pmk/YFRoZSAke28ucmVkKFwiYHNlbGVjdGBcIil9IHN0YXRlbWVudCBmb3IgdHlwZSAke28uYm9sZCh0Lm5hbWUpfSBtdXN0IG5vdCBiZSBlbXB0eS4gJHt1dChvKX1gOmBUaGUgJHtvLnJlZChcImBzZWxlY3RgXCIpfSBzdGF0ZW1lbnQgZm9yIHR5cGUgJHtvLmJvbGQodC5uYW1lKX0gbmVlZHMgJHtvLmJvbGQoXCJhdCBsZWFzdCBvbmUgdHJ1dGh5IHZhbHVlXCIpfS5gKX1mdW5jdGlvbiBTZChlLHIpe2xldCB0PW5ldyBsdDtmb3IobGV0IGkgb2YgZS5vdXRwdXRUeXBlLmZpZWxkcylpLmlzUmVsYXRpb258fHQuYWRkRmllbGQoaS5uYW1lLFwiZmFsc2VcIik7bGV0IG49bmV3IGFlKFwib21pdFwiLHQpLm1ha2VSZXF1aXJlZCgpO2lmKGUuc2VsZWN0aW9uUGF0aC5sZW5ndGg9PT0wKXIuYXJndW1lbnRzLmFkZFN1Z2dlc3Rpb24obik7ZWxzZXtsZXRbaSxvXT1EcihlLnNlbGVjdGlvblBhdGgpLGE9ci5hcmd1bWVudHMuZ2V0RGVlcFNlbGVjdGlvblBhcmVudChpKT8udmFsdWUuYXNPYmplY3QoKT8uZ2V0RmllbGQobyk7aWYoYSl7bGV0IGw9YT8udmFsdWUuYXNPYmplY3QoKT8/bmV3IGtyO2wuYWRkU3VnZ2VzdGlvbihuKSxhLnZhbHVlPWx9fXIuYWRkRXJyb3JNZXNzYWdlKGk9PmBUaGUgZ2xvYmFsICR7aS5yZWQoXCJvbWl0XCIpfSBjb25maWd1cmF0aW9uIGV4Y2x1ZGVzIGV2ZXJ5IGZpZWxkIG9mIHRoZSBtb2RlbCAke2kuYm9sZChlLm91dHB1dFR5cGUubmFtZSl9LiBBdCBsZWFzdCBvbmUgZmllbGQgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgcmVzdWx0YCl9ZnVuY3Rpb24gUmQoZSxyKXtsZXQgdD11YShlLnNlbGVjdGlvblBhdGgscik7aWYodC5wYXJlbnRLaW5kIT09XCJ1bmtub3duXCIpe3QuZmllbGQubWFya0FzRXJyb3IoKTtsZXQgbj10LnBhcmVudDtzd2l0Y2godC5wYXJlbnRLaW5kKXtjYXNlXCJzZWxlY3RcIjpsYShuLGUub3V0cHV0VHlwZSk7YnJlYWs7Y2FzZVwiaW5jbHVkZVwiOkZkKG4sZS5vdXRwdXRUeXBlKTticmVhaztjYXNlXCJvbWl0XCI6TWQobixlLm91dHB1dFR5cGUpO2JyZWFrfX1yLmFkZEVycm9yTWVzc2FnZShuPT57bGV0IGk9W2BVbmtub3duIGZpZWxkICR7bi5yZWQoYFxcYCR7dC5maWVsZE5hbWV9XFxgYCl9YF07cmV0dXJuIHQucGFyZW50S2luZCE9PVwidW5rbm93blwiJiZpLnB1c2goYGZvciAke24uYm9sZCh0LnBhcmVudEtpbmQpfSBzdGF0ZW1lbnRgKSxpLnB1c2goYG9uIG1vZGVsICR7bi5ib2xkKGBcXGAke2Uub3V0cHV0VHlwZS5uYW1lfVxcYGApfS5gKSxpLnB1c2godXQobikpLGkuam9pbihcIiBcIil9KX1mdW5jdGlvbiBBZChlLHIpe2xldCB0PXVhKGUuc2VsZWN0aW9uUGF0aCxyKTt0LnBhcmVudEtpbmQhPT1cInVua25vd25cIiYmdC5maWVsZC52YWx1ZS5tYXJrQXNFcnJvcigpLHIuYWRkRXJyb3JNZXNzYWdlKG49PmBJbnZhbGlkIHZhbHVlIGZvciBzZWxlY3Rpb24gZmllbGQgXFxgJHtuLnJlZCh0LmZpZWxkTmFtZSl9XFxgOiAke2UudW5kZXJseWluZ0Vycm9yfWApfWZ1bmN0aW9uIENkKGUscil7bGV0IHQ9ZS5hcmd1bWVudFBhdGhbMF0sbj1yLmFyZ3VtZW50cy5nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUoZS5zZWxlY3Rpb25QYXRoKT8uYXNPYmplY3QoKTtuJiYobi5nZXRGaWVsZCh0KT8ubWFya0FzRXJyb3IoKSwkZChuLGUuYXJndW1lbnRzKSksci5hZGRFcnJvck1lc3NhZ2UoaT0+c2EoaSx0LGUuYXJndW1lbnRzLm1hcChvPT5vLm5hbWUpKSl9ZnVuY3Rpb24gSWQoZSxyKXtsZXRbdCxuXT1EcihlLmFyZ3VtZW50UGF0aCksaT1yLmFyZ3VtZW50cy5nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUoZS5zZWxlY3Rpb25QYXRoKT8uYXNPYmplY3QoKTtpZihpKXtpLmdldERlZXBGaWVsZChlLmFyZ3VtZW50UGF0aCk/Lm1hcmtBc0Vycm9yKCk7bGV0IG89aS5nZXREZWVwRmllbGRWYWx1ZSh0KT8uYXNPYmplY3QoKTtvJiZjYShvLGUuaW5wdXRUeXBlKX1yLmFkZEVycm9yTWVzc2FnZShvPT5zYShvLG4sZS5pbnB1dFR5cGUuZmllbGRzLm1hcChzPT5zLm5hbWUpKSl9ZnVuY3Rpb24gc2EoZSxyLHQpe2xldCBuPVtgVW5rbm93biBhcmd1bWVudCBcXGAke2UucmVkKHIpfVxcYC5gXSxpPWpkKHIsdCk7cmV0dXJuIGkmJm4ucHVzaChgRGlkIHlvdSBtZWFuIFxcYCR7ZS5ncmVlbihpKX1cXGA/YCksdC5sZW5ndGg+MCYmbi5wdXNoKHV0KGUpKSxuLmpvaW4oXCIgXCIpfWZ1bmN0aW9uIGtkKGUscil7bGV0IHQ7ci5hZGRFcnJvck1lc3NhZ2UobD0+dD8udmFsdWUgaW5zdGFuY2VvZiBHJiZ0LnZhbHVlLnRleHQ9PT1cIm51bGxcIj9gQXJndW1lbnQgXFxgJHtsLmdyZWVuKG8pfVxcYCBtdXN0IG5vdCBiZSAke2wucmVkKFwibnVsbFwiKX0uYDpgQXJndW1lbnQgXFxgJHtsLmdyZWVuKG8pfVxcYCBpcyBtaXNzaW5nLmApO2xldCBuPXIuYXJndW1lbnRzLmdldERlZXBTdWJTZWxlY3Rpb25WYWx1ZShlLnNlbGVjdGlvblBhdGgpPy5hc09iamVjdCgpO2lmKCFuKXJldHVybjtsZXRbaSxvXT1EcihlLmFyZ3VtZW50UGF0aCkscz1uZXcgbHQsYT1uLmdldERlZXBGaWVsZFZhbHVlKGkpPy5hc09iamVjdCgpO2lmKGEpe2lmKHQ9YS5nZXRGaWVsZChvKSx0JiZhLnJlbW92ZUZpZWxkKG8pLGUuaW5wdXRUeXBlcy5sZW5ndGg9PT0xJiZlLmlucHV0VHlwZXNbMF0ua2luZD09PVwib2JqZWN0XCIpe2ZvcihsZXQgbCBvZiBlLmlucHV0VHlwZXNbMF0uZmllbGRzKXMuYWRkRmllbGQobC5uYW1lLGwudHlwZU5hbWVzLmpvaW4oXCIgfCBcIikpO2EuYWRkU3VnZ2VzdGlvbihuZXcgYWUobyxzKS5tYWtlUmVxdWlyZWQoKSl9ZWxzZXtsZXQgbD1lLmlucHV0VHlwZXMubWFwKGFhKS5qb2luKFwiIHwgXCIpO2EuYWRkU3VnZ2VzdGlvbihuZXcgYWUobyxsKS5tYWtlUmVxdWlyZWQoKSl9aWYoZS5kZXBlbmRlbnRBcmd1bWVudFBhdGgpe24uZ2V0RGVlcEZpZWxkKGUuZGVwZW5kZW50QXJndW1lbnRQYXRoKT8ubWFya0FzRXJyb3IoKTtsZXRbLGxdPURyKGUuZGVwZW5kZW50QXJndW1lbnRQYXRoKTtyLmFkZEVycm9yTWVzc2FnZSh1PT5gQXJndW1lbnQgXFxgJHt1LmdyZWVuKG8pfVxcYCBpcyByZXF1aXJlZCBiZWNhdXNlIGFyZ3VtZW50IFxcYCR7dS5ncmVlbihsKX1cXGAgd2FzIHByb3ZpZGVkLmApfX19ZnVuY3Rpb24gYWEoZSl7cmV0dXJuIGUua2luZD09PVwibGlzdFwiP2Ake2FhKGUuZWxlbWVudFR5cGUpfVtdYDplLm5hbWV9ZnVuY3Rpb24gRGQoZSxyKXtsZXQgdD1lLmFyZ3VtZW50Lm5hbWUsbj1yLmFyZ3VtZW50cy5nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUoZS5zZWxlY3Rpb25QYXRoKT8uYXNPYmplY3QoKTtuJiZuLmdldERlZXBGaWVsZFZhbHVlKGUuYXJndW1lbnRQYXRoKT8ubWFya0FzRXJyb3IoKSxyLmFkZEVycm9yTWVzc2FnZShpPT57bGV0IG89VG4oXCJvclwiLGUuYXJndW1lbnQudHlwZU5hbWVzLm1hcChzPT5pLmdyZWVuKHMpKSk7cmV0dXJuYEFyZ3VtZW50IFxcYCR7aS5ib2xkKHQpfVxcYDogSW52YWxpZCB2YWx1ZSBwcm92aWRlZC4gRXhwZWN0ZWQgJHtvfSwgcHJvdmlkZWQgJHtpLnJlZChlLmluZmVycmVkVHlwZSl9LmB9KX1mdW5jdGlvbiBPZChlLHIpe2xldCB0PWUuYXJndW1lbnQubmFtZSxuPXIuYXJndW1lbnRzLmdldERlZXBTdWJTZWxlY3Rpb25WYWx1ZShlLnNlbGVjdGlvblBhdGgpPy5hc09iamVjdCgpO24mJm4uZ2V0RGVlcEZpZWxkVmFsdWUoZS5hcmd1bWVudFBhdGgpPy5tYXJrQXNFcnJvcigpLHIuYWRkRXJyb3JNZXNzYWdlKGk9PntsZXQgbz1bYEludmFsaWQgdmFsdWUgZm9yIGFyZ3VtZW50IFxcYCR7aS5ib2xkKHQpfVxcYGBdO2lmKGUudW5kZXJseWluZ0Vycm9yJiZvLnB1c2goYDogJHtlLnVuZGVybHlpbmdFcnJvcn1gKSxvLnB1c2goXCIuXCIpLGUuYXJndW1lbnQudHlwZU5hbWVzLmxlbmd0aD4wKXtsZXQgcz1UbihcIm9yXCIsZS5hcmd1bWVudC50eXBlTmFtZXMubWFwKGE9PmkuZ3JlZW4oYSkpKTtvLnB1c2goYCBFeHBlY3RlZCAke3N9LmApfXJldHVybiBvLmpvaW4oXCJcIil9KX1mdW5jdGlvbiBfZChlLHIpe2xldCB0PWUuYXJndW1lbnQubmFtZSxuPXIuYXJndW1lbnRzLmdldERlZXBTdWJTZWxlY3Rpb25WYWx1ZShlLnNlbGVjdGlvblBhdGgpPy5hc09iamVjdCgpLGk7aWYobil7bGV0IHM9bi5nZXREZWVwRmllbGQoZS5hcmd1bWVudFBhdGgpPy52YWx1ZTtzPy5tYXJrQXNFcnJvcigpLHMgaW5zdGFuY2VvZiBHJiYoaT1zLnRleHQpfXIuYWRkRXJyb3JNZXNzYWdlKG89PntsZXQgcz1bXCJVbmFibGUgdG8gZml0IHZhbHVlXCJdO3JldHVybiBpJiZzLnB1c2goby5yZWQoaSkpLHMucHVzaChgaW50byBhIDY0LWJpdCBzaWduZWQgaW50ZWdlciBmb3IgZmllbGQgXFxgJHtvLmJvbGQodCl9XFxgYCkscy5qb2luKFwiIFwiKX0pfWZ1bmN0aW9uIE5kKGUscil7bGV0IHQ9ZS5hcmd1bWVudFBhdGhbZS5hcmd1bWVudFBhdGgubGVuZ3RoLTFdLG49ci5hcmd1bWVudHMuZ2V0RGVlcFN1YlNlbGVjdGlvblZhbHVlKGUuc2VsZWN0aW9uUGF0aCk/LmFzT2JqZWN0KCk7aWYobil7bGV0IGk9bi5nZXREZWVwRmllbGRWYWx1ZShlLmFyZ3VtZW50UGF0aCk/LmFzT2JqZWN0KCk7aSYmY2EoaSxlLmlucHV0VHlwZSl9ci5hZGRFcnJvck1lc3NhZ2UoaT0+e2xldCBvPVtgQXJndW1lbnQgXFxgJHtpLmJvbGQodCl9XFxgIG9mIHR5cGUgJHtpLmJvbGQoZS5pbnB1dFR5cGUubmFtZSl9IG5lZWRzYF07cmV0dXJuIGUuY29uc3RyYWludHMubWluRmllbGRDb3VudD09PTE/ZS5jb25zdHJhaW50cy5yZXF1aXJlZEZpZWxkcz9vLnB1c2goYCR7aS5ncmVlbihcImF0IGxlYXN0IG9uZSBvZlwiKX0gJHtUbihcIm9yXCIsZS5jb25zdHJhaW50cy5yZXF1aXJlZEZpZWxkcy5tYXAocz0+YFxcYCR7aS5ib2xkKHMpfVxcYGApKX0gYXJndW1lbnRzLmApOm8ucHVzaChgJHtpLmdyZWVuKFwiYXQgbGVhc3Qgb25lXCIpfSBhcmd1bWVudC5gKTpvLnB1c2goYCR7aS5ncmVlbihgYXQgbGVhc3QgJHtlLmNvbnN0cmFpbnRzLm1pbkZpZWxkQ291bnR9YCl9IGFyZ3VtZW50cy5gKSxvLnB1c2godXQoaSkpLG8uam9pbihcIiBcIil9KX1mdW5jdGlvbiBMZChlLHIpe2xldCB0PWUuYXJndW1lbnRQYXRoW2UuYXJndW1lbnRQYXRoLmxlbmd0aC0xXSxuPXIuYXJndW1lbnRzLmdldERlZXBTdWJTZWxlY3Rpb25WYWx1ZShlLnNlbGVjdGlvblBhdGgpPy5hc09iamVjdCgpLGk9W107aWYobil7bGV0IG89bi5nZXREZWVwRmllbGRWYWx1ZShlLmFyZ3VtZW50UGF0aCk/LmFzT2JqZWN0KCk7byYmKG8ubWFya0FzRXJyb3IoKSxpPU9iamVjdC5rZXlzKG8uZ2V0RmllbGRzKCkpKX1yLmFkZEVycm9yTWVzc2FnZShvPT57bGV0IHM9W2BBcmd1bWVudCBcXGAke28uYm9sZCh0KX1cXGAgb2YgdHlwZSAke28uYm9sZChlLmlucHV0VHlwZS5uYW1lKX0gbmVlZHNgXTtyZXR1cm4gZS5jb25zdHJhaW50cy5taW5GaWVsZENvdW50PT09MSYmZS5jb25zdHJhaW50cy5tYXhGaWVsZENvdW50PT0xP3MucHVzaChgJHtvLmdyZWVuKFwiZXhhY3RseSBvbmVcIil9IGFyZ3VtZW50LGApOmUuY29uc3RyYWludHMubWF4RmllbGRDb3VudD09MT9zLnB1c2goYCR7by5ncmVlbihcImF0IG1vc3Qgb25lXCIpfSBhcmd1bWVudCxgKTpzLnB1c2goYCR7by5ncmVlbihgYXQgbW9zdCAke2UuY29uc3RyYWludHMubWF4RmllbGRDb3VudH1gKX0gYXJndW1lbnRzLGApLHMucHVzaChgYnV0IHlvdSBwcm92aWRlZCAke1RuKFwiYW5kXCIsaS5tYXAoYT0+by5yZWQoYSkpKX0uIFBsZWFzZSBjaG9vc2VgKSxlLmNvbnN0cmFpbnRzLm1heEZpZWxkQ291bnQ9PT0xP3MucHVzaChcIm9uZS5cIik6cy5wdXNoKGAke2UuY29uc3RyYWludHMubWF4RmllbGRDb3VudH0uYCkscy5qb2luKFwiIFwiKX0pfWZ1bmN0aW9uIGxhKGUscil7Zm9yKGxldCB0IG9mIHIuZmllbGRzKWUuaGFzRmllbGQodC5uYW1lKXx8ZS5hZGRTdWdnZXN0aW9uKG5ldyBhZSh0Lm5hbWUsXCJ0cnVlXCIpKX1mdW5jdGlvbiBGZChlLHIpe2ZvcihsZXQgdCBvZiByLmZpZWxkcyl0LmlzUmVsYXRpb24mJiFlLmhhc0ZpZWxkKHQubmFtZSkmJmUuYWRkU3VnZ2VzdGlvbihuZXcgYWUodC5uYW1lLFwidHJ1ZVwiKSl9ZnVuY3Rpb24gTWQoZSxyKXtmb3IobGV0IHQgb2Ygci5maWVsZHMpIWUuaGFzRmllbGQodC5uYW1lKSYmIXQuaXNSZWxhdGlvbiYmZS5hZGRTdWdnZXN0aW9uKG5ldyBhZSh0Lm5hbWUsXCJ0cnVlXCIpKX1mdW5jdGlvbiAkZChlLHIpe2ZvcihsZXQgdCBvZiByKWUuaGFzRmllbGQodC5uYW1lKXx8ZS5hZGRTdWdnZXN0aW9uKG5ldyBhZSh0Lm5hbWUsdC50eXBlTmFtZXMuam9pbihcIiB8IFwiKSkpfWZ1bmN0aW9uIHVhKGUscil7bGV0W3Qsbl09RHIoZSksaT1yLmFyZ3VtZW50cy5nZXREZWVwU3ViU2VsZWN0aW9uVmFsdWUodCk/LmFzT2JqZWN0KCk7aWYoIWkpcmV0dXJue3BhcmVudEtpbmQ6XCJ1bmtub3duXCIsZmllbGROYW1lOm59O2xldCBvPWkuZ2V0RmllbGRWYWx1ZShcInNlbGVjdFwiKT8uYXNPYmplY3QoKSxzPWkuZ2V0RmllbGRWYWx1ZShcImluY2x1ZGVcIik/LmFzT2JqZWN0KCksYT1pLmdldEZpZWxkVmFsdWUoXCJvbWl0XCIpPy5hc09iamVjdCgpLGw9bz8uZ2V0RmllbGQobik7cmV0dXJuIG8mJmw/e3BhcmVudEtpbmQ6XCJzZWxlY3RcIixwYXJlbnQ6byxmaWVsZDpsLGZpZWxkTmFtZTpufToobD1zPy5nZXRGaWVsZChuKSxzJiZsP3twYXJlbnRLaW5kOlwiaW5jbHVkZVwiLGZpZWxkOmwscGFyZW50OnMsZmllbGROYW1lOm59OihsPWE/LmdldEZpZWxkKG4pLGEmJmw/e3BhcmVudEtpbmQ6XCJvbWl0XCIsZmllbGQ6bCxwYXJlbnQ6YSxmaWVsZE5hbWU6bn06e3BhcmVudEtpbmQ6XCJ1bmtub3duXCIsZmllbGROYW1lOm59KSl9ZnVuY3Rpb24gY2EoZSxyKXtpZihyLmtpbmQ9PT1cIm9iamVjdFwiKWZvcihsZXQgdCBvZiByLmZpZWxkcyllLmhhc0ZpZWxkKHQubmFtZSl8fGUuYWRkU3VnZ2VzdGlvbihuZXcgYWUodC5uYW1lLHQudHlwZU5hbWVzLmpvaW4oXCIgfCBcIikpKX1mdW5jdGlvbiBEcihlKXtsZXQgcj1bLi4uZV0sdD1yLnBvcCgpO2lmKCF0KXRocm93IG5ldyBFcnJvcihcInVuZXhwZWN0ZWQgZW1wdHkgcGF0aFwiKTtyZXR1cm5bcix0XX1mdW5jdGlvbiB1dCh7Z3JlZW46ZSxlbmFibGVkOnJ9KXtyZXR1cm5cIkF2YWlsYWJsZSBvcHRpb25zIGFyZSBcIisocj9gbGlzdGVkIGluICR7ZShcImdyZWVuXCIpfWA6XCJtYXJrZWQgd2l0aCA/XCIpK1wiLlwifWZ1bmN0aW9uIFRuKGUscil7aWYoci5sZW5ndGg9PT0xKXJldHVybiByWzBdO2xldCB0PVsuLi5yXSxuPXQucG9wKCk7cmV0dXJuYCR7dC5qb2luKFwiLCBcIil9ICR7ZX0gJHtufWB9dmFyIHFkPTM7ZnVuY3Rpb24gamQoZSxyKXtsZXQgdD0xLzAsbjtmb3IobGV0IGkgb2Ygcil7bGV0IG89KDAsb2EuZGVmYXVsdCkoZSxpKTtvPnFkfHxvPHQmJih0PW8sbj1pKX1yZXR1cm4gbn12YXIgY3Q9Y2xhc3N7bW9kZWxOYW1lO25hbWU7dHlwZU5hbWU7aXNMaXN0O2lzRW51bTtjb25zdHJ1Y3RvcihyLHQsbixpLG8pe3RoaXMubW9kZWxOYW1lPXIsdGhpcy5uYW1lPXQsdGhpcy50eXBlTmFtZT1uLHRoaXMuaXNMaXN0PWksdGhpcy5pc0VudW09b31fdG9HcmFwaFFMSW5wdXRUeXBlKCl7bGV0IHI9dGhpcy5pc0xpc3Q/XCJMaXN0XCI6XCJcIix0PXRoaXMuaXNFbnVtP1wiRW51bVwiOlwiXCI7cmV0dXJuYCR7cn0ke3R9JHt0aGlzLnR5cGVOYW1lfUZpZWxkUmVmSW5wdXQ8JHt0aGlzLm1vZGVsTmFtZX0+YH19O2Z1bmN0aW9uIE9yKGUpe3JldHVybiBlIGluc3RhbmNlb2YgY3R9dmFyIFNuPVN5bWJvbCgpLEJpPW5ldyBXZWFrTWFwLE1lPWNsYXNze2NvbnN0cnVjdG9yKHIpe3I9PT1Tbj9CaS5zZXQodGhpcyxgUHJpc21hLiR7dGhpcy5fZ2V0TmFtZSgpfWApOkJpLnNldCh0aGlzLGBuZXcgUHJpc21hLiR7dGhpcy5fZ2V0TmFtZXNwYWNlKCl9LiR7dGhpcy5fZ2V0TmFtZSgpfSgpYCl9X2dldE5hbWUoKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lfXRvU3RyaW5nKCl7cmV0dXJuIEJpLmdldCh0aGlzKX19LHB0PWNsYXNzIGV4dGVuZHMgTWV7X2dldE5hbWVzcGFjZSgpe3JldHVyblwiTnVsbFR5cGVzXCJ9fSxkdD1jbGFzcyBleHRlbmRzIHB0eyNlfTtHaShkdCxcIkRiTnVsbFwiKTt2YXIgbXQ9Y2xhc3MgZXh0ZW5kcyBwdHsjZX07R2kobXQsXCJKc29uTnVsbFwiKTt2YXIgZnQ9Y2xhc3MgZXh0ZW5kcyBwdHsjZX07R2koZnQsXCJBbnlOdWxsXCIpO3ZhciBVaT17Y2xhc3Nlczp7RGJOdWxsOmR0LEpzb25OdWxsOm10LEFueU51bGw6ZnR9LGluc3RhbmNlczp7RGJOdWxsOm5ldyBkdChTbiksSnNvbk51bGw6bmV3IG10KFNuKSxBbnlOdWxsOm5ldyBmdChTbil9fTtmdW5jdGlvbiBHaShlLHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwibmFtZVwiLHt2YWx1ZTpyLGNvbmZpZ3VyYWJsZTohMH0pfXZhciBwYT1cIjogXCIsUm49Y2xhc3N7Y29uc3RydWN0b3Iocix0KXt0aGlzLm5hbWU9cjt0aGlzLnZhbHVlPXR9aGFzRXJyb3I9ITE7bWFya0FzRXJyb3IoKXt0aGlzLmhhc0Vycm9yPSEwfWdldFByaW50V2lkdGgoKXtyZXR1cm4gdGhpcy5uYW1lLmxlbmd0aCt0aGlzLnZhbHVlLmdldFByaW50V2lkdGgoKStwYS5sZW5ndGh9d3JpdGUocil7bGV0IHQ9bmV3IFBlKHRoaXMubmFtZSk7dGhpcy5oYXNFcnJvciYmdC51bmRlcmxpbmUoKS5zZXRDb2xvcihyLmNvbnRleHQuY29sb3JzLnJlZCksci53cml0ZSh0KS53cml0ZShwYSkud3JpdGUodGhpcy52YWx1ZSl9fTt2YXIgUWk9Y2xhc3N7YXJndW1lbnRzO2Vycm9yTWVzc2FnZXM9W107Y29uc3RydWN0b3Iocil7dGhpcy5hcmd1bWVudHM9cn13cml0ZShyKXtyLndyaXRlKHRoaXMuYXJndW1lbnRzKX1hZGRFcnJvck1lc3NhZ2Uocil7dGhpcy5lcnJvck1lc3NhZ2VzLnB1c2gocil9cmVuZGVyQWxsTWVzc2FnZXMocil7cmV0dXJuIHRoaXMuZXJyb3JNZXNzYWdlcy5tYXAodD0+dChyKSkuam9pbihgXG5gKX19O2Z1bmN0aW9uIF9yKGUpe3JldHVybiBuZXcgUWkoZGEoZSkpfWZ1bmN0aW9uIGRhKGUpe2xldCByPW5ldyBrcjtmb3IobGV0W3Qsbl1vZiBPYmplY3QuZW50cmllcyhlKSl7bGV0IGk9bmV3IFJuKHQsbWEobikpO3IuYWRkRmllbGQoaSl9cmV0dXJuIHJ9ZnVuY3Rpb24gbWEoZSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpcmV0dXJuIG5ldyBHKEpTT04uc3RyaW5naWZ5KGUpKTtpZih0eXBlb2YgZT09XCJudW1iZXJcInx8dHlwZW9mIGU9PVwiYm9vbGVhblwiKXJldHVybiBuZXcgRyhTdHJpbmcoZSkpO2lmKHR5cGVvZiBlPT1cImJpZ2ludFwiKXJldHVybiBuZXcgRyhgJHtlfW5gKTtpZihlPT09bnVsbClyZXR1cm4gbmV3IEcoXCJudWxsXCIpO2lmKGU9PT12b2lkIDApcmV0dXJuIG5ldyBHKFwidW5kZWZpbmVkXCIpO2lmKFNyKGUpKXJldHVybiBuZXcgRyhgbmV3IFByaXNtYS5EZWNpbWFsKFwiJHtlLnRvRml4ZWQoKX1cIilgKTtpZihlIGluc3RhbmNlb2YgVWludDhBcnJheSlyZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGUpP25ldyBHKGBCdWZmZXIuYWxsb2MoJHtlLmJ5dGVMZW5ndGh9KWApOm5ldyBHKGBuZXcgVWludDhBcnJheSgke2UuYnl0ZUxlbmd0aH0pYCk7aWYoZSBpbnN0YW5jZW9mIERhdGUpe2xldCByPWduKGUpP2UudG9JU09TdHJpbmcoKTpcIkludmFsaWQgRGF0ZVwiO3JldHVybiBuZXcgRyhgbmV3IERhdGUoXCIke3J9XCIpYCl9cmV0dXJuIGUgaW5zdGFuY2VvZiBNZT9uZXcgRyhgUHJpc21hLiR7ZS5fZ2V0TmFtZSgpfWApOk9yKGUpP25ldyBHKGBwcmlzbWEuJHtZZShlLm1vZGVsTmFtZSl9LiRmaWVsZHMuJHtlLm5hbWV9YCk6QXJyYXkuaXNBcnJheShlKT9WZChlKTp0eXBlb2YgZT09XCJvYmplY3RcIj9kYShlKTpuZXcgRyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSkpfWZ1bmN0aW9uIFZkKGUpe2xldCByPW5ldyBJcjtmb3IobGV0IHQgb2YgZSlyLmFkZEl0ZW0obWEodCkpO3JldHVybiByfWZ1bmN0aW9uIEFuKGUscil7bGV0IHQ9cj09PVwicHJldHR5XCI/aWE6UG4sbj1lLnJlbmRlckFsbE1lc3NhZ2VzKHQpLGk9bmV3IEFyKDAse2NvbG9yczp0fSkud3JpdGUoZSkudG9TdHJpbmcoKTtyZXR1cm57bWVzc2FnZTpuLGFyZ3M6aX19ZnVuY3Rpb24gQ24oe2FyZ3M6ZSxlcnJvcnM6cixlcnJvckZvcm1hdDp0LGNhbGxzaXRlOm4sb3JpZ2luYWxNZXRob2Q6aSxjbGllbnRWZXJzaW9uOm8sZ2xvYmFsT21pdDpzfSl7bGV0IGE9X3IoZSk7Zm9yKGxldCBwIG9mIHIpd24ocCxhLHMpO2xldHttZXNzYWdlOmwsYXJnczp1fT1BbihhLHQpLGM9RW4oe21lc3NhZ2U6bCxjYWxsc2l0ZTpuLG9yaWdpbmFsTWV0aG9kOmksc2hvd0NvbG9yczp0PT09XCJwcmV0dHlcIixjYWxsQXJndW1lbnRzOnV9KTt0aHJvdyBuZXcgWChjLHtjbGllbnRWZXJzaW9uOm99KX1mdW5jdGlvbiBUZShlKXtyZXR1cm4gZS5yZXBsYWNlKC9eLi8scj0+ci50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBnYShlLHIsdCl7bGV0IG49VGUodCk7cmV0dXJuIXIucmVzdWx0fHwhKHIucmVzdWx0LiRhbGxNb2RlbHN8fHIucmVzdWx0W25dKT9lOkJkKHsuLi5lLC4uLmZhKHIubmFtZSxlLHIucmVzdWx0LiRhbGxNb2RlbHMpLC4uLmZhKHIubmFtZSxlLHIucmVzdWx0W25dKX0pfWZ1bmN0aW9uIEJkKGUpe2xldCByPW5ldyB2ZSx0PShuLGkpPT5yLmdldE9yQ3JlYXRlKG4sKCk9PmkuaGFzKG4pP1tuXTooaS5hZGQobiksZVtuXT9lW25dLm5lZWRzLmZsYXRNYXAobz0+dChvLGkpKTpbbl0pKTtyZXR1cm4geHIoZSxuPT4oey4uLm4sbmVlZHM6dChuLm5hbWUsbmV3IFNldCl9KSl9ZnVuY3Rpb24gZmEoZSxyLHQpe3JldHVybiB0P3hyKHQsKHtuZWVkczpuLGNvbXB1dGU6aX0sbyk9Pih7bmFtZTpvLG5lZWRzOm4/T2JqZWN0LmtleXMobikuZmlsdGVyKHM9Pm5bc10pOltdLGNvbXB1dGU6VWQocixvLGkpfSkpOnt9fWZ1bmN0aW9uIFVkKGUscix0KXtsZXQgbj1lPy5bcl0/LmNvbXB1dGU7cmV0dXJuIG4/aT0+dCh7Li4uaSxbcl06bihpKX0pOnR9ZnVuY3Rpb24gaGEoZSxyKXtpZighcilyZXR1cm4gZTtsZXQgdD17Li4uZX07Zm9yKGxldCBuIG9mIE9iamVjdC52YWx1ZXMocikpaWYoZVtuLm5hbWVdKWZvcihsZXQgaSBvZiBuLm5lZWRzKXRbaV09ITA7cmV0dXJuIHR9ZnVuY3Rpb24geWEoZSxyKXtpZighcilyZXR1cm4gZTtsZXQgdD17Li4uZX07Zm9yKGxldCBuIG9mIE9iamVjdC52YWx1ZXMocikpaWYoIWVbbi5uYW1lXSlmb3IobGV0IGkgb2Ygbi5uZWVkcylkZWxldGUgdFtpXTtyZXR1cm4gdH12YXIgSW49Y2xhc3N7Y29uc3RydWN0b3Iocix0KXt0aGlzLmV4dGVuc2lvbj1yO3RoaXMucHJldmlvdXM9dH1jb21wdXRlZEZpZWxkc0NhY2hlPW5ldyB2ZTttb2RlbEV4dGVuc2lvbnNDYWNoZT1uZXcgdmU7cXVlcnlDYWxsYmFja3NDYWNoZT1uZXcgdmU7Y2xpZW50RXh0ZW5zaW9ucz1hdCgoKT0+dGhpcy5leHRlbnNpb24uY2xpZW50P3suLi50aGlzLnByZXZpb3VzPy5nZXRBbGxDbGllbnRFeHRlbnNpb25zKCksLi4udGhpcy5leHRlbnNpb24uY2xpZW50fTp0aGlzLnByZXZpb3VzPy5nZXRBbGxDbGllbnRFeHRlbnNpb25zKCkpO2JhdGNoQ2FsbGJhY2tzPWF0KCgpPT57bGV0IHI9dGhpcy5wcmV2aW91cz8uZ2V0QWxsQmF0Y2hRdWVyeUNhbGxiYWNrcygpPz9bXSx0PXRoaXMuZXh0ZW5zaW9uLnF1ZXJ5Py4kX19pbnRlcm5hbEJhdGNoO3JldHVybiB0P3IuY29uY2F0KHQpOnJ9KTtnZXRBbGxDb21wdXRlZEZpZWxkcyhyKXtyZXR1cm4gdGhpcy5jb21wdXRlZEZpZWxkc0NhY2hlLmdldE9yQ3JlYXRlKHIsKCk9PmdhKHRoaXMucHJldmlvdXM/LmdldEFsbENvbXB1dGVkRmllbGRzKHIpLHRoaXMuZXh0ZW5zaW9uLHIpKX1nZXRBbGxDbGllbnRFeHRlbnNpb25zKCl7cmV0dXJuIHRoaXMuY2xpZW50RXh0ZW5zaW9ucy5nZXQoKX1nZXRBbGxNb2RlbEV4dGVuc2lvbnMocil7cmV0dXJuIHRoaXMubW9kZWxFeHRlbnNpb25zQ2FjaGUuZ2V0T3JDcmVhdGUociwoKT0+e2xldCB0PVRlKHIpO3JldHVybiF0aGlzLmV4dGVuc2lvbi5tb2RlbHx8ISh0aGlzLmV4dGVuc2lvbi5tb2RlbFt0XXx8dGhpcy5leHRlbnNpb24ubW9kZWwuJGFsbE1vZGVscyk/dGhpcy5wcmV2aW91cz8uZ2V0QWxsTW9kZWxFeHRlbnNpb25zKHIpOnsuLi50aGlzLnByZXZpb3VzPy5nZXRBbGxNb2RlbEV4dGVuc2lvbnMociksLi4udGhpcy5leHRlbnNpb24ubW9kZWwuJGFsbE1vZGVscywuLi50aGlzLmV4dGVuc2lvbi5tb2RlbFt0XX19KX1nZXRBbGxRdWVyeUNhbGxiYWNrcyhyLHQpe3JldHVybiB0aGlzLnF1ZXJ5Q2FsbGJhY2tzQ2FjaGUuZ2V0T3JDcmVhdGUoYCR7cn06JHt0fWAsKCk9PntsZXQgbj10aGlzLnByZXZpb3VzPy5nZXRBbGxRdWVyeUNhbGxiYWNrcyhyLHQpPz9bXSxpPVtdLG89dGhpcy5leHRlbnNpb24ucXVlcnk7cmV0dXJuIW98fCEob1tyXXx8by4kYWxsTW9kZWxzfHxvW3RdfHxvLiRhbGxPcGVyYXRpb25zKT9uOihvW3JdIT09dm9pZCAwJiYob1tyXVt0XSE9PXZvaWQgMCYmaS5wdXNoKG9bcl1bdF0pLG9bcl0uJGFsbE9wZXJhdGlvbnMhPT12b2lkIDAmJmkucHVzaChvW3JdLiRhbGxPcGVyYXRpb25zKSksciE9PVwiJG5vbmVcIiYmby4kYWxsTW9kZWxzIT09dm9pZCAwJiYoby4kYWxsTW9kZWxzW3RdIT09dm9pZCAwJiZpLnB1c2goby4kYWxsTW9kZWxzW3RdKSxvLiRhbGxNb2RlbHMuJGFsbE9wZXJhdGlvbnMhPT12b2lkIDAmJmkucHVzaChvLiRhbGxNb2RlbHMuJGFsbE9wZXJhdGlvbnMpKSxvW3RdIT09dm9pZCAwJiZpLnB1c2gob1t0XSksby4kYWxsT3BlcmF0aW9ucyE9PXZvaWQgMCYmaS5wdXNoKG8uJGFsbE9wZXJhdGlvbnMpLG4uY29uY2F0KGkpKX0pfWdldEFsbEJhdGNoUXVlcnlDYWxsYmFja3MoKXtyZXR1cm4gdGhpcy5iYXRjaENhbGxiYWNrcy5nZXQoKX19LE5yPWNsYXNzIGV7Y29uc3RydWN0b3Iocil7dGhpcy5oZWFkPXJ9c3RhdGljIGVtcHR5KCl7cmV0dXJuIG5ldyBlfXN0YXRpYyBzaW5nbGUocil7cmV0dXJuIG5ldyBlKG5ldyBJbihyKSl9aXNFbXB0eSgpe3JldHVybiB0aGlzLmhlYWQ9PT12b2lkIDB9YXBwZW5kKHIpe3JldHVybiBuZXcgZShuZXcgSW4ocix0aGlzLmhlYWQpKX1nZXRBbGxDb21wdXRlZEZpZWxkcyhyKXtyZXR1cm4gdGhpcy5oZWFkPy5nZXRBbGxDb21wdXRlZEZpZWxkcyhyKX1nZXRBbGxDbGllbnRFeHRlbnNpb25zKCl7cmV0dXJuIHRoaXMuaGVhZD8uZ2V0QWxsQ2xpZW50RXh0ZW5zaW9ucygpfWdldEFsbE1vZGVsRXh0ZW5zaW9ucyhyKXtyZXR1cm4gdGhpcy5oZWFkPy5nZXRBbGxNb2RlbEV4dGVuc2lvbnMocil9Z2V0QWxsUXVlcnlDYWxsYmFja3Mocix0KXtyZXR1cm4gdGhpcy5oZWFkPy5nZXRBbGxRdWVyeUNhbGxiYWNrcyhyLHQpPz9bXX1nZXRBbGxCYXRjaFF1ZXJ5Q2FsbGJhY2tzKCl7cmV0dXJuIHRoaXMuaGVhZD8uZ2V0QWxsQmF0Y2hRdWVyeUNhbGxiYWNrcygpPz9bXX19O3ZhciBrbj1jbGFzc3tjb25zdHJ1Y3RvcihyKXt0aGlzLm5hbWU9cn19O2Z1bmN0aW9uIGJhKGUpe3JldHVybiBlIGluc3RhbmNlb2Yga259ZnVuY3Rpb24gR2QoZSl7cmV0dXJuIG5ldyBrbihlKX12YXIgRWE9U3ltYm9sKCksZ3Q9Y2xhc3N7Y29uc3RydWN0b3Iocil7aWYociE9PUVhKXRocm93IG5ldyBFcnJvcihcIlNraXAgaW5zdGFuY2UgY2FuIG5vdCBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVwiKX1pZlVuZGVmaW5lZChyKXtyZXR1cm4gcj09PXZvaWQgMD9XaTpyfX0sV2k9bmV3IGd0KEVhKTtmdW5jdGlvbiBTZShlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIGd0fXZhciBRZD17ZmluZFVuaXF1ZTpcImZpbmRVbmlxdWVcIixmaW5kVW5pcXVlT3JUaHJvdzpcImZpbmRVbmlxdWVPclRocm93XCIsZmluZEZpcnN0OlwiZmluZEZpcnN0XCIsZmluZEZpcnN0T3JUaHJvdzpcImZpbmRGaXJzdE9yVGhyb3dcIixmaW5kTWFueTpcImZpbmRNYW55XCIsY291bnQ6XCJhZ2dyZWdhdGVcIixjcmVhdGU6XCJjcmVhdGVPbmVcIixjcmVhdGVNYW55OlwiY3JlYXRlTWFueVwiLGNyZWF0ZU1hbnlBbmRSZXR1cm46XCJjcmVhdGVNYW55QW5kUmV0dXJuXCIsdXBkYXRlOlwidXBkYXRlT25lXCIsdXBkYXRlTWFueTpcInVwZGF0ZU1hbnlcIix1cGRhdGVNYW55QW5kUmV0dXJuOlwidXBkYXRlTWFueUFuZFJldHVyblwiLHVwc2VydDpcInVwc2VydE9uZVwiLGRlbGV0ZTpcImRlbGV0ZU9uZVwiLGRlbGV0ZU1hbnk6XCJkZWxldGVNYW55XCIsZXhlY3V0ZVJhdzpcImV4ZWN1dGVSYXdcIixxdWVyeVJhdzpcInF1ZXJ5UmF3XCIsYWdncmVnYXRlOlwiYWdncmVnYXRlXCIsZ3JvdXBCeTpcImdyb3VwQnlcIixydW5Db21tYW5kUmF3OlwicnVuQ29tbWFuZFJhd1wiLGZpbmRSYXc6XCJmaW5kUmF3XCIsYWdncmVnYXRlUmF3OlwiYWdncmVnYXRlUmF3XCJ9LHdhPVwiZXhwbGljaXRseSBgdW5kZWZpbmVkYCB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkXCI7ZnVuY3Rpb24gSGkoe21vZGVsTmFtZTplLGFjdGlvbjpyLGFyZ3M6dCxydW50aW1lRGF0YU1vZGVsOm4sZXh0ZW5zaW9uczppPU5yLmVtcHR5KCksY2FsbHNpdGU6byxjbGllbnRNZXRob2Q6cyxlcnJvckZvcm1hdDphLGNsaWVudFZlcnNpb246bCxwcmV2aWV3RmVhdHVyZXM6dSxnbG9iYWxPbWl0OmN9KXtsZXQgcD1uZXcgSmkoe3J1bnRpbWVEYXRhTW9kZWw6bixtb2RlbE5hbWU6ZSxhY3Rpb246cixyb290QXJnczp0LGNhbGxzaXRlOm8sZXh0ZW5zaW9uczppLHNlbGVjdGlvblBhdGg6W10sYXJndW1lbnRQYXRoOltdLG9yaWdpbmFsTWV0aG9kOnMsZXJyb3JGb3JtYXQ6YSxjbGllbnRWZXJzaW9uOmwscHJldmlld0ZlYXR1cmVzOnUsZ2xvYmFsT21pdDpjfSk7cmV0dXJue21vZGVsTmFtZTplLGFjdGlvbjpRZFtyXSxxdWVyeTpodCh0LHApfX1mdW5jdGlvbiBodCh7c2VsZWN0OmUsaW5jbHVkZTpyLC4uLnR9PXt9LG4pe2xldCBpPXQub21pdDtyZXR1cm4gZGVsZXRlIHQub21pdCx7YXJndW1lbnRzOnZhKHQsbiksc2VsZWN0aW9uOldkKGUscixpLG4pfX1mdW5jdGlvbiBXZChlLHIsdCxuKXtyZXR1cm4gZT8ocj9uLnRocm93VmFsaWRhdGlvbkVycm9yKHtraW5kOlwiTXV0dWFsbHlFeGNsdXNpdmVGaWVsZHNcIixmaXJzdEZpZWxkOlwiaW5jbHVkZVwiLHNlY29uZEZpZWxkOlwic2VsZWN0XCIsc2VsZWN0aW9uUGF0aDpuLmdldFNlbGVjdGlvblBhdGgoKX0pOnQmJm4udGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJNdXR1YWxseUV4Y2x1c2l2ZUZpZWxkc1wiLGZpcnN0RmllbGQ6XCJvbWl0XCIsc2Vjb25kRmllbGQ6XCJzZWxlY3RcIixzZWxlY3Rpb25QYXRoOm4uZ2V0U2VsZWN0aW9uUGF0aCgpfSksWWQoZSxuKSk6SmQobixyLHQpfWZ1bmN0aW9uIEpkKGUscix0KXtsZXQgbj17fTtyZXR1cm4gZS5tb2RlbE9yVHlwZSYmIWUuaXNSYXdBY3Rpb24oKSYmKG4uJGNvbXBvc2l0ZXM9ITAsbi4kc2NhbGFycz0hMCksciYmSGQobixyLGUpLEtkKG4sdCxlKSxufWZ1bmN0aW9uIEhkKGUscix0KXtmb3IobGV0W24saV1vZiBPYmplY3QuZW50cmllcyhyKSl7aWYoU2UoaSkpY29udGludWU7bGV0IG89dC5uZXN0U2VsZWN0aW9uKG4pO2lmKEtpKGksbyksaT09PSExfHxpPT09dm9pZCAwKXtlW25dPSExO2NvbnRpbnVlfWxldCBzPXQuZmluZEZpZWxkKG4pO2lmKHMmJnMua2luZCE9PVwib2JqZWN0XCImJnQudGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJJbmNsdWRlT25TY2FsYXJcIixzZWxlY3Rpb25QYXRoOnQuZ2V0U2VsZWN0aW9uUGF0aCgpLmNvbmNhdChuKSxvdXRwdXRUeXBlOnQuZ2V0T3V0cHV0VHlwZURlc2NyaXB0aW9uKCl9KSxzKXtlW25dPWh0KGk9PT0hMD97fTppLG8pO2NvbnRpbnVlfWlmKGk9PT0hMCl7ZVtuXT0hMDtjb250aW51ZX1lW25dPWh0KGksbyl9fWZ1bmN0aW9uIEtkKGUscix0KXtsZXQgbj10LmdldENvbXB1dGVkRmllbGRzKCksaT17Li4udC5nZXRHbG9iYWxPbWl0KCksLi4ucn0sbz15YShpLG4pO2ZvcihsZXRbcyxhXW9mIE9iamVjdC5lbnRyaWVzKG8pKXtpZihTZShhKSljb250aW51ZTtLaShhLHQubmVzdFNlbGVjdGlvbihzKSk7bGV0IGw9dC5maW5kRmllbGQocyk7bj8uW3NdJiYhbHx8KGVbc109IWEpfX1mdW5jdGlvbiBZZChlLHIpe2xldCB0PXt9LG49ci5nZXRDb21wdXRlZEZpZWxkcygpLGk9aGEoZSxuKTtmb3IobGV0W28sc11vZiBPYmplY3QuZW50cmllcyhpKSl7aWYoU2UocykpY29udGludWU7bGV0IGE9ci5uZXN0U2VsZWN0aW9uKG8pO0tpKHMsYSk7bGV0IGw9ci5maW5kRmllbGQobyk7aWYoIShuPy5bb10mJiFsKSl7aWYocz09PSExfHxzPT09dm9pZCAwfHxTZShzKSl7dFtvXT0hMTtjb250aW51ZX1pZihzPT09ITApe2w/LmtpbmQ9PT1cIm9iamVjdFwiP3Rbb109aHQoe30sYSk6dFtvXT0hMDtjb250aW51ZX10W29dPWh0KHMsYSl9fXJldHVybiB0fWZ1bmN0aW9uIHhhKGUscil7aWYoZT09PW51bGwpcmV0dXJuIG51bGw7aWYodHlwZW9mIGU9PVwic3RyaW5nXCJ8fHR5cGVvZiBlPT1cIm51bWJlclwifHx0eXBlb2YgZT09XCJib29sZWFuXCIpcmV0dXJuIGU7aWYodHlwZW9mIGU9PVwiYmlnaW50XCIpcmV0dXJueyR0eXBlOlwiQmlnSW50XCIsdmFsdWU6U3RyaW5nKGUpfTtpZihUcihlKSl7aWYoZ24oZSkpcmV0dXJueyR0eXBlOlwiRGF0ZVRpbWVcIix2YWx1ZTplLnRvSVNPU3RyaW5nKCl9O3IudGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJJbnZhbGlkQXJndW1lbnRWYWx1ZVwiLHNlbGVjdGlvblBhdGg6ci5nZXRTZWxlY3Rpb25QYXRoKCksYXJndW1lbnRQYXRoOnIuZ2V0QXJndW1lbnRQYXRoKCksYXJndW1lbnQ6e25hbWU6ci5nZXRBcmd1bWVudE5hbWUoKSx0eXBlTmFtZXM6W1wiRGF0ZVwiXX0sdW5kZXJseWluZ0Vycm9yOlwiUHJvdmlkZWQgRGF0ZSBvYmplY3QgaXMgaW52YWxpZFwifSl9aWYoYmEoZSkpcmV0dXJueyR0eXBlOlwiUGFyYW1cIix2YWx1ZTplLm5hbWV9O2lmKE9yKGUpKXJldHVybnskdHlwZTpcIkZpZWxkUmVmXCIsdmFsdWU6e19yZWY6ZS5uYW1lLF9jb250YWluZXI6ZS5tb2RlbE5hbWV9fTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiB6ZChlLHIpO2lmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl7bGV0e2J1ZmZlcjp0LGJ5dGVPZmZzZXQ6bixieXRlTGVuZ3RoOml9PWU7cmV0dXJueyR0eXBlOlwiQnl0ZXNcIix2YWx1ZTpCdWZmZXIuZnJvbSh0LG4saSkudG9TdHJpbmcoXCJiYXNlNjRcIil9fWlmKFpkKGUpKXJldHVybiBlLnZhbHVlcztpZihTcihlKSlyZXR1cm57JHR5cGU6XCJEZWNpbWFsXCIsdmFsdWU6ZS50b0ZpeGVkKCl9O2lmKGUgaW5zdGFuY2VvZiBNZSl7aWYoZSE9PVVpLmluc3RhbmNlc1tlLl9nZXROYW1lKCldKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgT2JqZWN0RW51bVZhbHVlXCIpO3JldHVybnskdHlwZTpcIkVudW1cIix2YWx1ZTplLl9nZXROYW1lKCl9fWlmKFhkKGUpKXJldHVybiBlLnRvSlNPTigpO2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiKXJldHVybiB2YShlLHIpO3IudGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJJbnZhbGlkQXJndW1lbnRWYWx1ZVwiLHNlbGVjdGlvblBhdGg6ci5nZXRTZWxlY3Rpb25QYXRoKCksYXJndW1lbnRQYXRoOnIuZ2V0QXJndW1lbnRQYXRoKCksYXJndW1lbnQ6e25hbWU6ci5nZXRBcmd1bWVudE5hbWUoKSx0eXBlTmFtZXM6W119LHVuZGVybHlpbmdFcnJvcjpgV2UgY291bGQgbm90IHNlcmlhbGl6ZSAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKX0gdmFsdWUuIFNlcmlhbGl6ZSB0aGUgb2JqZWN0IHRvIEpTT04gb3IgaW1wbGVtZW50IGEgXCIudG9KU09OKClcIiBtZXRob2Qgb24gaXRgfSl9ZnVuY3Rpb24gdmEoZSxyKXtpZihlLiR0eXBlKXJldHVybnskdHlwZTpcIlJhd1wiLHZhbHVlOmV9O2xldCB0PXt9O2ZvcihsZXQgbiBpbiBlKXtsZXQgaT1lW25dLG89ci5uZXN0QXJndW1lbnQobik7U2UoaSl8fChpIT09dm9pZCAwP3Rbbl09eGEoaSxvKTpyLmlzUHJldmlld0ZlYXR1cmVPbihcInN0cmljdFVuZGVmaW5lZENoZWNrc1wiKSYmci50aHJvd1ZhbGlkYXRpb25FcnJvcih7a2luZDpcIkludmFsaWRBcmd1bWVudFZhbHVlXCIsYXJndW1lbnRQYXRoOm8uZ2V0QXJndW1lbnRQYXRoKCksc2VsZWN0aW9uUGF0aDpyLmdldFNlbGVjdGlvblBhdGgoKSxhcmd1bWVudDp7bmFtZTpyLmdldEFyZ3VtZW50TmFtZSgpLHR5cGVOYW1lczpbXX0sdW5kZXJseWluZ0Vycm9yOndhfSkpfXJldHVybiB0fWZ1bmN0aW9uIHpkKGUscil7bGV0IHQ9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2xldCBpPXIubmVzdEFyZ3VtZW50KFN0cmluZyhuKSksbz1lW25dO2lmKG89PT12b2lkIDB8fFNlKG8pKXtsZXQgcz1vPT09dm9pZCAwP1widW5kZWZpbmVkXCI6XCJQcmlzbWEuc2tpcFwiO3IudGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJJbnZhbGlkQXJndW1lbnRWYWx1ZVwiLHNlbGVjdGlvblBhdGg6aS5nZXRTZWxlY3Rpb25QYXRoKCksYXJndW1lbnRQYXRoOmkuZ2V0QXJndW1lbnRQYXRoKCksYXJndW1lbnQ6e25hbWU6YCR7ci5nZXRBcmd1bWVudE5hbWUoKX1bJHtufV1gLHR5cGVOYW1lczpbXX0sdW5kZXJseWluZ0Vycm9yOmBDYW4gbm90IHVzZSBcXGAke3N9XFxgIHZhbHVlIHdpdGhpbiBhcnJheS4gVXNlIFxcYG51bGxcXGAgb3IgZmlsdGVyIG91dCBcXGAke3N9XFxgIHZhbHVlc2B9KX10LnB1c2goeGEobyxpKSl9cmV0dXJuIHR9ZnVuY3Rpb24gWmQoZSl7cmV0dXJuIHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCYmZS5fX3ByaXNtYVJhd1BhcmFtZXRlcnNfXz09PSEwfWZ1bmN0aW9uIFhkKGUpe3JldHVybiB0eXBlb2YgZT09XCJvYmplY3RcIiYmZSE9PW51bGwmJnR5cGVvZiBlLnRvSlNPTj09XCJmdW5jdGlvblwifWZ1bmN0aW9uIEtpKGUscil7ZT09PXZvaWQgMCYmci5pc1ByZXZpZXdGZWF0dXJlT24oXCJzdHJpY3RVbmRlZmluZWRDaGVja3NcIikmJnIudGhyb3dWYWxpZGF0aW9uRXJyb3Ioe2tpbmQ6XCJJbnZhbGlkU2VsZWN0aW9uVmFsdWVcIixzZWxlY3Rpb25QYXRoOnIuZ2V0U2VsZWN0aW9uUGF0aCgpLHVuZGVybHlpbmdFcnJvcjp3YX0pfXZhciBKaT1jbGFzcyBle2NvbnN0cnVjdG9yKHIpe3RoaXMucGFyYW1zPXI7dGhpcy5wYXJhbXMubW9kZWxOYW1lJiYodGhpcy5tb2RlbE9yVHlwZT10aGlzLnBhcmFtcy5ydW50aW1lRGF0YU1vZGVsLm1vZGVsc1t0aGlzLnBhcmFtcy5tb2RlbE5hbWVdPz90aGlzLnBhcmFtcy5ydW50aW1lRGF0YU1vZGVsLnR5cGVzW3RoaXMucGFyYW1zLm1vZGVsTmFtZV0pfW1vZGVsT3JUeXBlO3Rocm93VmFsaWRhdGlvbkVycm9yKHIpe0NuKHtlcnJvcnM6W3JdLG9yaWdpbmFsTWV0aG9kOnRoaXMucGFyYW1zLm9yaWdpbmFsTWV0aG9kLGFyZ3M6dGhpcy5wYXJhbXMucm9vdEFyZ3M/P3t9LGNhbGxzaXRlOnRoaXMucGFyYW1zLmNhbGxzaXRlLGVycm9yRm9ybWF0OnRoaXMucGFyYW1zLmVycm9yRm9ybWF0LGNsaWVudFZlcnNpb246dGhpcy5wYXJhbXMuY2xpZW50VmVyc2lvbixnbG9iYWxPbWl0OnRoaXMucGFyYW1zLmdsb2JhbE9taXR9KX1nZXRTZWxlY3Rpb25QYXRoKCl7cmV0dXJuIHRoaXMucGFyYW1zLnNlbGVjdGlvblBhdGh9Z2V0QXJndW1lbnRQYXRoKCl7cmV0dXJuIHRoaXMucGFyYW1zLmFyZ3VtZW50UGF0aH1nZXRBcmd1bWVudE5hbWUoKXtyZXR1cm4gdGhpcy5wYXJhbXMuYXJndW1lbnRQYXRoW3RoaXMucGFyYW1zLmFyZ3VtZW50UGF0aC5sZW5ndGgtMV19Z2V0T3V0cHV0VHlwZURlc2NyaXB0aW9uKCl7aWYoISghdGhpcy5wYXJhbXMubW9kZWxOYW1lfHwhdGhpcy5tb2RlbE9yVHlwZSkpcmV0dXJue25hbWU6dGhpcy5wYXJhbXMubW9kZWxOYW1lLGZpZWxkczp0aGlzLm1vZGVsT3JUeXBlLmZpZWxkcy5tYXAocj0+KHtuYW1lOnIubmFtZSx0eXBlTmFtZTpcImJvb2xlYW5cIixpc1JlbGF0aW9uOnIua2luZD09PVwib2JqZWN0XCJ9KSl9fWlzUmF3QWN0aW9uKCl7cmV0dXJuW1wiZXhlY3V0ZVJhd1wiLFwicXVlcnlSYXdcIixcInJ1bkNvbW1hbmRSYXdcIixcImZpbmRSYXdcIixcImFnZ3JlZ2F0ZVJhd1wiXS5pbmNsdWRlcyh0aGlzLnBhcmFtcy5hY3Rpb24pfWlzUHJldmlld0ZlYXR1cmVPbihyKXtyZXR1cm4gdGhpcy5wYXJhbXMucHJldmlld0ZlYXR1cmVzLmluY2x1ZGVzKHIpfWdldENvbXB1dGVkRmllbGRzKCl7aWYodGhpcy5wYXJhbXMubW9kZWxOYW1lKXJldHVybiB0aGlzLnBhcmFtcy5leHRlbnNpb25zLmdldEFsbENvbXB1dGVkRmllbGRzKHRoaXMucGFyYW1zLm1vZGVsTmFtZSl9ZmluZEZpZWxkKHIpe3JldHVybiB0aGlzLm1vZGVsT3JUeXBlPy5maWVsZHMuZmluZCh0PT50Lm5hbWU9PT1yKX1uZXN0U2VsZWN0aW9uKHIpe2xldCB0PXRoaXMuZmluZEZpZWxkKHIpLG49dD8ua2luZD09PVwib2JqZWN0XCI/dC50eXBlOnZvaWQgMDtyZXR1cm4gbmV3IGUoey4uLnRoaXMucGFyYW1zLG1vZGVsTmFtZTpuLHNlbGVjdGlvblBhdGg6dGhpcy5wYXJhbXMuc2VsZWN0aW9uUGF0aC5jb25jYXQocil9KX1nZXRHbG9iYWxPbWl0KCl7cmV0dXJuIHRoaXMucGFyYW1zLm1vZGVsTmFtZSYmdGhpcy5zaG91bGRBcHBseUdsb2JhbE9taXQoKT90aGlzLnBhcmFtcy5nbG9iYWxPbWl0Py5bWWUodGhpcy5wYXJhbXMubW9kZWxOYW1lKV0/P3t9Ont9fXNob3VsZEFwcGx5R2xvYmFsT21pdCgpe3N3aXRjaCh0aGlzLnBhcmFtcy5hY3Rpb24pe2Nhc2VcImZpbmRGaXJzdFwiOmNhc2VcImZpbmRGaXJzdE9yVGhyb3dcIjpjYXNlXCJmaW5kVW5pcXVlT3JUaHJvd1wiOmNhc2VcImZpbmRNYW55XCI6Y2FzZVwidXBzZXJ0XCI6Y2FzZVwiZmluZFVuaXF1ZVwiOmNhc2VcImNyZWF0ZU1hbnlBbmRSZXR1cm5cIjpjYXNlXCJjcmVhdGVcIjpjYXNlXCJ1cGRhdGVcIjpjYXNlXCJ1cGRhdGVNYW55QW5kUmV0dXJuXCI6Y2FzZVwiZGVsZXRlXCI6cmV0dXJuITA7Y2FzZVwiZXhlY3V0ZVJhd1wiOmNhc2VcImFnZ3JlZ2F0ZVJhd1wiOmNhc2VcInJ1bkNvbW1hbmRSYXdcIjpjYXNlXCJmaW5kUmF3XCI6Y2FzZVwiY3JlYXRlTWFueVwiOmNhc2VcImRlbGV0ZU1hbnlcIjpjYXNlXCJncm91cEJ5XCI6Y2FzZVwidXBkYXRlTWFueVwiOmNhc2VcImNvdW50XCI6Y2FzZVwiYWdncmVnYXRlXCI6Y2FzZVwicXVlcnlSYXdcIjpyZXR1cm4hMTtkZWZhdWx0Ol9lKHRoaXMucGFyYW1zLmFjdGlvbixcIlVua25vd24gYWN0aW9uXCIpfX1uZXN0QXJndW1lbnQocil7cmV0dXJuIG5ldyBlKHsuLi50aGlzLnBhcmFtcyxhcmd1bWVudFBhdGg6dGhpcy5wYXJhbXMuYXJndW1lbnRQYXRoLmNvbmNhdChyKX0pfX07ZnVuY3Rpb24gUGEoZSl7aWYoIWUuX2hhc1ByZXZpZXdGbGFnKFwibWV0cmljc1wiKSl0aHJvdyBuZXcgWChcImBtZXRyaWNzYCBwcmV2aWV3IGZlYXR1cmUgbXVzdCBiZSBlbmFibGVkIGluIG9yZGVyIHRvIGFjY2VzcyBtZXRyaWNzIEFQSVwiLHtjbGllbnRWZXJzaW9uOmUuX2NsaWVudFZlcnNpb259KX12YXIgeXQ9Y2xhc3N7X2NsaWVudDtjb25zdHJ1Y3RvcihyKXt0aGlzLl9jbGllbnQ9cn1wcm9tZXRoZXVzKHIpe3JldHVybiBQYSh0aGlzLl9jbGllbnQpLHRoaXMuX2NsaWVudC5fZW5naW5lLm1ldHJpY3Moe2Zvcm1hdDpcInByb21ldGhldXNcIiwuLi5yfSl9anNvbihyKXtyZXR1cm4gUGEodGhpcy5fY2xpZW50KSx0aGlzLl9jbGllbnQuX2VuZ2luZS5tZXRyaWNzKHtmb3JtYXQ6XCJqc29uXCIsLi4ucn0pfX07ZnVuY3Rpb24gZW0oZSxyKXtsZXQgdD1hdCgoKT0+cm0ocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiZG1tZlwiLHtnZXQ6KCk9PnQuZ2V0KCl9KX1mdW5jdGlvbiBybShlKXtyZXR1cm57ZGF0YW1vZGVsOnttb2RlbHM6WWkoZS5tb2RlbHMpLGVudW1zOllpKGUuZW51bXMpLHR5cGVzOllpKGUudHlwZXMpfX19ZnVuY3Rpb24gWWkoZSl7cmV0dXJuIE9iamVjdC5lbnRyaWVzKGUpLm1hcCgoW3IsdF0pPT4oe25hbWU6ciwuLi50fSkpfXZhciB6aT1uZXcgV2Vha01hcCxEbj1cIiQkUHJpc21hVHlwZWRTcWxcIixidD1jbGFzc3tjb25zdHJ1Y3RvcihyLHQpe3ppLnNldCh0aGlzLHtzcWw6cix2YWx1ZXM6dH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLERuLHt2YWx1ZTpEbn0pfWdldCBzcWwoKXtyZXR1cm4gemkuZ2V0KHRoaXMpLnNxbH1nZXQgdmFsdWVzKCl7cmV0dXJuIHppLmdldCh0aGlzKS52YWx1ZXN9fTtmdW5jdGlvbiB0bShlKXtyZXR1cm4oLi4ucik9Pm5ldyBidChlLHIpfWZ1bmN0aW9uIE9uKGUpe3JldHVybiBlIT1udWxsJiZlW0RuXT09PURufXZhciB0dT1uZShoaSgpKTtpbXBvcnR7QXN5bmNSZXNvdXJjZSBhcyBfZn1mcm9tXCJub2RlOmFzeW5jX2hvb2tzXCI7aW1wb3J0e0V2ZW50RW1pdHRlciBhcyBOZn1mcm9tXCJub2RlOmV2ZW50c1wiO2ltcG9ydCBMZiBmcm9tXCJub2RlOmZzXCI7aW1wb3J0IFNvIGZyb21cIm5vZGU6cGF0aFwiO3ZhciBsZT1jbGFzcyBle2NvbnN0cnVjdG9yKHIsdCl7aWYoci5sZW5ndGgtMSE9PXQubGVuZ3RoKXRocm93IHIubGVuZ3RoPT09MD9uZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgMSBzdHJpbmdcIik6bmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgJHtyLmxlbmd0aH0gc3RyaW5ncyB0byBoYXZlICR7ci5sZW5ndGgtMX0gdmFsdWVzYCk7bGV0IG49dC5yZWR1Y2UoKHMsYSk9PnMrKGEgaW5zdGFuY2VvZiBlP2EudmFsdWVzLmxlbmd0aDoxKSwwKTt0aGlzLnZhbHVlcz1uZXcgQXJyYXkobiksdGhpcy5zdHJpbmdzPW5ldyBBcnJheShuKzEpLHRoaXMuc3RyaW5nc1swXT1yWzBdO2xldCBpPTAsbz0wO2Zvcig7aTx0Lmxlbmd0aDspe2xldCBzPXRbaSsrXSxhPXJbaV07aWYocyBpbnN0YW5jZW9mIGUpe3RoaXMuc3RyaW5nc1tvXSs9cy5zdHJpbmdzWzBdO2xldCBsPTA7Zm9yKDtsPHMudmFsdWVzLmxlbmd0aDspdGhpcy52YWx1ZXNbbysrXT1zLnZhbHVlc1tsKytdLHRoaXMuc3RyaW5nc1tvXT1zLnN0cmluZ3NbbF07dGhpcy5zdHJpbmdzW29dKz1hfWVsc2UgdGhpcy52YWx1ZXNbbysrXT1zLHRoaXMuc3RyaW5nc1tvXT1hfX1nZXQgc3FsKCl7bGV0IHI9dGhpcy5zdHJpbmdzLmxlbmd0aCx0PTEsbj10aGlzLnN0cmluZ3NbMF07Zm9yKDt0PHI7KW4rPWA/JHt0aGlzLnN0cmluZ3NbdCsrXX1gO3JldHVybiBufWdldCBzdGF0ZW1lbnQoKXtsZXQgcj10aGlzLnN0cmluZ3MubGVuZ3RoLHQ9MSxuPXRoaXMuc3RyaW5nc1swXTtmb3IoO3Q8cjspbis9YDoke3R9JHt0aGlzLnN0cmluZ3NbdCsrXX1gO3JldHVybiBufWdldCB0ZXh0KCl7bGV0IHI9dGhpcy5zdHJpbmdzLmxlbmd0aCx0PTEsbj10aGlzLnN0cmluZ3NbMF07Zm9yKDt0PHI7KW4rPWAkJHt0fSR7dGhpcy5zdHJpbmdzW3QrK119YDtyZXR1cm4gbn1pbnNwZWN0KCl7cmV0dXJue3NxbDp0aGlzLnNxbCxzdGF0ZW1lbnQ6dGhpcy5zdGF0ZW1lbnQsdGV4dDp0aGlzLnRleHQsdmFsdWVzOnRoaXMudmFsdWVzfX19O2Z1bmN0aW9uIG5tKGUscj1cIixcIix0PVwiXCIsbj1cIlwiKXtpZihlLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGBqb2luKFtdKWAgdG8gYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbXVsdGlwbGUgZWxlbWVudHMsIGJ1dCBnb3QgYW4gZW1wdHkgYXJyYXlcIik7cmV0dXJuIG5ldyBsZShbdCwuLi5BcnJheShlLmxlbmd0aC0xKS5maWxsKHIpLG5dLGUpfWZ1bmN0aW9uIFRhKGUpe3JldHVybiBuZXcgbGUoW2VdLFtdKX12YXIgaW09VGEoXCJcIik7ZnVuY3Rpb24gU2EoZSwuLi5yKXtyZXR1cm4gbmV3IGxlKGUscil9ZnVuY3Rpb24gRXQoZSl7cmV0dXJue2dldEtleXMoKXtyZXR1cm4gT2JqZWN0LmtleXMoZSl9LGdldFByb3BlcnR5VmFsdWUocil7cmV0dXJuIGVbcl19fX1mdW5jdGlvbiBlZShlLHIpe3JldHVybntnZXRLZXlzKCl7cmV0dXJuW2VdfSxnZXRQcm9wZXJ0eVZhbHVlKCl7cmV0dXJuIHIoKX19fWZ1bmN0aW9uIGFyKGUpe2xldCByPW5ldyB2ZTtyZXR1cm57Z2V0S2V5cygpe3JldHVybiBlLmdldEtleXMoKX0sZ2V0UHJvcGVydHlWYWx1ZSh0KXtyZXR1cm4gci5nZXRPckNyZWF0ZSh0LCgpPT5lLmdldFByb3BlcnR5VmFsdWUodCkpfSxnZXRQcm9wZXJ0eURlc2NyaXB0b3IodCl7cmV0dXJuIGUuZ2V0UHJvcGVydHlEZXNjcmlwdG9yPy4odCl9fX12YXIgX249e2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfTtmdW5jdGlvbiBObihlKXtsZXQgcj1uZXcgU2V0KGUpO3JldHVybntnZXRQcm90b3R5cGVPZjooKT0+T2JqZWN0LnByb3RvdHlwZSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6KCk9Pl9uLGhhczoodCxuKT0+ci5oYXMobiksc2V0Oih0LG4saSk9PnIuYWRkKG4pJiZSZWZsZWN0LnNldCh0LG4saSksb3duS2V5czooKT0+Wy4uLnJdfX12YXIgUmE9U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpO2Z1bmN0aW9uIGhlKGUscil7bGV0IHQ9b20ociksbj1uZXcgU2V0LGk9bmV3IFByb3h5KGUse2dldChvLHMpe2lmKG4uaGFzKHMpKXJldHVybiBvW3NdO2xldCBhPXQuZ2V0KHMpO3JldHVybiBhP2EuZ2V0UHJvcGVydHlWYWx1ZShzKTpvW3NdfSxoYXMobyxzKXtpZihuLmhhcyhzKSlyZXR1cm4hMDtsZXQgYT10LmdldChzKTtyZXR1cm4gYT9hLmhhcz8uKHMpPz8hMDpSZWZsZWN0LmhhcyhvLHMpfSxvd25LZXlzKG8pe2xldCBzPUFhKFJlZmxlY3Qub3duS2V5cyhvKSx0KSxhPUFhKEFycmF5LmZyb20odC5rZXlzKCkpLHQpO3JldHVyblsuLi5uZXcgU2V0KFsuLi5zLC4uLmEsLi4ubl0pXX0sc2V0KG8scyxhKXtyZXR1cm4gdC5nZXQocyk/LmdldFByb3BlcnR5RGVzY3JpcHRvcj8uKHMpPy53cml0YWJsZT09PSExPyExOihuLmFkZChzKSxSZWZsZWN0LnNldChvLHMsYSkpfSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobyxzKXtsZXQgYT1SZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLHMpO2lmKGEmJiFhLmNvbmZpZ3VyYWJsZSlyZXR1cm4gYTtsZXQgbD10LmdldChzKTtyZXR1cm4gbD9sLmdldFByb3BlcnR5RGVzY3JpcHRvcj97Li4uX24sLi4ubD8uZ2V0UHJvcGVydHlEZXNjcmlwdG9yKHMpfTpfbjphfSxkZWZpbmVQcm9wZXJ0eShvLHMsYSl7cmV0dXJuIG4uYWRkKHMpLFJlZmxlY3QuZGVmaW5lUHJvcGVydHkobyxzLGEpfSxnZXRQcm90b3R5cGVPZjooKT0+T2JqZWN0LnByb3RvdHlwZX0pO3JldHVybiBpW1JhXT1mdW5jdGlvbigpe2xldCBvPXsuLi50aGlzfTtyZXR1cm4gZGVsZXRlIG9bUmFdLG99LGl9ZnVuY3Rpb24gb20oZSl7bGV0IHI9bmV3IE1hcDtmb3IobGV0IHQgb2YgZSl7bGV0IG49dC5nZXRLZXlzKCk7Zm9yKGxldCBpIG9mIG4pci5zZXQoaSx0KX1yZXR1cm4gcn1mdW5jdGlvbiBBYShlLHIpe3JldHVybiBlLmZpbHRlcih0PT5yLmdldCh0KT8uaGFzPy4odCk/PyEwKX1mdW5jdGlvbiBMcihlKXtyZXR1cm57Z2V0S2V5cygpe3JldHVybiBlfSxoYXMoKXtyZXR1cm4hMX0sZ2V0UHJvcGVydHlWYWx1ZSgpe319fWZ1bmN0aW9uIEZyKGUscil7cmV0dXJue2JhdGNoOmUsdHJhbnNhY3Rpb246cj8ua2luZD09PVwiYmF0Y2hcIj97aXNvbGF0aW9uTGV2ZWw6ci5vcHRpb25zLmlzb2xhdGlvbkxldmVsfTp2b2lkIDB9fWZ1bmN0aW9uIENhKGUpe2lmKGU9PT12b2lkIDApcmV0dXJuXCJcIjtsZXQgcj1fcihlKTtyZXR1cm4gbmV3IEFyKDAse2NvbG9yczpQbn0pLndyaXRlKHIpLnRvU3RyaW5nKCl9dmFyIHNtPVwiUDIwMzdcIjtmdW5jdGlvbiBNcih7ZXJyb3I6ZSx1c2VyX2ZhY2luZ19lcnJvcjpyfSx0LG4pe3JldHVybiByLmVycm9yX2NvZGU/bmV3IFooYW0ocixuKSx7Y29kZTpyLmVycm9yX2NvZGUsY2xpZW50VmVyc2lvbjp0LG1ldGE6ci5tZXRhLGJhdGNoUmVxdWVzdElkeDpyLmJhdGNoX3JlcXVlc3RfaWR4fSk6bmV3IHEoZSx7Y2xpZW50VmVyc2lvbjp0LGJhdGNoUmVxdWVzdElkeDpyLmJhdGNoX3JlcXVlc3RfaWR4fSl9ZnVuY3Rpb24gYW0oZSxyKXtsZXQgdD1lLm1lc3NhZ2U7cmV0dXJuKHI9PT1cInBvc3RncmVzcWxcInx8cj09PVwicG9zdGdyZXNcInx8cj09PVwibXlzcWxcIikmJmUuZXJyb3JfY29kZT09PXNtJiYodCs9YFxuUHJpc21hIEFjY2VsZXJhdGUgaGFzIGJ1aWx0LWluIGNvbm5lY3Rpb24gcG9vbGluZyB0byBwcmV2ZW50IHN1Y2ggZXJyb3JzOiBodHRwczovL3ByaXMubHkvY2xpZW50L2Vycm9yLWFjY2VsZXJhdGVgKSx0fXZhciB3dD1cIjx1bmtub3duPlwiO2Z1bmN0aW9uIElhKGUpe3ZhciByPWUuc3BsaXQoYFxuYCk7cmV0dXJuIHIucmVkdWNlKGZ1bmN0aW9uKHQsbil7dmFyIGk9Y20obil8fGRtKG4pfHxnbShuKXx8RW0obil8fHltKG4pO3JldHVybiBpJiZ0LnB1c2goaSksdH0sW10pfXZhciBsbT0vXlxccyphdCAoLio/KSA/XFwoKCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lLWV4dGVuc2lvbnxuYXRpdmV8ZXZhbHx3ZWJwYWNrfHJzY3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2ksdW09L1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO2Z1bmN0aW9uIGNtKGUpe3ZhciByPWxtLmV4ZWMoZSk7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHQ9clsyXSYmclsyXS5pbmRleE9mKFwibmF0aXZlXCIpPT09MCxuPXJbMl0mJnJbMl0uaW5kZXhPZihcImV2YWxcIik9PT0wLGk9dW0uZXhlYyhyWzJdKTtyZXR1cm4gbiYmaSE9bnVsbCYmKHJbMl09aVsxXSxyWzNdPWlbMl0scls0XT1pWzNdKSx7ZmlsZTp0P251bGw6clsyXSxtZXRob2ROYW1lOnJbMV18fHd0LGFyZ3VtZW50czp0P1tyWzJdXTpbXSxsaW5lTnVtYmVyOnJbM10/K3JbM106bnVsbCxjb2x1bW46cls0XT8rcls0XTpudWxsfX12YXIgcG09L15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pPy4rKSApP1xcKD8oKD86ZmlsZXxtcy1hcHB4fGh0dHBzP3x3ZWJwYWNrfHJzY3xibG9iKTouKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO2Z1bmN0aW9uIGRtKGUpe3ZhciByPXBtLmV4ZWMoZSk7cmV0dXJuIHI/e2ZpbGU6clsyXSxtZXRob2ROYW1lOnJbMV18fHd0LGFyZ3VtZW50czpbXSxsaW5lTnVtYmVyOityWzNdLGNvbHVtbjpyWzRdPytyWzRdOm51bGx9Om51bGx9dmFyIG1tPS9eXFxzKiguKj8pKD86XFwoKC4qPylcXCkpPyg/Ol58QCkoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWV8d2VicGFja3xyc2N8cmVzb3VyY2V8XFxbbmF0aXZlKS4qP3xbXkBdKmJ1bmRsZSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pLGZtPS8oXFxTKykgbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbC9pO2Z1bmN0aW9uIGdtKGUpe3ZhciByPW1tLmV4ZWMoZSk7aWYoIXIpcmV0dXJuIG51bGw7dmFyIHQ9clszXSYmclszXS5pbmRleE9mKFwiID4gZXZhbFwiKT4tMSxuPWZtLmV4ZWMoclszXSk7cmV0dXJuIHQmJm4hPW51bGwmJihyWzNdPW5bMV0scls0XT1uWzJdLHJbNV09bnVsbCkse2ZpbGU6clszXSxtZXRob2ROYW1lOnJbMV18fHd0LGFyZ3VtZW50czpyWzJdP3JbMl0uc3BsaXQoXCIsXCIpOltdLGxpbmVOdW1iZXI6cls0XT8rcls0XTpudWxsLGNvbHVtbjpyWzVdPytyWzVdOm51bGx9fXZhciBobT0vXlxccyooPzooW15AXSopKD86XFwoKC4qPylcXCkpP0ApPyhcXFMuKj8pOihcXGQrKSg/OjooXFxkKykpP1xccyokL2k7ZnVuY3Rpb24geW0oZSl7dmFyIHI9aG0uZXhlYyhlKTtyZXR1cm4gcj97ZmlsZTpyWzNdLG1ldGhvZE5hbWU6clsxXXx8d3QsYXJndW1lbnRzOltdLGxpbmVOdW1iZXI6K3JbNF0sY29sdW1uOnJbNV0/K3JbNV06bnVsbH06bnVsbH12YXIgYm09L15cXHMqYXQgKD86KCg/OlxcW29iamVjdCBvYmplY3RcXF0pP1teXFxcXC9dKyg/OiBcXFthcyBcXFMrXFxdKT8pICk/XFwoPyguKj8pOihcXGQrKSg/OjooXFxkKykpP1xcKT9cXHMqJC9pO2Z1bmN0aW9uIEVtKGUpe3ZhciByPWJtLmV4ZWMoZSk7cmV0dXJuIHI/e2ZpbGU6clsyXSxtZXRob2ROYW1lOnJbMV18fHd0LGFyZ3VtZW50czpbXSxsaW5lTnVtYmVyOityWzNdLGNvbHVtbjpyWzRdPytyWzRdOm51bGx9Om51bGx9dmFyIFppPWNsYXNze2dldExvY2F0aW9uKCl7cmV0dXJuIG51bGx9fSxYaT1jbGFzc3tfZXJyb3I7Y29uc3RydWN0b3IoKXt0aGlzLl9lcnJvcj1uZXcgRXJyb3J9Z2V0TG9jYXRpb24oKXtsZXQgcj10aGlzLl9lcnJvci5zdGFjaztpZighcilyZXR1cm4gbnVsbDtsZXQgbj1JYShyKS5maW5kKGk9PntpZighaS5maWxlKXJldHVybiExO2xldCBvPVJpKGkuZmlsZSk7cmV0dXJuIG8hPT1cIjxhbm9ueW1vdXM+XCImJiFvLmluY2x1ZGVzKFwiQHByaXNtYVwiKSYmIW8uaW5jbHVkZXMoXCIvcGFja2FnZXMvY2xpZW50L3NyYy9ydW50aW1lL1wiKSYmIW8uZW5kc1dpdGgoXCIvcnVudGltZS9iaW5hcnkuanNcIikmJiFvLmVuZHNXaXRoKFwiL3J1bnRpbWUvbGlicmFyeS5qc1wiKSYmIW8uZW5kc1dpdGgoXCIvcnVudGltZS9lZGdlLmpzXCIpJiYhby5lbmRzV2l0aChcIi9ydW50aW1lL2VkZ2UtZXNtLmpzXCIpJiYhby5zdGFydHNXaXRoKFwiaW50ZXJuYWwvXCIpJiYhaS5tZXRob2ROYW1lLmluY2x1ZGVzKFwibmV3IFwiKSYmIWkubWV0aG9kTmFtZS5pbmNsdWRlcyhcImdldENhbGxTaXRlXCIpJiYhaS5tZXRob2ROYW1lLmluY2x1ZGVzKFwiUHJveHkuXCIpJiZpLm1ldGhvZE5hbWUuc3BsaXQoXCIuXCIpLmxlbmd0aDw0fSk7cmV0dXJuIW58fCFuLmZpbGU/bnVsbDp7ZmlsZU5hbWU6bi5maWxlLGxpbmVOdW1iZXI6bi5saW5lTnVtYmVyLGNvbHVtbk51bWJlcjpuLmNvbHVtbn19fTtmdW5jdGlvbiBaZShlKXtyZXR1cm4gZT09PVwibWluaW1hbFwiP3R5cGVvZiAkRW5hYmxlZENhbGxTaXRlPT1cImZ1bmN0aW9uXCImJmUhPT1cIm1pbmltYWxcIj9uZXcgJEVuYWJsZWRDYWxsU2l0ZTpuZXcgWmk6bmV3IFhpfXZhciBrYT17X2F2ZzohMCxfY291bnQ6ITAsX3N1bTohMCxfbWluOiEwLF9tYXg6ITB9O2Z1bmN0aW9uICRyKGU9e30pe2xldCByPXhtKGUpO3JldHVybiBPYmplY3QuZW50cmllcyhyKS5yZWR1Y2UoKG4sW2ksb10pPT4oa2FbaV0hPT12b2lkIDA/bi5zZWxlY3RbaV09e3NlbGVjdDpvfTpuW2ldPW8sbikse3NlbGVjdDp7fX0pfWZ1bmN0aW9uIHhtKGU9e30pe3JldHVybiB0eXBlb2YgZS5fY291bnQ9PVwiYm9vbGVhblwiP3suLi5lLF9jb3VudDp7X2FsbDplLl9jb3VudH19OmV9ZnVuY3Rpb24gTG4oZT17fSl7cmV0dXJuIHI9Pih0eXBlb2YgZS5fY291bnQ9PVwiYm9vbGVhblwiJiYoci5fY291bnQ9ci5fY291bnQuX2FsbCkscil9ZnVuY3Rpb24gRGEoZSxyKXtsZXQgdD1MbihlKTtyZXR1cm4gcih7YWN0aW9uOlwiYWdncmVnYXRlXCIsdW5wYWNrZXI6dCxhcmdzTWFwcGVyOiRyfSkoZSl9ZnVuY3Rpb24gdm0oZT17fSl7bGV0e3NlbGVjdDpyLC4uLnR9PWU7cmV0dXJuIHR5cGVvZiByPT1cIm9iamVjdFwiPyRyKHsuLi50LF9jb3VudDpyfSk6JHIoey4uLnQsX2NvdW50OntfYWxsOiEwfX0pfWZ1bmN0aW9uIFBtKGU9e30pe3JldHVybiB0eXBlb2YgZS5zZWxlY3Q9PVwib2JqZWN0XCI/cj0+TG4oZSkocikuX2NvdW50OnI9PkxuKGUpKHIpLl9jb3VudC5fYWxsfWZ1bmN0aW9uIE9hKGUscil7cmV0dXJuIHIoe2FjdGlvbjpcImNvdW50XCIsdW5wYWNrZXI6UG0oZSksYXJnc01hcHBlcjp2bX0pKGUpfWZ1bmN0aW9uIFRtKGU9e30pe2xldCByPSRyKGUpO2lmKEFycmF5LmlzQXJyYXkoci5ieSkpZm9yKGxldCB0IG9mIHIuYnkpdHlwZW9mIHQ9PVwic3RyaW5nXCImJihyLnNlbGVjdFt0XT0hMCk7ZWxzZSB0eXBlb2Ygci5ieT09XCJzdHJpbmdcIiYmKHIuc2VsZWN0W3IuYnldPSEwKTtyZXR1cm4gcn1mdW5jdGlvbiBTbShlPXt9KXtyZXR1cm4gcj0+KHR5cGVvZiBlPy5fY291bnQ9PVwiYm9vbGVhblwiJiZyLmZvckVhY2godD0+e3QuX2NvdW50PXQuX2NvdW50Ll9hbGx9KSxyKX1mdW5jdGlvbiBfYShlLHIpe3JldHVybiByKHthY3Rpb246XCJncm91cEJ5XCIsdW5wYWNrZXI6U20oZSksYXJnc01hcHBlcjpUbX0pKGUpfWZ1bmN0aW9uIE5hKGUscix0KXtpZihyPT09XCJhZ2dyZWdhdGVcIilyZXR1cm4gbj0+RGEobix0KTtpZihyPT09XCJjb3VudFwiKXJldHVybiBuPT5PYShuLHQpO2lmKHI9PT1cImdyb3VwQnlcIilyZXR1cm4gbj0+X2Eobix0KX1mdW5jdGlvbiBMYShlLHIpe2xldCB0PXIuZmllbGRzLmZpbHRlcihpPT4haS5yZWxhdGlvbk5hbWUpLG49V3ModCxcIm5hbWVcIik7cmV0dXJuIG5ldyBQcm94eSh7fSx7Z2V0KGksbyl7aWYobyBpbiBpfHx0eXBlb2Ygbz09XCJzeW1ib2xcIilyZXR1cm4gaVtvXTtsZXQgcz1uW29dO2lmKHMpcmV0dXJuIG5ldyBjdChlLG8scy50eXBlLHMuaXNMaXN0LHMua2luZD09PVwiZW51bVwiKX0sLi4uTm4oT2JqZWN0LmtleXMobikpfSl9dmFyIEZhPWU9PkFycmF5LmlzQXJyYXkoZSk/ZTplLnNwbGl0KFwiLlwiKSxlbz0oZSxyKT0+RmEocikucmVkdWNlKCh0LG4pPT50JiZ0W25dLGUpLE1hPShlLHIsdCk9PkZhKHIpLnJlZHVjZVJpZ2h0KChuLGksbyxzKT0+T2JqZWN0LmFzc2lnbih7fSxlbyhlLHMuc2xpY2UoMCxvKSkse1tpXTpufSksdCk7ZnVuY3Rpb24gUm0oZSxyKXtyZXR1cm4gZT09PXZvaWQgMHx8cj09PXZvaWQgMD9bXTpbLi4ucixcInNlbGVjdFwiLGVdfWZ1bmN0aW9uIEFtKGUscix0KXtyZXR1cm4gcj09PXZvaWQgMD9lPz97fTpNYShyLHQsZXx8ITApfWZ1bmN0aW9uIHJvKGUscix0LG4saSxvKXtsZXQgYT1lLl9ydW50aW1lRGF0YU1vZGVsLm1vZGVsc1tyXS5maWVsZHMucmVkdWNlKChsLHUpPT4oey4uLmwsW3UubmFtZV06dX0pLHt9KTtyZXR1cm4gbD0+e2xldCB1PVplKGUuX2Vycm9yRm9ybWF0KSxjPVJtKG4saSkscD1BbShsLG8sYyksZD10KHtkYXRhUGF0aDpjLGNhbGxzaXRlOnV9KShwKSxmPUNtKGUscik7cmV0dXJuIG5ldyBQcm94eShkLHtnZXQoaCxnKXtpZighZi5pbmNsdWRlcyhnKSlyZXR1cm4gaFtnXTtsZXQgUD1bYVtnXS50eXBlLHQsZ10sUj1bYyxwXTtyZXR1cm4gcm8oZSwuLi5QLC4uLlIpfSwuLi5ObihbLi4uZiwuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkKV0pfSl9fWZ1bmN0aW9uIENtKGUscil7cmV0dXJuIGUuX3J1bnRpbWVEYXRhTW9kZWwubW9kZWxzW3JdLmZpZWxkcy5maWx0ZXIodD0+dC5raW5kPT09XCJvYmplY3RcIikubWFwKHQ9PnQubmFtZSl9dmFyIEltPVtcImZpbmRVbmlxdWVcIixcImZpbmRVbmlxdWVPclRocm93XCIsXCJmaW5kRmlyc3RcIixcImZpbmRGaXJzdE9yVGhyb3dcIixcImNyZWF0ZVwiLFwidXBkYXRlXCIsXCJ1cHNlcnRcIixcImRlbGV0ZVwiXSxrbT1bXCJhZ2dyZWdhdGVcIixcImNvdW50XCIsXCJncm91cEJ5XCJdO2Z1bmN0aW9uIHRvKGUscil7bGV0IHQ9ZS5fZXh0ZW5zaW9ucy5nZXRBbGxNb2RlbEV4dGVuc2lvbnMocik/P3t9LG49W0RtKGUsciksX20oZSxyKSxFdCh0KSxlZShcIm5hbWVcIiwoKT0+ciksZWUoXCIkbmFtZVwiLCgpPT5yKSxlZShcIiRwYXJlbnRcIiwoKT0+ZS5fYXBwbGllZFBhcmVudCldO3JldHVybiBoZSh7fSxuKX1mdW5jdGlvbiBEbShlLHIpe2xldCB0PVRlKHIpLG49T2JqZWN0LmtleXMoUnIpLmNvbmNhdChcImNvdW50XCIpO3JldHVybntnZXRLZXlzKCl7cmV0dXJuIG59LGdldFByb3BlcnR5VmFsdWUoaSl7bGV0IG89aSxzPWE9Pmw9PntsZXQgdT1aZShlLl9lcnJvckZvcm1hdCk7cmV0dXJuIGUuX2NyZWF0ZVByaXNtYVByb21pc2UoYz0+e2xldCBwPXthcmdzOmwsZGF0YVBhdGg6W10sYWN0aW9uOm8sbW9kZWw6cixjbGllbnRNZXRob2Q6YCR7dH0uJHtpfWAsanNNb2RlbE5hbWU6dCx0cmFuc2FjdGlvbjpjLGNhbGxzaXRlOnV9O3JldHVybiBlLl9yZXF1ZXN0KHsuLi5wLC4uLmF9KX0se2FjdGlvbjpvLGFyZ3M6bCxtb2RlbDpyfSl9O3JldHVybiBJbS5pbmNsdWRlcyhvKT9ybyhlLHIscyk6T20oaSk/TmEoZSxpLHMpOnMoe30pfX19ZnVuY3Rpb24gT20oZSl7cmV0dXJuIGttLmluY2x1ZGVzKGUpfWZ1bmN0aW9uIF9tKGUscil7cmV0dXJuIGFyKGVlKFwiZmllbGRzXCIsKCk9PntsZXQgdD1lLl9ydW50aW1lRGF0YU1vZGVsLm1vZGVsc1tyXTtyZXR1cm4gTGEocix0KX0pKX1mdW5jdGlvbiAkYShlKXtyZXR1cm4gZS5yZXBsYWNlKC9eLi8scj0+ci50b1VwcGVyQ2FzZSgpKX12YXIgbm89U3ltYm9sKCk7ZnVuY3Rpb24geHQoZSl7bGV0IHI9W05tKGUpLExtKGUpLGVlKG5vLCgpPT5lKSxlZShcIiRwYXJlbnRcIiwoKT0+ZS5fYXBwbGllZFBhcmVudCldLHQ9ZS5fZXh0ZW5zaW9ucy5nZXRBbGxDbGllbnRFeHRlbnNpb25zKCk7cmV0dXJuIHQmJnIucHVzaChFdCh0KSksaGUoZSxyKX1mdW5jdGlvbiBObShlKXtsZXQgcj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoZS5fb3JpZ2luYWxDbGllbnQpLHQ9Wy4uLm5ldyBTZXQoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikpXTtyZXR1cm57Z2V0S2V5cygpe3JldHVybiB0fSxnZXRQcm9wZXJ0eVZhbHVlKG4pe3JldHVybiBlW25dfX19ZnVuY3Rpb24gTG0oZSl7bGV0IHI9T2JqZWN0LmtleXMoZS5fcnVudGltZURhdGFNb2RlbC5tb2RlbHMpLHQ9ci5tYXAoVGUpLG49Wy4uLm5ldyBTZXQoci5jb25jYXQodCkpXTtyZXR1cm4gYXIoe2dldEtleXMoKXtyZXR1cm4gbn0sZ2V0UHJvcGVydHlWYWx1ZShpKXtsZXQgbz0kYShpKTtpZihlLl9ydW50aW1lRGF0YU1vZGVsLm1vZGVsc1tvXSE9PXZvaWQgMClyZXR1cm4gdG8oZSxvKTtpZihlLl9ydW50aW1lRGF0YU1vZGVsLm1vZGVsc1tpXSE9PXZvaWQgMClyZXR1cm4gdG8oZSxpKX0sZ2V0UHJvcGVydHlEZXNjcmlwdG9yKGkpe2lmKCF0LmluY2x1ZGVzKGkpKXJldHVybntlbnVtZXJhYmxlOiExfX19KX1mdW5jdGlvbiBxYShlKXtyZXR1cm4gZVtub10/ZVtub106ZX1mdW5jdGlvbiBqYShlKXtpZih0eXBlb2YgZT09XCJmdW5jdGlvblwiKXJldHVybiBlKHRoaXMpO2lmKGUuY2xpZW50Py5fX0FjY2VsZXJhdGVFbmdpbmUpe2xldCB0PWUuY2xpZW50Ll9fQWNjZWxlcmF0ZUVuZ2luZTt0aGlzLl9vcmlnaW5hbENsaWVudC5fZW5naW5lPW5ldyB0KHRoaXMuX29yaWdpbmFsQ2xpZW50Ll9hY2NlbGVyYXRlRW5naW5lQ29uZmlnKX1sZXQgcj1PYmplY3QuY3JlYXRlKHRoaXMuX29yaWdpbmFsQ2xpZW50LHtfZXh0ZW5zaW9uczp7dmFsdWU6dGhpcy5fZXh0ZW5zaW9ucy5hcHBlbmQoZSl9LF9hcHBsaWVkUGFyZW50Ont2YWx1ZTp0aGlzLGNvbmZpZ3VyYWJsZTohMH0sJHVzZTp7dmFsdWU6dm9pZCAwfSwkb246e3ZhbHVlOnZvaWQgMH19KTtyZXR1cm4geHQocil9ZnVuY3Rpb24gVmEoe3Jlc3VsdDplLG1vZGVsTmFtZTpyLHNlbGVjdDp0LG9taXQ6bixleHRlbnNpb25zOml9KXtsZXQgbz1pLmdldEFsbENvbXB1dGVkRmllbGRzKHIpO2lmKCFvKXJldHVybiBlO2xldCBzPVtdLGE9W107Zm9yKGxldCBsIG9mIE9iamVjdC52YWx1ZXMobykpe2lmKG4pe2lmKG5bbC5uYW1lXSljb250aW51ZTtsZXQgdT1sLm5lZWRzLmZpbHRlcihjPT5uW2NdKTt1Lmxlbmd0aD4wJiZhLnB1c2goTHIodSkpfWVsc2UgaWYodCl7aWYoIXRbbC5uYW1lXSljb250aW51ZTtsZXQgdT1sLm5lZWRzLmZpbHRlcihjPT4hdFtjXSk7dS5sZW5ndGg+MCYmYS5wdXNoKExyKHUpKX1GbShlLGwubmVlZHMpJiZzLnB1c2goTW0obCxoZShlLHMpKSl9cmV0dXJuIHMubGVuZ3RoPjB8fGEubGVuZ3RoPjA/aGUoZSxbLi4ucywuLi5hXSk6ZX1mdW5jdGlvbiBGbShlLHIpe3JldHVybiByLmV2ZXJ5KHQ9Pk9pKGUsdCkpfWZ1bmN0aW9uIE1tKGUscil7cmV0dXJuIGFyKGVlKGUubmFtZSwoKT0+ZS5jb21wdXRlKHIpKSl9ZnVuY3Rpb24gRm4oe3Zpc2l0b3I6ZSxyZXN1bHQ6cixhcmdzOnQscnVudGltZURhdGFNb2RlbDpuLG1vZGVsTmFtZTppfSl7aWYoQXJyYXkuaXNBcnJheShyKSl7Zm9yKGxldCBzPTA7czxyLmxlbmd0aDtzKyspcltzXT1Gbih7cmVzdWx0OnJbc10sYXJnczp0LG1vZGVsTmFtZTppLHJ1bnRpbWVEYXRhTW9kZWw6bix2aXNpdG9yOmV9KTtyZXR1cm4gcn1sZXQgbz1lKHIsaSx0KT8/cjtyZXR1cm4gdC5pbmNsdWRlJiZCYSh7aW5jbHVkZU9yU2VsZWN0OnQuaW5jbHVkZSxyZXN1bHQ6byxwYXJlbnRNb2RlbE5hbWU6aSxydW50aW1lRGF0YU1vZGVsOm4sdmlzaXRvcjplfSksdC5zZWxlY3QmJkJhKHtpbmNsdWRlT3JTZWxlY3Q6dC5zZWxlY3QscmVzdWx0Om8scGFyZW50TW9kZWxOYW1lOmkscnVudGltZURhdGFNb2RlbDpuLHZpc2l0b3I6ZX0pLG99ZnVuY3Rpb24gQmEoe2luY2x1ZGVPclNlbGVjdDplLHJlc3VsdDpyLHBhcmVudE1vZGVsTmFtZTp0LHJ1bnRpbWVEYXRhTW9kZWw6bix2aXNpdG9yOml9KXtmb3IobGV0W28sc11vZiBPYmplY3QuZW50cmllcyhlKSl7aWYoIXN8fHJbb109PW51bGx8fFNlKHMpKWNvbnRpbnVlO2xldCBsPW4ubW9kZWxzW3RdLmZpZWxkcy5maW5kKGM9PmMubmFtZT09PW8pO2lmKCFsfHxsLmtpbmQhPT1cIm9iamVjdFwifHwhbC5yZWxhdGlvbk5hbWUpY29udGludWU7bGV0IHU9dHlwZW9mIHM9PVwib2JqZWN0XCI/czp7fTtyW29dPUZuKHt2aXNpdG9yOmkscmVzdWx0OnJbb10sYXJnczp1LG1vZGVsTmFtZTpsLnR5cGUscnVudGltZURhdGFNb2RlbDpufSl9fWZ1bmN0aW9uIFVhKHtyZXN1bHQ6ZSxtb2RlbE5hbWU6cixhcmdzOnQsZXh0ZW5zaW9uczpuLHJ1bnRpbWVEYXRhTW9kZWw6aSxnbG9iYWxPbWl0Om99KXtyZXR1cm4gbi5pc0VtcHR5KCl8fGU9PW51bGx8fHR5cGVvZiBlIT1cIm9iamVjdFwifHwhaS5tb2RlbHNbcl0/ZTpGbih7cmVzdWx0OmUsYXJnczp0Pz97fSxtb2RlbE5hbWU6cixydW50aW1lRGF0YU1vZGVsOmksdmlzaXRvcjooYSxsLHUpPT57bGV0IGM9VGUobCk7cmV0dXJuIFZhKHtyZXN1bHQ6YSxtb2RlbE5hbWU6YyxzZWxlY3Q6dS5zZWxlY3Qsb21pdDp1LnNlbGVjdD92b2lkIDA6ey4uLm8/LltjXSwuLi51Lm9taXR9LGV4dGVuc2lvbnM6bn0pfX0pfXZhciAkbT1bXCIkY29ubmVjdFwiLFwiJGRpc2Nvbm5lY3RcIixcIiRvblwiLFwiJHRyYW5zYWN0aW9uXCIsXCIkdXNlXCIsXCIkZXh0ZW5kc1wiXSxHYT0kbTtmdW5jdGlvbiBRYShlKXtpZihlIGluc3RhbmNlb2YgbGUpcmV0dXJuIHFtKGUpO2lmKE9uKGUpKXJldHVybiBqbShlKTtpZihBcnJheS5pc0FycmF5KGUpKXtsZXQgdD1bZVswXV07Zm9yKGxldCBuPTE7bjxlLmxlbmd0aDtuKyspdFtuXT12dChlW25dKTtyZXR1cm4gdH1sZXQgcj17fTtmb3IobGV0IHQgaW4gZSlyW3RdPXZ0KGVbdF0pO3JldHVybiByfWZ1bmN0aW9uIHFtKGUpe3JldHVybiBuZXcgbGUoZS5zdHJpbmdzLGUudmFsdWVzKX1mdW5jdGlvbiBqbShlKXtyZXR1cm4gbmV3IGJ0KGUuc3FsLGUudmFsdWVzKX1mdW5jdGlvbiB2dChlKXtpZih0eXBlb2YgZSE9XCJvYmplY3RcInx8ZT09bnVsbHx8ZSBpbnN0YW5jZW9mIE1lfHxPcihlKSlyZXR1cm4gZTtpZihTcihlKSlyZXR1cm4gbmV3IEZlKGUudG9GaXhlZCgpKTtpZihUcihlKSlyZXR1cm4gbmV3IERhdGUoK2UpO2lmKEFycmF5QnVmZmVyLmlzVmlldyhlKSlyZXR1cm4gZS5zbGljZSgwKTtpZihBcnJheS5pc0FycmF5KGUpKXtsZXQgcj1lLmxlbmd0aCx0O2Zvcih0PUFycmF5KHIpO3ItLTspdFtyXT12dChlW3JdKTtyZXR1cm4gdH1pZih0eXBlb2YgZT09XCJvYmplY3RcIil7bGV0IHI9e307Zm9yKGxldCB0IGluIGUpdD09PVwiX19wcm90b19fXCI/T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsdCx7dmFsdWU6dnQoZVt0XSksY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsd3JpdGFibGU6ITB9KTpyW3RdPXZ0KGVbdF0pO3JldHVybiByfV9lKGUsXCJVbmtub3duIHZhbHVlXCIpfWZ1bmN0aW9uIEphKGUscix0LG49MCl7cmV0dXJuIGUuX2NyZWF0ZVByaXNtYVByb21pc2UoaT0+e2xldCBvPXIuY3VzdG9tRGF0YVByb3h5RmV0Y2g7cmV0dXJuXCJ0cmFuc2FjdGlvblwiaW4gciYmaSE9PXZvaWQgMCYmKHIudHJhbnNhY3Rpb24/LmtpbmQ9PT1cImJhdGNoXCImJnIudHJhbnNhY3Rpb24ubG9jay50aGVuKCksci50cmFuc2FjdGlvbj1pKSxuPT09dC5sZW5ndGg/ZS5fZXhlY3V0ZVJlcXVlc3Qocik6dFtuXSh7bW9kZWw6ci5tb2RlbCxvcGVyYXRpb246ci5tb2RlbD9yLmFjdGlvbjpyLmNsaWVudE1ldGhvZCxhcmdzOlFhKHIuYXJncz8/e30pLF9faW50ZXJuYWxQYXJhbXM6cixxdWVyeToocyxhPXIpPT57bGV0IGw9YS5jdXN0b21EYXRhUHJveHlGZXRjaDtyZXR1cm4gYS5jdXN0b21EYXRhUHJveHlGZXRjaD16YShvLGwpLGEuYXJncz1zLEphKGUsYSx0LG4rMSl9fSl9KX1mdW5jdGlvbiBIYShlLHIpe2xldHtqc01vZGVsTmFtZTp0LGFjdGlvbjpuLGNsaWVudE1ldGhvZDppfT1yLG89dD9uOmk7aWYoZS5fZXh0ZW5zaW9ucy5pc0VtcHR5KCkpcmV0dXJuIGUuX2V4ZWN1dGVSZXF1ZXN0KHIpO2xldCBzPWUuX2V4dGVuc2lvbnMuZ2V0QWxsUXVlcnlDYWxsYmFja3ModD8/XCIkbm9uZVwiLG8pO3JldHVybiBKYShlLHIscyl9ZnVuY3Rpb24gS2EoZSl7cmV0dXJuIHI9PntsZXQgdD17cmVxdWVzdHM6cn0sbj1yWzBdLmV4dGVuc2lvbnMuZ2V0QWxsQmF0Y2hRdWVyeUNhbGxiYWNrcygpO3JldHVybiBuLmxlbmd0aD9ZYSh0LG4sMCxlKTplKHQpfX1mdW5jdGlvbiBZYShlLHIsdCxuKXtpZih0PT09ci5sZW5ndGgpcmV0dXJuIG4oZSk7bGV0IGk9ZS5jdXN0b21EYXRhUHJveHlGZXRjaCxvPWUucmVxdWVzdHNbMF0udHJhbnNhY3Rpb247cmV0dXJuIHJbdF0oe2FyZ3M6e3F1ZXJpZXM6ZS5yZXF1ZXN0cy5tYXAocz0+KHttb2RlbDpzLm1vZGVsTmFtZSxvcGVyYXRpb246cy5hY3Rpb24sYXJnczpzLmFyZ3N9KSksdHJhbnNhY3Rpb246bz97aXNvbGF0aW9uTGV2ZWw6by5raW5kPT09XCJiYXRjaFwiP28uaXNvbGF0aW9uTGV2ZWw6dm9pZCAwfTp2b2lkIDB9LF9faW50ZXJuYWxQYXJhbXM6ZSxxdWVyeShzLGE9ZSl7bGV0IGw9YS5jdXN0b21EYXRhUHJveHlGZXRjaDtyZXR1cm4gYS5jdXN0b21EYXRhUHJveHlGZXRjaD16YShpLGwpLFlhKGEscix0KzEsbil9fSl9dmFyIFdhPWU9PmU7ZnVuY3Rpb24gemEoZT1XYSxyPVdhKXtyZXR1cm4gdD0+ZShyKHQpKX12YXIgWmE9TChcInByaXNtYTpjbGllbnRcIiksWGE9e1ZlcmNlbDpcInZlcmNlbFwiLFwiTmV0bGlmeSBDSVwiOlwibmV0bGlmeVwifTtmdW5jdGlvbiBlbCh7cG9zdGluc3RhbGw6ZSxjaU5hbWU6cixjbGllbnRWZXJzaW9uOnR9KXtpZihaYShcImNoZWNrUGxhdGZvcm1DYWNoaW5nOnBvc3RpbnN0YWxsXCIsZSksWmEoXCJjaGVja1BsYXRmb3JtQ2FjaGluZzpjaU5hbWVcIixyKSxlPT09ITAmJnImJnIgaW4gWGEpe2xldCBuPWBQcmlzbWEgaGFzIGRldGVjdGVkIHRoYXQgdGhpcyBwcm9qZWN0IHdhcyBidWlsdCBvbiAke3J9LCB3aGljaCBjYWNoZXMgZGVwZW5kZW5jaWVzLiBUaGlzIGxlYWRzIHRvIGFuIG91dGRhdGVkIFByaXNtYSBDbGllbnQgYmVjYXVzZSBQcmlzbWEncyBhdXRvLWdlbmVyYXRpb24gaXNuJ3QgdHJpZ2dlcmVkLiBUbyBmaXggdGhpcywgbWFrZSBzdXJlIHRvIHJ1biB0aGUgXFxgcHJpc21hIGdlbmVyYXRlXFxgIGNvbW1hbmQgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzLlxuXG5MZWFybiBob3c6IGh0dHBzOi8vcHJpcy5seS9kLyR7WGFbcl19LWJ1aWxkYDt0aHJvdyBjb25zb2xlLmVycm9yKG4pLG5ldyBUKG4sdCl9fWZ1bmN0aW9uIHJsKGUscil7cmV0dXJuIGU/ZS5kYXRhc291cmNlcz9lLmRhdGFzb3VyY2VzOmUuZGF0YXNvdXJjZVVybD97W3JbMF1dOnt1cmw6ZS5kYXRhc291cmNlVXJsfX06e306e319dmFyIFZtPSgpPT5nbG9iYWxUaGlzLnByb2Nlc3M/LnJlbGVhc2U/Lm5hbWU9PT1cIm5vZGVcIixCbT0oKT0+ISFnbG9iYWxUaGlzLkJ1bnx8ISFnbG9iYWxUaGlzLnByb2Nlc3M/LnZlcnNpb25zPy5idW4sVW09KCk9PiEhZ2xvYmFsVGhpcy5EZW5vLEdtPSgpPT50eXBlb2YgZ2xvYmFsVGhpcy5OZXRsaWZ5PT1cIm9iamVjdFwiLFFtPSgpPT50eXBlb2YgZ2xvYmFsVGhpcy5FZGdlUnVudGltZT09XCJvYmplY3RcIixXbT0oKT0+Z2xvYmFsVGhpcy5uYXZpZ2F0b3I/LnVzZXJBZ2VudD09PVwiQ2xvdWRmbGFyZS1Xb3JrZXJzXCI7ZnVuY3Rpb24gSm0oKXtyZXR1cm5bW0dtLFwibmV0bGlmeVwiXSxbUW0sXCJlZGdlLWxpZ2h0XCJdLFtXbSxcIndvcmtlcmRcIl0sW1VtLFwiZGVub1wiXSxbQm0sXCJidW5cIl0sW1ZtLFwibm9kZVwiXV0uZmxhdE1hcCh0PT50WzBdKCk/W3RbMV1dOltdKS5hdCgwKT8/XCJcIn12YXIgSG09e25vZGU6XCJOb2RlLmpzXCIsd29ya2VyZDpcIkNsb3VkZmxhcmUgV29ya2Vyc1wiLGRlbm86XCJEZW5vIGFuZCBEZW5vIERlcGxveVwiLG5ldGxpZnk6XCJOZXRsaWZ5IEVkZ2UgRnVuY3Rpb25zXCIsXCJlZGdlLWxpZ2h0XCI6XCJFZGdlIFJ1bnRpbWUgKFZlcmNlbCBFZGdlIEZ1bmN0aW9ucywgVmVyY2VsIEVkZ2UgTWlkZGxld2FyZSwgTmV4dC5qcyAoUGFnZXMgUm91dGVyKSBFZGdlIEFQSSBSb3V0ZXMsIE5leHQuanMgKEFwcCBSb3V0ZXIpIEVkZ2UgUm91dGUgSGFuZGxlcnMgb3IgTmV4dC5qcyBNaWRkbGV3YXJlKVwifTtmdW5jdGlvbiBpbygpe2xldCBlPUptKCk7cmV0dXJue2lkOmUscHJldHR5TmFtZTpIbVtlXXx8ZSxpc0VkZ2U6W1wid29ya2VyZFwiLFwiZGVub1wiLFwibmV0bGlmeVwiLFwiZWRnZS1saWdodFwiXS5pbmNsdWRlcyhlKX19aW1wb3J0IFltIGZyb21cIm5vZGU6ZnNcIjtpbXBvcnQgam4gZnJvbVwibm9kZTpwYXRoXCI7ZnVuY3Rpb24gTW4oZSl7bGV0e3J1bnRpbWVCaW5hcnlUYXJnZXQ6cn09ZTtyZXR1cm5gQWRkIFwiJHtyfVwiIHRvIFxcYGJpbmFyeVRhcmdldHNcXGAgaW4gdGhlIFwic2NoZW1hLnByaXNtYVwiIGZpbGUgYW5kIHJ1biBcXGBwcmlzbWEgZ2VuZXJhdGVcXGAgYWZ0ZXIgc2F2aW5nIGl0OlxuXG4ke0ttKGUpfWB9ZnVuY3Rpb24gS20oZSl7bGV0e2dlbmVyYXRvcjpyLGdlbmVyYXRvckJpbmFyeVRhcmdldHM6dCxydW50aW1lQmluYXJ5VGFyZ2V0Om59PWUsaT17ZnJvbUVudlZhcjpudWxsLHZhbHVlOm59LG89Wy4uLnQsaV07cmV0dXJuIFBpKHsuLi5yLGJpbmFyeVRhcmdldHM6b30pfWZ1bmN0aW9uIFhlKGUpe2xldHtydW50aW1lQmluYXJ5VGFyZ2V0OnJ9PWU7cmV0dXJuYFByaXNtYSBDbGllbnQgY291bGQgbm90IGxvY2F0ZSB0aGUgUXVlcnkgRW5naW5lIGZvciBydW50aW1lIFwiJHtyfVwiLmB9ZnVuY3Rpb24gZXIoZSl7bGV0e3NlYXJjaGVkTG9jYXRpb25zOnJ9PWU7cmV0dXJuYFRoZSBmb2xsb3dpbmcgbG9jYXRpb25zIGhhdmUgYmVlbiBzZWFyY2hlZDpcbiR7Wy4uLm5ldyBTZXQocildLm1hcChpPT5gICAke2l9YCkuam9pbihgXG5gKX1gfWZ1bmN0aW9uIHRsKGUpe2xldHtydW50aW1lQmluYXJ5VGFyZ2V0OnJ9PWU7cmV0dXJuYCR7WGUoZSl9XG5cblRoaXMgaGFwcGVuZWQgYmVjYXVzZSBcXGBiaW5hcnlUYXJnZXRzXFxgIGhhdmUgYmVlbiBwaW5uZWQsIGJ1dCB0aGUgYWN0dWFsIGRlcGxveW1lbnQgYWxzbyByZXF1aXJlZCBcIiR7cn1cIi5cbiR7TW4oZSl9XG5cbiR7ZXIoZSl9YH1mdW5jdGlvbiAkbihlKXtyZXR1cm5gV2Ugd291bGQgYXBwcmVjaWF0ZSBpZiB5b3UgY291bGQgdGFrZSB0aGUgdGltZSB0byBzaGFyZSBzb21lIGluZm9ybWF0aW9uIHdpdGggdXMuXG5QbGVhc2UgaGVscCB1cyBieSBhbnN3ZXJpbmcgYSBmZXcgcXVlc3Rpb25zOiBodHRwczovL3ByaXMubHkvJHtlfWB9ZnVuY3Rpb24gcW4oZSl7bGV0e2Vycm9yU3RhY2s6cn09ZTtyZXR1cm4gcj8ubWF0Y2goL1xcL1xcLm5leHR8XFwvbmV4dEB8XFwvbmV4dFxcLy8pP2BcblxuV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgYXJlIHVzaW5nIE5leHQuanMsIGxlYXJuIGhvdyB0byBmaXggdGhpczogaHR0cHM6Ly9wcmlzLmx5L2QvZW5naW5lLW5vdC1mb3VuZC1uZXh0anMuYDpcIlwifWZ1bmN0aW9uIG5sKGUpe2xldHtxdWVyeUVuZ2luZU5hbWU6cn09ZTtyZXR1cm5gJHtYZShlKX0ke3FuKGUpfVxuXG5UaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidW5kbGVyIHRoYXQgaGFzIG5vdCBjb3BpZWQgXCIke3J9XCIgbmV4dCB0byB0aGUgcmVzdWx0aW5nIGJ1bmRsZS5cbkVuc3VyZSB0aGF0IFwiJHtyfVwiIGhhcyBiZWVuIGNvcGllZCBuZXh0IHRvIHRoZSBidW5kbGUgb3IgaW4gXCIke2UuZXhwZWN0ZWRMb2NhdGlvbn1cIi5cblxuJHskbihcImVuZ2luZS1ub3QtZm91bmQtYnVuZGxlci1pbnZlc3RpZ2F0aW9uXCIpfVxuXG4ke2VyKGUpfWB9ZnVuY3Rpb24gaWwoZSl7bGV0e3J1bnRpbWVCaW5hcnlUYXJnZXQ6cixnZW5lcmF0b3JCaW5hcnlUYXJnZXRzOnR9PWUsbj10LmZpbmQoaT0+aS5uYXRpdmUpO3JldHVybmAke1hlKGUpfVxuXG5UaGlzIGhhcHBlbmVkIGJlY2F1c2UgUHJpc21hIENsaWVudCB3YXMgZ2VuZXJhdGVkIGZvciBcIiR7bj8udmFsdWU/P1widW5rbm93blwifVwiLCBidXQgdGhlIGFjdHVhbCBkZXBsb3ltZW50IHJlcXVpcmVkIFwiJHtyfVwiLlxuJHtNbihlKX1cblxuJHtlcihlKX1gfWZ1bmN0aW9uIG9sKGUpe2xldHtxdWVyeUVuZ2luZU5hbWU6cn09ZTtyZXR1cm5gJHtYZShlKX0ke3FuKGUpfVxuXG5UaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgdG9vbGluZyB0aGF0IGhhcyBub3QgY29waWVkIFwiJHtyfVwiIHRvIHRoZSBkZXBsb3ltZW50IGZvbGRlci5cbkVuc3VyZSB0aGF0IHlvdSByYW4gXFxgcHJpc21hIGdlbmVyYXRlXFxgIGFuZCB0aGF0IFwiJHtyfVwiIGhhcyBiZWVuIGNvcGllZCB0byBcIiR7ZS5leHBlY3RlZExvY2F0aW9ufVwiLlxuXG4keyRuKFwiZW5naW5lLW5vdC1mb3VuZC10b29saW5nLWludmVzdGlnYXRpb25cIil9XG5cbiR7ZXIoZSl9YH12YXIgem09TChcInByaXNtYTpjbGllbnQ6ZW5naW5lczpyZXNvbHZlRW5naW5lUGF0aFwiKSxabT0oKT0+bmV3IFJlZ0V4cChcInJ1bnRpbWVbXFxcXFxcXFwvXWxpYnJhcnlcXFxcLm0/anMkXCIpO2FzeW5jIGZ1bmN0aW9uIHNsKGUscil7bGV0IHQ9e2JpbmFyeTpwcm9jZXNzLmVudi5QUklTTUFfUVVFUllfRU5HSU5FX0JJTkFSWSxsaWJyYXJ5OnByb2Nlc3MuZW52LlBSSVNNQV9RVUVSWV9FTkdJTkVfTElCUkFSWX1bZV0/P3IucHJpc21hUGF0aDtpZih0IT09dm9pZCAwKXJldHVybiB0O2xldHtlbmdpbmVQYXRoOm4sc2VhcmNoZWRMb2NhdGlvbnM6aX09YXdhaXQgWG0oZSxyKTtpZih6bShcImVuZ2luZVBhdGhcIixuKSxuIT09dm9pZCAwJiZlPT09XCJiaW5hcnlcIiYmeWkobiksbiE9PXZvaWQgMClyZXR1cm4gci5wcmlzbWFQYXRoPW47bGV0IG89YXdhaXQgbnIoKSxzPXIuZ2VuZXJhdG9yPy5iaW5hcnlUYXJnZXRzPz9bXSxhPXMuc29tZShkPT5kLm5hdGl2ZSksbD0hcy5zb21lKGQ9PmQudmFsdWU9PT1vKSx1PV9fZmlsZW5hbWUubWF0Y2goWm0oKSk9PT1udWxsLGM9e3NlYXJjaGVkTG9jYXRpb25zOmksZ2VuZXJhdG9yQmluYXJ5VGFyZ2V0czpzLGdlbmVyYXRvcjpyLmdlbmVyYXRvcixydW50aW1lQmluYXJ5VGFyZ2V0Om8scXVlcnlFbmdpbmVOYW1lOmFsKGUsbyksZXhwZWN0ZWRMb2NhdGlvbjpqbi5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLHIuZGlybmFtZSksZXJyb3JTdGFjazpuZXcgRXJyb3IoKS5zdGFja30scDt0aHJvdyBhJiZsP3A9aWwoYyk6bD9wPXRsKGMpOnU/cD1ubChjKTpwPW9sKGMpLG5ldyBUKHAsci5jbGllbnRWZXJzaW9uKX1hc3luYyBmdW5jdGlvbiBYbShlLHIpe2xldCB0PWF3YWl0IG5yKCksbj1bXSxpPVtyLmRpcm5hbWUsam4ucmVzb2x2ZShfX2Rpcm5hbWUsXCIuLlwiKSxyLmdlbmVyYXRvcj8ub3V0cHV0Py52YWx1ZT8/X19kaXJuYW1lLGpuLnJlc29sdmUoX19kaXJuYW1lLFwiLi4vLi4vLi4vLnByaXNtYS9jbGllbnRcIiksXCIvdG1wL3ByaXNtYS1lbmdpbmVzXCIsci5jd2RdO19fZmlsZW5hbWUuaW5jbHVkZXMoXCJyZXNvbHZlRW5naW5lUGF0aFwiKSYmaS5wdXNoKGxzKCkpO2ZvcihsZXQgbyBvZiBpKXtsZXQgcz1hbChlLHQpLGE9am4uam9pbihvLHMpO2lmKG4ucHVzaChvKSxZbS5leGlzdHNTeW5jKGEpKXJldHVybntlbmdpbmVQYXRoOmEsc2VhcmNoZWRMb2NhdGlvbnM6bn19cmV0dXJue2VuZ2luZVBhdGg6dm9pZCAwLHNlYXJjaGVkTG9jYXRpb25zOm59fWZ1bmN0aW9uIGFsKGUscil7cmV0dXJuIGU9PT1cImxpYnJhcnlcIj9qdChyLFwiZnNcIik6YHF1ZXJ5LWVuZ2luZS0ke3J9JHtyPT09XCJ3aW5kb3dzXCI/XCIuZXhlXCI6XCJcIn1gfXZhciBvbz1uZShTaSgpKTtmdW5jdGlvbiBsbChlKXtyZXR1cm4gZT9lLnJlcGxhY2UoL1wiLipcIi9nLCdcIlhcIicpLnJlcGxhY2UoL1tcXHM6XFxbXShbKy1dPyhbMC05XSpbLl0pP1swLTldKykvZyxyPT5gJHtyWzBdfTVgKTpcIlwifWZ1bmN0aW9uIHVsKGUpe3JldHVybiBlLnNwbGl0KGBcbmApLm1hcChyPT5yLnJlcGxhY2UoL15cXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZFxcLlxcZCsoWystXVswLTJdXFxkOlswLTVdXFxkfFopXFxzKi8sXCJcIikucmVwbGFjZSgvXFwrXFxkK1xccyptcyQvLFwiXCIpKS5qb2luKGBcbmApfXZhciBjbD1uZShrcygpKTtmdW5jdGlvbiBwbCh7dGl0bGU6ZSx1c2VyOnI9XCJwcmlzbWFcIixyZXBvOnQ9XCJwcmlzbWFcIix0ZW1wbGF0ZTpuPVwiYnVnX3JlcG9ydC55bWxcIixib2R5Oml9KXtyZXR1cm4oMCxjbC5kZWZhdWx0KSh7dXNlcjpyLHJlcG86dCx0ZW1wbGF0ZTpuLHRpdGxlOmUsYm9keTppfSl9ZnVuY3Rpb24gZGwoe3ZlcnNpb246ZSxiaW5hcnlUYXJnZXQ6cix0aXRsZTp0LGRlc2NyaXB0aW9uOm4sZW5naW5lVmVyc2lvbjppLGRhdGFiYXNlOm8scXVlcnk6c30pe2xldCBhPXFvKDZlMy0ocz8ubGVuZ3RoPz8wKSksbD11bCgoMCxvby5kZWZhdWx0KShhKSksdT1uP2AjIERlc2NyaXB0aW9uXG5cXGBcXGBcXGBcbiR7bn1cblxcYFxcYFxcYGA6XCJcIixjPSgwLG9vLmRlZmF1bHQpKGBIaSBQcmlzbWEgVGVhbSEgTXkgUHJpc21hIENsaWVudCBqdXN0IGNyYXNoZWQuIFRoaXMgaXMgdGhlIHJlcG9ydDpcbiMjIFZlcnNpb25zXG5cbnwgTmFtZSAgICAgICAgICAgIHwgVmVyc2lvbiAgICAgICAgICAgIHxcbnwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLXxcbnwgTm9kZSAgICAgICAgICAgIHwgJHtwcm9jZXNzLnZlcnNpb24/LnBhZEVuZCgxOSl9fCBcbnwgT1MgICAgICAgICAgICAgIHwgJHtyPy5wYWRFbmQoMTkpfXxcbnwgUHJpc21hIENsaWVudCAgIHwgJHtlPy5wYWRFbmQoMTkpfXxcbnwgUXVlcnkgRW5naW5lICAgIHwgJHtpPy5wYWRFbmQoMTkpfXxcbnwgRGF0YWJhc2UgICAgICAgIHwgJHtvPy5wYWRFbmQoMTkpfXxcblxuJHt1fVxuXG4jIyBMb2dzXG5cXGBcXGBcXGBcbiR7bH1cblxcYFxcYFxcYFxuXG4jIyBDbGllbnQgU25pcHBldFxuXFxgXFxgXFxgdHNcbi8vIFBMRUFTRSBGSUxMIFlPVVIgQ09ERSBTTklQUEVUIEhFUkVcblxcYFxcYFxcYFxuXG4jIyBTY2hlbWFcblxcYFxcYFxcYHByaXNtYVxuLy8gUExFQVNFIEFERCBZT1VSIFNDSEVNQSBIRVJFIElGIFBPU1NJQkxFXG5cXGBcXGBcXGBcblxuIyMgUHJpc21hIEVuZ2luZSBRdWVyeVxuXFxgXFxgXFxgXG4ke3M/bGwocyk6XCJcIn1cblxcYFxcYFxcYFxuYCkscD1wbCh7dGl0bGU6dCxib2R5OmN9KTtyZXR1cm5gJHt0fVxuXG5UaGlzIGlzIGEgbm9uLXJlY292ZXJhYmxlIGVycm9yIHdoaWNoIHByb2JhYmx5IGhhcHBlbnMgd2hlbiB0aGUgUHJpc21hIFF1ZXJ5IEVuZ2luZSBoYXMgYSBwYW5pYy5cblxuJHtLKHApfVxuXG5JZiB5b3Ugd2FudCB0aGUgUHJpc21hIHRlYW0gdG8gbG9vayBpbnRvIGl0LCBwbGVhc2Ugb3BlbiB0aGUgbGluayBhYm92ZSBcXHV7MUY2NEZ9XG5UbyBpbmNyZWFzZSB0aGUgY2hhbmNlIG9mIHN1Y2Nlc3MsIHBsZWFzZSBwb3N0IHlvdXIgc2NoZW1hIGFuZCBhIHNuaXBwZXQgb2ZcbmhvdyB5b3UgdXNlZCBQcmlzbWEgQ2xpZW50IGluIHRoZSBpc3N1ZS4gXG5gfXZhciBtbD1cIjYuMTMuMFwiO2Z1bmN0aW9uIHFyKHtpbmxpbmVEYXRhc291cmNlczplLG92ZXJyaWRlRGF0YXNvdXJjZXM6cixlbnY6dCxjbGllbnRWZXJzaW9uOm59KXtsZXQgaSxvPU9iamVjdC5rZXlzKGUpWzBdLHM9ZVtvXT8udXJsLGE9cltvXT8udXJsO2lmKG89PT12b2lkIDA/aT12b2lkIDA6YT9pPWE6cz8udmFsdWU/aT1zLnZhbHVlOnM/LmZyb21FbnZWYXImJihpPXRbcy5mcm9tRW52VmFyXSkscz8uZnJvbUVudlZhciE9PXZvaWQgMCYmaT09PXZvaWQgMCl0aHJvdyBuZXcgVChgZXJyb3I6IEVudmlyb25tZW50IHZhcmlhYmxlIG5vdCBmb3VuZDogJHtzLmZyb21FbnZWYXJ9LmAsbik7aWYoaT09PXZvaWQgMCl0aHJvdyBuZXcgVChcImVycm9yOiBNaXNzaW5nIFVSTCBlbnZpcm9ubWVudCB2YXJpYWJsZSwgdmFsdWUsIG9yIG92ZXJyaWRlLlwiLG4pO3JldHVybiBpfXZhciBWbj1jbGFzcyBleHRlbmRzIEVycm9ye2NsaWVudFZlcnNpb247Y2F1c2U7Y29uc3RydWN0b3Iocix0KXtzdXBlcihyKSx0aGlzLmNsaWVudFZlcnNpb249dC5jbGllbnRWZXJzaW9uLHRoaXMuY2F1c2U9dC5jYXVzZX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVybiB0aGlzLm5hbWV9fTt2YXIgb2U9Y2xhc3MgZXh0ZW5kcyBWbntpc1JldHJ5YWJsZTtjb25zdHJ1Y3RvcihyLHQpe3N1cGVyKHIsdCksdGhpcy5pc1JldHJ5YWJsZT10LmlzUmV0cnlhYmxlPz8hMH19O2Z1bmN0aW9uIEEoZSxyKXtyZXR1cm57Li4uZSxpc1JldHJ5YWJsZTpyfX12YXIgbHI9Y2xhc3MgZXh0ZW5kcyBvZXtuYW1lPVwiSW52YWxpZERhdGFzb3VyY2VFcnJvclwiO2NvZGU9XCJQNjAwMVwiO2NvbnN0cnVjdG9yKHIsdCl7c3VwZXIocixBKHQsITEpKX19O3gobHIsXCJJbnZhbGlkRGF0YXNvdXJjZUVycm9yXCIpO2Z1bmN0aW9uIGZsKGUpe2xldCByPXtjbGllbnRWZXJzaW9uOmUuY2xpZW50VmVyc2lvbn0sdD1PYmplY3Qua2V5cyhlLmlubGluZURhdGFzb3VyY2VzKVswXSxuPXFyKHtpbmxpbmVEYXRhc291cmNlczplLmlubGluZURhdGFzb3VyY2VzLG92ZXJyaWRlRGF0YXNvdXJjZXM6ZS5vdmVycmlkZURhdGFzb3VyY2VzLGNsaWVudFZlcnNpb246ZS5jbGllbnRWZXJzaW9uLGVudjp7Li4uZS5lbnYsLi4udHlwZW9mIHByb2Nlc3M8XCJ1XCI/cHJvY2Vzcy5lbnY6e319fSksaTt0cnl7aT1uZXcgVVJMKG4pfWNhdGNoe3Rocm93IG5ldyBscihgRXJyb3IgdmFsaWRhdGluZyBkYXRhc291cmNlIFxcYCR7dH1cXGA6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIHRoZSBwcm90b2NvbCBcXGBwcmlzbWE6Ly9cXGBgLHIpfWxldHtwcm90b2NvbDpvLHNlYXJjaFBhcmFtczpzfT1pO2lmKG8hPT1cInByaXNtYTpcIiYmbyE9PVh0KXRocm93IG5ldyBscihgRXJyb3IgdmFsaWRhdGluZyBkYXRhc291cmNlIFxcYCR7dH1cXGA6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIHRoZSBwcm90b2NvbCBcXGBwcmlzbWE6Ly9cXGAgb3IgXFxgcHJpc21hK3Bvc3RncmVzOi8vXFxgYCxyKTtsZXQgYT1zLmdldChcImFwaV9rZXlcIik7aWYoYT09PW51bGx8fGEubGVuZ3RoPDEpdGhyb3cgbmV3IGxyKGBFcnJvciB2YWxpZGF0aW5nIGRhdGFzb3VyY2UgXFxgJHt0fVxcYDogdGhlIFVSTCBtdXN0IGNvbnRhaW4gYSB2YWxpZCBBUEkga2V5YCxyKTtsZXQgbD13aShpKT9cImh0dHA6XCI6XCJodHRwczpcIix1PW5ldyBVUkwoaS5ocmVmLnJlcGxhY2UobyxsKSk7cmV0dXJue2FwaUtleTphLHVybDp1fX12YXIgZ2w9bmUoWnQoKSksQm49Y2xhc3N7YXBpS2V5O3RyYWNpbmdIZWxwZXI7bG9nTGV2ZWw7bG9nUXVlcmllcztlbmdpbmVIYXNoO2NvbnN0cnVjdG9yKHthcGlLZXk6cix0cmFjaW5nSGVscGVyOnQsbG9nTGV2ZWw6bixsb2dRdWVyaWVzOmksZW5naW5lSGFzaDpvfSl7dGhpcy5hcGlLZXk9cix0aGlzLnRyYWNpbmdIZWxwZXI9dCx0aGlzLmxvZ0xldmVsPW4sdGhpcy5sb2dRdWVyaWVzPWksdGhpcy5lbmdpbmVIYXNoPW99YnVpbGQoe3RyYWNlcGFyZW50OnIsdHJhbnNhY3Rpb25JZDp0fT17fSl7bGV0IG49e0FjY2VwdDpcImFwcGxpY2F0aW9uL2pzb25cIixBdXRob3JpemF0aW9uOmBCZWFyZXIgJHt0aGlzLmFwaUtleX1gLFwiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCIsXCJQcmlzbWEtRW5naW5lLUhhc2hcIjp0aGlzLmVuZ2luZUhhc2gsXCJQcmlzbWEtRW5naW5lLVZlcnNpb25cIjpnbC5lbmdpbmVzVmVyc2lvbn07dGhpcy50cmFjaW5nSGVscGVyLmlzRW5hYmxlZCgpJiYobi50cmFjZXBhcmVudD1yPz90aGlzLnRyYWNpbmdIZWxwZXIuZ2V0VHJhY2VQYXJlbnQoKSksdCYmKG5bXCJYLVRyYW5zYWN0aW9uLUlkXCJdPXQpO2xldCBpPXRoaXMuI2UoKTtyZXR1cm4gaS5sZW5ndGg+MCYmKG5bXCJYLUNhcHR1cmUtVGVsZW1ldHJ5XCJdPWkuam9pbihcIiwgXCIpKSxufSNlKCl7bGV0IHI9W107cmV0dXJuIHRoaXMudHJhY2luZ0hlbHBlci5pc0VuYWJsZWQoKSYmci5wdXNoKFwidHJhY2luZ1wiKSx0aGlzLmxvZ0xldmVsJiZyLnB1c2godGhpcy5sb2dMZXZlbCksdGhpcy5sb2dRdWVyaWVzJiZyLnB1c2goXCJxdWVyeVwiKSxyfX07ZnVuY3Rpb24gcmYoZSl7cmV0dXJuIGVbMF0qMWUzK2VbMV0vMWU2fWZ1bmN0aW9uIHNvKGUpe3JldHVybiBuZXcgRGF0ZShyZihlKSl9dmFyIGpyPWNsYXNzIGV4dGVuZHMgb2V7bmFtZT1cIkZvcmNlZFJldHJ5RXJyb3JcIjtjb2RlPVwiUDUwMDFcIjtjb25zdHJ1Y3RvcihyKXtzdXBlcihcIlRoaXMgcmVxdWVzdCBtdXN0IGJlIHJldHJpZWRcIixBKHIsITApKX19O3goanIsXCJGb3JjZWRSZXRyeUVycm9yXCIpO3ZhciB1cj1jbGFzcyBleHRlbmRzIG9le25hbWU9XCJOb3RJbXBsZW1lbnRlZFlldEVycm9yXCI7Y29kZT1cIlA1MDA0XCI7Y29uc3RydWN0b3Iocix0KXtzdXBlcihyLEEodCwhMSkpfX07eCh1cixcIk5vdEltcGxlbWVudGVkWWV0RXJyb3JcIik7dmFyIEY9Y2xhc3MgZXh0ZW5kcyBvZXtyZXNwb25zZTtjb25zdHJ1Y3RvcihyLHQpe3N1cGVyKHIsdCksdGhpcy5yZXNwb25zZT10LnJlc3BvbnNlO2xldCBuPXRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJwcmlzbWEtcmVxdWVzdC1pZFwiKTtpZihuKXtsZXQgaT1gKFRoZSByZXF1ZXN0IGlkIHdhczogJHtufSlgO3RoaXMubWVzc2FnZT10aGlzLm1lc3NhZ2UrXCIgXCIraX19fTt2YXIgY3I9Y2xhc3MgZXh0ZW5kcyBGe25hbWU9XCJTY2hlbWFNaXNzaW5nRXJyb3JcIjtjb2RlPVwiUDUwMDVcIjtjb25zdHJ1Y3RvcihyKXtzdXBlcihcIlNjaGVtYSBuZWVkcyB0byBiZSB1cGxvYWRlZFwiLEEociwhMCkpfX07eChjcixcIlNjaGVtYU1pc3NpbmdFcnJvclwiKTt2YXIgYW89XCJUaGlzIHJlcXVlc3QgY291bGQgbm90IGJlIHVuZGVyc3Rvb2QgYnkgdGhlIHNlcnZlclwiLFB0PWNsYXNzIGV4dGVuZHMgRntuYW1lPVwiQmFkUmVxdWVzdEVycm9yXCI7Y29kZT1cIlA1MDAwXCI7Y29uc3RydWN0b3Iocix0LG4pe3N1cGVyKHR8fGFvLEEociwhMSkpLG4mJih0aGlzLmNvZGU9bil9fTt4KFB0LFwiQmFkUmVxdWVzdEVycm9yXCIpO3ZhciBUdD1jbGFzcyBleHRlbmRzIEZ7bmFtZT1cIkhlYWx0aGNoZWNrVGltZW91dEVycm9yXCI7Y29kZT1cIlA1MDEzXCI7bG9ncztjb25zdHJ1Y3RvcihyLHQpe3N1cGVyKFwiRW5naW5lIG5vdCBzdGFydGVkOiBoZWFsdGhjaGVjayB0aW1lb3V0XCIsQShyLCEwKSksdGhpcy5sb2dzPXR9fTt4KFR0LFwiSGVhbHRoY2hlY2tUaW1lb3V0RXJyb3JcIik7dmFyIFN0PWNsYXNzIGV4dGVuZHMgRntuYW1lPVwiRW5naW5lU3RhcnR1cEVycm9yXCI7Y29kZT1cIlA1MDE0XCI7bG9ncztjb25zdHJ1Y3RvcihyLHQsbil7c3VwZXIodCxBKHIsITApKSx0aGlzLmxvZ3M9bn19O3goU3QsXCJFbmdpbmVTdGFydHVwRXJyb3JcIik7dmFyIFJ0PWNsYXNzIGV4dGVuZHMgRntuYW1lPVwiRW5naW5lVmVyc2lvbk5vdFN1cHBvcnRlZEVycm9yXCI7Y29kZT1cIlA1MDEyXCI7Y29uc3RydWN0b3Iocil7c3VwZXIoXCJFbmdpbmUgdmVyc2lvbiBpcyBub3Qgc3VwcG9ydGVkXCIsQShyLCExKSl9fTt4KFJ0LFwiRW5naW5lVmVyc2lvbk5vdFN1cHBvcnRlZEVycm9yXCIpO3ZhciBsbz1cIlJlcXVlc3QgdGltZWQgb3V0XCIsQXQ9Y2xhc3MgZXh0ZW5kcyBGe25hbWU9XCJHYXRld2F5VGltZW91dEVycm9yXCI7Y29kZT1cIlA1MDA5XCI7Y29uc3RydWN0b3Iocix0PWxvKXtzdXBlcih0LEEociwhMSkpfX07eChBdCxcIkdhdGV3YXlUaW1lb3V0RXJyb3JcIik7dmFyIHRmPVwiSW50ZXJhY3RpdmUgdHJhbnNhY3Rpb24gZXJyb3JcIixDdD1jbGFzcyBleHRlbmRzIEZ7bmFtZT1cIkludGVyYWN0aXZlVHJhbnNhY3Rpb25FcnJvclwiO2NvZGU9XCJQNTAxNVwiO2NvbnN0cnVjdG9yKHIsdD10Zil7c3VwZXIodCxBKHIsITEpKX19O3goQ3QsXCJJbnRlcmFjdGl2ZVRyYW5zYWN0aW9uRXJyb3JcIik7dmFyIG5mPVwiUmVxdWVzdCBwYXJhbWV0ZXJzIGFyZSBpbnZhbGlkXCIsSXQ9Y2xhc3MgZXh0ZW5kcyBGe25hbWU9XCJJbnZhbGlkUmVxdWVzdEVycm9yXCI7Y29kZT1cIlA1MDExXCI7Y29uc3RydWN0b3Iocix0PW5mKXtzdXBlcih0LEEociwhMSkpfX07eChJdCxcIkludmFsaWRSZXF1ZXN0RXJyb3JcIik7dmFyIHVvPVwiUmVxdWVzdGVkIHJlc291cmNlIGRvZXMgbm90IGV4aXN0XCIsa3Q9Y2xhc3MgZXh0ZW5kcyBGe25hbWU9XCJOb3RGb3VuZEVycm9yXCI7Y29kZT1cIlA1MDAzXCI7Y29uc3RydWN0b3Iocix0PXVvKXtzdXBlcih0LEEociwhMSkpfX07eChrdCxcIk5vdEZvdW5kRXJyb3JcIik7dmFyIGNvPVwiVW5rbm93biBzZXJ2ZXIgZXJyb3JcIixWcj1jbGFzcyBleHRlbmRzIEZ7bmFtZT1cIlNlcnZlckVycm9yXCI7Y29kZT1cIlA1MDA2XCI7bG9ncztjb25zdHJ1Y3RvcihyLHQsbil7c3VwZXIodHx8Y28sQShyLCEwKSksdGhpcy5sb2dzPW59fTt4KFZyLFwiU2VydmVyRXJyb3JcIik7dmFyIHBvPVwiVW5hdXRob3JpemVkLCBjaGVjayB5b3VyIGNvbm5lY3Rpb24gc3RyaW5nXCIsRHQ9Y2xhc3MgZXh0ZW5kcyBGe25hbWU9XCJVbmF1dGhvcml6ZWRFcnJvclwiO2NvZGU9XCJQNTAwN1wiO2NvbnN0cnVjdG9yKHIsdD1wbyl7c3VwZXIodCxBKHIsITEpKX19O3goRHQsXCJVbmF1dGhvcml6ZWRFcnJvclwiKTt2YXIgbW89XCJVc2FnZSBleGNlZWRlZCwgcmV0cnkgYWdhaW4gbGF0ZXJcIixPdD1jbGFzcyBleHRlbmRzIEZ7bmFtZT1cIlVzYWdlRXhjZWVkZWRFcnJvclwiO2NvZGU9XCJQNTAwOFwiO2NvbnN0cnVjdG9yKHIsdD1tbyl7c3VwZXIodCxBKHIsITApKX19O3goT3QsXCJVc2FnZUV4Y2VlZGVkRXJyb3JcIik7YXN5bmMgZnVuY3Rpb24gb2YoZSl7bGV0IHI7dHJ5e3I9YXdhaXQgZS50ZXh0KCl9Y2F0Y2h7cmV0dXJue3R5cGU6XCJFbXB0eUVycm9yXCJ9fXRyeXtsZXQgdD1KU09OLnBhcnNlKHIpO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXN3aXRjaCh0KXtjYXNlXCJJbnRlcm5hbERhdGFQcm94eUVycm9yXCI6cmV0dXJue3R5cGU6XCJEYXRhUHJveHlFcnJvclwiLGJvZHk6dH07ZGVmYXVsdDpyZXR1cm57dHlwZTpcIlVua25vd25UZXh0RXJyb3JcIixib2R5OnR9fWlmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZ0IT09bnVsbCl7aWYoXCJpc19wYW5pY1wiaW4gdCYmXCJtZXNzYWdlXCJpbiB0JiZcImVycm9yX2NvZGVcImluIHQpcmV0dXJue3R5cGU6XCJRdWVyeUVuZ2luZUVycm9yXCIsYm9keTp0fTtpZihcIkVuZ2luZU5vdFN0YXJ0ZWRcImluIHR8fFwiSW50ZXJhY3RpdmVUcmFuc2FjdGlvbk1pc3JvdXRlZFwiaW4gdHx8XCJJbnZhbGlkUmVxdWVzdEVycm9yXCJpbiB0KXtsZXQgbj1PYmplY3QudmFsdWVzKHQpWzBdLnJlYXNvbjtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCImJiFbXCJTY2hlbWFNaXNzaW5nXCIsXCJFbmdpbmVWZXJzaW9uTm90U3VwcG9ydGVkXCJdLmluY2x1ZGVzKG4pP3t0eXBlOlwiVW5rbm93bkpzb25FcnJvclwiLGJvZHk6dH06e3R5cGU6XCJEYXRhUHJveHlFcnJvclwiLGJvZHk6dH19fXJldHVybnt0eXBlOlwiVW5rbm93bkpzb25FcnJvclwiLGJvZHk6dH19Y2F0Y2h7cmV0dXJuIHI9PT1cIlwiP3t0eXBlOlwiRW1wdHlFcnJvclwifTp7dHlwZTpcIlVua25vd25UZXh0RXJyb3JcIixib2R5OnJ9fX1hc3luYyBmdW5jdGlvbiBfdChlLHIpe2lmKGUub2spcmV0dXJuO2xldCB0PXtjbGllbnRWZXJzaW9uOnIscmVzcG9uc2U6ZX0sbj1hd2FpdCBvZihlKTtpZihuLnR5cGU9PT1cIlF1ZXJ5RW5naW5lRXJyb3JcIil0aHJvdyBuZXcgWihuLmJvZHkubWVzc2FnZSx7Y29kZTpuLmJvZHkuZXJyb3JfY29kZSxjbGllbnRWZXJzaW9uOnJ9KTtpZihuLnR5cGU9PT1cIkRhdGFQcm94eUVycm9yXCIpe2lmKG4uYm9keT09PVwiSW50ZXJuYWxEYXRhUHJveHlFcnJvclwiKXRocm93IG5ldyBWcih0LFwiSW50ZXJuYWwgRGF0YSBQcm94eSBlcnJvclwiKTtpZihcIkVuZ2luZU5vdFN0YXJ0ZWRcImluIG4uYm9keSl7aWYobi5ib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uPT09XCJTY2hlbWFNaXNzaW5nXCIpcmV0dXJuIG5ldyBjcih0KTtpZihuLmJvZHkuRW5naW5lTm90U3RhcnRlZC5yZWFzb249PT1cIkVuZ2luZVZlcnNpb25Ob3RTdXBwb3J0ZWRcIil0aHJvdyBuZXcgUnQodCk7aWYoXCJFbmdpbmVTdGFydHVwRXJyb3JcImluIG4uYm9keS5FbmdpbmVOb3RTdGFydGVkLnJlYXNvbil7bGV0e21zZzppLGxvZ3M6b309bi5ib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uLkVuZ2luZVN0YXJ0dXBFcnJvcjt0aHJvdyBuZXcgU3QodCxpLG8pfWlmKFwiS25vd25FbmdpbmVTdGFydHVwRXJyb3JcImluIG4uYm9keS5FbmdpbmVOb3RTdGFydGVkLnJlYXNvbil7bGV0e21zZzppLGVycm9yX2NvZGU6b309bi5ib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uLktub3duRW5naW5lU3RhcnR1cEVycm9yO3Rocm93IG5ldyBUKGkscixvKX1pZihcIkhlYWx0aGNoZWNrVGltZW91dFwiaW4gbi5ib2R5LkVuZ2luZU5vdFN0YXJ0ZWQucmVhc29uKXtsZXR7bG9nczppfT1uLmJvZHkuRW5naW5lTm90U3RhcnRlZC5yZWFzb24uSGVhbHRoY2hlY2tUaW1lb3V0O3Rocm93IG5ldyBUdCh0LGkpfX1pZihcIkludGVyYWN0aXZlVHJhbnNhY3Rpb25NaXNyb3V0ZWRcImluIG4uYm9keSl7bGV0IGk9e0lEUGFyc2VFcnJvcjpcIkNvdWxkIG5vdCBwYXJzZSBpbnRlcmFjdGl2ZSB0cmFuc2FjdGlvbiBJRFwiLE5vUXVlcnlFbmdpbmVGb3VuZEVycm9yOlwiQ291bGQgbm90IGZpbmQgUXVlcnkgRW5naW5lIGZvciB0aGUgc3BlY2lmaWVkIGhvc3QgYW5kIHRyYW5zYWN0aW9uIElEXCIsVHJhbnNhY3Rpb25TdGFydEVycm9yOlwiQ291bGQgbm90IHN0YXJ0IGludGVyYWN0aXZlIHRyYW5zYWN0aW9uXCJ9O3Rocm93IG5ldyBDdCh0LGlbbi5ib2R5LkludGVyYWN0aXZlVHJhbnNhY3Rpb25NaXNyb3V0ZWQucmVhc29uXSl9aWYoXCJJbnZhbGlkUmVxdWVzdEVycm9yXCJpbiBuLmJvZHkpdGhyb3cgbmV3IEl0KHQsbi5ib2R5LkludmFsaWRSZXF1ZXN0RXJyb3IucmVhc29uKX1pZihlLnN0YXR1cz09PTQwMXx8ZS5zdGF0dXM9PT00MDMpdGhyb3cgbmV3IER0KHQsQnIocG8sbikpO2lmKGUuc3RhdHVzPT09NDA0KXJldHVybiBuZXcga3QodCxCcih1byxuKSk7aWYoZS5zdGF0dXM9PT00MjkpdGhyb3cgbmV3IE90KHQsQnIobW8sbikpO2lmKGUuc3RhdHVzPT09NTA0KXRocm93IG5ldyBBdCh0LEJyKGxvLG4pKTtpZihlLnN0YXR1cz49NTAwKXRocm93IG5ldyBWcih0LEJyKGNvLG4pKTtpZihlLnN0YXR1cz49NDAwKXRocm93IG5ldyBQdCh0LEJyKGFvLG4pKX1mdW5jdGlvbiBCcihlLHIpe3JldHVybiByLnR5cGU9PT1cIkVtcHR5RXJyb3JcIj9lOmAke2V9OiAke0pTT04uc3RyaW5naWZ5KHIpfWB9ZnVuY3Rpb24gaGwoZSl7bGV0IHI9TWF0aC5wb3coMixlKSo1MCx0PU1hdGguY2VpbChNYXRoLnJhbmRvbSgpKnIpLU1hdGguY2VpbChyLzIpLG49cit0O3JldHVybiBuZXcgUHJvbWlzZShpPT5zZXRUaW1lb3V0KCgpPT5pKG4pLG4pKX12YXIgJGU9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7ZnVuY3Rpb24geWwoZSl7bGV0IHI9bmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGUpLHQ9XCJcIixuPXIuYnl0ZUxlbmd0aCxpPW4lMyxvPW4taSxzLGEsbCx1LGM7Zm9yKGxldCBwPTA7cDxvO3A9cCszKWM9cltwXTw8MTZ8cltwKzFdPDw4fHJbcCsyXSxzPShjJjE2NTE1MDcyKT4+MTgsYT0oYyYyNTgwNDgpPj4xMixsPShjJjQwMzIpPj42LHU9YyY2Myx0Kz0kZVtzXSskZVthXSskZVtsXSskZVt1XTtyZXR1cm4gaT09MT8oYz1yW29dLHM9KGMmMjUyKT4+MixhPShjJjMpPDw0LHQrPSRlW3NdKyRlW2FdK1wiPT1cIik6aT09MiYmKGM9cltvXTw8OHxyW28rMV0scz0oYyY2NDUxMik+PjEwLGE9KGMmMTAwOCk+PjQsbD0oYyYxNSk8PDIsdCs9JGVbc10rJGVbYV0rJGVbbF0rXCI9XCIpLHR9ZnVuY3Rpb24gYmwoZSl7aWYoISFlLmdlbmVyYXRvcj8ucHJldmlld0ZlYXR1cmVzLnNvbWUodD0+dC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwibWV0cmljc1wiKSkpdGhyb3cgbmV3IFQoXCJUaGUgYG1ldHJpY3NgIHByZXZpZXcgZmVhdHVyZSBpcyBub3QgeWV0IGF2YWlsYWJsZSB3aXRoIEFjY2VsZXJhdGUuXFxuUGxlYXNlIHJlbW92ZSBgbWV0cmljc2AgZnJvbSB0aGUgYHByZXZpZXdGZWF0dXJlc2AgaW4geW91ciBzY2hlbWEuXFxuXFxuTW9yZSBpbmZvcm1hdGlvbiBhYm91dCBBY2NlbGVyYXRlOiBodHRwczovL3ByaXMubHkvZC9hY2NlbGVyYXRlXCIsZS5jbGllbnRWZXJzaW9uKX12YXIgRWw9e1wiQHByaXNtYS9kZWJ1Z1wiOlwid29ya3NwYWNlOipcIixcIkBwcmlzbWEvZW5naW5lcy12ZXJzaW9uXCI6XCI2LjEzLjAtMzUuMzYxZTg2ZDBlYTQ5ODdlOWY1M2E1NjUzMDliM2VlZDc5N2E2YmNiZFwiLFwiQHByaXNtYS9mZXRjaC1lbmdpbmVcIjpcIndvcmtzcGFjZToqXCIsXCJAcHJpc21hL2dldC1wbGF0Zm9ybVwiOlwid29ya3NwYWNlOipcIn07dmFyIE50PWNsYXNzIGV4dGVuZHMgb2V7bmFtZT1cIlJlcXVlc3RFcnJvclwiO2NvZGU9XCJQNTAxMFwiO2NvbnN0cnVjdG9yKHIsdCl7c3VwZXIoYENhbm5vdCBmZXRjaCBkYXRhIGZyb20gc2VydmljZTpcbiR7cn1gLEEodCwhMCkpfX07eChOdCxcIlJlcXVlc3RFcnJvclwiKTthc3luYyBmdW5jdGlvbiBwcihlLHIsdD1uPT5uKXtsZXR7Y2xpZW50VmVyc2lvbjpuLC4uLml9PXIsbz10KGZldGNoKTt0cnl7cmV0dXJuIGF3YWl0IG8oZSxpKX1jYXRjaChzKXtsZXQgYT1zLm1lc3NhZ2U/P1wiVW5rbm93biBlcnJvclwiO3Rocm93IG5ldyBOdChhLHtjbGllbnRWZXJzaW9uOm4sY2F1c2U6c30pfX12YXIgYWY9L15bMS05XVswLTldKlxcLlswLTldK1xcLlswLTldKyQvLHdsPUwoXCJwcmlzbWE6Y2xpZW50OmRhdGFwcm94eUVuZ2luZVwiKTthc3luYyBmdW5jdGlvbiBsZihlLHIpe2xldCB0PUVsW1wiQHByaXNtYS9lbmdpbmVzLXZlcnNpb25cIl0sbj1yLmNsaWVudFZlcnNpb24/P1widW5rbm93blwiO2lmKHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfREFUQV9QUk9YWV9DTElFTlRfVkVSU0lPTnx8Z2xvYmFsVGhpcy5QUklTTUFfQ0xJRU5UX0RBVEFfUFJPWFlfQ0xJRU5UX1ZFUlNJT04pcmV0dXJuIHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfREFUQV9QUk9YWV9DTElFTlRfVkVSU0lPTnx8Z2xvYmFsVGhpcy5QUklTTUFfQ0xJRU5UX0RBVEFfUFJPWFlfQ0xJRU5UX1ZFUlNJT047aWYoZS5pbmNsdWRlcyhcImFjY2VsZXJhdGVcIikmJm4hPT1cIjAuMC4wXCImJm4hPT1cImluLW1lbW9yeVwiKXJldHVybiBuO2xldFtpLG9dPW4/LnNwbGl0KFwiLVwiKT8/W107aWYobz09PXZvaWQgMCYmYWYudGVzdChpKSlyZXR1cm4gaTtpZihvIT09dm9pZCAwfHxuPT09XCIwLjAuMFwifHxuPT09XCJpbi1tZW1vcnlcIil7bGV0W3NdPXQuc3BsaXQoXCItXCIpPz9bXSxbYSxsLHVdPXMuc3BsaXQoXCIuXCIpLGM9dWYoYDw9JHthfS4ke2x9LiR7dX1gKSxwPWF3YWl0IHByKGMse2NsaWVudFZlcnNpb246bn0pO2lmKCFwLm9rKXRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIHN0YWJsZSBQcmlzbWEgdmVyc2lvbiwgdW5wa2cuY29tIHN0YXR1cyAke3Auc3RhdHVzfSAke3Auc3RhdHVzVGV4dH0sIHJlc3BvbnNlIGJvZHk6ICR7YXdhaXQgcC50ZXh0KCl8fFwiPGVtcHR5IGJvZHk+XCJ9YCk7bGV0IGQ9YXdhaXQgcC50ZXh0KCk7d2woXCJsZW5ndGggb2YgYm9keSBmZXRjaGVkIGZyb20gdW5wa2cuY29tXCIsZC5sZW5ndGgpO2xldCBmO3RyeXtmPUpTT04ucGFyc2UoZCl9Y2F0Y2goaCl7dGhyb3cgY29uc29sZS5lcnJvcihcIkpTT04ucGFyc2UgZXJyb3I6IGJvZHkgZmV0Y2hlZCBmcm9tIHVucGtnLmNvbTogXCIsZCksaH1yZXR1cm4gZi52ZXJzaW9ufXRocm93IG5ldyB1cihcIk9ubHkgYG1ham9yLm1pbm9yLnBhdGNoYCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkIGJ5IEFjY2VsZXJhdGUuXCIse2NsaWVudFZlcnNpb246bn0pfWFzeW5jIGZ1bmN0aW9uIHhsKGUscil7bGV0IHQ9YXdhaXQgbGYoZSxyKTtyZXR1cm4gd2woXCJ2ZXJzaW9uXCIsdCksdH1mdW5jdGlvbiB1ZihlKXtyZXR1cm4gZW5jb2RlVVJJKGBodHRwczovL3VucGtnLmNvbS9wcmlzbWFAJHtlfS9wYWNrYWdlLmpzb25gKX12YXIgdmw9MyxMdD1MKFwicHJpc21hOmNsaWVudDpkYXRhcHJveHlFbmdpbmVcIiksRnQ9Y2xhc3N7bmFtZT1cIkRhdGFQcm94eUVuZ2luZVwiO2lubGluZVNjaGVtYTtpbmxpbmVTY2hlbWFIYXNoO2lubGluZURhdGFzb3VyY2VzO2NvbmZpZztsb2dFbWl0dGVyO2VudjtjbGllbnRWZXJzaW9uO2VuZ2luZUhhc2g7dHJhY2luZ0hlbHBlcjtyZW1vdGVDbGllbnRWZXJzaW9uO2hvc3Q7aGVhZGVyQnVpbGRlcjtzdGFydFByb21pc2U7cHJvdG9jb2w7Y29uc3RydWN0b3Iocil7YmwociksdGhpcy5jb25maWc9cix0aGlzLmVudj1yLmVudix0aGlzLmlubGluZVNjaGVtYT15bChyLmlubGluZVNjaGVtYSksdGhpcy5pbmxpbmVEYXRhc291cmNlcz1yLmlubGluZURhdGFzb3VyY2VzLHRoaXMuaW5saW5lU2NoZW1hSGFzaD1yLmlubGluZVNjaGVtYUhhc2gsdGhpcy5jbGllbnRWZXJzaW9uPXIuY2xpZW50VmVyc2lvbix0aGlzLmVuZ2luZUhhc2g9ci5lbmdpbmVWZXJzaW9uLHRoaXMubG9nRW1pdHRlcj1yLmxvZ0VtaXR0ZXIsdGhpcy50cmFjaW5nSGVscGVyPXIudHJhY2luZ0hlbHBlcn1hcGlLZXkoKXtyZXR1cm4gdGhpcy5oZWFkZXJCdWlsZGVyLmFwaUtleX12ZXJzaW9uKCl7cmV0dXJuIHRoaXMuZW5naW5lSGFzaH1hc3luYyBzdGFydCgpe3RoaXMuc3RhcnRQcm9taXNlIT09dm9pZCAwJiZhd2FpdCB0aGlzLnN0YXJ0UHJvbWlzZSx0aGlzLnN0YXJ0UHJvbWlzZT0oYXN5bmMoKT0+e2xldHthcGlLZXk6cix1cmw6dH09dGhpcy5nZXRVUkxBbmRBUElLZXkoKTt0aGlzLmhvc3Q9dC5ob3N0LHRoaXMucHJvdG9jb2w9dC5wcm90b2NvbCx0aGlzLmhlYWRlckJ1aWxkZXI9bmV3IEJuKHthcGlLZXk6cix0cmFjaW5nSGVscGVyOnRoaXMudHJhY2luZ0hlbHBlcixsb2dMZXZlbDp0aGlzLmNvbmZpZy5sb2dMZXZlbD8/XCJlcnJvclwiLGxvZ1F1ZXJpZXM6dGhpcy5jb25maWcubG9nUXVlcmllcyxlbmdpbmVIYXNoOnRoaXMuZW5naW5lSGFzaH0pLHRoaXMucmVtb3RlQ2xpZW50VmVyc2lvbj1hd2FpdCB4bCh0aGlzLmhvc3QsdGhpcy5jb25maWcpLEx0KFwiaG9zdFwiLHRoaXMuaG9zdCksTHQoXCJwcm90b2NvbFwiLHRoaXMucHJvdG9jb2wpfSkoKSxhd2FpdCB0aGlzLnN0YXJ0UHJvbWlzZX1hc3luYyBzdG9wKCl7fXByb3BhZ2F0ZVJlc3BvbnNlRXh0ZW5zaW9ucyhyKXtyPy5sb2dzPy5sZW5ndGgmJnIubG9ncy5mb3JFYWNoKHQ9Pntzd2l0Y2godC5sZXZlbCl7Y2FzZVwiZGVidWdcIjpjYXNlXCJ0cmFjZVwiOkx0KHQpO2JyZWFrO2Nhc2VcImVycm9yXCI6Y2FzZVwid2FyblwiOmNhc2VcImluZm9cIjp7dGhpcy5sb2dFbWl0dGVyLmVtaXQodC5sZXZlbCx7dGltZXN0YW1wOnNvKHQudGltZXN0YW1wKSxtZXNzYWdlOnQuYXR0cmlidXRlcy5tZXNzYWdlPz9cIlwiLHRhcmdldDp0LnRhcmdldH0pO2JyZWFrfWNhc2VcInF1ZXJ5XCI6e3RoaXMubG9nRW1pdHRlci5lbWl0KFwicXVlcnlcIix7cXVlcnk6dC5hdHRyaWJ1dGVzLnF1ZXJ5Pz9cIlwiLHRpbWVzdGFtcDpzbyh0LnRpbWVzdGFtcCksZHVyYXRpb246dC5hdHRyaWJ1dGVzLmR1cmF0aW9uX21zPz8wLHBhcmFtczp0LmF0dHJpYnV0ZXMucGFyYW1zPz9cIlwiLHRhcmdldDp0LnRhcmdldH0pO2JyZWFrfWRlZmF1bHQ6dC5sZXZlbH19KSxyPy50cmFjZXM/Lmxlbmd0aCYmdGhpcy50cmFjaW5nSGVscGVyLmRpc3BhdGNoRW5naW5lU3BhbnMoci50cmFjZXMpfW9uQmVmb3JlRXhpdCgpe3Rocm93IG5ldyBFcnJvcignXCJiZWZvcmVFeGl0XCIgaG9vayBpcyBub3QgYXBwbGljYWJsZSB0byB0aGUgcmVtb3RlIHF1ZXJ5IGVuZ2luZScpfWFzeW5jIHVybChyKXtyZXR1cm4gYXdhaXQgdGhpcy5zdGFydCgpLGAke3RoaXMucHJvdG9jb2x9Ly8ke3RoaXMuaG9zdH0vJHt0aGlzLnJlbW90ZUNsaWVudFZlcnNpb259LyR7dGhpcy5pbmxpbmVTY2hlbWFIYXNofS8ke3J9YH1hc3luYyB1cGxvYWRTY2hlbWEoKXtsZXQgcj17bmFtZTpcInNjaGVtYVVwbG9hZFwiLGludGVybmFsOiEwfTtyZXR1cm4gdGhpcy50cmFjaW5nSGVscGVyLnJ1bkluQ2hpbGRTcGFuKHIsYXN5bmMoKT0+e2xldCB0PWF3YWl0IHByKGF3YWl0IHRoaXMudXJsKFwic2NoZW1hXCIpLHttZXRob2Q6XCJQVVRcIixoZWFkZXJzOnRoaXMuaGVhZGVyQnVpbGRlci5idWlsZCgpLGJvZHk6dGhpcy5pbmxpbmVTY2hlbWEsY2xpZW50VmVyc2lvbjp0aGlzLmNsaWVudFZlcnNpb259KTt0Lm9rfHxMdChcInNjaGVtYSByZXNwb25zZSBzdGF0dXNcIix0LnN0YXR1cyk7bGV0IG49YXdhaXQgX3QodCx0aGlzLmNsaWVudFZlcnNpb24pO2lmKG4pdGhyb3cgdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJ3YXJuXCIse21lc3NhZ2U6YEVycm9yIHdoaWxlIHVwbG9hZGluZyBzY2hlbWE6ICR7bi5tZXNzYWdlfWAsdGltZXN0YW1wOm5ldyBEYXRlLHRhcmdldDpcIlwifSksbjt0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcImluZm9cIix7bWVzc2FnZTpgU2NoZW1hIChyZSl1cGxvYWRlZCAoaGFzaDogJHt0aGlzLmlubGluZVNjaGVtYUhhc2h9KWAsdGltZXN0YW1wOm5ldyBEYXRlLHRhcmdldDpcIlwifSl9KX1yZXF1ZXN0KHIse3RyYWNlcGFyZW50OnQsaW50ZXJhY3RpdmVUcmFuc2FjdGlvbjpuLGN1c3RvbURhdGFQcm94eUZldGNoOml9KXtyZXR1cm4gdGhpcy5yZXF1ZXN0SW50ZXJuYWwoe2JvZHk6cix0cmFjZXBhcmVudDp0LGludGVyYWN0aXZlVHJhbnNhY3Rpb246bixjdXN0b21EYXRhUHJveHlGZXRjaDppfSl9YXN5bmMgcmVxdWVzdEJhdGNoKHIse3RyYWNlcGFyZW50OnQsdHJhbnNhY3Rpb246bixjdXN0b21EYXRhUHJveHlGZXRjaDppfSl7bGV0IG89bj8ua2luZD09PVwiaXR4XCI/bi5vcHRpb25zOnZvaWQgMCxzPUZyKHIsbik7cmV0dXJuKGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKHtib2R5OnMsY3VzdG9tRGF0YVByb3h5RmV0Y2g6aSxpbnRlcmFjdGl2ZVRyYW5zYWN0aW9uOm8sdHJhY2VwYXJlbnQ6dH0pKS5tYXAobD0+KGwuZXh0ZW5zaW9ucyYmdGhpcy5wcm9wYWdhdGVSZXNwb25zZUV4dGVuc2lvbnMobC5leHRlbnNpb25zKSxcImVycm9yc1wiaW4gbD90aGlzLmNvbnZlcnRQcm90b2NvbEVycm9yc1RvQ2xpZW50RXJyb3IobC5lcnJvcnMpOmwpKX1yZXF1ZXN0SW50ZXJuYWwoe2JvZHk6cix0cmFjZXBhcmVudDp0LGN1c3RvbURhdGFQcm94eUZldGNoOm4saW50ZXJhY3RpdmVUcmFuc2FjdGlvbjppfSl7cmV0dXJuIHRoaXMud2l0aFJldHJ5KHthY3Rpb25HZXJ1bmQ6XCJxdWVyeWluZ1wiLGNhbGxiYWNrOmFzeW5jKHtsb2dIdHRwQ2FsbDpvfSk9PntsZXQgcz1pP2Ake2kucGF5bG9hZC5lbmRwb2ludH0vZ3JhcGhxbGA6YXdhaXQgdGhpcy51cmwoXCJncmFwaHFsXCIpO28ocyk7bGV0IGE9YXdhaXQgcHIocyx7bWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6dGhpcy5oZWFkZXJCdWlsZGVyLmJ1aWxkKHt0cmFjZXBhcmVudDp0LHRyYW5zYWN0aW9uSWQ6aT8uaWR9KSxib2R5OkpTT04uc3RyaW5naWZ5KHIpLGNsaWVudFZlcnNpb246dGhpcy5jbGllbnRWZXJzaW9ufSxuKTthLm9rfHxMdChcImdyYXBocWwgcmVzcG9uc2Ugc3RhdHVzXCIsYS5zdGF0dXMpLGF3YWl0IHRoaXMuaGFuZGxlRXJyb3IoYXdhaXQgX3QoYSx0aGlzLmNsaWVudFZlcnNpb24pKTtsZXQgbD1hd2FpdCBhLmpzb24oKTtpZihsLmV4dGVuc2lvbnMmJnRoaXMucHJvcGFnYXRlUmVzcG9uc2VFeHRlbnNpb25zKGwuZXh0ZW5zaW9ucyksXCJlcnJvcnNcImluIGwpdGhyb3cgdGhpcy5jb252ZXJ0UHJvdG9jb2xFcnJvcnNUb0NsaWVudEVycm9yKGwuZXJyb3JzKTtyZXR1cm5cImJhdGNoUmVzdWx0XCJpbiBsP2wuYmF0Y2hSZXN1bHQ6bH19KX1hc3luYyB0cmFuc2FjdGlvbihyLHQsbil7bGV0IGk9e3N0YXJ0Olwic3RhcnRpbmdcIixjb21taXQ6XCJjb21taXR0aW5nXCIscm9sbGJhY2s6XCJyb2xsaW5nIGJhY2tcIn07cmV0dXJuIHRoaXMud2l0aFJldHJ5KHthY3Rpb25HZXJ1bmQ6YCR7aVtyXX0gdHJhbnNhY3Rpb25gLGNhbGxiYWNrOmFzeW5jKHtsb2dIdHRwQ2FsbDpvfSk9PntpZihyPT09XCJzdGFydFwiKXtsZXQgcz1KU09OLnN0cmluZ2lmeSh7bWF4X3dhaXQ6bi5tYXhXYWl0LHRpbWVvdXQ6bi50aW1lb3V0LGlzb2xhdGlvbl9sZXZlbDpuLmlzb2xhdGlvbkxldmVsfSksYT1hd2FpdCB0aGlzLnVybChcInRyYW5zYWN0aW9uL3N0YXJ0XCIpO28oYSk7bGV0IGw9YXdhaXQgcHIoYSx7bWV0aG9kOlwiUE9TVFwiLGhlYWRlcnM6dGhpcy5oZWFkZXJCdWlsZGVyLmJ1aWxkKHt0cmFjZXBhcmVudDp0LnRyYWNlcGFyZW50fSksYm9keTpzLGNsaWVudFZlcnNpb246dGhpcy5jbGllbnRWZXJzaW9ufSk7YXdhaXQgdGhpcy5oYW5kbGVFcnJvcihhd2FpdCBfdChsLHRoaXMuY2xpZW50VmVyc2lvbikpO2xldCB1PWF3YWl0IGwuanNvbigpLHtleHRlbnNpb25zOmN9PXU7YyYmdGhpcy5wcm9wYWdhdGVSZXNwb25zZUV4dGVuc2lvbnMoYyk7bGV0IHA9dS5pZCxkPXVbXCJkYXRhLXByb3h5XCJdLmVuZHBvaW50O3JldHVybntpZDpwLHBheWxvYWQ6e2VuZHBvaW50OmR9fX1lbHNle2xldCBzPWAke24ucGF5bG9hZC5lbmRwb2ludH0vJHtyfWA7byhzKTtsZXQgYT1hd2FpdCBwcihzLHttZXRob2Q6XCJQT1NUXCIsaGVhZGVyczp0aGlzLmhlYWRlckJ1aWxkZXIuYnVpbGQoe3RyYWNlcGFyZW50OnQudHJhY2VwYXJlbnR9KSxjbGllbnRWZXJzaW9uOnRoaXMuY2xpZW50VmVyc2lvbn0pO2F3YWl0IHRoaXMuaGFuZGxlRXJyb3IoYXdhaXQgX3QoYSx0aGlzLmNsaWVudFZlcnNpb24pKTtsZXQgbD1hd2FpdCBhLmpzb24oKSx7ZXh0ZW5zaW9uczp1fT1sO3UmJnRoaXMucHJvcGFnYXRlUmVzcG9uc2VFeHRlbnNpb25zKHUpO3JldHVybn19fSl9Z2V0VVJMQW5kQVBJS2V5KCl7cmV0dXJuIGZsKHtjbGllbnRWZXJzaW9uOnRoaXMuY2xpZW50VmVyc2lvbixlbnY6dGhpcy5lbnYsaW5saW5lRGF0YXNvdXJjZXM6dGhpcy5pbmxpbmVEYXRhc291cmNlcyxvdmVycmlkZURhdGFzb3VyY2VzOnRoaXMuY29uZmlnLm92ZXJyaWRlRGF0YXNvdXJjZXN9KX1tZXRyaWNzKCl7dGhyb3cgbmV3IHVyKFwiTWV0cmljcyBhcmUgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEFjY2VsZXJhdGVcIix7Y2xpZW50VmVyc2lvbjp0aGlzLmNsaWVudFZlcnNpb259KX1hc3luYyB3aXRoUmV0cnkocil7Zm9yKGxldCB0PTA7O3QrKyl7bGV0IG49aT0+e3RoaXMubG9nRW1pdHRlci5lbWl0KFwiaW5mb1wiLHttZXNzYWdlOmBDYWxsaW5nICR7aX0gKG49JHt0fSlgLHRpbWVzdGFtcDpuZXcgRGF0ZSx0YXJnZXQ6XCJcIn0pfTt0cnl7cmV0dXJuIGF3YWl0IHIuY2FsbGJhY2soe2xvZ0h0dHBDYWxsOm59KX1jYXRjaChpKXtpZighKGkgaW5zdGFuY2VvZiBvZSl8fCFpLmlzUmV0cnlhYmxlKXRocm93IGk7aWYodD49dmwpdGhyb3cgaSBpbnN0YW5jZW9mIGpyP2kuY2F1c2U6aTt0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcIndhcm5cIix7bWVzc2FnZTpgQXR0ZW1wdCAke3QrMX0vJHt2bH0gZmFpbGVkIGZvciAke3IuYWN0aW9uR2VydW5kfTogJHtpLm1lc3NhZ2U/P1wiKHVua25vd24pXCJ9YCx0aW1lc3RhbXA6bmV3IERhdGUsdGFyZ2V0OlwiXCJ9KTtsZXQgbz1hd2FpdCBobCh0KTt0aGlzLmxvZ0VtaXR0ZXIuZW1pdChcIndhcm5cIix7bWVzc2FnZTpgUmV0cnlpbmcgYWZ0ZXIgJHtvfW1zYCx0aW1lc3RhbXA6bmV3IERhdGUsdGFyZ2V0OlwiXCJ9KX19fWFzeW5jIGhhbmRsZUVycm9yKHIpe2lmKHIgaW5zdGFuY2VvZiBjcil0aHJvdyBhd2FpdCB0aGlzLnVwbG9hZFNjaGVtYSgpLG5ldyBqcih7Y2xpZW50VmVyc2lvbjp0aGlzLmNsaWVudFZlcnNpb24sY2F1c2U6cn0pO2lmKHIpdGhyb3cgcn1jb252ZXJ0UHJvdG9jb2xFcnJvcnNUb0NsaWVudEVycm9yKHIpe3JldHVybiByLmxlbmd0aD09PTE/TXIoclswXSx0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uLHRoaXMuY29uZmlnLmFjdGl2ZVByb3ZpZGVyKTpuZXcgcShKU09OLnN0cmluZ2lmeShyKSx7Y2xpZW50VmVyc2lvbjp0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9ufSl9YXBwbHlQZW5kaW5nTWlncmF0aW9ucygpe3Rocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpfX07ZnVuY3Rpb24gUGwoZSl7aWYoZT8ua2luZD09PVwiaXR4XCIpcmV0dXJuIGUub3B0aW9ucy5pZH1pbXBvcnQgVGwgZnJvbVwibm9kZTpvc1wiO2ltcG9ydCBjZiBmcm9tXCJub2RlOnBhdGhcIjt2YXIgZm89U3ltYm9sKFwiUHJpc21hTGlicmFyeUVuZ2luZUNhY2hlXCIpO2Z1bmN0aW9uIHBmKCl7bGV0IGU9Z2xvYmFsVGhpcztyZXR1cm4gZVtmb109PT12b2lkIDAmJihlW2ZvXT17fSksZVtmb119ZnVuY3Rpb24gZGYoZSl7bGV0IHI9cGYoKTtpZihyW2VdIT09dm9pZCAwKXJldHVybiByW2VdO2xldCB0PWNmLnRvTmFtZXNwYWNlZFBhdGgoZSksbj17ZXhwb3J0czp7fX0saT0wO3JldHVybiBwcm9jZXNzLnBsYXRmb3JtIT09XCJ3aW4zMlwiJiYoaT1UbC5jb25zdGFudHMuZGxvcGVuLlJUTERfTEFaWXxUbC5jb25zdGFudHMuZGxvcGVuLlJUTERfREVFUEJJTkQpLHByb2Nlc3MuZGxvcGVuKG4sdCxpKSxyW2VdPW4uZXhwb3J0cyxuLmV4cG9ydHN9dmFyIFNsPXthc3luYyBsb2FkTGlicmFyeShlKXtsZXQgcj1hd2FpdCBvaSgpLHQ9YXdhaXQgc2woXCJsaWJyYXJ5XCIsZSk7dHJ5e3JldHVybiBlLnRyYWNpbmdIZWxwZXIucnVuSW5DaGlsZFNwYW4oe25hbWU6XCJsb2FkTGlicmFyeVwiLGludGVybmFsOiEwfSwoKT0+ZGYodCkpfWNhdGNoKG4pe2xldCBpPWJpKHtlOm4scGxhdGZvcm1JbmZvOnIsaWQ6dH0pO3Rocm93IG5ldyBUKGksZS5jbGllbnRWZXJzaW9uKX19fTt2YXIgZ28sUmw9e2FzeW5jIGxvYWRMaWJyYXJ5KGUpe2xldHtjbGllbnRWZXJzaW9uOnIsYWRhcHRlcjp0LGVuZ2luZVdhc206bn09ZTtpZih0PT09dm9pZCAwKXRocm93IG5ldyBUKGBUaGUgXFxgYWRhcHRlclxcYCBvcHRpb24gZm9yIFxcYFByaXNtYUNsaWVudFxcYCBpcyByZXF1aXJlZCBpbiB0aGlzIGNvbnRleHQgKCR7aW8oKS5wcmV0dHlOYW1lfSlgLHIpO2lmKG49PT12b2lkIDApdGhyb3cgbmV3IFQoXCJXQVNNIGVuZ2luZSB3YXMgdW5leHBlY3RlZGx5IGB1bmRlZmluZWRgXCIscik7Z289PT12b2lkIDAmJihnbz0oYXN5bmMoKT0+e2xldCBvPWF3YWl0IG4uZ2V0UnVudGltZSgpLHM9YXdhaXQgbi5nZXRRdWVyeUVuZ2luZVdhc21Nb2R1bGUoKTtpZihzPT1udWxsKXRocm93IG5ldyBUKFwiVGhlIGxvYWRlZCB3YXNtIG1vZHVsZSB3YXMgdW5leHBlY3RlZGx5IGB1bmRlZmluZWRgIG9yIGBudWxsYCBvbmNlIGxvYWRlZFwiLHIpO2xldCBhPXtcIi4vcXVlcnlfZW5naW5lX2JnLmpzXCI6b30sbD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UocyxhKSx1PWwuZXhwb3J0cy5fX3diaW5kZ2VuX3N0YXJ0O3JldHVybiBvLl9fd2JnX3NldF93YXNtKGwuZXhwb3J0cyksdSgpLG8uUXVlcnlFbmdpbmV9KSgpKTtsZXQgaT1hd2FpdCBnbztyZXR1cm57ZGVidWdQYW5pYygpe3JldHVybiBQcm9taXNlLnJlamVjdChcInt9XCIpfSxkbW1mKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShcInt9XCIpfSx2ZXJzaW9uKCl7cmV0dXJue2NvbW1pdDpcInVua25vd25cIix2ZXJzaW9uOlwidW5rbm93blwifX0sUXVlcnlFbmdpbmU6aX19fTt2YXIgbWY9XCJQMjAzNlwiLFJlPUwoXCJwcmlzbWE6Y2xpZW50OmxpYnJhcnlFbmdpbmVcIik7ZnVuY3Rpb24gZmYoZSl7cmV0dXJuIGUuaXRlbV90eXBlPT09XCJxdWVyeVwiJiZcInF1ZXJ5XCJpbiBlfWZ1bmN0aW9uIGdmKGUpe3JldHVyblwibGV2ZWxcImluIGU/ZS5sZXZlbD09PVwiZXJyb3JcIiYmZS5tZXNzYWdlPT09XCJQQU5JQ1wiOiExfXZhciBBbD1bLi4uWG4sXCJuYXRpdmVcIl0saGY9MHhmZmZmZmZmZmZmZmZmZmZmbixobz0xbjtmdW5jdGlvbiB5Zigpe2xldCBlPWhvKys7cmV0dXJuIGhvPmhmJiYoaG89MW4pLGV9dmFyIFVyPWNsYXNze25hbWU9XCJMaWJyYXJ5RW5naW5lXCI7ZW5naW5lO2xpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZTtsaWJyYXJ5U3RhcnRpbmdQcm9taXNlO2xpYnJhcnlTdG9wcGluZ1Byb21pc2U7bGlicmFyeVN0YXJ0ZWQ7ZXhlY3V0aW5nUXVlcnlQcm9taXNlO2NvbmZpZztRdWVyeUVuZ2luZUNvbnN0cnVjdG9yO2xpYnJhcnlMb2FkZXI7bGlicmFyeTtsb2dFbWl0dGVyO2xpYlF1ZXJ5RW5naW5lUGF0aDtiaW5hcnlUYXJnZXQ7ZGF0YXNvdXJjZU92ZXJyaWRlcztkYXRhbW9kZWw7bG9nUXVlcmllcztsb2dMZXZlbDtsYXN0UXVlcnk7bG9nZ2VyUnVzdFBhbmljO3RyYWNpbmdIZWxwZXI7YWRhcHRlclByb21pc2U7dmVyc2lvbkluZm87Y29uc3RydWN0b3Iocix0KXt0aGlzLmxpYnJhcnlMb2FkZXI9dD8/U2wsci5lbmdpbmVXYXNtIT09dm9pZCAwJiYodGhpcy5saWJyYXJ5TG9hZGVyPXQ/P1JsKSx0aGlzLmNvbmZpZz1yLHRoaXMubGlicmFyeVN0YXJ0ZWQ9ITEsdGhpcy5sb2dRdWVyaWVzPXIubG9nUXVlcmllcz8/ITEsdGhpcy5sb2dMZXZlbD1yLmxvZ0xldmVsPz9cImVycm9yXCIsdGhpcy5sb2dFbWl0dGVyPXIubG9nRW1pdHRlcix0aGlzLmRhdGFtb2RlbD1yLmlubGluZVNjaGVtYSx0aGlzLnRyYWNpbmdIZWxwZXI9ci50cmFjaW5nSGVscGVyLHIuZW5hYmxlRGVidWdMb2dzJiYodGhpcy5sb2dMZXZlbD1cImRlYnVnXCIpO2xldCBuPU9iamVjdC5rZXlzKHIub3ZlcnJpZGVEYXRhc291cmNlcylbMF0saT1yLm92ZXJyaWRlRGF0YXNvdXJjZXNbbl0/LnVybDtuIT09dm9pZCAwJiZpIT09dm9pZCAwJiYodGhpcy5kYXRhc291cmNlT3ZlcnJpZGVzPXtbbl06aX0pLHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlPXRoaXMuaW5zdGFudGlhdGVMaWJyYXJ5KCl9d3JhcEVuZ2luZShyKXtyZXR1cm57YXBwbHlQZW5kaW5nTWlncmF0aW9uczpyLmFwcGx5UGVuZGluZ01pZ3JhdGlvbnM/LmJpbmQociksY29tbWl0VHJhbnNhY3Rpb246dGhpcy53aXRoUmVxdWVzdElkKHIuY29tbWl0VHJhbnNhY3Rpb24uYmluZChyKSksY29ubmVjdDp0aGlzLndpdGhSZXF1ZXN0SWQoci5jb25uZWN0LmJpbmQocikpLGRpc2Nvbm5lY3Q6dGhpcy53aXRoUmVxdWVzdElkKHIuZGlzY29ubmVjdC5iaW5kKHIpKSxtZXRyaWNzOnIubWV0cmljcz8uYmluZChyKSxxdWVyeTp0aGlzLndpdGhSZXF1ZXN0SWQoci5xdWVyeS5iaW5kKHIpKSxyb2xsYmFja1RyYW5zYWN0aW9uOnRoaXMud2l0aFJlcXVlc3RJZChyLnJvbGxiYWNrVHJhbnNhY3Rpb24uYmluZChyKSksc2RsU2NoZW1hOnIuc2RsU2NoZW1hPy5iaW5kKHIpLHN0YXJ0VHJhbnNhY3Rpb246dGhpcy53aXRoUmVxdWVzdElkKHIuc3RhcnRUcmFuc2FjdGlvbi5iaW5kKHIpKSx0cmFjZTpyLnRyYWNlLmJpbmQociksZnJlZTpyLmZyZWU/LmJpbmQocil9fXdpdGhSZXF1ZXN0SWQocil7cmV0dXJuIGFzeW5jKC4uLnQpPT57bGV0IG49eWYoKS50b1N0cmluZygpO3RyeXtyZXR1cm4gYXdhaXQgciguLi50LG4pfWZpbmFsbHl7aWYodGhpcy50cmFjaW5nSGVscGVyLmlzRW5hYmxlZCgpKXtsZXQgaT1hd2FpdCB0aGlzLmVuZ2luZT8udHJhY2Uobik7aWYoaSl7bGV0IG89SlNPTi5wYXJzZShpKTt0aGlzLnRyYWNpbmdIZWxwZXIuZGlzcGF0Y2hFbmdpbmVTcGFucyhvLnNwYW5zKX19fX19YXN5bmMgYXBwbHlQZW5kaW5nTWlncmF0aW9ucygpe3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIHRoaXMgbWV0aG9kIGZyb20gdGhpcyB0eXBlIG9mIGVuZ2luZSBpbnN0YW5jZVwiKX1hc3luYyB0cmFuc2FjdGlvbihyLHQsbil7YXdhaXQgdGhpcy5zdGFydCgpO2xldCBpPWF3YWl0IHRoaXMuYWRhcHRlclByb21pc2Usbz1KU09OLnN0cmluZ2lmeSh0KSxzO2lmKHI9PT1cInN0YXJ0XCIpe2xldCBsPUpTT04uc3RyaW5naWZ5KHttYXhfd2FpdDpuLm1heFdhaXQsdGltZW91dDpuLnRpbWVvdXQsaXNvbGF0aW9uX2xldmVsOm4uaXNvbGF0aW9uTGV2ZWx9KTtzPWF3YWl0IHRoaXMuZW5naW5lPy5zdGFydFRyYW5zYWN0aW9uKGwsbyl9ZWxzZSByPT09XCJjb21taXRcIj9zPWF3YWl0IHRoaXMuZW5naW5lPy5jb21taXRUcmFuc2FjdGlvbihuLmlkLG8pOnI9PT1cInJvbGxiYWNrXCImJihzPWF3YWl0IHRoaXMuZW5naW5lPy5yb2xsYmFja1RyYW5zYWN0aW9uKG4uaWQsbykpO2xldCBhPXRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShzKTtpZihiZihhKSl7bGV0IGw9dGhpcy5nZXRFeHRlcm5hbEFkYXB0ZXJFcnJvcihhLGk/LmVycm9yUmVnaXN0cnkpO3Rocm93IGw/bC5lcnJvcjpuZXcgWihhLm1lc3NhZ2Use2NvZGU6YS5lcnJvcl9jb2RlLGNsaWVudFZlcnNpb246dGhpcy5jb25maWcuY2xpZW50VmVyc2lvbixtZXRhOmEubWV0YX0pfWVsc2UgaWYodHlwZW9mIGEubWVzc2FnZT09XCJzdHJpbmdcIil0aHJvdyBuZXcgcShhLm1lc3NhZ2Use2NsaWVudFZlcnNpb246dGhpcy5jb25maWcuY2xpZW50VmVyc2lvbn0pO3JldHVybiBhfWFzeW5jIGluc3RhbnRpYXRlTGlicmFyeSgpe2lmKFJlKFwiaW50ZXJuYWxTZXR1cFwiKSx0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZSlyZXR1cm4gdGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2U7Wm4oKSx0aGlzLmJpbmFyeVRhcmdldD1hd2FpdCB0aGlzLmdldEN1cnJlbnRCaW5hcnlUYXJnZXQoKSxhd2FpdCB0aGlzLnRyYWNpbmdIZWxwZXIucnVuSW5DaGlsZFNwYW4oXCJsb2FkX2VuZ2luZVwiLCgpPT50aGlzLmxvYWRFbmdpbmUoKSksdGhpcy52ZXJzaW9uKCl9YXN5bmMgZ2V0Q3VycmVudEJpbmFyeVRhcmdldCgpe3tpZih0aGlzLmJpbmFyeVRhcmdldClyZXR1cm4gdGhpcy5iaW5hcnlUYXJnZXQ7bGV0IHI9YXdhaXQgdGhpcy50cmFjaW5nSGVscGVyLnJ1bkluQ2hpbGRTcGFuKFwiZGV0ZWN0X3BsYXRmb3JtXCIsKCk9Pm5yKCkpO2lmKCFBbC5pbmNsdWRlcyhyKSl0aHJvdyBuZXcgVChgVW5rbm93biAke3VlKFwiUFJJU01BX1FVRVJZX0VOR0lORV9MSUJSQVJZXCIpfSAke3VlKFEocikpfS4gUG9zc2libGUgYmluYXJ5VGFyZ2V0czogJHtxZShBbC5qb2luKFwiLCBcIikpfSBvciBhIHBhdGggdG8gdGhlIHF1ZXJ5IGVuZ2luZSBsaWJyYXJ5LlxuWW91IG1heSBoYXZlIHRvIHJ1biAke3FlKFwicHJpc21hIGdlbmVyYXRlXCIpfSBmb3IgeW91ciBjaGFuZ2VzIHRvIHRha2UgZWZmZWN0LmAsdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7cmV0dXJuIHJ9fXBhcnNlRW5naW5lUmVzcG9uc2Uocil7aWYoIXIpdGhyb3cgbmV3IHEoXCJSZXNwb25zZSBmcm9tIHRoZSBFbmdpbmUgd2FzIGVtcHR5XCIse2NsaWVudFZlcnNpb246dGhpcy5jb25maWcuY2xpZW50VmVyc2lvbn0pO3RyeXtyZXR1cm4gSlNPTi5wYXJzZShyKX1jYXRjaHt0aHJvdyBuZXcgcShcIlVuYWJsZSB0byBKU09OLnBhcnNlIHJlc3BvbnNlIGZyb20gZW5naW5lXCIse2NsaWVudFZlcnNpb246dGhpcy5jb25maWcuY2xpZW50VmVyc2lvbn0pfX1hc3luYyBsb2FkRW5naW5lKCl7aWYoIXRoaXMuZW5naW5lKXt0aGlzLlF1ZXJ5RW5naW5lQ29uc3RydWN0b3J8fCh0aGlzLmxpYnJhcnk9YXdhaXQgdGhpcy5saWJyYXJ5TG9hZGVyLmxvYWRMaWJyYXJ5KHRoaXMuY29uZmlnKSx0aGlzLlF1ZXJ5RW5naW5lQ29uc3RydWN0b3I9dGhpcy5saWJyYXJ5LlF1ZXJ5RW5naW5lKTt0cnl7bGV0IHI9bmV3IFdlYWtSZWYodGhpcyk7dGhpcy5hZGFwdGVyUHJvbWlzZXx8KHRoaXMuYWRhcHRlclByb21pc2U9dGhpcy5jb25maWcuYWRhcHRlcj8uY29ubmVjdCgpPy50aGVuKFl0KSk7bGV0IHQ9YXdhaXQgdGhpcy5hZGFwdGVyUHJvbWlzZTt0JiZSZShcIlVzaW5nIGRyaXZlciBhZGFwdGVyOiAlT1wiLHQpLHRoaXMuZW5naW5lPXRoaXMud3JhcEVuZ2luZShuZXcgdGhpcy5RdWVyeUVuZ2luZUNvbnN0cnVjdG9yKHtkYXRhbW9kZWw6dGhpcy5kYXRhbW9kZWwsZW52OnByb2Nlc3MuZW52LGxvZ1F1ZXJpZXM6dGhpcy5jb25maWcubG9nUXVlcmllcz8/ITEsaWdub3JlRW52VmFyRXJyb3JzOiEwLGRhdGFzb3VyY2VPdmVycmlkZXM6dGhpcy5kYXRhc291cmNlT3ZlcnJpZGVzPz97fSxsb2dMZXZlbDp0aGlzLmxvZ0xldmVsLGNvbmZpZ0Rpcjp0aGlzLmNvbmZpZy5jd2QsZW5naW5lUHJvdG9jb2w6XCJqc29uXCIsZW5hYmxlVHJhY2luZzp0aGlzLnRyYWNpbmdIZWxwZXIuaXNFbmFibGVkKCl9LG49PntyLmRlcmVmKCk/LmxvZ2dlcihuKX0sdCkpfWNhdGNoKHIpe2xldCB0PXIsbj10aGlzLnBhcnNlSW5pdEVycm9yKHQubWVzc2FnZSk7dGhyb3cgdHlwZW9mIG49PVwic3RyaW5nXCI/dDpuZXcgVChuLm1lc3NhZ2UsdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbixuLmVycm9yX2NvZGUpfX19bG9nZ2VyKHIpe2xldCB0PXRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShyKTt0JiYodC5sZXZlbD10Py5sZXZlbC50b0xvd2VyQ2FzZSgpPz9cInVua25vd25cIixmZih0KT90aGlzLmxvZ0VtaXR0ZXIuZW1pdChcInF1ZXJ5XCIse3RpbWVzdGFtcDpuZXcgRGF0ZSxxdWVyeTp0LnF1ZXJ5LHBhcmFtczp0LnBhcmFtcyxkdXJhdGlvbjpOdW1iZXIodC5kdXJhdGlvbl9tcyksdGFyZ2V0OnQubW9kdWxlX3BhdGh9KTpnZih0KT90aGlzLmxvZ2dlclJ1c3RQYW5pYz1uZXcgZGUoeW8odGhpcyxgJHt0Lm1lc3NhZ2V9OiAke3QucmVhc29ufSBpbiAke3QuZmlsZX06JHt0LmxpbmV9OiR7dC5jb2x1bW59YCksdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik6dGhpcy5sb2dFbWl0dGVyLmVtaXQodC5sZXZlbCx7dGltZXN0YW1wOm5ldyBEYXRlLG1lc3NhZ2U6dC5tZXNzYWdlLHRhcmdldDp0Lm1vZHVsZV9wYXRofSkpfXBhcnNlSW5pdEVycm9yKHIpe3RyeXtyZXR1cm4gSlNPTi5wYXJzZShyKX1jYXRjaHt9cmV0dXJuIHJ9cGFyc2VSZXF1ZXN0RXJyb3Iocil7dHJ5e3JldHVybiBKU09OLnBhcnNlKHIpfWNhdGNoe31yZXR1cm4gcn1vbkJlZm9yZUV4aXQoKXt0aHJvdyBuZXcgRXJyb3IoJ1wiYmVmb3JlRXhpdFwiIGhvb2sgaXMgbm90IGFwcGxpY2FibGUgdG8gdGhlIGxpYnJhcnkgZW5naW5lIHNpbmNlIFByaXNtYSA1LjAuMCwgaXQgaXMgb25seSByZWxldmFudCBhbmQgaW1wbGVtZW50ZWQgZm9yIHRoZSBiaW5hcnkgZW5naW5lLiBQbGVhc2UgYWRkIHlvdXIgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGBwcm9jZXNzYCBvYmplY3QgZGlyZWN0bHkgaW5zdGVhZC4nKX1hc3luYyBzdGFydCgpe2lmKHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlfHwodGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2U9dGhpcy5pbnN0YW50aWF0ZUxpYnJhcnkoKSksYXdhaXQgdGhpcy5saWJyYXJ5SW5zdGFudGlhdGlvblByb21pc2UsYXdhaXQgdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlLHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZSlyZXR1cm4gUmUoYGxpYnJhcnkgYWxyZWFkeSBzdGFydGluZywgdGhpcy5saWJyYXJ5U3RhcnRlZDogJHt0aGlzLmxpYnJhcnlTdGFydGVkfWApLHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZTtpZih0aGlzLmxpYnJhcnlTdGFydGVkKXJldHVybjtsZXQgcj1hc3luYygpPT57UmUoXCJsaWJyYXJ5IHN0YXJ0aW5nXCIpO3RyeXtsZXQgdD17dHJhY2VwYXJlbnQ6dGhpcy50cmFjaW5nSGVscGVyLmdldFRyYWNlUGFyZW50KCl9O2F3YWl0IHRoaXMuZW5naW5lPy5jb25uZWN0KEpTT04uc3RyaW5naWZ5KHQpKSx0aGlzLmxpYnJhcnlTdGFydGVkPSEwLHRoaXMuYWRhcHRlclByb21pc2V8fCh0aGlzLmFkYXB0ZXJQcm9taXNlPXRoaXMuY29uZmlnLmFkYXB0ZXI/LmNvbm5lY3QoKT8udGhlbihZdCkpLGF3YWl0IHRoaXMuYWRhcHRlclByb21pc2UsUmUoXCJsaWJyYXJ5IHN0YXJ0ZWRcIil9Y2F0Y2godCl7bGV0IG49dGhpcy5wYXJzZUluaXRFcnJvcih0Lm1lc3NhZ2UpO3Rocm93IHR5cGVvZiBuPT1cInN0cmluZ1wiP3Q6bmV3IFQobi5tZXNzYWdlLHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24sbi5lcnJvcl9jb2RlKX1maW5hbGx5e3RoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZT12b2lkIDB9fTtyZXR1cm4gdGhpcy5saWJyYXJ5U3RhcnRpbmdQcm9taXNlPXRoaXMudHJhY2luZ0hlbHBlci5ydW5JbkNoaWxkU3BhbihcImNvbm5lY3RcIixyKSx0aGlzLmxpYnJhcnlTdGFydGluZ1Byb21pc2V9YXN5bmMgc3RvcCgpe2lmKGF3YWl0IHRoaXMubGlicmFyeUluc3RhbnRpYXRpb25Qcm9taXNlLGF3YWl0IHRoaXMubGlicmFyeVN0YXJ0aW5nUHJvbWlzZSxhd2FpdCB0aGlzLmV4ZWN1dGluZ1F1ZXJ5UHJvbWlzZSx0aGlzLmxpYnJhcnlTdG9wcGluZ1Byb21pc2UpcmV0dXJuIFJlKFwibGlicmFyeSBpcyBhbHJlYWR5IHN0b3BwaW5nXCIpLHRoaXMubGlicmFyeVN0b3BwaW5nUHJvbWlzZTtpZighdGhpcy5saWJyYXJ5U3RhcnRlZCl7YXdhaXQoYXdhaXQgdGhpcy5hZGFwdGVyUHJvbWlzZSk/LmRpc3Bvc2UoKSx0aGlzLmFkYXB0ZXJQcm9taXNlPXZvaWQgMDtyZXR1cm59bGV0IHI9YXN5bmMoKT0+e2F3YWl0IG5ldyBQcm9taXNlKG49PnNldEltbWVkaWF0ZShuKSksUmUoXCJsaWJyYXJ5IHN0b3BwaW5nXCIpO2xldCB0PXt0cmFjZXBhcmVudDp0aGlzLnRyYWNpbmdIZWxwZXIuZ2V0VHJhY2VQYXJlbnQoKX07YXdhaXQgdGhpcy5lbmdpbmU/LmRpc2Nvbm5lY3QoSlNPTi5zdHJpbmdpZnkodCkpLHRoaXMuZW5naW5lPy5mcmVlJiZ0aGlzLmVuZ2luZS5mcmVlKCksdGhpcy5lbmdpbmU9dm9pZCAwLHRoaXMubGlicmFyeVN0YXJ0ZWQ9ITEsdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlPXZvaWQgMCx0aGlzLmxpYnJhcnlJbnN0YW50aWF0aW9uUHJvbWlzZT12b2lkIDAsYXdhaXQoYXdhaXQgdGhpcy5hZGFwdGVyUHJvbWlzZSk/LmRpc3Bvc2UoKSx0aGlzLmFkYXB0ZXJQcm9taXNlPXZvaWQgMCxSZShcImxpYnJhcnkgc3RvcHBlZFwiKX07cmV0dXJuIHRoaXMubGlicmFyeVN0b3BwaW5nUHJvbWlzZT10aGlzLnRyYWNpbmdIZWxwZXIucnVuSW5DaGlsZFNwYW4oXCJkaXNjb25uZWN0XCIsciksdGhpcy5saWJyYXJ5U3RvcHBpbmdQcm9taXNlfXZlcnNpb24oKXtyZXR1cm4gdGhpcy52ZXJzaW9uSW5mbz10aGlzLmxpYnJhcnk/LnZlcnNpb24oKSx0aGlzLnZlcnNpb25JbmZvPy52ZXJzaW9uPz9cInVua25vd25cIn1kZWJ1Z1BhbmljKHIpe3JldHVybiB0aGlzLmxpYnJhcnk/LmRlYnVnUGFuaWMocil9YXN5bmMgcmVxdWVzdChyLHt0cmFjZXBhcmVudDp0LGludGVyYWN0aXZlVHJhbnNhY3Rpb246bn0pe1JlKGBzZW5kaW5nIHJlcXVlc3QsIHRoaXMubGlicmFyeVN0YXJ0ZWQ6ICR7dGhpcy5saWJyYXJ5U3RhcnRlZH1gKTtsZXQgaT1KU09OLnN0cmluZ2lmeSh7dHJhY2VwYXJlbnQ6dH0pLG89SlNPTi5zdHJpbmdpZnkocik7dHJ5e2F3YWl0IHRoaXMuc3RhcnQoKTtsZXQgcz1hd2FpdCB0aGlzLmFkYXB0ZXJQcm9taXNlO3RoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlPXRoaXMuZW5naW5lPy5xdWVyeShvLGksbj8uaWQpLHRoaXMubGFzdFF1ZXJ5PW87bGV0IGE9dGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKGF3YWl0IHRoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlKTtpZihhLmVycm9ycyl0aHJvdyBhLmVycm9ycy5sZW5ndGg9PT0xP3RoaXMuYnVpbGRRdWVyeUVycm9yKGEuZXJyb3JzWzBdLHM/LmVycm9yUmVnaXN0cnkpOm5ldyBxKEpTT04uc3RyaW5naWZ5KGEuZXJyb3JzKSx7Y2xpZW50VmVyc2lvbjp0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9ufSk7aWYodGhpcy5sb2dnZXJSdXN0UGFuaWMpdGhyb3cgdGhpcy5sb2dnZXJSdXN0UGFuaWM7cmV0dXJue2RhdGE6YX19Y2F0Y2gocyl7aWYocyBpbnN0YW5jZW9mIFQpdGhyb3cgcztpZihzLmNvZGU9PT1cIkdlbmVyaWNGYWlsdXJlXCImJnMubWVzc2FnZT8uc3RhcnRzV2l0aChcIlBBTklDOlwiKSl0aHJvdyBuZXcgZGUoeW8odGhpcyxzLm1lc3NhZ2UpLHRoaXMuY29uZmlnLmNsaWVudFZlcnNpb24pO2xldCBhPXRoaXMucGFyc2VSZXF1ZXN0RXJyb3Iocy5tZXNzYWdlKTt0aHJvdyB0eXBlb2YgYT09XCJzdHJpbmdcIj9zOm5ldyBxKGAke2EubWVzc2FnZX1cbiR7YS5iYWNrdHJhY2V9YCx7Y2xpZW50VmVyc2lvbjp0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9ufSl9fWFzeW5jIHJlcXVlc3RCYXRjaChyLHt0cmFuc2FjdGlvbjp0LHRyYWNlcGFyZW50Om59KXtSZShcInJlcXVlc3RCYXRjaFwiKTtsZXQgaT1GcihyLHQpO2F3YWl0IHRoaXMuc3RhcnQoKTtsZXQgbz1hd2FpdCB0aGlzLmFkYXB0ZXJQcm9taXNlO3RoaXMubGFzdFF1ZXJ5PUpTT04uc3RyaW5naWZ5KGkpLHRoaXMuZXhlY3V0aW5nUXVlcnlQcm9taXNlPXRoaXMuZW5naW5lPy5xdWVyeSh0aGlzLmxhc3RRdWVyeSxKU09OLnN0cmluZ2lmeSh7dHJhY2VwYXJlbnQ6bn0pLFBsKHQpKTtsZXQgcz1hd2FpdCB0aGlzLmV4ZWN1dGluZ1F1ZXJ5UHJvbWlzZSxhPXRoaXMucGFyc2VFbmdpbmVSZXNwb25zZShzKTtpZihhLmVycm9ycyl0aHJvdyBhLmVycm9ycy5sZW5ndGg9PT0xP3RoaXMuYnVpbGRRdWVyeUVycm9yKGEuZXJyb3JzWzBdLG8/LmVycm9yUmVnaXN0cnkpOm5ldyBxKEpTT04uc3RyaW5naWZ5KGEuZXJyb3JzKSx7Y2xpZW50VmVyc2lvbjp0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9ufSk7bGV0e2JhdGNoUmVzdWx0OmwsZXJyb3JzOnV9PWE7aWYoQXJyYXkuaXNBcnJheShsKSlyZXR1cm4gbC5tYXAoYz0+Yy5lcnJvcnMmJmMuZXJyb3JzLmxlbmd0aD4wP3RoaXMubG9nZ2VyUnVzdFBhbmljPz90aGlzLmJ1aWxkUXVlcnlFcnJvcihjLmVycm9yc1swXSxvPy5lcnJvclJlZ2lzdHJ5KTp7ZGF0YTpjfSk7dGhyb3cgdSYmdS5sZW5ndGg9PT0xP25ldyBFcnJvcih1WzBdLmVycm9yKTpuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoYSkpfWJ1aWxkUXVlcnlFcnJvcihyLHQpe2lmKHIudXNlcl9mYWNpbmdfZXJyb3IuaXNfcGFuaWMpcmV0dXJuIG5ldyBkZSh5byh0aGlzLHIudXNlcl9mYWNpbmdfZXJyb3IubWVzc2FnZSksdGhpcy5jb25maWcuY2xpZW50VmVyc2lvbik7bGV0IG49dGhpcy5nZXRFeHRlcm5hbEFkYXB0ZXJFcnJvcihyLnVzZXJfZmFjaW5nX2Vycm9yLHQpO3JldHVybiBuP24uZXJyb3I6TXIocix0aGlzLmNvbmZpZy5jbGllbnRWZXJzaW9uLHRoaXMuY29uZmlnLmFjdGl2ZVByb3ZpZGVyKX1nZXRFeHRlcm5hbEFkYXB0ZXJFcnJvcihyLHQpe2lmKHIuZXJyb3JfY29kZT09PW1mJiZ0KXtsZXQgbj1yLm1ldGE/LmlkO3JuKHR5cGVvZiBuPT1cIm51bWJlclwiLFwiTWFsZm9ybWVkIGV4dGVybmFsIEpTIGVycm9yIHJlY2VpdmVkIGZyb20gdGhlIGVuZ2luZVwiKTtsZXQgaT10LmNvbnN1bWVFcnJvcihuKTtyZXR1cm4gcm4oaSxcIkV4dGVybmFsIGVycm9yIHdpdGggcmVwb3J0ZWQgaWQgd2FzIG5vdCByZWdpc3RlcmVkXCIpLGl9fWFzeW5jIG1ldHJpY3Mocil7YXdhaXQgdGhpcy5zdGFydCgpO2xldCB0PWF3YWl0IHRoaXMuZW5naW5lLm1ldHJpY3MoSlNPTi5zdHJpbmdpZnkocikpO3JldHVybiByLmZvcm1hdD09PVwicHJvbWV0aGV1c1wiP3Q6dGhpcy5wYXJzZUVuZ2luZVJlc3BvbnNlKHQpfX07ZnVuY3Rpb24gYmYoZSl7cmV0dXJuIHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCYmZS5lcnJvcl9jb2RlIT09dm9pZCAwfWZ1bmN0aW9uIHlvKGUscil7cmV0dXJuIGRsKHtiaW5hcnlUYXJnZXQ6ZS5iaW5hcnlUYXJnZXQsdGl0bGU6cix2ZXJzaW9uOmUuY29uZmlnLmNsaWVudFZlcnNpb24sZW5naW5lVmVyc2lvbjplLnZlcnNpb25JbmZvPy5jb21taXQsZGF0YWJhc2U6ZS5jb25maWcuYWN0aXZlUHJvdmlkZXIscXVlcnk6ZS5sYXN0UXVlcnl9KX1mdW5jdGlvbiBDbCh7dXJsOmUsYWRhcHRlcjpyLGNvcHlFbmdpbmU6dCx0YXJnZXRCdWlsZFR5cGU6bn0pe2xldCBpPVtdLG89W10scz1nPT57aS5wdXNoKHtfdGFnOlwid2FybmluZ1wiLHZhbHVlOmd9KX0sYT1nPT57bGV0IFM9Zy5qb2luKGBcbmApO28ucHVzaCh7X3RhZzpcImVycm9yXCIsdmFsdWU6U30pfSxsPSEhZT8uc3RhcnRzV2l0aChcInByaXNtYTovL1wiKSx1PWVuKGUpLGM9ISFyLHA9bHx8dTshYyYmdCYmcCYmcyhbXCJyZWNvbW1lbmQtLW5vLWVuZ2luZVwiLFwiSW4gcHJvZHVjdGlvbiwgd2UgcmVjb21tZW5kIHVzaW5nIGBwcmlzbWEgZ2VuZXJhdGUgLS1uby1lbmdpbmVgIChTZWU6IGBwcmlzbWEgZ2VuZXJhdGUgLS1oZWxwYClcIl0pO2xldCBkPXB8fCF0O2MmJihkfHxuPT09XCJlZGdlXCIpJiYobj09PVwiZWRnZVwiP2EoW1wiUHJpc21hIENsaWVudCB3YXMgY29uZmlndXJlZCB0byB1c2UgdGhlIGBhZGFwdGVyYCBvcHRpb24gYnV0IGl0IHdhcyBpbXBvcnRlZCB2aWEgaXRzIGAvZWRnZWAgZW5kcG9pbnQuXCIsXCJQbGVhc2UgZWl0aGVyIHJlbW92ZSB0aGUgYC9lZGdlYCBlbmRwb2ludCBvciByZW1vdmUgdGhlIGBhZGFwdGVyYCBmcm9tIHRoZSBQcmlzbWEgQ2xpZW50IGNvbnN0cnVjdG9yLlwiXSk6dD9sJiZhKFtcIlByaXNtYSBDbGllbnQgd2FzIGNvbmZpZ3VyZWQgdG8gdXNlIHRoZSBgYWRhcHRlcmAgb3B0aW9uIGJ1dCB0aGUgVVJMIHdhcyBhIGBwcmlzbWE6Ly9gIFVSTC5cIixcIlBsZWFzZSBlaXRoZXIgdXNlIHRoZSBgcHJpc21hOi8vYCBVUkwgb3IgcmVtb3ZlIHRoZSBgYWRhcHRlcmAgZnJvbSB0aGUgUHJpc21hIENsaWVudCBjb25zdHJ1Y3Rvci5cIl0pOmEoW1wiUHJpc21hIENsaWVudCB3YXMgY29uZmlndXJlZCB0byB1c2UgdGhlIGBhZGFwdGVyYCBvcHRpb24gYnV0IGBwcmlzbWEgZ2VuZXJhdGVgIHdhcyBydW4gd2l0aCBgLS1uby1lbmdpbmVgLlwiLFwiUGxlYXNlIHJ1biBgcHJpc21hIGdlbmVyYXRlYCB3aXRob3V0IGAtLW5vLWVuZ2luZWAgdG8gYmUgYWJsZSB0byB1c2UgUHJpc21hIENsaWVudCB3aXRoIHRoZSBhZGFwdGVyLlwiXSkpO2xldCBmPXthY2NlbGVyYXRlOmQscHBnOnUsZHJpdmVyQWRhcHRlcnM6Y307ZnVuY3Rpb24gaChnKXtyZXR1cm4gZy5sZW5ndGg+MH1yZXR1cm4gaChvKT97b2s6ITEsZGlhZ25vc3RpY3M6e3dhcm5pbmdzOmksZXJyb3JzOm99LGlzVXNpbmc6Zn06e29rOiEwLGRpYWdub3N0aWNzOnt3YXJuaW5nczppfSxpc1VzaW5nOmZ9fWZ1bmN0aW9uIElsKHtjb3B5RW5naW5lOmU9ITB9LHIpe2xldCB0O3RyeXt0PXFyKHtpbmxpbmVEYXRhc291cmNlczpyLmlubGluZURhdGFzb3VyY2VzLG92ZXJyaWRlRGF0YXNvdXJjZXM6ci5vdmVycmlkZURhdGFzb3VyY2VzLGVudjp7Li4uci5lbnYsLi4ucHJvY2Vzcy5lbnZ9LGNsaWVudFZlcnNpb246ci5jbGllbnRWZXJzaW9ufSl9Y2F0Y2h7fWxldHtvazpuLGlzVXNpbmc6aSxkaWFnbm9zdGljczpvfT1DbCh7dXJsOnQsYWRhcHRlcjpyLmFkYXB0ZXIsY29weUVuZ2luZTplLHRhcmdldEJ1aWxkVHlwZTpcImxpYnJhcnlcIn0pO2ZvcihsZXQgcCBvZiBvLndhcm5pbmdzKW9uKC4uLnAudmFsdWUpO2lmKCFuKXtsZXQgcD1vLmVycm9yc1swXTt0aHJvdyBuZXcgWChwLnZhbHVlLHtjbGllbnRWZXJzaW9uOnIuY2xpZW50VmVyc2lvbn0pfWxldCBzPXdyKHIuZ2VuZXJhdG9yKSxhPXM9PT1cImxpYnJhcnlcIixsPXM9PT1cImJpbmFyeVwiLHU9cz09PVwiY2xpZW50XCIsYz0oaS5hY2NlbGVyYXRlfHxpLnBwZykmJiFpLmRyaXZlckFkYXB0ZXJzO3JldHVybiBpLmFjY2VsZXJhdGU/bmV3IEZ0KHIpOihpLmRyaXZlckFkYXB0ZXJzLGE/bmV3IFVyKHIpOihpLmFjY2VsZXJhdGUsbmV3IFVyKHIpKSl9ZnVuY3Rpb24gVW4oe2dlbmVyYXRvcjplfSl7cmV0dXJuIGU/LnByZXZpZXdGZWF0dXJlcz8/W119dmFyIGtsPWU9Pih7Y29tbWFuZDplfSk7dmFyIERsPWU9PmUuc3RyaW5ncy5yZWR1Y2UoKHIsdCxuKT0+YCR7cn1AUCR7bn0ke3R9YCk7ZnVuY3Rpb24gR3IoZSl7dHJ5e3JldHVybiBPbChlLFwiZmFzdFwiKX1jYXRjaHtyZXR1cm4gT2woZSxcInNsb3dcIil9fWZ1bmN0aW9uIE9sKGUscil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGUubWFwKHQ9Pk5sKHQscikpKX1mdW5jdGlvbiBObChlLHIpe2lmKEFycmF5LmlzQXJyYXkoZSkpcmV0dXJuIGUubWFwKHQ9Pk5sKHQscikpO2lmKHR5cGVvZiBlPT1cImJpZ2ludFwiKXJldHVybntwcmlzbWFfX3R5cGU6XCJiaWdpbnRcIixwcmlzbWFfX3ZhbHVlOmUudG9TdHJpbmcoKX07aWYoVHIoZSkpcmV0dXJue3ByaXNtYV9fdHlwZTpcImRhdGVcIixwcmlzbWFfX3ZhbHVlOmUudG9KU09OKCl9O2lmKEZlLmlzRGVjaW1hbChlKSlyZXR1cm57cHJpc21hX190eXBlOlwiZGVjaW1hbFwiLHByaXNtYV9fdmFsdWU6ZS50b0pTT04oKX07aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXJldHVybntwcmlzbWFfX3R5cGU6XCJieXRlc1wiLHByaXNtYV9fdmFsdWU6ZS50b1N0cmluZyhcImJhc2U2NFwiKX07aWYoRWYoZSkpcmV0dXJue3ByaXNtYV9fdHlwZTpcImJ5dGVzXCIscHJpc21hX192YWx1ZTpCdWZmZXIuZnJvbShlKS50b1N0cmluZyhcImJhc2U2NFwiKX07aWYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpKXtsZXR7YnVmZmVyOnQsYnl0ZU9mZnNldDpuLGJ5dGVMZW5ndGg6aX09ZTtyZXR1cm57cHJpc21hX190eXBlOlwiYnl0ZXNcIixwcmlzbWFfX3ZhbHVlOkJ1ZmZlci5mcm9tKHQsbixpKS50b1N0cmluZyhcImJhc2U2NFwiKX19cmV0dXJuIHR5cGVvZiBlPT1cIm9iamVjdFwiJiZyPT09XCJzbG93XCI/TGwoZSk6ZX1mdW5jdGlvbiBFZihlKXtyZXR1cm4gZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxlIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXI/ITA6dHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsP2VbU3ltYm9sLnRvU3RyaW5nVGFnXT09PVwiQXJyYXlCdWZmZXJcInx8ZVtTeW1ib2wudG9TdHJpbmdUYWddPT09XCJTaGFyZWRBcnJheUJ1ZmZlclwiOiExfWZ1bmN0aW9uIExsKGUpe2lmKHR5cGVvZiBlIT1cIm9iamVjdFwifHxlPT09bnVsbClyZXR1cm4gZTtpZih0eXBlb2YgZS50b0pTT049PVwiZnVuY3Rpb25cIilyZXR1cm4gZS50b0pTT04oKTtpZihBcnJheS5pc0FycmF5KGUpKXJldHVybiBlLm1hcChfbCk7bGV0IHI9e307Zm9yKGxldCB0IG9mIE9iamVjdC5rZXlzKGUpKXJbdF09X2woZVt0XSk7cmV0dXJuIHJ9ZnVuY3Rpb24gX2woZSl7cmV0dXJuIHR5cGVvZiBlPT1cImJpZ2ludFwiP2UudG9TdHJpbmcoKTpMbChlKX12YXIgd2Y9L14oXFxzKmFsdGVyXFxzKS9pLEZsPUwoXCJwcmlzbWE6Y2xpZW50XCIpO2Z1bmN0aW9uIGJvKGUscix0LG4pe2lmKCEoZSE9PVwicG9zdGdyZXNxbFwiJiZlIT09XCJjb2Nrcm9hY2hkYlwiKSYmdC5sZW5ndGg+MCYmd2YuZXhlYyhyKSl0aHJvdyBuZXcgRXJyb3IoYFJ1bm5pbmcgQUxURVIgdXNpbmcgJHtufSBpcyBub3Qgc3VwcG9ydGVkXG5Vc2luZyB0aGUgZXhhbXBsZSBiZWxvdyB5b3UgY2FuIHN0aWxsIGV4ZWN1dGUgeW91ciBxdWVyeSB3aXRoIFByaXNtYSwgYnV0IHBsZWFzZSBub3RlIHRoYXQgaXQgaXMgdnVsbmVyYWJsZSB0byBTUUwgaW5qZWN0aW9uIGF0dGFja3MgYW5kIHJlcXVpcmVzIHlvdSB0byB0YWtlIGNhcmUgb2YgaW5wdXQgc2FuaXRpemF0aW9uLlxuXG5FeGFtcGxlOlxuICBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdVbnNhZmUoXFxgQUxURVIgVVNFUiBwcmlzbWEgV0lUSCBQQVNTV09SRCAnXFwke3Bhc3N3b3JkfSdcXGApXG5cbk1vcmUgSW5mb3JtYXRpb246IGh0dHBzOi8vcHJpcy5seS9kL2V4ZWN1dGUtcmF3XG5gKX12YXIgRW89KHtjbGllbnRNZXRob2Q6ZSxhY3RpdmVQcm92aWRlcjpyfSk9PnQ9PntsZXQgbj1cIlwiLGk7aWYoT24odCkpbj10LnNxbCxpPXt2YWx1ZXM6R3IodC52YWx1ZXMpLF9fcHJpc21hUmF3UGFyYW1ldGVyc19fOiEwfTtlbHNlIGlmKEFycmF5LmlzQXJyYXkodCkpe2xldFtvLC4uLnNdPXQ7bj1vLGk9e3ZhbHVlczpHcihzfHxbXSksX19wcmlzbWFSYXdQYXJhbWV0ZXJzX186ITB9fWVsc2Ugc3dpdGNoKHIpe2Nhc2VcInNxbGl0ZVwiOmNhc2VcIm15c3FsXCI6e249dC5zcWwsaT17dmFsdWVzOkdyKHQudmFsdWVzKSxfX3ByaXNtYVJhd1BhcmFtZXRlcnNfXzohMH07YnJlYWt9Y2FzZVwiY29ja3JvYWNoZGJcIjpjYXNlXCJwb3N0Z3Jlc3FsXCI6Y2FzZVwicG9zdGdyZXNcIjp7bj10LnRleHQsaT17dmFsdWVzOkdyKHQudmFsdWVzKSxfX3ByaXNtYVJhd1BhcmFtZXRlcnNfXzohMH07YnJlYWt9Y2FzZVwic3Fsc2VydmVyXCI6e249RGwodCksaT17dmFsdWVzOkdyKHQudmFsdWVzKSxfX3ByaXNtYVJhd1BhcmFtZXRlcnNfXzohMH07YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRoZSAke3J9IHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgJHtlfWApfXJldHVybiBpPy52YWx1ZXM/RmwoYHByaXNtYS4ke2V9KCR7bn0sICR7aS52YWx1ZXN9KWApOkZsKGBwcmlzbWEuJHtlfSgke259KWApLHtxdWVyeTpuLHBhcmFtZXRlcnM6aX19LE1sPXtyZXF1ZXN0QXJnc1RvTWlkZGxld2FyZUFyZ3MoZSl7cmV0dXJuW2Uuc3RyaW5ncywuLi5lLnZhbHVlc119LG1pZGRsZXdhcmVBcmdzVG9SZXF1ZXN0QXJncyhlKXtsZXRbciwuLi50XT1lO3JldHVybiBuZXcgbGUocix0KX19LCRsPXtyZXF1ZXN0QXJnc1RvTWlkZGxld2FyZUFyZ3MoZSl7cmV0dXJuW2VdfSxtaWRkbGV3YXJlQXJnc1RvUmVxdWVzdEFyZ3MoZSl7cmV0dXJuIGVbMF19fTtmdW5jdGlvbiB3byhlKXtyZXR1cm4gZnVuY3Rpb24odCxuKXtsZXQgaSxvPShzPWUpPT57dHJ5e3JldHVybiBzPT09dm9pZCAwfHxzPy5raW5kPT09XCJpdHhcIj9pPz89cWwodChzKSk6cWwodChzKSl9Y2F0Y2goYSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGEpfX07cmV0dXJue2dldCBzcGVjKCl7cmV0dXJuIG59LHRoZW4ocyxhKXtyZXR1cm4gbygpLnRoZW4ocyxhKX0sY2F0Y2gocyl7cmV0dXJuIG8oKS5jYXRjaChzKX0sZmluYWxseShzKXtyZXR1cm4gbygpLmZpbmFsbHkocyl9LHJlcXVlc3RUcmFuc2FjdGlvbihzKXtsZXQgYT1vKHMpO3JldHVybiBhLnJlcXVlc3RUcmFuc2FjdGlvbj9hLnJlcXVlc3RUcmFuc2FjdGlvbihzKTphfSxbU3ltYm9sLnRvU3RyaW5nVGFnXTpcIlByaXNtYVByb21pc2VcIn19fWZ1bmN0aW9uIHFsKGUpe3JldHVybiB0eXBlb2YgZS50aGVuPT1cImZ1bmN0aW9uXCI/ZTpQcm9taXNlLnJlc29sdmUoZSl9dmFyIHhmPW1pLnNwbGl0KFwiLlwiKVswXSx2Zj17aXNFbmFibGVkKCl7cmV0dXJuITF9LGdldFRyYWNlUGFyZW50KCl7cmV0dXJuXCIwMC0xMC0xMC0wMFwifSxkaXNwYXRjaEVuZ2luZVNwYW5zKCl7fSxnZXRBY3RpdmVDb250ZXh0KCl7fSxydW5JbkNoaWxkU3BhbihlLHIpe3JldHVybiByKCl9fSx4bz1jbGFzc3tpc0VuYWJsZWQoKXtyZXR1cm4gdGhpcy5nZXRHbG9iYWxUcmFjaW5nSGVscGVyKCkuaXNFbmFibGVkKCl9Z2V0VHJhY2VQYXJlbnQocil7cmV0dXJuIHRoaXMuZ2V0R2xvYmFsVHJhY2luZ0hlbHBlcigpLmdldFRyYWNlUGFyZW50KHIpfWRpc3BhdGNoRW5naW5lU3BhbnMocil7cmV0dXJuIHRoaXMuZ2V0R2xvYmFsVHJhY2luZ0hlbHBlcigpLmRpc3BhdGNoRW5naW5lU3BhbnMocil9Z2V0QWN0aXZlQ29udGV4dCgpe3JldHVybiB0aGlzLmdldEdsb2JhbFRyYWNpbmdIZWxwZXIoKS5nZXRBY3RpdmVDb250ZXh0KCl9cnVuSW5DaGlsZFNwYW4ocix0KXtyZXR1cm4gdGhpcy5nZXRHbG9iYWxUcmFjaW5nSGVscGVyKCkucnVuSW5DaGlsZFNwYW4ocix0KX1nZXRHbG9iYWxUcmFjaW5nSGVscGVyKCl7bGV0IHI9Z2xvYmFsVGhpc1tgViR7eGZ9X1BSSVNNQV9JTlNUUlVNRU5UQVRJT05gXSx0PWdsb2JhbFRoaXMuUFJJU01BX0lOU1RSVU1FTlRBVElPTjtyZXR1cm4gcj8uaGVscGVyPz90Py5oZWxwZXI/P3ZmfX07ZnVuY3Rpb24gamwoKXtyZXR1cm4gbmV3IHhvfWZ1bmN0aW9uIFZsKGUscj0oKT0+e30pe2xldCB0LG49bmV3IFByb21pc2UoaT0+dD1pKTtyZXR1cm57dGhlbihpKXtyZXR1cm4tLWU9PT0wJiZ0KHIoKSksaT8uKG4pfX19ZnVuY3Rpb24gQmwoZSl7cmV0dXJuIHR5cGVvZiBlPT1cInN0cmluZ1wiP2U6ZS5yZWR1Y2UoKHIsdCk9PntsZXQgbj10eXBlb2YgdD09XCJzdHJpbmdcIj90OnQubGV2ZWw7cmV0dXJuIG49PT1cInF1ZXJ5XCI/cjpyJiYodD09PVwiaW5mb1wifHxyPT09XCJpbmZvXCIpP1wiaW5mb1wiOm59LHZvaWQgMCl9dmFyIEduPWNsYXNze19taWRkbGV3YXJlcz1bXTt1c2Uocil7dGhpcy5fbWlkZGxld2FyZXMucHVzaChyKX1nZXQocil7cmV0dXJuIHRoaXMuX21pZGRsZXdhcmVzW3JdfWhhcyhyKXtyZXR1cm4hIXRoaXMuX21pZGRsZXdhcmVzW3JdfWxlbmd0aCgpe3JldHVybiB0aGlzLl9taWRkbGV3YXJlcy5sZW5ndGh9fTt2YXIgR2w9bmUoU2koKSk7ZnVuY3Rpb24gUW4oZSl7cmV0dXJuIHR5cGVvZiBlLmJhdGNoUmVxdWVzdElkeD09XCJudW1iZXJcIn1mdW5jdGlvbiBVbChlKXtpZihlLmFjdGlvbiE9PVwiZmluZFVuaXF1ZVwiJiZlLmFjdGlvbiE9PVwiZmluZFVuaXF1ZU9yVGhyb3dcIilyZXR1cm47bGV0IHI9W107cmV0dXJuIGUubW9kZWxOYW1lJiZyLnB1c2goZS5tb2RlbE5hbWUpLGUucXVlcnkuYXJndW1lbnRzJiZyLnB1c2godm8oZS5xdWVyeS5hcmd1bWVudHMpKSxyLnB1c2godm8oZS5xdWVyeS5zZWxlY3Rpb24pKSxyLmpvaW4oXCJcIil9ZnVuY3Rpb24gdm8oZSl7cmV0dXJuYCgke09iamVjdC5rZXlzKGUpLnNvcnQoKS5tYXAodD0+e2xldCBuPWVbdF07cmV0dXJuIHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbD9gKCR7dH0gJHt2byhuKX0pYDp0fSkuam9pbihcIiBcIil9KWB9dmFyIFBmPXthZ2dyZWdhdGU6ITEsYWdncmVnYXRlUmF3OiExLGNyZWF0ZU1hbnk6ITAsY3JlYXRlTWFueUFuZFJldHVybjohMCxjcmVhdGVPbmU6ITAsZGVsZXRlTWFueTohMCxkZWxldGVPbmU6ITAsZXhlY3V0ZVJhdzohMCxmaW5kRmlyc3Q6ITEsZmluZEZpcnN0T3JUaHJvdzohMSxmaW5kTWFueTohMSxmaW5kUmF3OiExLGZpbmRVbmlxdWU6ITEsZmluZFVuaXF1ZU9yVGhyb3c6ITEsZ3JvdXBCeTohMSxxdWVyeVJhdzohMSxydW5Db21tYW5kUmF3OiEwLHVwZGF0ZU1hbnk6ITAsdXBkYXRlTWFueUFuZFJldHVybjohMCx1cGRhdGVPbmU6ITAsdXBzZXJ0T25lOiEwfTtmdW5jdGlvbiBQbyhlKXtyZXR1cm4gUGZbZV19dmFyIFduPWNsYXNze2NvbnN0cnVjdG9yKHIpe3RoaXMub3B0aW9ucz1yO3RoaXMuYmF0Y2hlcz17fX1iYXRjaGVzO3RpY2tBY3RpdmU9ITE7cmVxdWVzdChyKXtsZXQgdD10aGlzLm9wdGlvbnMuYmF0Y2hCeShyKTtyZXR1cm4gdD8odGhpcy5iYXRjaGVzW3RdfHwodGhpcy5iYXRjaGVzW3RdPVtdLHRoaXMudGlja0FjdGl2ZXx8KHRoaXMudGlja0FjdGl2ZT0hMCxwcm9jZXNzLm5leHRUaWNrKCgpPT57dGhpcy5kaXNwYXRjaEJhdGNoZXMoKSx0aGlzLnRpY2tBY3RpdmU9ITF9KSkpLG5ldyBQcm9taXNlKChuLGkpPT57dGhpcy5iYXRjaGVzW3RdLnB1c2goe3JlcXVlc3Q6cixyZXNvbHZlOm4scmVqZWN0Oml9KX0pKTp0aGlzLm9wdGlvbnMuc2luZ2xlTG9hZGVyKHIpfWRpc3BhdGNoQmF0Y2hlcygpe2ZvcihsZXQgciBpbiB0aGlzLmJhdGNoZXMpe2xldCB0PXRoaXMuYmF0Y2hlc1tyXTtkZWxldGUgdGhpcy5iYXRjaGVzW3JdLHQubGVuZ3RoPT09MT90aGlzLm9wdGlvbnMuc2luZ2xlTG9hZGVyKHRbMF0ucmVxdWVzdCkudGhlbihuPT57biBpbnN0YW5jZW9mIEVycm9yP3RbMF0ucmVqZWN0KG4pOnRbMF0ucmVzb2x2ZShuKX0pLmNhdGNoKG49Pnt0WzBdLnJlamVjdChuKX0pOih0LnNvcnQoKG4saSk9PnRoaXMub3B0aW9ucy5iYXRjaE9yZGVyKG4ucmVxdWVzdCxpLnJlcXVlc3QpKSx0aGlzLm9wdGlvbnMuYmF0Y2hMb2FkZXIodC5tYXAobj0+bi5yZXF1ZXN0KSkudGhlbihuPT57aWYobiBpbnN0YW5jZW9mIEVycm9yKWZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXRbaV0ucmVqZWN0KG4pO2Vsc2UgZm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspe2xldCBvPW5baV07byBpbnN0YW5jZW9mIEVycm9yP3RbaV0ucmVqZWN0KG8pOnRbaV0ucmVzb2x2ZShvKX19KS5jYXRjaChuPT57Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdFtpXS5yZWplY3Qobil9KSl9fWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJEYXRhTG9hZGVyXCJ9fTtmdW5jdGlvbiBkcihlLHIpe2lmKHI9PT1udWxsKXJldHVybiByO3N3aXRjaChlKXtjYXNlXCJiaWdpbnRcIjpyZXR1cm4gQmlnSW50KHIpO2Nhc2VcImJ5dGVzXCI6e2xldHtidWZmZXI6dCxieXRlT2Zmc2V0Om4sYnl0ZUxlbmd0aDppfT1CdWZmZXIuZnJvbShyLFwiYmFzZTY0XCIpO3JldHVybiBuZXcgVWludDhBcnJheSh0LG4saSl9Y2FzZVwiZGVjaW1hbFwiOnJldHVybiBuZXcgRmUocik7Y2FzZVwiZGF0ZXRpbWVcIjpjYXNlXCJkYXRlXCI6cmV0dXJuIG5ldyBEYXRlKHIpO2Nhc2VcInRpbWVcIjpyZXR1cm4gbmV3IERhdGUoYDE5NzAtMDEtMDFUJHtyfVpgKTtjYXNlXCJiaWdpbnQtYXJyYXlcIjpyZXR1cm4gci5tYXAodD0+ZHIoXCJiaWdpbnRcIix0KSk7Y2FzZVwiYnl0ZXMtYXJyYXlcIjpyZXR1cm4gci5tYXAodD0+ZHIoXCJieXRlc1wiLHQpKTtjYXNlXCJkZWNpbWFsLWFycmF5XCI6cmV0dXJuIHIubWFwKHQ9PmRyKFwiZGVjaW1hbFwiLHQpKTtjYXNlXCJkYXRldGltZS1hcnJheVwiOnJldHVybiByLm1hcCh0PT5kcihcImRhdGV0aW1lXCIsdCkpO2Nhc2VcImRhdGUtYXJyYXlcIjpyZXR1cm4gci5tYXAodD0+ZHIoXCJkYXRlXCIsdCkpO2Nhc2VcInRpbWUtYXJyYXlcIjpyZXR1cm4gci5tYXAodD0+ZHIoXCJ0aW1lXCIsdCkpO2RlZmF1bHQ6cmV0dXJuIHJ9fWZ1bmN0aW9uIFRvKGUpe2xldCByPVtdLHQ9VGYoZSk7Zm9yKGxldCBuPTA7bjxlLnJvd3MubGVuZ3RoO24rKyl7bGV0IGk9ZS5yb3dzW25dLG89ey4uLnR9O2ZvcihsZXQgcz0wO3M8aS5sZW5ndGg7cysrKW9bZS5jb2x1bW5zW3NdXT1kcihlLnR5cGVzW3NdLGlbc10pO3IucHVzaChvKX1yZXR1cm4gcn1mdW5jdGlvbiBUZihlKXtsZXQgcj17fTtmb3IobGV0IHQ9MDt0PGUuY29sdW1ucy5sZW5ndGg7dCsrKXJbZS5jb2x1bW5zW3RdXT1udWxsO3JldHVybiByfXZhciBTZj1MKFwicHJpc21hOmNsaWVudDpyZXF1ZXN0X2hhbmRsZXJcIiksSm49Y2xhc3N7Y2xpZW50O2RhdGFsb2FkZXI7bG9nRW1pdHRlcjtjb25zdHJ1Y3RvcihyLHQpe3RoaXMubG9nRW1pdHRlcj10LHRoaXMuY2xpZW50PXIsdGhpcy5kYXRhbG9hZGVyPW5ldyBXbih7YmF0Y2hMb2FkZXI6S2EoYXN5bmMoe3JlcXVlc3RzOm4sY3VzdG9tRGF0YVByb3h5RmV0Y2g6aX0pPT57bGV0e3RyYW5zYWN0aW9uOm8sb3RlbFBhcmVudEN0eDpzfT1uWzBdLGE9bi5tYXAocD0+cC5wcm90b2NvbFF1ZXJ5KSxsPXRoaXMuY2xpZW50Ll90cmFjaW5nSGVscGVyLmdldFRyYWNlUGFyZW50KHMpLHU9bi5zb21lKHA9PlBvKHAucHJvdG9jb2xRdWVyeS5hY3Rpb24pKTtyZXR1cm4oYXdhaXQgdGhpcy5jbGllbnQuX2VuZ2luZS5yZXF1ZXN0QmF0Y2goYSx7dHJhY2VwYXJlbnQ6bCx0cmFuc2FjdGlvbjpSZihvKSxjb250YWluc1dyaXRlOnUsY3VzdG9tRGF0YVByb3h5RmV0Y2g6aX0pKS5tYXAoKHAsZCk9PntpZihwIGluc3RhbmNlb2YgRXJyb3IpcmV0dXJuIHA7dHJ5e3JldHVybiB0aGlzLm1hcFF1ZXJ5RW5naW5lUmVzdWx0KG5bZF0scCl9Y2F0Y2goZil7cmV0dXJuIGZ9fSl9KSxzaW5nbGVMb2FkZXI6YXN5bmMgbj0+e2xldCBpPW4udHJhbnNhY3Rpb24/LmtpbmQ9PT1cIml0eFwiP1FsKG4udHJhbnNhY3Rpb24pOnZvaWQgMCxvPWF3YWl0IHRoaXMuY2xpZW50Ll9lbmdpbmUucmVxdWVzdChuLnByb3RvY29sUXVlcnkse3RyYWNlcGFyZW50OnRoaXMuY2xpZW50Ll90cmFjaW5nSGVscGVyLmdldFRyYWNlUGFyZW50KCksaW50ZXJhY3RpdmVUcmFuc2FjdGlvbjppLGlzV3JpdGU6UG8obi5wcm90b2NvbFF1ZXJ5LmFjdGlvbiksY3VzdG9tRGF0YVByb3h5RmV0Y2g6bi5jdXN0b21EYXRhUHJveHlGZXRjaH0pO3JldHVybiB0aGlzLm1hcFF1ZXJ5RW5naW5lUmVzdWx0KG4sbyl9LGJhdGNoQnk6bj0+bi50cmFuc2FjdGlvbj8uaWQ/YHRyYW5zYWN0aW9uLSR7bi50cmFuc2FjdGlvbi5pZH1gOlVsKG4ucHJvdG9jb2xRdWVyeSksYmF0Y2hPcmRlcihuLGkpe3JldHVybiBuLnRyYW5zYWN0aW9uPy5raW5kPT09XCJiYXRjaFwiJiZpLnRyYW5zYWN0aW9uPy5raW5kPT09XCJiYXRjaFwiP24udHJhbnNhY3Rpb24uaW5kZXgtaS50cmFuc2FjdGlvbi5pbmRleDowfX0pfWFzeW5jIHJlcXVlc3Qocil7dHJ5e3JldHVybiBhd2FpdCB0aGlzLmRhdGFsb2FkZXIucmVxdWVzdChyKX1jYXRjaCh0KXtsZXR7Y2xpZW50TWV0aG9kOm4sY2FsbHNpdGU6aSx0cmFuc2FjdGlvbjpvLGFyZ3M6cyxtb2RlbE5hbWU6YX09cjt0aGlzLmhhbmRsZUFuZExvZ1JlcXVlc3RFcnJvcih7ZXJyb3I6dCxjbGllbnRNZXRob2Q6bixjYWxsc2l0ZTppLHRyYW5zYWN0aW9uOm8sYXJnczpzLG1vZGVsTmFtZTphLGdsb2JhbE9taXQ6ci5nbG9iYWxPbWl0fSl9fW1hcFF1ZXJ5RW5naW5lUmVzdWx0KHtkYXRhUGF0aDpyLHVucGFja2VyOnR9LG4pe2xldCBpPW4/LmRhdGEsbz10aGlzLnVucGFjayhpLHIsdCk7cmV0dXJuIHByb2Nlc3MuZW52LlBSSVNNQV9DTElFTlRfR0VUX1RJTUU/e2RhdGE6b306b31oYW5kbGVBbmRMb2dSZXF1ZXN0RXJyb3Iocil7dHJ5e3RoaXMuaGFuZGxlUmVxdWVzdEVycm9yKHIpfWNhdGNoKHQpe3Rocm93IHRoaXMubG9nRW1pdHRlciYmdGhpcy5sb2dFbWl0dGVyLmVtaXQoXCJlcnJvclwiLHttZXNzYWdlOnQubWVzc2FnZSx0YXJnZXQ6ci5jbGllbnRNZXRob2QsdGltZXN0YW1wOm5ldyBEYXRlfSksdH19aGFuZGxlUmVxdWVzdEVycm9yKHtlcnJvcjpyLGNsaWVudE1ldGhvZDp0LGNhbGxzaXRlOm4sdHJhbnNhY3Rpb246aSxhcmdzOm8sbW9kZWxOYW1lOnMsZ2xvYmFsT21pdDphfSl7aWYoU2YociksQWYocixpKSl0aHJvdyByO2lmKHIgaW5zdGFuY2VvZiBaJiZDZihyKSl7bGV0IHU9V2woci5tZXRhKTtDbih7YXJnczpvLGVycm9yczpbdV0sY2FsbHNpdGU6bixlcnJvckZvcm1hdDp0aGlzLmNsaWVudC5fZXJyb3JGb3JtYXQsb3JpZ2luYWxNZXRob2Q6dCxjbGllbnRWZXJzaW9uOnRoaXMuY2xpZW50Ll9jbGllbnRWZXJzaW9uLGdsb2JhbE9taXQ6YX0pfWxldCBsPXIubWVzc2FnZTtpZihuJiYobD1Fbih7Y2FsbHNpdGU6bixvcmlnaW5hbE1ldGhvZDp0LGlzUGFuaWM6ci5pc1BhbmljLHNob3dDb2xvcnM6dGhpcy5jbGllbnQuX2Vycm9yRm9ybWF0PT09XCJwcmV0dHlcIixtZXNzYWdlOmx9KSksbD10aGlzLnNhbml0aXplTWVzc2FnZShsKSxyLmNvZGUpe2xldCB1PXM/e21vZGVsTmFtZTpzLC4uLnIubWV0YX06ci5tZXRhO3Rocm93IG5ldyBaKGwse2NvZGU6ci5jb2RlLGNsaWVudFZlcnNpb246dGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24sbWV0YTp1LGJhdGNoUmVxdWVzdElkeDpyLmJhdGNoUmVxdWVzdElkeH0pfWVsc2V7aWYoci5pc1BhbmljKXRocm93IG5ldyBkZShsLHRoaXMuY2xpZW50Ll9jbGllbnRWZXJzaW9uKTtpZihyIGluc3RhbmNlb2YgcSl0aHJvdyBuZXcgcShsLHtjbGllbnRWZXJzaW9uOnRoaXMuY2xpZW50Ll9jbGllbnRWZXJzaW9uLGJhdGNoUmVxdWVzdElkeDpyLmJhdGNoUmVxdWVzdElkeH0pO2lmKHIgaW5zdGFuY2VvZiBUKXRocm93IG5ldyBUKGwsdGhpcy5jbGllbnQuX2NsaWVudFZlcnNpb24pO2lmKHIgaW5zdGFuY2VvZiBkZSl0aHJvdyBuZXcgZGUobCx0aGlzLmNsaWVudC5fY2xpZW50VmVyc2lvbil9dGhyb3cgci5jbGllbnRWZXJzaW9uPXRoaXMuY2xpZW50Ll9jbGllbnRWZXJzaW9uLHJ9c2FuaXRpemVNZXNzYWdlKHIpe3JldHVybiB0aGlzLmNsaWVudC5fZXJyb3JGb3JtYXQmJnRoaXMuY2xpZW50Ll9lcnJvckZvcm1hdCE9PVwicHJldHR5XCI/KDAsR2wuZGVmYXVsdCkocik6cn11bnBhY2socix0LG4pe2lmKCFyfHwoci5kYXRhJiYocj1yLmRhdGEpLCFyKSlyZXR1cm4gcjtsZXQgaT1PYmplY3Qua2V5cyhyKVswXSxvPU9iamVjdC52YWx1ZXMocilbMF0scz10LmZpbHRlcih1PT51IT09XCJzZWxlY3RcIiYmdSE9PVwiaW5jbHVkZVwiKSxhPWVvKG8scyksbD1pPT09XCJxdWVyeVJhd1wiP1RvKGEpOnN0KGEpO3JldHVybiBuP24obCk6bH1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiUmVxdWVzdEhhbmRsZXJcIn19O2Z1bmN0aW9uIFJmKGUpe2lmKGUpe2lmKGUua2luZD09PVwiYmF0Y2hcIilyZXR1cm57a2luZDpcImJhdGNoXCIsb3B0aW9uczp7aXNvbGF0aW9uTGV2ZWw6ZS5pc29sYXRpb25MZXZlbH19O2lmKGUua2luZD09PVwiaXR4XCIpcmV0dXJue2tpbmQ6XCJpdHhcIixvcHRpb25zOlFsKGUpfTtfZShlLFwiVW5rbm93biB0cmFuc2FjdGlvbiBraW5kXCIpfX1mdW5jdGlvbiBRbChlKXtyZXR1cm57aWQ6ZS5pZCxwYXlsb2FkOmUucGF5bG9hZH19ZnVuY3Rpb24gQWYoZSxyKXtyZXR1cm4gUW4oZSkmJnI/LmtpbmQ9PT1cImJhdGNoXCImJmUuYmF0Y2hSZXF1ZXN0SWR4IT09ci5pbmRleH1mdW5jdGlvbiBDZihlKXtyZXR1cm4gZS5jb2RlPT09XCJQMjAwOVwifHxlLmNvZGU9PT1cIlAyMDEyXCJ9ZnVuY3Rpb24gV2woZSl7aWYoZS5raW5kPT09XCJVbmlvblwiKXJldHVybntraW5kOlwiVW5pb25cIixlcnJvcnM6ZS5lcnJvcnMubWFwKFdsKX07aWYoQXJyYXkuaXNBcnJheShlLnNlbGVjdGlvblBhdGgpKXtsZXRbLC4uLnJdPWUuc2VsZWN0aW9uUGF0aDtyZXR1cm57Li4uZSxzZWxlY3Rpb25QYXRoOnJ9fXJldHVybiBlfXZhciBKbD1tbDt2YXIgWmw9bmUoamkoKSk7dmFyIEQ9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihyKXtzdXBlcihyK2BcblJlYWQgbW9yZSBhdCBodHRwczovL3ByaXMubHkvZC9jbGllbnQtY29uc3RydWN0b3JgKSx0aGlzLm5hbWU9XCJQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvclwifWdldFtTeW1ib2wudG9TdHJpbmdUYWddKCl7cmV0dXJuXCJQcmlzbWFDbGllbnRDb25zdHJ1Y3RvclZhbGlkYXRpb25FcnJvclwifX07eChELFwiUHJpc21hQ2xpZW50Q29uc3RydWN0b3JWYWxpZGF0aW9uRXJyb3JcIik7dmFyIEhsPVtcImRhdGFzb3VyY2VzXCIsXCJkYXRhc291cmNlVXJsXCIsXCJlcnJvckZvcm1hdFwiLFwiYWRhcHRlclwiLFwibG9nXCIsXCJ0cmFuc2FjdGlvbk9wdGlvbnNcIixcIm9taXRcIixcIl9faW50ZXJuYWxcIl0sS2w9W1wicHJldHR5XCIsXCJjb2xvcmxlc3NcIixcIm1pbmltYWxcIl0sWWw9W1wiaW5mb1wiLFwicXVlcnlcIixcIndhcm5cIixcImVycm9yXCJdLElmPXtkYXRhc291cmNlczooZSx7ZGF0YXNvdXJjZU5hbWVzOnJ9KT0+e2lmKGUpe2lmKHR5cGVvZiBlIT1cIm9iamVjdFwifHxBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBEKGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkoZSl9IGZvciBcImRhdGFzb3VyY2VzXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yYCk7Zm9yKGxldFt0LG5db2YgT2JqZWN0LmVudHJpZXMoZSkpe2lmKCFyLmluY2x1ZGVzKHQpKXtsZXQgaT1Rcih0LHIpfHxgIEF2YWlsYWJsZSBkYXRhc291cmNlczogJHtyLmpvaW4oXCIsIFwiKX1gO3Rocm93IG5ldyBEKGBVbmtub3duIGRhdGFzb3VyY2UgJHt0fSBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtpfWApfWlmKHR5cGVvZiBuIT1cIm9iamVjdFwifHxBcnJheS5pc0FycmF5KG4pKXRocm93IG5ldyBEKGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkoZSl9IGZvciBkYXRhc291cmNlIFwiJHt0fVwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci5cbkl0IHNob3VsZCBoYXZlIHRoaXMgZm9ybTogeyB1cmw6IFwiQ09OTkVDVElPTl9TVFJJTkdcIiB9YCk7aWYobiYmdHlwZW9mIG49PVwib2JqZWN0XCIpZm9yKGxldFtpLG9db2YgT2JqZWN0LmVudHJpZXMobikpe2lmKGkhPT1cInVybFwiKXRocm93IG5ldyBEKGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkoZSl9IGZvciBkYXRhc291cmNlIFwiJHt0fVwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci5cbkl0IHNob3VsZCBoYXZlIHRoaXMgZm9ybTogeyB1cmw6IFwiQ09OTkVDVElPTl9TVFJJTkdcIiB9YCk7aWYodHlwZW9mIG8hPVwic3RyaW5nXCIpdGhyb3cgbmV3IEQoYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShvKX0gZm9yIGRhdGFzb3VyY2UgXCIke3R9XCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLlxuSXQgc2hvdWxkIGhhdmUgdGhpcyBmb3JtOiB7IHVybDogXCJDT05ORUNUSU9OX1NUUklOR1wiIH1gKX19fX0sYWRhcHRlcjooZSxyKT0+e2lmKCFlJiZ3cihyLmdlbmVyYXRvcik9PT1cImNsaWVudFwiKXRocm93IG5ldyBEKCdVc2luZyBlbmdpbmUgdHlwZSBcImNsaWVudFwiIHJlcXVpcmVzIGEgZHJpdmVyIGFkYXB0ZXIgdG8gYmUgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLicpO2lmKGU9PT1udWxsKXJldHVybjtpZihlPT09dm9pZCAwKXRocm93IG5ldyBEKCdcImFkYXB0ZXJcIiBwcm9wZXJ0eSBtdXN0IG5vdCBiZSB1bmRlZmluZWQsIHVzZSBudWxsIHRvIGNvbmRpdGlvbmFsbHkgZGlzYWJsZSBkcml2ZXIgYWRhcHRlcnMuJyk7aWYoIVVuKHIpLmluY2x1ZGVzKFwiZHJpdmVyQWRhcHRlcnNcIikpdGhyb3cgbmV3IEQoJ1wiYWRhcHRlclwiIHByb3BlcnR5IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3RvciB3aGVuIFwiZHJpdmVyQWRhcHRlcnNcIiBwcmV2aWV3IGZlYXR1cmUgaXMgZW5hYmxlZC4nKTtpZih3cihyLmdlbmVyYXRvcik9PT1cImJpbmFyeVwiKXRocm93IG5ldyBEKCdDYW5ub3QgdXNlIGEgZHJpdmVyIGFkYXB0ZXIgd2l0aCB0aGUgXCJiaW5hcnlcIiBRdWVyeSBFbmdpbmUuIFBsZWFzZSB1c2UgdGhlIFwibGlicmFyeVwiIFF1ZXJ5IEVuZ2luZS4nKX0sZGF0YXNvdXJjZVVybDplPT57aWYodHlwZW9mIGU8XCJ1XCImJnR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBEKGBJbnZhbGlkIHZhbHVlICR7SlNPTi5zdHJpbmdpZnkoZSl9IGZvciBcImRhdGFzb3VyY2VVcmxcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuXG5FeHBlY3RlZCBzdHJpbmcgb3IgdW5kZWZpbmVkLmApfSxlcnJvckZvcm1hdDplPT57aWYoZSl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEQoYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShlKX0gZm9yIFwiZXJyb3JGb3JtYXRcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuYCk7aWYoIUtsLmluY2x1ZGVzKGUpKXtsZXQgcj1RcihlLEtsKTt0aHJvdyBuZXcgRChgSW52YWxpZCBlcnJvckZvcm1hdCAke2V9IHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke3J9YCl9fX0sbG9nOmU9PntpZighZSlyZXR1cm47aWYoIUFycmF5LmlzQXJyYXkoZSkpdGhyb3cgbmV3IEQoYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShlKX0gZm9yIFwibG9nXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLmApO2Z1bmN0aW9uIHIodCl7aWYodHlwZW9mIHQ9PVwic3RyaW5nXCImJiFZbC5pbmNsdWRlcyh0KSl7bGV0IG49UXIodCxZbCk7dGhyb3cgbmV3IEQoYEludmFsaWQgbG9nIGxldmVsIFwiJHt0fVwiIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke259YCl9fWZvcihsZXQgdCBvZiBlKXtyKHQpO2xldCBuPXtsZXZlbDpyLGVtaXQ6aT0+e2xldCBvPVtcInN0ZG91dFwiLFwiZXZlbnRcIl07aWYoIW8uaW5jbHVkZXMoaSkpe2xldCBzPVFyKGksbyk7dGhyb3cgbmV3IEQoYEludmFsaWQgdmFsdWUgJHtKU09OLnN0cmluZ2lmeShpKX0gZm9yIFwiZW1pdFwiIGluIGxvZ0xldmVsIHByb3ZpZGVkIHRvIFByaXNtYUNsaWVudCBjb25zdHJ1Y3Rvci4ke3N9YCl9fX07aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCIpZm9yKGxldFtpLG9db2YgT2JqZWN0LmVudHJpZXModCkpaWYobltpXSluW2ldKG8pO2Vsc2UgdGhyb3cgbmV3IEQoYEludmFsaWQgcHJvcGVydHkgJHtpfSBmb3IgXCJsb2dcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3JgKX19LHRyYW5zYWN0aW9uT3B0aW9uczplPT57aWYoIWUpcmV0dXJuO2xldCByPWUubWF4V2FpdDtpZihyIT1udWxsJiZyPD0wKXRocm93IG5ldyBEKGBJbnZhbGlkIHZhbHVlICR7cn0gZm9yIG1heFdhaXQgaW4gXCJ0cmFuc2FjdGlvbk9wdGlvbnNcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuIG1heFdhaXQgbmVlZHMgdG8gYmUgZ3JlYXRlciB0aGFuIDBgKTtsZXQgdD1lLnRpbWVvdXQ7aWYodCE9bnVsbCYmdDw9MCl0aHJvdyBuZXcgRChgSW52YWxpZCB2YWx1ZSAke3R9IGZvciB0aW1lb3V0IGluIFwidHJhbnNhY3Rpb25PcHRpb25zXCIgcHJvdmlkZWQgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yLiB0aW1lb3V0IG5lZWRzIHRvIGJlIGdyZWF0ZXIgdGhhbiAwYCl9LG9taXQ6KGUscik9PntpZih0eXBlb2YgZSE9XCJvYmplY3RcIil0aHJvdyBuZXcgRCgnXCJvbWl0XCIgb3B0aW9uIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdC4nKTtpZihlPT09bnVsbCl0aHJvdyBuZXcgRCgnXCJvbWl0XCIgb3B0aW9uIGNhbiBub3QgYmUgYG51bGxgJyk7bGV0IHQ9W107Zm9yKGxldFtuLGldb2YgT2JqZWN0LmVudHJpZXMoZSkpe2xldCBvPURmKG4sci5ydW50aW1lRGF0YU1vZGVsKTtpZighbyl7dC5wdXNoKHtraW5kOlwiVW5rbm93bk1vZGVsXCIsbW9kZWxLZXk6bn0pO2NvbnRpbnVlfWZvcihsZXRbcyxhXW9mIE9iamVjdC5lbnRyaWVzKGkpKXtsZXQgbD1vLmZpZWxkcy5maW5kKHU9PnUubmFtZT09PXMpO2lmKCFsKXt0LnB1c2goe2tpbmQ6XCJVbmtub3duRmllbGRcIixtb2RlbEtleTpuLGZpZWxkTmFtZTpzfSk7Y29udGludWV9aWYobC5yZWxhdGlvbk5hbWUpe3QucHVzaCh7a2luZDpcIlJlbGF0aW9uSW5PbWl0XCIsbW9kZWxLZXk6bixmaWVsZE5hbWU6c30pO2NvbnRpbnVlfXR5cGVvZiBhIT1cImJvb2xlYW5cIiYmdC5wdXNoKHtraW5kOlwiSW52YWxpZEZpZWxkVmFsdWVcIixtb2RlbEtleTpuLGZpZWxkTmFtZTpzfSl9fWlmKHQubGVuZ3RoPjApdGhyb3cgbmV3IEQoT2YoZSx0KSl9LF9faW50ZXJuYWw6ZT0+e2lmKCFlKXJldHVybjtsZXQgcj1bXCJkZWJ1Z1wiLFwiZW5naW5lXCIsXCJjb25maWdPdmVycmlkZVwiXTtpZih0eXBlb2YgZSE9XCJvYmplY3RcIil0aHJvdyBuZXcgRChgSW52YWxpZCB2YWx1ZSAke0pTT04uc3RyaW5naWZ5KGUpfSBmb3IgXCJfX2ludGVybmFsXCIgdG8gUHJpc21hQ2xpZW50IGNvbnN0cnVjdG9yYCk7Zm9yKGxldFt0XW9mIE9iamVjdC5lbnRyaWVzKGUpKWlmKCFyLmluY2x1ZGVzKHQpKXtsZXQgbj1Rcih0LHIpO3Rocm93IG5ldyBEKGBJbnZhbGlkIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkodCl9IGZvciBcIl9faW50ZXJuYWxcIiBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtufWApfX19O2Z1bmN0aW9uIFhsKGUscil7Zm9yKGxldFt0LG5db2YgT2JqZWN0LmVudHJpZXMoZSkpe2lmKCFIbC5pbmNsdWRlcyh0KSl7bGV0IGk9UXIodCxIbCk7dGhyb3cgbmV3IEQoYFVua25vd24gcHJvcGVydHkgJHt0fSBwcm92aWRlZCB0byBQcmlzbWFDbGllbnQgY29uc3RydWN0b3IuJHtpfWApfUlmW3RdKG4scil9aWYoZS5kYXRhc291cmNlVXJsJiZlLmRhdGFzb3VyY2VzKXRocm93IG5ldyBEKCdDYW4gbm90IHVzZSBcImRhdGFzb3VyY2VVcmxcIiBhbmQgXCJkYXRhc291cmNlc1wiIG9wdGlvbnMgYXQgdGhlIHNhbWUgdGltZS4gUGljayBvbmUgb2YgdGhlbScpfWZ1bmN0aW9uIFFyKGUscil7aWYoci5sZW5ndGg9PT0wfHx0eXBlb2YgZSE9XCJzdHJpbmdcIilyZXR1cm5cIlwiO2xldCB0PWtmKGUscik7cmV0dXJuIHQ/YCBEaWQgeW91IG1lYW4gXCIke3R9XCI/YDpcIlwifWZ1bmN0aW9uIGtmKGUscil7aWYoci5sZW5ndGg9PT0wKXJldHVybiBudWxsO2xldCB0PXIubWFwKGk9Pih7dmFsdWU6aSxkaXN0YW5jZTooMCxabC5kZWZhdWx0KShlLGkpfSkpO3Quc29ydCgoaSxvKT0+aS5kaXN0YW5jZTxvLmRpc3RhbmNlPy0xOjEpO2xldCBuPXRbMF07cmV0dXJuIG4uZGlzdGFuY2U8Mz9uLnZhbHVlOm51bGx9ZnVuY3Rpb24gRGYoZSxyKXtyZXR1cm4gemwoci5tb2RlbHMsZSk/P3psKHIudHlwZXMsZSl9ZnVuY3Rpb24gemwoZSxyKXtsZXQgdD1PYmplY3Qua2V5cyhlKS5maW5kKG49PlllKG4pPT09cik7aWYodClyZXR1cm4gZVt0XX1mdW5jdGlvbiBPZihlLHIpe2xldCB0PV9yKGUpO2ZvcihsZXQgbyBvZiByKXN3aXRjaChvLmtpbmQpe2Nhc2VcIlVua25vd25Nb2RlbFwiOnQuYXJndW1lbnRzLmdldEZpZWxkKG8ubW9kZWxLZXkpPy5tYXJrQXNFcnJvcigpLHQuYWRkRXJyb3JNZXNzYWdlKCgpPT5gVW5rbm93biBtb2RlbCBuYW1lOiAke28ubW9kZWxLZXl9LmApO2JyZWFrO2Nhc2VcIlVua25vd25GaWVsZFwiOnQuYXJndW1lbnRzLmdldERlZXBGaWVsZChbby5tb2RlbEtleSxvLmZpZWxkTmFtZV0pPy5tYXJrQXNFcnJvcigpLHQuYWRkRXJyb3JNZXNzYWdlKCgpPT5gTW9kZWwgXCIke28ubW9kZWxLZXl9XCIgZG9lcyBub3QgaGF2ZSBhIGZpZWxkIG5hbWVkIFwiJHtvLmZpZWxkTmFtZX1cIi5gKTticmVhaztjYXNlXCJSZWxhdGlvbkluT21pdFwiOnQuYXJndW1lbnRzLmdldERlZXBGaWVsZChbby5tb2RlbEtleSxvLmZpZWxkTmFtZV0pPy5tYXJrQXNFcnJvcigpLHQuYWRkRXJyb3JNZXNzYWdlKCgpPT4nUmVsYXRpb25zIGFyZSBhbHJlYWR5IGV4Y2x1ZGVkIGJ5IGRlZmF1bHQgYW5kIGNhbiBub3QgYmUgc3BlY2lmaWVkIGluIFwib21pdFwiLicpO2JyZWFrO2Nhc2VcIkludmFsaWRGaWVsZFZhbHVlXCI6dC5hcmd1bWVudHMuZ2V0RGVlcEZpZWxkVmFsdWUoW28ubW9kZWxLZXksby5maWVsZE5hbWVdKT8ubWFya0FzRXJyb3IoKSx0LmFkZEVycm9yTWVzc2FnZSgoKT0+XCJPbWl0IGZpZWxkIG9wdGlvbiB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi5cIik7YnJlYWt9bGV0e21lc3NhZ2U6bixhcmdzOml9PUFuKHQsXCJjb2xvcmxlc3NcIik7cmV0dXJuYEVycm9yIHZhbGlkYXRpbmcgXCJvbWl0XCIgb3B0aW9uOlxuXG4ke2l9XG5cbiR7bn1gfWZ1bmN0aW9uIGV1KGUpe3JldHVybiBlLmxlbmd0aD09PTA/UHJvbWlzZS5yZXNvbHZlKFtdKTpuZXcgUHJvbWlzZSgocix0KT0+e2xldCBuPW5ldyBBcnJheShlLmxlbmd0aCksaT1udWxsLG89ITEscz0wLGE9KCk9PntvfHwocysrLHM9PT1lLmxlbmd0aCYmKG89ITAsaT90KGkpOnIobikpKX0sbD11PT57b3x8KG89ITAsdCh1KSl9O2ZvcihsZXQgdT0wO3U8ZS5sZW5ndGg7dSsrKWVbdV0udGhlbihjPT57blt1XT1jLGEoKX0sYz0+e2lmKCFRbihjKSl7bChjKTtyZXR1cm59Yy5iYXRjaFJlcXVlc3RJZHg9PT11P2woYyk6KGl8fChpPWMpLGEoKSl9KX0pfXZhciBycj1MKFwicHJpc21hOmNsaWVudFwiKTt0eXBlb2YgZ2xvYmFsVGhpcz09XCJvYmplY3RcIiYmKGdsb2JhbFRoaXMuTk9ERV9DTElFTlQ9ITApO3ZhciBGZj17cmVxdWVzdEFyZ3NUb01pZGRsZXdhcmVBcmdzOmU9PmUsbWlkZGxld2FyZUFyZ3NUb1JlcXVlc3RBcmdzOmU9PmV9LE1mPVN5bWJvbC5mb3IoXCJwcmlzbWEuY2xpZW50LnRyYW5zYWN0aW9uLmlkXCIpLCRmPXtpZDowLG5leHRJZCgpe3JldHVybisrdGhpcy5pZH19O2Z1bmN0aW9uIHFmKGUpe2NsYXNzIHJ7X29yaWdpbmFsQ2xpZW50PXRoaXM7X3J1bnRpbWVEYXRhTW9kZWw7X3JlcXVlc3RIYW5kbGVyO19jb25uZWN0aW9uUHJvbWlzZTtfZGlzY29ubmVjdGlvblByb21pc2U7X2VuZ2luZUNvbmZpZztfYWNjZWxlcmF0ZUVuZ2luZUNvbmZpZztfY2xpZW50VmVyc2lvbjtfZXJyb3JGb3JtYXQ7X3RyYWNpbmdIZWxwZXI7X21pZGRsZXdhcmVzPW5ldyBHbjtfcHJldmlld0ZlYXR1cmVzO19hY3RpdmVQcm92aWRlcjtfZ2xvYmFsT21pdDtfZXh0ZW5zaW9ucztfZW5naW5lO19hcHBsaWVkUGFyZW50O19jcmVhdGVQcmlzbWFQcm9taXNlPXdvKCk7Y29uc3RydWN0b3Iobil7ZT1uPy5fX2ludGVybmFsPy5jb25maWdPdmVycmlkZT8uKGUpPz9lLGVsKGUpLG4mJlhsKG4sZSk7bGV0IGk9bmV3IE5mKCkub24oXCJlcnJvclwiLCgpPT57fSk7dGhpcy5fZXh0ZW5zaW9ucz1Oci5lbXB0eSgpLHRoaXMuX3ByZXZpZXdGZWF0dXJlcz1VbihlKSx0aGlzLl9jbGllbnRWZXJzaW9uPWUuY2xpZW50VmVyc2lvbj8/SmwsdGhpcy5fYWN0aXZlUHJvdmlkZXI9ZS5hY3RpdmVQcm92aWRlcix0aGlzLl9nbG9iYWxPbWl0PW4/Lm9taXQsdGhpcy5fdHJhY2luZ0hlbHBlcj1qbCgpO2xldCBvPWUucmVsYXRpdmVFbnZQYXRocyYme3Jvb3RFbnZQYXRoOmUucmVsYXRpdmVFbnZQYXRocy5yb290RW52UGF0aCYmU28ucmVzb2x2ZShlLmRpcm5hbWUsZS5yZWxhdGl2ZUVudlBhdGhzLnJvb3RFbnZQYXRoKSxzY2hlbWFFbnZQYXRoOmUucmVsYXRpdmVFbnZQYXRocy5zY2hlbWFFbnZQYXRoJiZTby5yZXNvbHZlKGUuZGlybmFtZSxlLnJlbGF0aXZlRW52UGF0aHMuc2NoZW1hRW52UGF0aCl9LHM7aWYobj8uYWRhcHRlcil7cz1uLmFkYXB0ZXI7bGV0IGw9ZS5hY3RpdmVQcm92aWRlcj09PVwicG9zdGdyZXNxbFwifHxlLmFjdGl2ZVByb3ZpZGVyPT09XCJjb2Nrcm9hY2hkYlwiP1wicG9zdGdyZXNcIjplLmFjdGl2ZVByb3ZpZGVyO2lmKHMucHJvdmlkZXIhPT1sKXRocm93IG5ldyBUKGBUaGUgRHJpdmVyIEFkYXB0ZXIgXFxgJHtzLmFkYXB0ZXJOYW1lfVxcYCwgYmFzZWQgb24gXFxgJHtzLnByb3ZpZGVyfVxcYCwgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgcHJvdmlkZXIgXFxgJHtsfVxcYCBzcGVjaWZpZWQgaW4gdGhlIFByaXNtYSBzY2hlbWEuYCx0aGlzLl9jbGllbnRWZXJzaW9uKTtpZihuLmRhdGFzb3VyY2VzfHxuLmRhdGFzb3VyY2VVcmwhPT12b2lkIDApdGhyb3cgbmV3IFQoXCJDdXN0b20gZGF0YXNvdXJjZSBjb25maWd1cmF0aW9uIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggUHJpc21hIERyaXZlciBBZGFwdGVycy4gUGxlYXNlIGRlZmluZSB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiBzdHJpbmcgZGlyZWN0bHkgaW4gdGhlIERyaXZlciBBZGFwdGVyIGNvbmZpZ3VyYXRpb24uXCIsdGhpcy5fY2xpZW50VmVyc2lvbil9bGV0IGE9IXMmJm8mJml0KG8se2NvbmZsaWN0Q2hlY2s6XCJub25lXCJ9KXx8ZS5pbmplY3RhYmxlRWRnZUVudj8uKCk7dHJ5e2xldCBsPW4/P3t9LHU9bC5fX2ludGVybmFsPz97fSxjPXUuZGVidWc9PT0hMDtjJiZMLmVuYWJsZShcInByaXNtYTpjbGllbnRcIik7bGV0IHA9U28ucmVzb2x2ZShlLmRpcm5hbWUsZS5yZWxhdGl2ZVBhdGgpO0xmLmV4aXN0c1N5bmMocCl8fChwPWUuZGlybmFtZSkscnIoXCJkaXJuYW1lXCIsZS5kaXJuYW1lKSxycihcInJlbGF0aXZlUGF0aFwiLGUucmVsYXRpdmVQYXRoKSxycihcImN3ZFwiLHApO2xldCBkPXUuZW5naW5lfHx7fTtpZihsLmVycm9yRm9ybWF0P3RoaXMuX2Vycm9yRm9ybWF0PWwuZXJyb3JGb3JtYXQ6cHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT1cInByb2R1Y3Rpb25cIj90aGlzLl9lcnJvckZvcm1hdD1cIm1pbmltYWxcIjpwcm9jZXNzLmVudi5OT19DT0xPUj90aGlzLl9lcnJvckZvcm1hdD1cImNvbG9ybGVzc1wiOnRoaXMuX2Vycm9yRm9ybWF0PVwiY29sb3JsZXNzXCIsdGhpcy5fcnVudGltZURhdGFNb2RlbD1lLnJ1bnRpbWVEYXRhTW9kZWwsdGhpcy5fZW5naW5lQ29uZmlnPXtjd2Q6cCxkaXJuYW1lOmUuZGlybmFtZSxlbmFibGVEZWJ1Z0xvZ3M6YyxhbGxvd1RyaWdnZXJQYW5pYzpkLmFsbG93VHJpZ2dlclBhbmljLHByaXNtYVBhdGg6ZC5iaW5hcnlQYXRoPz92b2lkIDAsZW5naW5lRW5kcG9pbnQ6ZC5lbmRwb2ludCxnZW5lcmF0b3I6ZS5nZW5lcmF0b3Isc2hvd0NvbG9yczp0aGlzLl9lcnJvckZvcm1hdD09PVwicHJldHR5XCIsbG9nTGV2ZWw6bC5sb2cmJkJsKGwubG9nKSxsb2dRdWVyaWVzOmwubG9nJiYhISh0eXBlb2YgbC5sb2c9PVwic3RyaW5nXCI/bC5sb2c9PT1cInF1ZXJ5XCI6bC5sb2cuZmluZChmPT50eXBlb2YgZj09XCJzdHJpbmdcIj9mPT09XCJxdWVyeVwiOmYubGV2ZWw9PT1cInF1ZXJ5XCIpKSxlbnY6YT8ucGFyc2VkPz97fSxmbGFnczpbXSxlbmdpbmVXYXNtOmUuZW5naW5lV2FzbSxjb21waWxlcldhc206ZS5jb21waWxlcldhc20sY2xpZW50VmVyc2lvbjplLmNsaWVudFZlcnNpb24sZW5naW5lVmVyc2lvbjplLmVuZ2luZVZlcnNpb24scHJldmlld0ZlYXR1cmVzOnRoaXMuX3ByZXZpZXdGZWF0dXJlcyxhY3RpdmVQcm92aWRlcjplLmFjdGl2ZVByb3ZpZGVyLGlubGluZVNjaGVtYTplLmlubGluZVNjaGVtYSxvdmVycmlkZURhdGFzb3VyY2VzOnJsKGwsZS5kYXRhc291cmNlTmFtZXMpLGlubGluZURhdGFzb3VyY2VzOmUuaW5saW5lRGF0YXNvdXJjZXMsaW5saW5lU2NoZW1hSGFzaDplLmlubGluZVNjaGVtYUhhc2gsdHJhY2luZ0hlbHBlcjp0aGlzLl90cmFjaW5nSGVscGVyLHRyYW5zYWN0aW9uT3B0aW9uczp7bWF4V2FpdDpsLnRyYW5zYWN0aW9uT3B0aW9ucz8ubWF4V2FpdD8/MmUzLHRpbWVvdXQ6bC50cmFuc2FjdGlvbk9wdGlvbnM/LnRpbWVvdXQ/PzVlMyxpc29sYXRpb25MZXZlbDpsLnRyYW5zYWN0aW9uT3B0aW9ucz8uaXNvbGF0aW9uTGV2ZWx9LGxvZ0VtaXR0ZXI6aSxpc0J1bmRsZWQ6ZS5pc0J1bmRsZWQsYWRhcHRlcjpzfSx0aGlzLl9hY2NlbGVyYXRlRW5naW5lQ29uZmlnPXsuLi50aGlzLl9lbmdpbmVDb25maWcsYWNjZWxlcmF0ZVV0aWxzOntyZXNvbHZlRGF0YXNvdXJjZVVybDpxcixnZXRCYXRjaFJlcXVlc3RQYXlsb2FkOkZyLHByaXNtYUdyYXBoUUxUb0pTRXJyb3I6TXIsUHJpc21hQ2xpZW50VW5rbm93blJlcXVlc3RFcnJvcjpxLFByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3I6VCxQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvcjpaLGRlYnVnOkwoXCJwcmlzbWE6Y2xpZW50OmFjY2VsZXJhdGVFbmdpbmVcIiksZW5naW5lVmVyc2lvbjp0dS52ZXJzaW9uLGNsaWVudFZlcnNpb246ZS5jbGllbnRWZXJzaW9ufX0scnIoXCJjbGllbnRWZXJzaW9uXCIsZS5jbGllbnRWZXJzaW9uKSx0aGlzLl9lbmdpbmU9SWwoZSx0aGlzLl9lbmdpbmVDb25maWcpLHRoaXMuX3JlcXVlc3RIYW5kbGVyPW5ldyBKbih0aGlzLGkpLGwubG9nKWZvcihsZXQgZiBvZiBsLmxvZyl7bGV0IGg9dHlwZW9mIGY9PVwic3RyaW5nXCI/ZjpmLmVtaXQ9PT1cInN0ZG91dFwiP2YubGV2ZWw6bnVsbDtoJiZ0aGlzLiRvbihoLGc9PntydC5sb2coYCR7cnQudGFnc1toXT8/XCJcIn1gLGcubWVzc2FnZXx8Zy5xdWVyeSl9KX19Y2F0Y2gobCl7dGhyb3cgbC5jbGllbnRWZXJzaW9uPXRoaXMuX2NsaWVudFZlcnNpb24sbH1yZXR1cm4gdGhpcy5fYXBwbGllZFBhcmVudD14dCh0aGlzKX1nZXRbU3ltYm9sLnRvU3RyaW5nVGFnXSgpe3JldHVyblwiUHJpc21hQ2xpZW50XCJ9JHVzZShuKXt0aGlzLl9taWRkbGV3YXJlcy51c2Uobil9JG9uKG4saSl7cmV0dXJuIG49PT1cImJlZm9yZUV4aXRcIj90aGlzLl9lbmdpbmUub25CZWZvcmVFeGl0KGkpOm4mJnRoaXMuX2VuZ2luZUNvbmZpZy5sb2dFbWl0dGVyLm9uKG4saSksdGhpc30kY29ubmVjdCgpe3RyeXtyZXR1cm4gdGhpcy5fZW5naW5lLnN0YXJ0KCl9Y2F0Y2gobil7dGhyb3cgbi5jbGllbnRWZXJzaW9uPXRoaXMuX2NsaWVudFZlcnNpb24sbn19YXN5bmMgJGRpc2Nvbm5lY3QoKXt0cnl7YXdhaXQgdGhpcy5fZW5naW5lLnN0b3AoKX1jYXRjaChuKXt0aHJvdyBuLmNsaWVudFZlcnNpb249dGhpcy5fY2xpZW50VmVyc2lvbixufWZpbmFsbHl7am8oKX19JGV4ZWN1dGVSYXdJbnRlcm5hbChuLGksbyxzKXtsZXQgYT10aGlzLl9hY3RpdmVQcm92aWRlcjtyZXR1cm4gdGhpcy5fcmVxdWVzdCh7YWN0aW9uOlwiZXhlY3V0ZVJhd1wiLGFyZ3M6byx0cmFuc2FjdGlvbjpuLGNsaWVudE1ldGhvZDppLGFyZ3NNYXBwZXI6RW8oe2NsaWVudE1ldGhvZDppLGFjdGl2ZVByb3ZpZGVyOmF9KSxjYWxsc2l0ZTpaZSh0aGlzLl9lcnJvckZvcm1hdCksZGF0YVBhdGg6W10sbWlkZGxld2FyZUFyZ3NNYXBwZXI6c30pfSRleGVjdXRlUmF3KG4sLi4uaSl7cmV0dXJuIHRoaXMuX2NyZWF0ZVByaXNtYVByb21pc2Uobz0+e2lmKG4ucmF3IT09dm9pZCAwfHxuLnNxbCE9PXZvaWQgMCl7bGV0W3MsYV09cnUobixpKTtyZXR1cm4gYm8odGhpcy5fYWN0aXZlUHJvdmlkZXIscy50ZXh0LHMudmFsdWVzLEFycmF5LmlzQXJyYXkobik/XCJwcmlzbWEuJGV4ZWN1dGVSYXdgPFNRTD5gXCI6XCJwcmlzbWEuJGV4ZWN1dGVSYXcoc3FsYDxTUUw+YClcIiksdGhpcy4kZXhlY3V0ZVJhd0ludGVybmFsKG8sXCIkZXhlY3V0ZVJhd1wiLHMsYSl9dGhyb3cgbmV3IFgoXCJgJGV4ZWN1dGVSYXdgIGlzIGEgdGFnIGZ1bmN0aW9uLCBwbGVhc2UgdXNlIGl0IGxpa2UgdGhlIGZvbGxvd2luZzpcXG5gYGBcXG5jb25zdCByZXN1bHQgPSBhd2FpdCBwcmlzbWEuJGV4ZWN1dGVSYXdgVVBEQVRFIFVzZXIgU0VUIGNvb2wgPSAke3RydWV9IFdIRVJFIGVtYWlsID0gJHsndXNlckBlbWFpbC5jb20nfTtgXFxuYGBgXFxuXFxuT3IgcmVhZCBvdXIgZG9jcyBhdCBodHRwczovL3d3dy5wcmlzbWEuaW8vZG9jcy9jb25jZXB0cy9jb21wb25lbnRzL3ByaXNtYS1jbGllbnQvcmF3LWRhdGFiYXNlLWFjY2VzcyNleGVjdXRlcmF3XFxuXCIse2NsaWVudFZlcnNpb246dGhpcy5fY2xpZW50VmVyc2lvbn0pfSl9JGV4ZWN1dGVSYXdVbnNhZmUobiwuLi5pKXtyZXR1cm4gdGhpcy5fY3JlYXRlUHJpc21hUHJvbWlzZShvPT4oYm8odGhpcy5fYWN0aXZlUHJvdmlkZXIsbixpLFwicHJpc21hLiRleGVjdXRlUmF3VW5zYWZlKDxTUUw+LCBbLi4udmFsdWVzXSlcIiksdGhpcy4kZXhlY3V0ZVJhd0ludGVybmFsKG8sXCIkZXhlY3V0ZVJhd1Vuc2FmZVwiLFtuLC4uLmldKSkpfSRydW5Db21tYW5kUmF3KG4pe2lmKGUuYWN0aXZlUHJvdmlkZXIhPT1cIm1vbmdvZGJcIil0aHJvdyBuZXcgWChgVGhlICR7ZS5hY3RpdmVQcm92aWRlcn0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAkcnVuQ29tbWFuZFJhdy4gVXNlIHRoZSBtb25nb2RiIHByb3ZpZGVyLmAse2NsaWVudFZlcnNpb246dGhpcy5fY2xpZW50VmVyc2lvbn0pO3JldHVybiB0aGlzLl9jcmVhdGVQcmlzbWFQcm9taXNlKGk9PnRoaXMuX3JlcXVlc3Qoe2FyZ3M6bixjbGllbnRNZXRob2Q6XCIkcnVuQ29tbWFuZFJhd1wiLGRhdGFQYXRoOltdLGFjdGlvbjpcInJ1bkNvbW1hbmRSYXdcIixhcmdzTWFwcGVyOmtsLGNhbGxzaXRlOlplKHRoaXMuX2Vycm9yRm9ybWF0KSx0cmFuc2FjdGlvbjppfSkpfWFzeW5jICRxdWVyeVJhd0ludGVybmFsKG4saSxvLHMpe2xldCBhPXRoaXMuX2FjdGl2ZVByb3ZpZGVyO3JldHVybiB0aGlzLl9yZXF1ZXN0KHthY3Rpb246XCJxdWVyeVJhd1wiLGFyZ3M6byx0cmFuc2FjdGlvbjpuLGNsaWVudE1ldGhvZDppLGFyZ3NNYXBwZXI6RW8oe2NsaWVudE1ldGhvZDppLGFjdGl2ZVByb3ZpZGVyOmF9KSxjYWxsc2l0ZTpaZSh0aGlzLl9lcnJvckZvcm1hdCksZGF0YVBhdGg6W10sbWlkZGxld2FyZUFyZ3NNYXBwZXI6c30pfSRxdWVyeVJhdyhuLC4uLmkpe3JldHVybiB0aGlzLl9jcmVhdGVQcmlzbWFQcm9taXNlKG89PntpZihuLnJhdyE9PXZvaWQgMHx8bi5zcWwhPT12b2lkIDApcmV0dXJuIHRoaXMuJHF1ZXJ5UmF3SW50ZXJuYWwobyxcIiRxdWVyeVJhd1wiLC4uLnJ1KG4saSkpO3Rocm93IG5ldyBYKFwiYCRxdWVyeVJhd2AgaXMgYSB0YWcgZnVuY3Rpb24sIHBsZWFzZSB1c2UgaXQgbGlrZSB0aGUgZm9sbG93aW5nOlxcbmBgYFxcbmNvbnN0IHJlc3VsdCA9IGF3YWl0IHByaXNtYS4kcXVlcnlSYXdgU0VMRUNUICogRlJPTSBVc2VyIFdIRVJFIGlkID0gJHsxfSBPUiBlbWFpbCA9ICR7J3VzZXJAZW1haWwuY29tJ307YFxcbmBgYFxcblxcbk9yIHJlYWQgb3VyIGRvY3MgYXQgaHR0cHM6Ly93d3cucHJpc21hLmlvL2RvY3MvY29uY2VwdHMvY29tcG9uZW50cy9wcmlzbWEtY2xpZW50L3Jhdy1kYXRhYmFzZS1hY2Nlc3MjcXVlcnlyYXdcXG5cIix7Y2xpZW50VmVyc2lvbjp0aGlzLl9jbGllbnRWZXJzaW9ufSl9KX0kcXVlcnlSYXdUeXBlZChuKXtyZXR1cm4gdGhpcy5fY3JlYXRlUHJpc21hUHJvbWlzZShpPT57aWYoIXRoaXMuX2hhc1ByZXZpZXdGbGFnKFwidHlwZWRTcWxcIikpdGhyb3cgbmV3IFgoXCJgdHlwZWRTcWxgIHByZXZpZXcgZmVhdHVyZSBtdXN0IGJlIGVuYWJsZWQgaW4gb3JkZXIgdG8gYWNjZXNzICRxdWVyeVJhd1R5cGVkIEFQSVwiLHtjbGllbnRWZXJzaW9uOnRoaXMuX2NsaWVudFZlcnNpb259KTtyZXR1cm4gdGhpcy4kcXVlcnlSYXdJbnRlcm5hbChpLFwiJHF1ZXJ5UmF3VHlwZWRcIixuKX0pfSRxdWVyeVJhd1Vuc2FmZShuLC4uLmkpe3JldHVybiB0aGlzLl9jcmVhdGVQcmlzbWFQcm9taXNlKG89PnRoaXMuJHF1ZXJ5UmF3SW50ZXJuYWwobyxcIiRxdWVyeVJhd1Vuc2FmZVwiLFtuLC4uLmldKSl9X3RyYW5zYWN0aW9uV2l0aEFycmF5KHtwcm9taXNlczpuLG9wdGlvbnM6aX0pe2xldCBvPSRmLm5leHRJZCgpLHM9Vmwobi5sZW5ndGgpLGE9bi5tYXAoKGwsdSk9PntpZihsPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSE9PVwiUHJpc21hUHJvbWlzZVwiKXRocm93IG5ldyBFcnJvcihcIkFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXkgbmVlZCB0byBiZSBQcmlzbWEgQ2xpZW50IHByb21pc2VzLiBIaW50OiBQbGVhc2UgbWFrZSBzdXJlIHlvdSBhcmUgbm90IGF3YWl0aW5nIHRoZSBQcmlzbWEgY2xpZW50IGNhbGxzIHlvdSBpbnRlbmRlZCB0byBwYXNzIGluIHRoZSAkdHJhbnNhY3Rpb24gZnVuY3Rpb24uXCIpO2xldCBjPWk/Lmlzb2xhdGlvbkxldmVsPz90aGlzLl9lbmdpbmVDb25maWcudHJhbnNhY3Rpb25PcHRpb25zLmlzb2xhdGlvbkxldmVsLHA9e2tpbmQ6XCJiYXRjaFwiLGlkOm8saW5kZXg6dSxpc29sYXRpb25MZXZlbDpjLGxvY2s6c307cmV0dXJuIGwucmVxdWVzdFRyYW5zYWN0aW9uPy4ocCk/P2x9KTtyZXR1cm4gZXUoYSl9YXN5bmMgX3RyYW5zYWN0aW9uV2l0aENhbGxiYWNrKHtjYWxsYmFjazpuLG9wdGlvbnM6aX0pe2xldCBvPXt0cmFjZXBhcmVudDp0aGlzLl90cmFjaW5nSGVscGVyLmdldFRyYWNlUGFyZW50KCl9LHM9e21heFdhaXQ6aT8ubWF4V2FpdD8/dGhpcy5fZW5naW5lQ29uZmlnLnRyYW5zYWN0aW9uT3B0aW9ucy5tYXhXYWl0LHRpbWVvdXQ6aT8udGltZW91dD8/dGhpcy5fZW5naW5lQ29uZmlnLnRyYW5zYWN0aW9uT3B0aW9ucy50aW1lb3V0LGlzb2xhdGlvbkxldmVsOmk/Lmlzb2xhdGlvbkxldmVsPz90aGlzLl9lbmdpbmVDb25maWcudHJhbnNhY3Rpb25PcHRpb25zLmlzb2xhdGlvbkxldmVsfSxhPWF3YWl0IHRoaXMuX2VuZ2luZS50cmFuc2FjdGlvbihcInN0YXJ0XCIsbyxzKSxsO3RyeXtsZXQgdT17a2luZDpcIml0eFwiLC4uLmF9O2w9YXdhaXQgbih0aGlzLl9jcmVhdGVJdHhDbGllbnQodSkpLGF3YWl0IHRoaXMuX2VuZ2luZS50cmFuc2FjdGlvbihcImNvbW1pdFwiLG8sYSl9Y2F0Y2godSl7dGhyb3cgYXdhaXQgdGhpcy5fZW5naW5lLnRyYW5zYWN0aW9uKFwicm9sbGJhY2tcIixvLGEpLmNhdGNoKCgpPT57fSksdX1yZXR1cm4gbH1fY3JlYXRlSXR4Q2xpZW50KG4pe3JldHVybiBoZSh4dChoZShxYSh0aGlzKSxbZWUoXCJfYXBwbGllZFBhcmVudFwiLCgpPT50aGlzLl9hcHBsaWVkUGFyZW50Ll9jcmVhdGVJdHhDbGllbnQobikpLGVlKFwiX2NyZWF0ZVByaXNtYVByb21pc2VcIiwoKT0+d28obikpLGVlKE1mLCgpPT5uLmlkKV0pKSxbTHIoR2EpXSl9JHRyYW5zYWN0aW9uKG4saSl7bGV0IG87dHlwZW9mIG49PVwiZnVuY3Rpb25cIj90aGlzLl9lbmdpbmVDb25maWcuYWRhcHRlcj8uYWRhcHRlck5hbWU9PT1cIkBwcmlzbWEvYWRhcHRlci1kMVwiP289KCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDbG91ZGZsYXJlIEQxIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJhY3RpdmUgdHJhbnNhY3Rpb25zLiBXZSByZWNvbW1lbmQgeW91IHRvIHJlZmFjdG9yIHlvdXIgcXVlcmllcyB3aXRoIHRoYXQgbGltaXRhdGlvbiBpbiBtaW5kLCBhbmQgdXNlIGJhdGNoIHRyYW5zYWN0aW9ucyB3aXRoIGBwcmlzbWEuJHRyYW5zYWN0aW9ucyhbXSlgIHdoZXJlIGFwcGxpY2FibGUuXCIpfTpvPSgpPT50aGlzLl90cmFuc2FjdGlvbldpdGhDYWxsYmFjayh7Y2FsbGJhY2s6bixvcHRpb25zOml9KTpvPSgpPT50aGlzLl90cmFuc2FjdGlvbldpdGhBcnJheSh7cHJvbWlzZXM6bixvcHRpb25zOml9KTtsZXQgcz17bmFtZTpcInRyYW5zYWN0aW9uXCIsYXR0cmlidXRlczp7bWV0aG9kOlwiJHRyYW5zYWN0aW9uXCJ9fTtyZXR1cm4gdGhpcy5fdHJhY2luZ0hlbHBlci5ydW5JbkNoaWxkU3BhbihzLG8pfV9yZXF1ZXN0KG4pe24ub3RlbFBhcmVudEN0eD10aGlzLl90cmFjaW5nSGVscGVyLmdldEFjdGl2ZUNvbnRleHQoKTtsZXQgaT1uLm1pZGRsZXdhcmVBcmdzTWFwcGVyPz9GZixvPXthcmdzOmkucmVxdWVzdEFyZ3NUb01pZGRsZXdhcmVBcmdzKG4uYXJncyksZGF0YVBhdGg6bi5kYXRhUGF0aCxydW5JblRyYW5zYWN0aW9uOiEhbi50cmFuc2FjdGlvbixhY3Rpb246bi5hY3Rpb24sbW9kZWw6bi5tb2RlbH0scz17bWlkZGxld2FyZTp7bmFtZTpcIm1pZGRsZXdhcmVcIixtaWRkbGV3YXJlOiEwLGF0dHJpYnV0ZXM6e21ldGhvZDpcIiR1c2VcIn0sYWN0aXZlOiExfSxvcGVyYXRpb246e25hbWU6XCJvcGVyYXRpb25cIixhdHRyaWJ1dGVzOnttZXRob2Q6by5hY3Rpb24sbW9kZWw6by5tb2RlbCxuYW1lOm8ubW9kZWw/YCR7by5tb2RlbH0uJHtvLmFjdGlvbn1gOm8uYWN0aW9ufX19LGE9LTEsbD1hc3luYyB1PT57bGV0IGM9dGhpcy5fbWlkZGxld2FyZXMuZ2V0KCsrYSk7aWYoYylyZXR1cm4gdGhpcy5fdHJhY2luZ0hlbHBlci5ydW5JbkNoaWxkU3BhbihzLm1pZGRsZXdhcmUsUz0+Yyh1LFA9PihTPy5lbmQoKSxsKFApKSkpO2xldHtydW5JblRyYW5zYWN0aW9uOnAsYXJnczpkLC4uLmZ9PXUsaD17Li4ubiwuLi5mfTtkJiYoaC5hcmdzPWkubWlkZGxld2FyZUFyZ3NUb1JlcXVlc3RBcmdzKGQpKSxuLnRyYW5zYWN0aW9uIT09dm9pZCAwJiZwPT09ITEmJmRlbGV0ZSBoLnRyYW5zYWN0aW9uO2xldCBnPWF3YWl0IEhhKHRoaXMsaCk7cmV0dXJuIGgubW9kZWw/VWEoe3Jlc3VsdDpnLG1vZGVsTmFtZTpoLm1vZGVsLGFyZ3M6aC5hcmdzLGV4dGVuc2lvbnM6dGhpcy5fZXh0ZW5zaW9ucyxydW50aW1lRGF0YU1vZGVsOnRoaXMuX3J1bnRpbWVEYXRhTW9kZWwsZ2xvYmFsT21pdDp0aGlzLl9nbG9iYWxPbWl0fSk6Z307cmV0dXJuIHRoaXMuX3RyYWNpbmdIZWxwZXIucnVuSW5DaGlsZFNwYW4ocy5vcGVyYXRpb24sKCk9Pm5ldyBfZihcInByaXNtYS1jbGllbnQtcmVxdWVzdFwiKS5ydW5JbkFzeW5jU2NvcGUoKCk9PmwobykpKX1hc3luYyBfZXhlY3V0ZVJlcXVlc3Qoe2FyZ3M6bixjbGllbnRNZXRob2Q6aSxkYXRhUGF0aDpvLGNhbGxzaXRlOnMsYWN0aW9uOmEsbW9kZWw6bCxhcmdzTWFwcGVyOnUsdHJhbnNhY3Rpb246Yyx1bnBhY2tlcjpwLG90ZWxQYXJlbnRDdHg6ZCxjdXN0b21EYXRhUHJveHlGZXRjaDpmfSl7dHJ5e249dT91KG4pOm47bGV0IGg9e25hbWU6XCJzZXJpYWxpemVcIn0sZz10aGlzLl90cmFjaW5nSGVscGVyLnJ1bkluQ2hpbGRTcGFuKGgsKCk9PkhpKHttb2RlbE5hbWU6bCxydW50aW1lRGF0YU1vZGVsOnRoaXMuX3J1bnRpbWVEYXRhTW9kZWwsYWN0aW9uOmEsYXJnczpuLGNsaWVudE1ldGhvZDppLGNhbGxzaXRlOnMsZXh0ZW5zaW9uczp0aGlzLl9leHRlbnNpb25zLGVycm9yRm9ybWF0OnRoaXMuX2Vycm9yRm9ybWF0LGNsaWVudFZlcnNpb246dGhpcy5fY2xpZW50VmVyc2lvbixwcmV2aWV3RmVhdHVyZXM6dGhpcy5fcHJldmlld0ZlYXR1cmVzLGdsb2JhbE9taXQ6dGhpcy5fZ2xvYmFsT21pdH0pKTtyZXR1cm4gTC5lbmFibGVkKFwicHJpc21hOmNsaWVudFwiKSYmKHJyKFwiUHJpc21hIENsaWVudCBjYWxsOlwiKSxycihgcHJpc21hLiR7aX0oJHtDYShuKX0pYCkscnIoXCJHZW5lcmF0ZWQgcmVxdWVzdDpcIikscnIoSlNPTi5zdHJpbmdpZnkoZyxudWxsLDIpK2BcbmApKSxjPy5raW5kPT09XCJiYXRjaFwiJiZhd2FpdCBjLmxvY2ssdGhpcy5fcmVxdWVzdEhhbmRsZXIucmVxdWVzdCh7cHJvdG9jb2xRdWVyeTpnLG1vZGVsTmFtZTpsLGFjdGlvbjphLGNsaWVudE1ldGhvZDppLGRhdGFQYXRoOm8sY2FsbHNpdGU6cyxhcmdzOm4sZXh0ZW5zaW9uczp0aGlzLl9leHRlbnNpb25zLHRyYW5zYWN0aW9uOmMsdW5wYWNrZXI6cCxvdGVsUGFyZW50Q3R4OmQsb3RlbENoaWxkQ3R4OnRoaXMuX3RyYWNpbmdIZWxwZXIuZ2V0QWN0aXZlQ29udGV4dCgpLGdsb2JhbE9taXQ6dGhpcy5fZ2xvYmFsT21pdCxjdXN0b21EYXRhUHJveHlGZXRjaDpmfSl9Y2F0Y2goaCl7dGhyb3cgaC5jbGllbnRWZXJzaW9uPXRoaXMuX2NsaWVudFZlcnNpb24saH19JG1ldHJpY3M9bmV3IHl0KHRoaXMpO19oYXNQcmV2aWV3RmxhZyhuKXtyZXR1cm4hIXRoaXMuX2VuZ2luZUNvbmZpZy5wcmV2aWV3RmVhdHVyZXM/LmluY2x1ZGVzKG4pfSRhcHBseVBlbmRpbmdNaWdyYXRpb25zKCl7cmV0dXJuIHRoaXMuX2VuZ2luZS5hcHBseVBlbmRpbmdNaWdyYXRpb25zKCl9JGV4dGVuZHM9amF9cmV0dXJuIHJ9ZnVuY3Rpb24gcnUoZSxyKXtyZXR1cm4gamYoZSk/W25ldyBsZShlLHIpLE1sXTpbZSwkbF19ZnVuY3Rpb24gamYoZSl7cmV0dXJuIEFycmF5LmlzQXJyYXkoZSkmJkFycmF5LmlzQXJyYXkoZS5yYXcpfXZhciBWZj1uZXcgU2V0KFtcInRvSlNPTlwiLFwiJCR0eXBlb2ZcIixcImFzeW1tZXRyaWNNYXRjaFwiLFN5bWJvbC5pdGVyYXRvcixTeW1ib2wudG9TdHJpbmdUYWcsU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSxTeW1ib2wudG9QcmltaXRpdmVdKTtmdW5jdGlvbiBCZihlKXtyZXR1cm4gbmV3IFByb3h5KGUse2dldChyLHQpe2lmKHQgaW4gcilyZXR1cm4gclt0XTtpZighVmYuaGFzKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZW51bSB2YWx1ZTogJHtTdHJpbmcodCl9YCl9fSl9ZnVuY3Rpb24gVWYoZSl7aXQoZSx7Y29uZmxpY3RDaGVjazpcIndhcm5cIn0pfWV4cG9ydHtobiBhcyBETU1GLEwgYXMgRGVidWcsRmUgYXMgRGVjaW1hbCxJbyBhcyBFeHRlbnNpb25zLHl0IGFzIE1ldHJpY3NDbGllbnQsVCBhcyBQcmlzbWFDbGllbnRJbml0aWFsaXphdGlvbkVycm9yLFogYXMgUHJpc21hQ2xpZW50S25vd25SZXF1ZXN0RXJyb3IsZGUgYXMgUHJpc21hQ2xpZW50UnVzdFBhbmljRXJyb3IscSBhcyBQcmlzbWFDbGllbnRVbmtub3duUmVxdWVzdEVycm9yLFggYXMgUHJpc21hQ2xpZW50VmFsaWRhdGlvbkVycm9yLERvIGFzIFB1YmxpYyxsZSBhcyBTcWwsR2QgYXMgY3JlYXRlUGFyYW0sZW0gYXMgZGVmaW5lRG1tZlByb3BlcnR5LHN0IGFzIGRlc2VyaWFsaXplSnNvblJlc3BvbnNlLFRvIGFzIGRlc2VyaWFsaXplUmF3UmVzdWx0LHRkIGFzIGRtbWZUb1J1bnRpbWVEYXRhTW9kZWwsaW0gYXMgZW1wdHkscWYgYXMgZ2V0UHJpc21hQ2xpZW50LGlvIGFzIGdldFJ1bnRpbWUsbm0gYXMgam9pbixCZiBhcyBtYWtlU3RyaWN0RW51bSx0bSBhcyBtYWtlVHlwZWRRdWVyeUZhY3RvcnksVWkgYXMgb2JqZWN0RW51bVZhbHVlcyxUYSBhcyByYXcsSGkgYXMgc2VyaWFsaXplSnNvblF1ZXJ5LFdpIGFzIHNraXAsU2EgYXMgc3FsdGFnLFVmIGFzIHdhcm5FbnZDb25mbGljdHMsb24gYXMgd2Fybk9uY2V9O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxuZGVjaW1hbC5qcy9kZWNpbWFsLm1qczpcbiAgKCohXG4gICAqICBkZWNpbWFsLmpzIHYxMC41LjBcbiAgICogIEFuIGFyYml0cmFyeS1wcmVjaXNpb24gRGVjaW1hbCB0eXBlIGZvciBKYXZhU2NyaXB0LlxuICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xuICAgKiAgQ29weXJpZ2h0IChjKSAyMDI1IE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XG4gICAqICBNSVQgTGljZW5jZVxuICAgKilcbiovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1saWJyYXJ5Lm1qcy5tYXBcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsInZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IChvYmopID0+IChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSkgOiAob2JqKSA9PiAob2JqLl9fcHJvdG9fXyk7XG52YXIgbGVhZlByb3RvdHlwZXM7XG4vLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8vIG1vZGUgJiAxNjogcmV0dXJuIHZhbHVlIHdoZW4gaXQncyBQcm9taXNlLWxpa2Vcbi8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbl9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG5cdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IHRoaXModmFsdWUpO1xuXHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuXHRpZih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlKSB7XG5cdFx0aWYoKG1vZGUgJiA0KSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG5cdFx0aWYoKG1vZGUgJiAxNikgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcblx0fVxuXHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuXHR2YXIgZGVmID0ge307XG5cdGxlYWZQcm90b3R5cGVzID0gbGVhZlByb3RvdHlwZXMgfHwgW251bGwsIGdldFByb3RvKHt9KSwgZ2V0UHJvdG8oW10pLCBnZXRQcm90byhnZXRQcm90byldO1xuXHRmb3IodmFyIGN1cnJlbnQgPSBtb2RlICYgMiAmJiB2YWx1ZTsgdHlwZW9mIGN1cnJlbnQgPT0gJ29iamVjdCcgJiYgIX5sZWFmUHJvdG90eXBlcy5pbmRleE9mKGN1cnJlbnQpOyBjdXJyZW50ID0gZ2V0UHJvdG8oY3VycmVudCkpIHtcblx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdXJyZW50KS5mb3JFYWNoKChrZXkpID0+IChkZWZba2V5XSA9ICgpID0+ICh2YWx1ZVtrZXldKSkpO1xuXHR9XG5cdGRlZlsnZGVmYXVsdCddID0gKCkgPT4gKHZhbHVlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBkZWYpO1xuXHRyZXR1cm4gbnM7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgJ0Bkb3RlbnZ4L2RvdGVudngvY29uZmlnJztcbmltcG9ydCB7IGFwcCwgaXBjTWFpbiB9IGZyb20gXCJlbGVjdHJvblwiO1xuaW1wb3J0IHNlcnZlIGZyb20gXCJlbGVjdHJvbi1zZXJ2ZVwiO1xuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IGFwcEV2ZW50cyB9IGZyb20gXCIuL2hlbHBlcnMvYXBwRXZlbnRzXCI7XG5pbXBvcnQgeyBlbGVjdHJvbkJ1aWxkZXJCb290c3RyYXAgfSBmcm9tIFwiLi9oZWxwZXJzL2VsZWN0cm9uQnVpbGRlckJvb3RzdHJhcFwiO1xuaW1wb3J0IHsgaXBjRXZlbnRzIH0gZnJvbSBcIi4vaGVscGVycy9pcGNFdmVudHNcIjtcbmltcG9ydCB7IGlwY0hhbmRsZXJzIH0gZnJvbSBcIi4vaGVscGVycy9pcGNIYW5kbGVyc1wiO1xuaW1wb3J0IHsgaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlLCBsb2dnZXIgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWxzXCI7XG5pbXBvcnQgeyBpbnN0YW50aWF0ZVdpbmRvdyB9IGZyb20gXCIuL2hlbHBlcnMvd2luZG93c1wiO1xuXG5jb25zdCBpc1Byb2QgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG5jb25zdCB7IGF1dG9VcGRhdGVyLCBBcHBVcGRhdGVyIH0gPSByZXF1aXJlKFwiZWxlY3Ryb24tdXBkYXRlclwiKTtcblxuY29uc29sZS5sb2coYFxcblxcbkFwcGxpY2F0aW9uIFN0YXJ0ZWRcXG5cXG5gKTtcblxuaWYgKGlzUHJvZCkge1xuICBzZXJ2ZSh7IGRpcmVjdG9yeTogXCJhcHBcIiB9KTtcbiAgYXV0b1VwZGF0ZXIudXBkYXRlQ29uZmlnUGF0aCA9IHByb2Nlc3MucmVzb3VyY2VzUGF0aDtcbn0gZWxzZSB7XG4gIGFwcC5zZXRQYXRoKFwidXNlckRhdGFcIiwgYCR7YXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKX0gKGRldmVsb3BtZW50KWApO1xuICBhdXRvVXBkYXRlci51cGRhdGVDb25maWdQYXRoID0gcGF0aC5qb2luKFxuICAgIF9fZGlybmFtZSxcbiAgICBcIi4uL3Jlc291cmNlcy9hcHAtdXBkYXRlLnltbFwiXG4gICk7XG59XG5cbmNvbnNvbGUubG9nKGBcXG5cXG5TdGFydGluZyBCYWNrZ3JvdW5kXFxuXFxuYCk7XG5cbmF1dG9VcGRhdGVyLmF1dG9Eb3dubG9hZCA9IGZhbHNlO1xuYXV0b1VwZGF0ZXIuYXV0b0luc3RhbGxPbkFwcFF1aXQgPSB0cnVlO1xuYXV0b1VwZGF0ZXIuZm9yY2VEZXZVcGRhdGVDb25maWcgPSB0cnVlO1xuYXV0b1VwZGF0ZXIuY2hhbm5lbCA9IFwibGF0ZXN0XCI7XG5hdXRvVXBkYXRlci5zZXRGZWVkVXJsID0gXCJodHRwczovL2dpdGh1Yi5jb20vRGV4RGV2TGFiL25leHRyb24tYXV0b3VwZGF0ZS1hcHBcIjtcblxuY29uc29sZS5sb2coYFxcblxcbkJvb3RzdHJhcHBpbmcgRWxlY3Ryb24gQnVpbGRlciBDb25maWdcXG5cXG5gKTtcblxuZWxlY3Ryb25CdWlsZGVyQm9vdHN0cmFwKCk7XG5cbihhc3luYyAoKSA9PiB7XG4gIC8vIFRyaWdnZXIgJ1JlYWR5JyBFdmVudFxuICBhd2FpdCBhcHAud2hlblJlYWR5KCk7XG4gIGNvbnNvbGUubG9nKGBcXG5cXG5SZWFkeSBFdmVudHMgVHJpZ2dlcmVkXFxuXFxuYCk7XG5cbiAgLy8gSW5zdGFudGlhdGUgYW5kIHNob3cgU3BsYXNoIFdpbmRvd1xuICBhd2FpdCBpbnN0YW50aWF0ZVdpbmRvdy5zcGxhc2goKTtcbiAgY29uc29sZS5sb2coYFxcblxcblNwbGFzaCBTY3JlZW4gSW5zdGFudGlhdGVkXFxuXFxuYCk7XG5cbiAgLy8gSW5zdGFudGlhdGUgRWxlY3Ryb24gU3RvcmVcbiAgYXdhaXQgaW5zdGFudGlhdGVFbGVjdHJvblN0b3JlKHRydWUpO1xuICBjb25zb2xlLmxvZyhgXFxuXFxuRWxlY3Ryb24gU3RvcmUgSW5zdGFudGlhdGVkXFxuXFxuYCk7XG5cbiAgLy8gSW5zdGFudGlhdGUgTG9nZ2VyXG4gIGF3YWl0IGluc3RhbnRpYXRlRWxlY3Ryb25TdG9yZSh0cnVlLCB7IG5hbWU6IFwibG9nXCIgfSk7XG4gIGNvbnNvbGUubG9nKGBcXG5cXG5Mb2dnZXIgU3RvcmUgSW5zdGFudGlhdGVkXFxuXFxuYCk7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgRXZlbnRzIGFuZCBGdW5jdGlvbnNcbiAgYXBwRXZlbnRzKCk7XG4gIGF3YWl0IGxvZ2dlcihgQXBwIEV2ZW50cyBSZWdpc3RlcmVkYCk7XG5cbiAgLy8gR2xvYmFsIGV4Y2VwdGlvbiBoYW5kbGVyXG4gIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCAoZXJyb3IpID0+IHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgbG9nZ2VyKGVycm9yKTtcbiAgfSk7XG5cbiAgaXBjRXZlbnRzKCk7XG4gIGF3YWl0IGxvZ2dlcihgSVBDIEV2ZW50cyBhbmQgRnVuY3Rpb25zIFJlZ2lzdGVyZWRgKTtcblxuICBpcGNIYW5kbGVycygpO1xuICBhd2FpdCBsb2dnZXIoYElQQyBBUEkgSGFuZGxlcnMgUmVnaXN0ZXJlZGApO1xuXG4gIGF1dG9VcGRhdGVyLmNoZWNrRm9yVXBkYXRlcygpO1xuICBpcGNNYWluLmVtaXQoXCJ1cGRhdGUtbXNnXCIsIG51bGwsIHtcbiAgICBzdGF0dXM6IDEwMixcbiAgICBkYXRhOiBcIkNoZWNraW5nIGZvciB1cGRhdGVzLi4uXCIsXG4gIH0pO1xuXG4gIGF1dG9VcGRhdGVyLm9uKFwidXBkYXRlLWF2YWlsYWJsZVwiLCAoaW5mbykgPT4ge1xuICAgIGlwY01haW4uZW1pdChcInVwZGF0ZS1tc2dcIiwgbnVsbCwgeyBzdGF0dXM6IDIwMCwgZGF0YTogXCJVcGRhdGUgYXZhaWxhYmxlXCIgfSk7XG4gICAgbGV0IHB0aCA9IGF1dG9VcGRhdGVyLmRvd25sb2FkVXBkYXRlKCk7XG4gICAgaXBjTWFpbi5lbWl0KFwidXBkYXRlLW1zZ1wiLCBudWxsLCB7IHN0YXR1czogMjAwLCBkYXRhOiBwdGggfSk7XG4gIH0pO1xuXG4gIGF1dG9VcGRhdGVyLm9uKFwidXBkYXRlLW5vdC1hdmFpbGFibGVcIiwgKGluZm8pID0+IHtcbiAgICBpcGNNYWluLmVtaXQoXCJ1cGRhdGUtbXNnXCIsIG51bGwsIHtcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgZGF0YTogXCJObyB1cGRhdGUgYXZhaWxhYmxlXCIsXG4gICAgfSk7XG4gICAgaXBjTWFpbi5lbWl0KFwidXBkYXRlLW1zZ1wiLCBudWxsLCB7IHN0YXR1czogMjAwLCBkYXRhOiBwdGggfSk7XG4gIH0pO1xuXG4gIGF1dG9VcGRhdGVyLm9uKFwidXBkYXRlLWRvd25sb2FkZWRcIiwgKGluZm8pID0+IHtcbiAgICBpcGNNYWluLmVtaXQoXCJ1cGRhdGUtbXNnXCIsIG51bGwsIHtcbiAgICAgIHN0YXR1czogMjAwLFxuICAgICAgZGF0YTogXCJVcGRhdGUgZG93bmxvYWRlZFwiLFxuICAgIH0pO1xuICB9KTtcblxuICBhdXRvVXBkYXRlci5vbihcImVycm9yXCIsIChpbmZvKSA9PiB7XG4gICAgaXBjTWFpbi5lbWl0KFwidXBkYXRlLW1zZ1wiLCBudWxsLCB7IHN0YXR1czogNTAwLCBkYXRhOiBpbmZvIH0pO1xuICB9KTtcbn0pKCk7XG4iXSwibmFtZXMiOlsibGF1bmNoZXIiLCJzdG9yZSIsInRlc3QiLCJwcmlzbWFTZXJ2aWNlIiwiR0VUIiwiZm4iLCJhcmdzIiwiZGF0YSIsInRhYmxlIiwiX29iamVjdFNwcmVhZCIsInN0YXR1cyIsIl8iLCJpbnN0YW50aWF0ZUVsZWN0cm9uU3RvcmUiLCJnZXQiLCJpc1VuZGVmaW5lZCIsIlBPU1QiLCJrZXlzIiwiX09iamVjdCRrZXlzIiwibGVuZ3RoIiwiam9pbiIsInNldCIsImhhc0tleSIsImhhcyIsImlzRXF1YWwiLCJERUxFVEUiLCJkZWxldGUiLCJ1c2VyIiwid2hlcmUiLCJuYW1lIiwiYXBwIiwibG9nZ2VyIiwiYXBwRXZlbnRzIiwiaXNQcm9kIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwib24iLCJxdWl0IiwiZ2xvYmFsU2hvcnRjdXQiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJCcm93c2VyV2luZG93Iiwic2NyZWVuIiwiU3RvcmUiLCJjcmVhdGVXaW5kb3ciLCJ3aW5kb3dOYW1lIiwib3B0aW9ucyIsImtleSIsImRlZmF1bHRTaXplIiwid2lkdGgiLCJoZWlnaHQiLCJzdGF0ZSIsInJlc3RvcmUiLCJnZXRDdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvbiIsIndpbiIsImdldFBvc2l0aW9uIiwic2l6ZSIsImdldFNpemUiLCJ4IiwieSIsIndpbmRvd1dpdGhpbkJvdW5kcyIsIndpbmRvd1N0YXRlIiwiYm91bmRzIiwicmVzZXRUb0RlZmF1bHRzIiwiZ2V0UHJpbWFyeURpc3BsYXkiLCJfT2JqZWN0JGFzc2lnbiIsImVuc3VyZVZpc2libGVPblNvbWVEaXNwbGF5IiwiX2NvbnRleHQiLCJ2aXNpYmxlIiwiX3NvbWVJbnN0YW5jZVByb3BlcnR5IiwiZ2V0QWxsRGlzcGxheXMiLCJjYWxsIiwiZGlzcGxheSIsInNhdmVTdGF0ZSIsImlzTWluaW1pemVkIiwiaXNNYXhpbWl6ZWQiLCJ3ZWJQcmVmZXJlbmNlcyIsIm5vZGVJbnRlZ3JhdGlvbiIsImNvbnRleHRJc29sYXRpb24iLCJmcyIsInBhdGgiLCJlbGVjdHJvbkJ1aWxkZXJCb290c3RyYXAiLCJjb25maWciLCJwcm92aWRlciIsInVybCIsInVzZU11bHRpcGxlUmFuZ2VSZXF1ZXN0IiwiY2hhbm5lbCIsInVwZGF0ZXJDYWNoZURpck5hbWUiLCJnZXROYW1lIiwicmVzb3VyY2VQYXRoIiwicmVzb3VyY2VzUGF0aCIsIl9fZGlybmFtZSIsInlhbWwiLCJ1cGRhdGVfZmlsZSIsImRldl91cGRhdGVfZmlsZSIsImNoZWNrRmlsZXMiLCJmaWxlIiwiZXhpc3RzU3luYyIsIndyaXRlRmlsZVN5bmMiLCJpcGNNYWluIiwiZG93bmxvYWQiLCJnZXRBbGxXaW5kb3dzIiwiaW5zdGFudGlhdGVXaW5kb3ciLCJpcGNFdmVudHMiLCJldmVudCIsImFyZyIsInVzZXJzIiwiZ2V0QXBwUGF0aCIsInJlcGx5IiwiZXJyb3IiLCJ3aW5kb3ciLCJnZXRGb2N1c2VkV2luZG93IiwiY29uc29sZSIsImxvZyIsIm9uUHJvZ3Jlc3MiLCJtYWluV2luZG93SWQiLCJpZCIsImZyb21JZCIsIndlYkNvbnRlbnRzIiwic2VuZCIsImVtYWlsIiwicGFzc3dvcmQiLCJuZXh0U2Vhc29uVGFncyIsImNyZWF0ZVVzZXIiLCJjbG9zZVBhcmVudCIsInNlbmRlciIsImNsb3NlIiwid2luZG93SWQiLCJzaG93IiwiZXhpdEFwcCIsImV4aXQiLCJpcGNIYW5kbGVycyIsImhhbmRsZSIsInZhbHVlIiwid2F0Y2hlcnMiLCJpc0FycmF5IiwiX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5Iiwid2luZG93VGl0bGVzIiwiZ2V0QmFja2VuZFBhdGgiLCJwYWdlUGF0aCIsInBvcnQiLCJhcmd2IiwiZ2VuZXJhdGVGb3JtYXR0ZWREYXRlIiwiZGF0ZSIsIl9jb250ZXh0MiIsIl9jb250ZXh0MyIsIl9jb250ZXh0NCIsIl9jb250ZXh0NSIsInRvZGF5IiwiRGF0ZSIsIllZWVkiLCJnZXRGdWxsWWVhciIsIk1NIiwiX3BhZFN0YXJ0SW5zdGFuY2VQcm9wZXJ0eSIsIlN0cmluZyIsImdldE1vbnRoIiwiREQiLCJnZXREYXRlIiwiaGgiLCJnZXRIb3VycyIsIm1tIiwiZ2V0TWludXRlcyIsInNzIiwiZ2V0U2Vjb25kcyIsImZvcm1hdHRlZERhdGUiLCJpbml0IiwiY2xlYXIiLCJ0aW1lc3RhbXAiLCJ2ZXJzaW9uIiwiZ2V0VmVyc2lvbiIsInNldEVsZWN0cm9uU3RvcmUiLCJFcnJvciIsImUiLCJtZXNzYWdlIiwiX3NldFRpbWVvdXQiLCJtc2ciLCJ0aXRsZSIsImJyb3dzZXJXaW5kb3dBcnIiLCJ3aW5kb3dMaXN0IiwicHVzaCIsImdldFRpdGxlIiwiX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5IiwiX2ZpbHRlckluc3RhbmNlUHJvcGVydHkiLCJzcGxhc2giLCJsb2dpbiIsIm1haW4iLCJtaW5IZWlnaHQiLCJtaW5XaWR0aCIsImF1dG9IaWRlTWVudUJhciIsInByZWxvYWQiLCJ3ZWJTZWN1cml0eSIsImFsd2F5c09uVG9wIiwiZm9jdXNhYmxlIiwiZnJhbWUiLCJza2lwVGFza2JhciIsIm1vdmFibGUiLCJyZXNpemFibGUiLCJtYXhpbWl6YWJsZSIsIm1pbmltaXphYmxlIiwibG9hZFVSTCIsIm9wZW5EZXZUb29scyIsImNlbnRlciIsInNldEJhY2tncm91bmRDb2xvciIsIm1heGltaXplIiwiUHJpc21hQ2xpZW50IiwiZGF0YWJhc2VVcmwiLCJEQVRBQkFTRV9VUkwiLCJwcmlzbWEiLCJkYXRhc291cmNlcyIsImRiIiwicXVlcnkiLCIkZGlzY29ubmVjdCIsImNvZGUiLCJlcnJvckNvZGUiLCJmaWxlVVJMVG9QYXRoIiwiZGlybmFtZSIsImltcG9ydCIsIm1ldGEiLCIkQ2xhc3MiLCJQcmlzbWEiLCJfJEVudW1zIiwiJEVudW1zIiwiZ2V0UHJpc21hQ2xpZW50Q2xhc3MiLCJjd2QiLCJydW50aW1lIiwicnVudGltZURhdGFNb2RlbCIsIkpTT04iLCJwYXJzZSIsImVuZ2luZVdhc20iLCJ1bmRlZmluZWQiLCJjb21waWxlcldhc20iLCJnZXRQcmlzbWFDbGllbnQiLCJ2YWxpZGF0b3IiLCJQdWJsaWMiLCJQcmlzbWFDbGllbnRLbm93blJlcXVlc3RFcnJvciIsIlByaXNtYUNsaWVudFVua25vd25SZXF1ZXN0RXJyb3IiLCJQcmlzbWFDbGllbnRSdXN0UGFuaWNFcnJvciIsIlByaXNtYUNsaWVudEluaXRpYWxpemF0aW9uRXJyb3IiLCJQcmlzbWFDbGllbnRWYWxpZGF0aW9uRXJyb3IiLCJzcWwiLCJzcWx0YWciLCJlbXB0eSIsInJhdyIsIlNxbCIsIkRlY2ltYWwiLCJnZXRFeHRlbnNpb25Db250ZXh0IiwiRXh0ZW5zaW9ucyIsInByaXNtYVZlcnNpb24iLCJjbGllbnQiLCJlbmdpbmUiLCJOdWxsVHlwZXMiLCJEYk51bGwiLCJvYmplY3RFbnVtVmFsdWVzIiwiY2xhc3NlcyIsIkpzb25OdWxsIiwiQW55TnVsbCIsImluc3RhbmNlcyIsIk1vZGVsTmFtZSIsIlVzZXIiLCJMYXVuY2hlciIsIk1vdGQiLCJTZXJ2ZXIiLCJTZXJ2ZXJUYWciLCJBcnRpY2xlcyIsIlRyYW5zYWN0aW9uSXNvbGF0aW9uTGV2ZWwiLCJtYWtlU3RyaWN0RW51bSIsIlJlYWRVbmNvbW1pdHRlZCIsIlJlYWRDb21taXR0ZWQiLCJSZXBlYXRhYmxlUmVhZCIsIlNlcmlhbGl6YWJsZSIsIlVzZXJTY2FsYXJGaWVsZEVudW0iLCJwb2xsVGFncyIsImNyZWF0ZWRBdCIsInVwZGF0ZWRBdCIsIkxhdW5jaGVyU2NhbGFyRmllbGRFbnVtIiwiZGF0YVR5cGUiLCJkYXRhVmFsdWUiLCJNb3RkU2NhbGFyRmllbGRFbnVtIiwibW90ZCIsIlNlcnZlclNjYWxhckZpZWxkRW51bSIsInNlcnZlcklkIiwiZGVzYyIsIm1jVmVyc2lvbiIsImRpZmZpY3VsdHkiLCJhc3NldHMiLCJjb3JlIiwibW9kcGFjayIsImF2YWlsYWJsZSIsIm1vZGRlZCIsImZlYXR1cmVkIiwicGVyaW9kaWMiLCJTZXJ2ZXJUYWdTY2FsYXJGaWVsZEVudW0iLCJ0YWdJZCIsIkFydGljbGVzU2NhbGFyRmllbGRFbnVtIiwiYXJ0aWNsZUlkIiwidGFiTmFtZSIsInBhZ2VPcmRlciIsInN1YnRpdGxlIiwidGV4dCIsIlNvcnRPcmRlciIsImFzYyIsIlVzZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtIiwiTGF1bmNoZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtIiwiTW90ZE9yZGVyQnlSZWxldmFuY2VGaWVsZEVudW0iLCJTZXJ2ZXJPcmRlckJ5UmVsZXZhbmNlRmllbGRFbnVtIiwiU2VydmVyVGFnT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSIsIkFydGljbGVzT3JkZXJCeVJlbGV2YW5jZUZpZWxkRW51bSIsImRlZmluZUV4dGVuc2lvbiIsInNlcnZlIiwiYXV0b1VwZGF0ZXIiLCJBcHBVcGRhdGVyIiwicmVxdWlyZSIsImRpcmVjdG9yeSIsInVwZGF0ZUNvbmZpZ1BhdGgiLCJzZXRQYXRoIiwiZ2V0UGF0aCIsImF1dG9Eb3dubG9hZCIsImF1dG9JbnN0YWxsT25BcHBRdWl0IiwiZm9yY2VEZXZVcGRhdGVDb25maWciLCJzZXRGZWVkVXJsIiwid2hlblJlYWR5IiwiY2hlY2tGb3JVcGRhdGVzIiwiZW1pdCIsImluZm8iLCJwdGgiLCJkb3dubG9hZFVwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=